
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="multiprocessing — Paralelismo basado en procesos" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/multiprocessing.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Código fuente: Lib/multiprocessing/ Availability: not Emscripten, not WASI. Este módulo no funciona o no está disponible en las plataformas WebAssembly wasm32-emscripten y wasm32-wasi. Consulte Pla..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Código fuente: Lib/multiprocessing/ Availability: not Emscripten, not WASI. Este módulo no funciona o no está disponible en las plataformas WebAssembly wasm32-emscripten y wasm32-wasi. Consulte Pla..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>multiprocessing — Paralelismo basado en procesos &#8212; documentación de Python - 3.11.2</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=2d3badd06fe70b34b68db01f99471ce1624ffe4a" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.11.2"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="multiprocessing.shared_memory — Shared memory for direct access across processes" href="multiprocessing.shared_memory.html" />
    <link rel="prev" title="threading — Paralelismo basado en hilos" href="threading.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/multiprocessing.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code> — Paralelismo basado en procesos</a><ul>
<li><a class="reference internal" href="#introduction">Introducción</a><ul>
<li><a class="reference internal" href="#the-process-class">La clase <code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a></li>
<li><a class="reference internal" href="#contexts-and-start-methods">Contextos y métodos de inicio</a></li>
<li><a class="reference internal" href="#exchanging-objects-between-processes">Intercambiando objetos entre procesos</a></li>
<li><a class="reference internal" href="#synchronization-between-processes">Sincronización entre procesos</a></li>
<li><a class="reference internal" href="#sharing-state-between-processes">Compartiendo estado entre procesos</a></li>
<li><a class="reference internal" href="#using-a-pool-of-workers">Usando una piscina de trabajadores (<em>pool of workers</em>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference">Referencia</a><ul>
<li><a class="reference internal" href="#process-and-exceptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code> y excepciones</a></li>
<li><a class="reference internal" href="#pipes-and-queues">Tuberías (<em>Pipes</em>) y Colas (<em>Queues</em>)</a></li>
<li><a class="reference internal" href="#miscellaneous">Miscelánea</a></li>
<li><a class="reference internal" href="#connection-objects">Objetos de conexión <em>Connection Objects</em></a></li>
<li><a class="reference internal" href="#synchronization-primitives">Primitivas de sincronización (<em>Synchronization primitives</em>)</a></li>
<li><a class="reference internal" href="#shared-ctypes-objects">Objetos compartidos <code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a><ul>
<li><a class="reference internal" href="#module-multiprocessing.sharedctypes">El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing.sharedctypes</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#managers">Administradores (<em>Managers</em>)</a><ul>
<li><a class="reference internal" href="#customized-managers">Administradores customizables (<em>Customized managers</em>)</a></li>
<li><a class="reference internal" href="#using-a-remote-manager">Utilizando un administrador remoto</a></li>
</ul>
</li>
<li><a class="reference internal" href="#proxy-objects">Objetos Proxy (<em>Proxy Objects</em>)</a><ul>
<li><a class="reference internal" href="#cleanup">Limpieza (<em>Cleanup</em>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-multiprocessing.pool">Piscinas de procesos (<em>Process Pools</em>)</a></li>
<li><a class="reference internal" href="#module-multiprocessing.connection">Oyentes y clientes (<em>Listeners and Clients</em>)</a><ul>
<li><a class="reference internal" href="#address-formats">Formatos de dirección (<em>Address formats</em>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#authentication-keys">Llaves de autentificación</a></li>
<li><a class="reference internal" href="#logging"><em>Logging</em></a></li>
<li><a class="reference internal" href="#module-multiprocessing.dummy">El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing.dummy</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#programming-guidelines">Pautas de programación</a><ul>
<li><a class="reference internal" href="#all-start-methods">Todos los métodos de inicio</a></li>
<li><a class="reference internal" href="#the-spawn-and-forkserver-start-methods">Los métodos de inicio <em>spawn</em> y <em>forkserver</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Ejemplos</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="threading.html"
                          title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code> — Paralelismo basado en hilos</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="multiprocessing.shared_memory.html"
                          title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing.shared_memory</span></code> — Shared memory for direct access across processes</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/library/multiprocessing.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="multiprocessing.shared_memory.html" title="multiprocessing.shared_memory — Shared memory for direct access across processes"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="threading.html" title="threading — Paralelismo basado en hilos"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="concurrency.html" accesskey="U">Ejecución concurrente</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code> — Paralelismo basado en procesos</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-multiprocessing">
<span id="multiprocessing-process-based-parallelism"></span><h1><a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> — Paralelismo basado en procesos<a class="headerlink" href="#module-multiprocessing" title="Enlazar permanentemente con este título">¶</a></h1>
<p><strong>Código fuente:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.11/Lib/multiprocessing/">Lib/multiprocessing/</a></p>
<hr class="docutils" />
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not Emscripten, not WASI.</p>
<p>Este módulo no funciona o no está disponible en las plataformas WebAssembly <code class="docutils literal notranslate"><span class="pre">wasm32-emscripten</span></code> y <code class="docutils literal notranslate"><span class="pre">wasm32-wasi</span></code>. Consulte <a class="reference internal" href="intro.html#wasm-availability"><span class="std std-ref">Plataformas WebAssembly</span></a> para obtener más información.</p>
</div>
<section id="introduction">
<h2>Introducción<a class="headerlink" href="#introduction" title="Enlazar permanentemente con este título">¶</a></h2>
<p><a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> es un paquete que permite crear procesos (<em>spawning</em>) utilizando una API similar al módulo <a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a>. El paquete <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> ofrece concurrencia tanto local como remota, esquivando el <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">Global Interpreter Lock</span></a> mediante el uso de subprocesos en lugar de hilos (<em>threads</em>). Debido a esto, el módulo <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> le permite al programador aprovechar al máximo múltiples procesadores en una máquina determinada. Se ejecuta tanto en Unix como en Windows.</p>
<p>El módulo <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> también introduce API que no tienen análogos en el módulo <a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a>. Un buen ejemplo de esto es el objeto <a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pool</span></code></a> que ofrece un medio conveniente de paralelizar la ejecución de una función a través de múltiples valores de entrada, distribuyendo los datos de entrada a través de procesos (paralelismo de datos). El siguiente ejemplo demuestra la práctica común de definir tales funciones en un módulo para que los procesos secundarios puedan importar con éxito ese módulo. Este ejemplo básico de paralelismo de datos usando <a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pool</span></code></a>,</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">as</span> <span class="n">p</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
</pre></div>
</div>
<p>imprimirá la salida estándar</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p><a class="reference internal" href="concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" title="concurrent.futures.ProcessPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures.ProcessPoolExecutor</span></code></a> ofrece una interfaz de nivel superior para enviar tareas a un proceso en segundo plano sin bloquear la ejecución del proceso de llamada. En comparación con el uso directo de la interfaz <a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pool</span></code></a>, la API <a class="reference internal" href="concurrent.futures.html#module-concurrent.futures" title="concurrent.futures: Execute computations concurrently using threads or processes."><code class="xref py py-mod docutils literal notranslate"><span class="pre">concurrent.futures</span></code></a> permite separar el envío de trabajo al grupo de procesos subyacente de la espera de los resultados.</p>
</div>
<section id="the-process-class">
<h3>La clase <code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code><a class="headerlink" href="#the-process-class" title="Enlazar permanentemente con este título">¶</a></h3>
<p>En <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a>, los procesos se generan creando un objeto <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> y luego llamando a su método <a class="reference internal" href="#multiprocessing.Process.start" title="multiprocessing.Process.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a> .  <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> sigue la API de <a class="reference internal" href="threading.html#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Thread</span></code></a>. Un ejemplo trivial de un programa multiproceso es</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;bob&#39;</span><span class="p">,))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
</div>
<p>Para mostrar las IDs individuales involucradas en el proceso, aquí hay un ejemplo ampliado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="n">title</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;module name:&#39;</span><span class="p">,</span> <span class="vm">__name__</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;parent process:&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;process id:&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">info</span><span class="p">(</span><span class="s1">&#39;function f&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">info</span><span class="p">(</span><span class="s1">&#39;main line&#39;</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;bob&#39;</span><span class="p">,))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
</div>
<p>Para obtener una explicación de por qué es necesaria la parte <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code> , consulte <a class="reference internal" href="#multiprocessing-programming"><span class="std std-ref">Pautas de programación</span></a>.</p>
</section>
<section id="contexts-and-start-methods">
<h3>Contextos y métodos de inicio<a class="headerlink" href="#contexts-and-start-methods" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="multiprocessing-start-methods">Dependiendo de la plataforma, <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> admite tres formas de iniciar un proceso. Estos métodos de inicio <em>start methods</em> son</p>
<blockquote>
<div><dl>
<dt>Generación (<em>spawn</em>)</dt><dd><p>El proceso principal inicia un nuevo proceso de interpretación de Python. El proceso secundario solo heredará los recursos necesarios para ejecutar el método <a class="reference internal" href="#multiprocessing.Process.run" title="multiprocessing.Process.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> del objeto de proceso. En particular, los identificadores y descriptores de archivo innecesarios del proceso principal no se heredarán. Iniciar un proceso con este método es bastante lento en comparación con <em>fork</em> o <em>forkserver</em>.</p>
<p>Disponible en Unix y Windows. Por defecto en Windows y macOS.</p>
</dd>
<dt><em>fork</em></dt><dd><p>El proceso parental usa <a class="reference internal" href="os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a> para bifurcar el intérprete de Python. El proceso hijo, cuando comienza, es efectivamente idéntico al proceso parental. Todos los recursos del proceso parental son heredados por el proceso hijo. Tenga en cuenta que bifurcar (<em>forking</em>) de forma segura un proceso multihilo es problemático.</p>
<p>Disponible solo en Unix. Por defecto en Unix.</p>
</dd>
<dt><em>forkserver</em></dt><dd><p>Cuando el programa se inicia y selecciona el método de inicio <em>forkserver</em>, se inicia un proceso de servidor. A partir de ese momento, cada vez que se necesite un nuevo proceso, el proceso parental se conecta al servidor y solicita que bifurque un nuevo proceso. El proceso del servidor <em>fork</em> es de un solo hilo, por lo que es seguro usarlo <a class="reference internal" href="os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a>. No se heredan recursos innecesarios.</p>
<p>Disponible en plataformas Unix que admiten pasar descriptores de archivo a través de tuberías (<em>pipes</em>) Unix.</p>
</dd>
</dl>
</div></blockquote>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>En macOS, el método de inicio <em>spawn</em> ahora es el predeterminado. El método de inicio <em>fork</em> debe considerarse inseguro ya que puede provocar bloqueos del subproceso. Consulte <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=33725">bpo-33725</a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Se agregó <em>spawn</em> en todas las plataformas Unix y se agregó <em>forkserver</em> para algunas plataformas Unix. Los procesos secundarios ya no heredan todos los identificadores heredables principales en Windows.</p>
</div>
<p>En Unix, los métodos de inicio <em>spawn</em> o <em>forkserver</em> también iniciarán un proceso <em>resource tracker</em> que rastrea los recursos del sistema con nombre no vinculados (como los nombrados semáforos o objetos <a class="reference internal" href="multiprocessing.shared_memory.html#multiprocessing.shared_memory.SharedMemory" title="multiprocessing.shared_memory.SharedMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">SharedMemory</span></code></a>) creado por procesos del programa. Cuando todos los procesos han salido, el rastreador de recursos desvincula cualquier objeto rastreado restante. Por lo general, no debería haber ninguno, pero si un proceso fue eliminado por una señal, puede haber algunos recursos «filtrados». (Ni los semáforos filtrados ni los segmentos de memoria compartida se desvincularán automáticamente hasta el próximo reinicio. Esto es problemático para ambos objetos porque el sistema solo permite un número limitado de semáforos con nombre, y los segmentos de memoria compartida ocupan algo de espacio en la memoria principal).</p>
<p>Para seleccionar un método de inicio, utilice la función <a class="reference internal" href="#multiprocessing.set_start_method" title="multiprocessing.set_start_method"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_start_method()</span></code></a> en la cláusula <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code> del módulo principal. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">mp</span><span class="o">.</span><span class="n">set_start_method</span><span class="p">(</span><span class="s1">&#39;spawn&#39;</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">foo</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
</div>
<p><a class="reference internal" href="#multiprocessing.set_start_method" title="multiprocessing.set_start_method"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_start_method()</span></code></a> no debería ser usada más de una vez en el programa.</p>
<p>Alternativamente, se puede usar <a class="reference internal" href="#multiprocessing.get_context" title="multiprocessing.get_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_context()</span></code></a> para obtener un objeto de contexto. Los objetos de contexto tienen la misma API que el módulo de multiprocesamiento, y permiten utilizar múltiples métodos de inicio en el mismo programa.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="s1">&#39;spawn&#39;</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">foo</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
</div>
<p>Tenga en cuenta que los objetos relacionados con un contexto pueden no ser compatibles con procesos para un contexto diferente. En particular, los <em>locks</em> creados con el contexto <em>fork</em> no se pueden pasar a los procesos iniciados con los métodos de inicio <em>spawn</em> o <em>forkserver</em> .</p>
<p>Una biblioteca que quiera usar un método de inicio particular probablemente debería usar <a class="reference internal" href="#multiprocessing.get_context" title="multiprocessing.get_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_context()</span></code></a> para evitar interferir con la elección del usuario de la biblioteca.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Los métodos de inicio <code class="docutils literal notranslate"><span class="pre">'spawn'</span></code> y <code class="docutils literal notranslate"><span class="pre">'forkserver'</span></code> actualmente no pueden ser usados con ejecutables «congelados» (<em>frozen</em>)(es decir, binarios producidos por paquetes como <strong>PyInstaller</strong> y <strong>cx_Freeze</strong>) en Unix. El método de inicio <code class="docutils literal notranslate"><span class="pre">'fork'</span></code> funciona.</p>
</div>
</section>
<section id="exchanging-objects-between-processes">
<h3>Intercambiando objetos entre procesos<a class="headerlink" href="#exchanging-objects-between-processes" title="Enlazar permanentemente con este título">¶</a></h3>
<p><a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> admite dos tipos de canales de comunicación entre procesos:</p>
<p><strong>Colas (*queues*)</strong></p>
<blockquote>
<div><p>La clase <a class="reference internal" href="#multiprocessing.Queue" title="multiprocessing.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> es prácticamente un clon de <a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.Queue</span></code></a>. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Queue</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">([</span><span class="mi">42</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">])</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>    <span class="c1"># prints &quot;[42, None, &#39;hello&#39;]&quot;</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
</div>
<p>Las colas (<em>queues</em>) son hilos y procesos seguro.</p>
</div></blockquote>
<p><strong>Tuberías (*Pipes*)</strong></p>
<blockquote>
<div><p>La función <a class="reference internal" href="#multiprocessing.Pipe" title="multiprocessing.Pipe"><code class="xref py py-func docutils literal notranslate"><span class="pre">Pipe()</span></code></a> retorna un par de objetos de conexión conectados por una tubería (<em>pipe</em>) que, por defecto, es un dúplex (bidireccional). Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Pipe</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">conn</span><span class="p">):</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">send</span><span class="p">([</span><span class="mi">42</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">])</span>
    <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">parent_conn</span><span class="p">,</span> <span class="n">child_conn</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">child_conn</span><span class="p">,))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">parent_conn</span><span class="o">.</span><span class="n">recv</span><span class="p">())</span>   <span class="c1"># prints &quot;[42, None, &#39;hello&#39;]&quot;</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
</div>
<p>Los dos objetos de conexión retornados por <a class="reference internal" href="#multiprocessing.Pipe" title="multiprocessing.Pipe"><code class="xref py py-func docutils literal notranslate"><span class="pre">Pipe()</span></code></a> representan los dos extremos de la tubería (<em>pipe</em>). Cada objeto de conexión tiene los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code> (entre otros). Tenga en cuenta que los datos en una tubería pueden corromperse si dos procesos (o hilos) intentan leer o escribir en el <em>mismo</em> (<em>same</em>) extremo de la tubería al mismo tiempo. Por supuesto, no hay riesgo de corrupción por procesos que utilizan diferentes extremos de la tubería (<em>pipe</em>) al mismo tiempo.</p>
</div></blockquote>
</section>
<section id="synchronization-between-processes">
<h3>Sincronización entre procesos<a class="headerlink" href="#synchronization-between-processes" title="Enlazar permanentemente con este título">¶</a></h3>
<p><a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> contiene equivalentes de todas las sincronizaciones primitivas de <a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a>.  Por ejemplo, se puede usar un candado (<em>lock</em>) para garantizar que solo un proceso se imprima a la salida estándar a la vez:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Lock</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="n">l</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hello world&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">l</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">num</span><span class="p">))</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>Sin usar el candado (<em>lock</em>) de salida de los diferentes procesos, es probable que todo se mezcle.</p>
</section>
<section id="sharing-state-between-processes">
<h3>Compartiendo estado entre procesos<a class="headerlink" href="#sharing-state-between-processes" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Como se mencionó anteriormente, cuando se realiza una programación concurrente, generalmente es mejor evitar el uso del estado compartido en la medida de lo posible. Esto es particularmente cierto cuando se utilizan múltiples procesos.</p>
<p>Sin embargo, si usted realmente necesita usar algunos datos compartidos el <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> proporciona un par de maneras de hacerlo.</p>
<p><strong>Memoria compartida</strong></p>
<blockquote>
<div><p>Los datos se pueden almacenar en un mapa de memoria compartida usando <a class="reference internal" href="#multiprocessing.Value" title="multiprocessing.Value"><code class="xref py py-class docutils literal notranslate"><span class="pre">Value</span></code></a> o <a class="reference internal" href="#multiprocessing.Array" title="multiprocessing.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a>. Por ejemplo, el siguiente código</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Value</span><span class="p">,</span> <span class="n">Array</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mf">3.1415927</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">Value</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">arr</span><span class="p">))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">num</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[:])</span>
</pre></div>
</div>
<p>imprimirá</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="mf">3.1415927</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">9</span><span class="p">]</span>
</pre></div>
</div>
<p>Los argumentos <code class="docutils literal notranslate"><span class="pre">'d'</span></code> y <code class="docutils literal notranslate"><span class="pre">'i'</span></code> utilizados al crear <code class="docutils literal notranslate"><span class="pre">num</span></code> y <code class="docutils literal notranslate"><span class="pre">arr</span></code> son códigos de tipo del tipo utilizado por <a class="reference internal" href="array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> module: <code class="docutils literal notranslate"><span class="pre">'d'</span></code> indica un flotador de doble precisión y <code class="docutils literal notranslate"><span class="pre">'i'</span></code> indica un entero con signo. Estos objetos compartidos serán seguros para procesos y subprocesos.</p>
<p>Para una mayor flexibilidad en el uso de la memoria compartida, se puede usar el módulo <a class="reference internal" href="#module-multiprocessing.sharedctypes" title="multiprocessing.sharedctypes: Allocate ctypes objects from shared memory."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing.sharedctypes</span></code></a> que admite la creación arbitraria de objetos <em>ctypes</em> asignados desde la memoria compartida.</p>
</div></blockquote>
<p><strong>Proceso servidor (*Server process*)</strong></p>
<blockquote>
<div><p>Un objeto de administrador retornado por <a class="reference internal" href="#multiprocessing.Manager" title="multiprocessing.Manager"><code class="xref py py-func docutils literal notranslate"><span class="pre">Manager()</span></code></a> controla un proceso de servidor que contiene objetos de Python y permite que otros procesos los manipulen usando proxies.</p>
<p>Un administrador retornado por <a class="reference internal" href="#multiprocessing.Manager" title="multiprocessing.Manager"><code class="xref py py-func docutils literal notranslate"><span class="pre">Manager()</span></code></a> soportará tipos de clases  como <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>, <a class="reference internal" href="#multiprocessing.managers.Namespace" title="multiprocessing.managers.Namespace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Namespace</span></code></a>, <a class="reference internal" href="#multiprocessing.Lock" title="multiprocessing.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a>, <a class="reference internal" href="#multiprocessing.RLock" title="multiprocessing.RLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">RLock</span></code></a>, <a class="reference internal" href="#multiprocessing.Semaphore" title="multiprocessing.Semaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">Semaphore</span></code></a>, <a class="reference internal" href="#multiprocessing.BoundedSemaphore" title="multiprocessing.BoundedSemaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoundedSemaphore</span></code></a>, <a class="reference internal" href="#multiprocessing.Condition" title="multiprocessing.Condition"><code class="xref py py-class docutils literal notranslate"><span class="pre">Condition</span></code></a>, <a class="reference internal" href="#multiprocessing.Event" title="multiprocessing.Event"><code class="xref py py-class docutils literal notranslate"><span class="pre">Event</span></code></a>, <a class="reference internal" href="#multiprocessing.Barrier" title="multiprocessing.Barrier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Barrier</span></code></a>, <a class="reference internal" href="#multiprocessing.Queue" title="multiprocessing.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>, <a class="reference internal" href="#multiprocessing.Value" title="multiprocessing.Value"><code class="xref py py-class docutils literal notranslate"><span class="pre">Value</span></code></a> y <a class="reference internal" href="#multiprocessing.Array" title="multiprocessing.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a>.  Por ejemplo,</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Manager</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
    <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
    <span class="n">d</span><span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">d</span><span class="p">[</span><span class="mf">0.25</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">l</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">Manager</span><span class="p">()</span> <span class="k">as</span> <span class="n">manager</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">dict</span><span class="p">()</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span>
        <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
</pre></div>
</div>
<p>imprimirá</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="mf">0.25</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Los administradores de procesos del servidor son más flexibles que el uso de objetos de memoria compartida porque pueden hacerse para admitir tipos de objetos arbitrarios. Por lo tanto, un solo administrador puede ser compartido por procesos en diferentes ordenadores a través de una red. Sin embargo, son más lentos que usar memoria compartida.</p>
</div></blockquote>
</section>
<section id="using-a-pool-of-workers">
<h3>Usando una piscina de trabajadores (<em>pool of workers</em>)<a class="headerlink" href="#using-a-pool-of-workers" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La clase <a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pool</span></code></a> representa procesos de piscina de trabajadores (<em>pool of workers</em>). Tiene métodos que permiten que las tareas se descarguen a los procesos de trabajo de diferentes maneras.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="ne">TimeoutError</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># start 4 worker processes</span>
    <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>

        <span class="c1"># print &quot;[0, 1, 4,..., 81]&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span>

        <span class="c1"># print same numbers in arbitrary order</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># evaluate &quot;f(20)&quot; asynchronously</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mi">20</span><span class="p">,))</span>      <span class="c1"># runs in *only* one process</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>             <span class="c1"># prints &quot;400&quot;</span>

        <span class="c1"># evaluate &quot;os.getpid()&quot; asynchronously</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">,</span> <span class="p">())</span> <span class="c1"># runs in *only* one process</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>             <span class="c1"># prints the PID of that process</span>

        <span class="c1"># launching multiple evaluations asynchronously *may* use more processes</span>
        <span class="n">multiple_results</span> <span class="o">=</span> <span class="p">[</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">,</span> <span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
        <span class="nb">print</span><span class="p">([</span><span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">multiple_results</span><span class="p">])</span>

        <span class="c1"># make a single worker sleep for 10 seconds</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="p">,))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">TimeoutError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;We lacked patience and got a multiprocessing.TimeoutError&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;For the moment, the pool remains available for more work&quot;</span><span class="p">)</span>

    <span class="c1"># exiting the &#39;with&#39;-block has stopped the pool</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Now the pool is closed and no longer available&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Tenga en cuenta que los métodos de una piscina (<em>pool</em>) solo deben ser utilizados por el proceso que lo creó.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La funcionalidad en este paquete requiere que los procesos hijos (<em>children</em>) puedan importar el módulo <code class="docutils literal notranslate"><span class="pre">__main__</span></code>. Esto está cubierto en <a class="reference internal" href="#multiprocessing-programming"><span class="std std-ref">Pautas de programación</span></a> sin embargo, vale la pena señalarlo aquí. Esto significa que algunos ejemplos, como <a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal notranslate"><span class="pre">multiprocessing.pool.Pool</span></code></a> no funcionarán en el intérprete interactivo. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">p</span><span class="p">:</span>
<span class="gp">... </span>  <span class="n">p</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">Process PoolWorker-1:</span>
<span class="go">Process PoolWorker-2:</span>
<span class="go">Process PoolWorker-3:</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;module&#39; object has no attribute &#39;f&#39;</span>
<span class="go">AttributeError: &#39;module&#39; object has no attribute &#39;f&#39;</span>
<span class="go">AttributeError: &#39;module&#39; object has no attribute &#39;f&#39;</span>
</pre></div>
</div>
<p>(Si intenta esto, en realidad generará tres trazas completas intercaladas de forma semialeatoria, y luego tendrá que detener el proceso principal de alguna manera)</p>
</div>
</section>
</section>
<section id="reference">
<h2>Referencia<a class="headerlink" href="#reference" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El paquete <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> mayoritariamente replica la API del módulo <a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a>.</p>
<section id="process-and-exceptions">
<h3><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code> y excepciones<a class="headerlink" href="#process-and-exceptions" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="multiprocessing.Process">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">Process</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">daemon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Process" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Los objetos de proceso representan la actividad que se ejecuta en un proceso separado. La clase <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> tiene equivalentes para todos los métodos <a class="reference internal" href="threading.html#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Thread</span></code></a>.</p>
<p>El constructor siempre debe llamarse con argumentos de palabras clave. <em>group</em> siempre debe ser <code class="docutils literal notranslate"><span class="pre">None</span></code>; existe únicamente por compatibilidad con <a class="reference internal" href="threading.html#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Thread</span></code></a>. <em>target</em> es el objeto invocable a ser llamado por el método <a class="reference internal" href="#multiprocessing.Process.run" title="multiprocessing.Process.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> . El valor predeterminado es <code class="docutils literal notranslate"><span class="pre">None</span></code>, lo que significa que nada es llamado. <em>name</em> es el nombre del proceso (consulte <a class="reference internal" href="#multiprocessing.Process.name" title="multiprocessing.Process.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a> para más detalles). <em>args</em> es la tupla de argumento para la invocación de destino. <em>kwargs</em> es un diccionario de argumentos de palabras clave para la invocación de destino. Si se proporciona, el argumento <em>daemon</em> solo de palabra clave establece el proceso <a class="reference internal" href="#multiprocessing.Process.daemon" title="multiprocessing.Process.daemon"><code class="xref py py-attr docutils literal notranslate"><span class="pre">daemon</span></code></a> en <code class="docutils literal notranslate"><span class="pre">True</span></code> o <code class="docutils literal notranslate"><span class="pre">False</span></code>.  Si <code class="docutils literal notranslate"><span class="pre">None</span></code> (el valor predeterminado), este indicador se heredará del proceso de creación.</p>
<p>De forma predeterminada, no se pasan argumentos a <em>target</em>. El argumento <em>args</em>, que por defecto es <code class="docutils literal notranslate"><span class="pre">()</span></code>, se puede usar para especificar una lista o tupla de los argumentos para pasar a <em>target</em>.</p>
<p>Si una subclase anula al constructor, debe asegurarse de que invoca al constructor de la clase base (<code class="xref py py-meth docutils literal notranslate"><span class="pre">Process.__init__()</span></code>) antes de hacer cualquier otra cosa al proceso.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Añadido el argumento <em>daemon</em>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.Process.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Process.run" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Método que representa la actividad del proceso.</p>
<p>Puede anular este método en una subclase. El método estándar <a class="reference internal" href="#multiprocessing.Process.run" title="multiprocessing.Process.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> invoca el objeto invocable pasado al constructor del objeto como argumento objetivo, si lo hay, con argumentos posicionares y de palabras clave tomados de los argumentos <em>args</em> y <em>kwargs</em>, respectivamente.</p>
<p>El uso de una lista o tupla como argumento <em>args</em> pasado a <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> logra el mismo efecto.</p>
<p>Ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="nb">print</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="nb">print</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.Process.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Process.start" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Comienza la actividad del proceso.</p>
<p>Esto debe llamarse como máximo una vez por objeto de proceso. Organiza la invocación del método <a class="reference internal" href="#multiprocessing.Process.run" title="multiprocessing.Process.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> del objeto en un proceso separado.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.Process.join">
<span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Process.join" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si el argumento opcional <em>timeout</em> es <code class="docutils literal notranslate"><span class="pre">None</span></code> (el valor predeterminado), el método se bloquea hasta que el proceso cuyo método <a class="reference internal" href="#multiprocessing.Process.join" title="multiprocessing.Process.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code></a> se llama termina. Si <em>timeout</em> es un número positivo, bloquea como máximo <em>timeout</em> segundos. Tenga en cuenta que el método retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si su proceso finaliza o si el método agota el tiempo de espera. Verifique el proceso <a class="reference internal" href="#multiprocessing.Process.exitcode" title="multiprocessing.Process.exitcode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">exitcode</span></code></a> para determinar si terminó.</p>
<p>Un proceso puede unirse muchas veces.</p>
<p>Un proceso no puede unirse a sí mismo porque esto provocaría un punto muerto. Es un error intentar unirse a un proceso antes de que se haya iniciado.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="multiprocessing.Process.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#multiprocessing.Process.name" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El nombre del proceso. El nombre es una cadena utilizada solo con fines de identificación. No tiene semántica. Múltiples procesos pueden tener el mismo nombre.</p>
<p>El nombre inicial es establecido por el constructor. Si no se proporciona un nombre explícito al constructor, se forma un nombre usando <em>“Process-N:sub:`1`:N:sub:`2`:…:N:sub:`k`”</em> se construye, donde cada <em>N:sub:`k`</em> es el <em>N-enésimo</em> hijo del parental.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.Process.is_alive">
<span class="sig-name descname"><span class="pre">is_alive</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Process.is_alive" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna si el proceso está vivo.</p>
<p>Aproximadamente, un objeto de proceso está vivo desde el momento en que el método <a class="reference internal" href="#multiprocessing.Process.start" title="multiprocessing.Process.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a> retorna hasta que finaliza el proceso hijo.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="multiprocessing.Process.daemon">
<span class="sig-name descname"><span class="pre">daemon</span></span><a class="headerlink" href="#multiprocessing.Process.daemon" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La bandera del proceso <em>daemon</em> , es un valor booleano. Esto debe establecerse antes de que <a class="reference internal" href="#multiprocessing.Process.start" title="multiprocessing.Process.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a> sea llamado.</p>
<p>El valor inicial se hereda del proceso de creación.</p>
<p>Cuando un proceso sale, intenta terminar todos sus procesos demoníacos (<em>daemonic</em>) hijos.</p>
<p>Tenga en cuenta que un proceso demoníaco (<em>daemonic</em>) no puede crear procesos hijos. De lo contrario, un proceso demoníaco (<em>daemonic</em>) dejaría a sus hijos huérfanos si se termina cuando finaliza su proceso parental. Además, estos <strong>no</strong> son <em>daemons</em> o servicios de Unix, son procesos normales qué finalizarán (y no se unirán) si los procesos no demoníacos han salido.</p>
</dd></dl>

<p>Además de API <a class="reference internal" href="threading.html#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Thread</span></code></a>, los objetos <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> también admiten los siguientes atributos y métodos:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="multiprocessing.Process.pid">
<span class="sig-name descname"><span class="pre">pid</span></span><a class="headerlink" href="#multiprocessing.Process.pid" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el ID del proceso. Antes de que se genere el proceso, esto será <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="multiprocessing.Process.exitcode">
<span class="sig-name descname"><span class="pre">exitcode</span></span><a class="headerlink" href="#multiprocessing.Process.exitcode" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El código de salida del proceso secundario. Será <code class="docutils literal notranslate"><span class="pre">None</span></code> si el proceso aún no ha finalizado.</p>
<p>Si el método <a class="reference internal" href="#multiprocessing.Process.run" title="multiprocessing.Process.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> del proceso secundario se retornó normalmente, el código de salida será 0. Si terminó a través de <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a> con un argumento entero <em>N</em>, el código de salida será <em>N</em>.</p>
<p>Si el proceso secundario finalizó debido a una excepción no capturada dentro de <a class="reference internal" href="#multiprocessing.Process.run" title="multiprocessing.Process.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a>, el código de salida será 1. Si fue terminado por la señal <em>N</em>, el código de salida será el valor negativo <em>-N</em>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="multiprocessing.Process.authkey">
<span class="sig-name descname"><span class="pre">authkey</span></span><a class="headerlink" href="#multiprocessing.Process.authkey" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La clave de autenticación del proceso (una cadena de bytes).</p>
<p>Cuando el <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> se inicializa el proceso principal se le asigna una cadena aleatoria usando <a class="reference internal" href="os.html#os.urandom" title="os.urandom"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.urandom()</span></code></a>.</p>
<p>Cuando se crea un objeto <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a>, este heredará la clave de autenticación de su proceso parental, aunque esto puede cambiarse configurando <a class="reference internal" href="#multiprocessing.Process.authkey" title="multiprocessing.Process.authkey"><code class="xref py py-attr docutils literal notranslate"><span class="pre">authkey</span></code></a> a otra cadena de bytes.</p>
<p>Consulte <a class="reference internal" href="#multiprocessing-auth-keys"><span class="std std-ref">Llaves de autentificación</span></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="multiprocessing.Process.sentinel">
<span class="sig-name descname"><span class="pre">sentinel</span></span><a class="headerlink" href="#multiprocessing.Process.sentinel" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un identificador numérico de un objeto del sistema que estará «listo» cuando finalice el proceso.</p>
<p>Se puede usar este valor si desea esperar varios eventos a la vez usando <a class="reference internal" href="#multiprocessing.connection.wait" title="multiprocessing.connection.wait"><code class="xref py py-func docutils literal notranslate"><span class="pre">multiprocessing.connection.wait()</span></code></a>. De lo contrario, llamar a <a class="reference internal" href="#multiprocessing.Process.join" title="multiprocessing.Process.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code></a> es más simple.</p>
<p>En Windows, este es un sistema operativo manejable con la familia de llamadas API <code class="docutils literal notranslate"><span class="pre">WaitForSingleObject</span></code> y <code class="docutils literal notranslate"><span class="pre">WaitForMultipleObjects</span></code>. En Unix, este es un descriptor de archivo utilizable con primitivas del módulo <a class="reference internal" href="select.html#module-select" title="select: Wait for I/O completion on multiple streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">select</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.Process.terminate">
<span class="sig-name descname"><span class="pre">terminate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Process.terminate" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Terminar el proceso. En Unix, esto se hace usando la señal <code class="docutils literal notranslate"><span class="pre">SIGTERM</span></code>; en Windows se utiliza <code class="xref c c-func docutils literal notranslate"><span class="pre">TerminateProcess()</span></code> . Tenga en cuenta que los manejadores de salida y finalmente las cláusulas, etc., no se ejecutarán.</p>
<p>Tenga en cuenta que los procesos descendientes del proceso <em>no</em> finalizarán – simplemente quedarán huérfanos.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Si este método se usa cuando el proceso asociado está usando una tubería (<em>pipe</em>) o una cola(<em>queue</em>), entonces la tubería o la cola pueden corromperse y pueden quedar inutilizables por otro proceso. Del mismo modo, si el proceso ha adquirido un <em>lock</em> o un semáforo, etc., su finalización puede provocar el bloqueo de otros procesos.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.Process.kill">
<span class="sig-name descname"><span class="pre">kill</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Process.kill" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Siempre como <a class="reference internal" href="#multiprocessing.Process.terminate" title="multiprocessing.Process.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">terminate()</span></code></a> pero utilizando la señal <code class="docutils literal notranslate"><span class="pre">SIGKILL</span></code> en Unix.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.Process.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Process.close" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El cierre del objeto <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a>, libera todos los recursos asociados a él.  <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> se lanza si el proceso subyacente aún se está ejecutando. Una vez <a class="reference internal" href="#multiprocessing.Process.close" title="multiprocessing.Process.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> se retorna con éxito, la mayoría de los otros métodos y atributos del objeto <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> lanzará <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<p>Tenga en cuenta que los métodos <a class="reference internal" href="#multiprocessing.Process.start" title="multiprocessing.Process.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a>, <a class="reference internal" href="#multiprocessing.Process.join" title="multiprocessing.Process.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code></a>, <a class="reference internal" href="#multiprocessing.Process.is_alive" title="multiprocessing.Process.is_alive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_alive()</span></code></a>, <a class="reference internal" href="#multiprocessing.Process.terminate" title="multiprocessing.Process.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">terminate()</span></code></a> y <a class="reference internal" href="#multiprocessing.Process.exitcode" title="multiprocessing.Process.exitcode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">exitcode</span></code></a> deberían solo ser llamados por el proceso que creó el objeto del proceso.</p>
<p>Ejemplo de uso de algunos métodos de la <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a>:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">multiprocessing</span><span class="o">,</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">signal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">1000</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">is_alive</span><span class="p">())</span>
<span class="go">&lt;Process ... initial&gt; False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">is_alive</span><span class="p">())</span>
<span class="go">&lt;Process ... started&gt; True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">is_alive</span><span class="p">())</span>
<span class="go">&lt;Process ... stopped exitcode=-SIGTERM&gt; False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">exitcode</span> <span class="o">==</span> <span class="o">-</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGTERM</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="multiprocessing.ProcessError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">ProcessError</span></span><a class="headerlink" href="#multiprocessing.ProcessError" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La clase base de todas las excepciones <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a>.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="multiprocessing.BufferTooShort">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">BufferTooShort</span></span><a class="headerlink" href="#multiprocessing.BufferTooShort" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La excepción <code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.recv_bytes_into()</span></code> es lanzada cuando el objeto de búfer suministrado es demasiado pequeño para el mensaje leído.</p>
<p>Si <code class="docutils literal notranslate"><span class="pre">e</span></code> es una instancia de <a class="reference internal" href="#multiprocessing.BufferTooShort" title="multiprocessing.BufferTooShort"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BufferTooShort</span></code></a> entonces <code class="docutils literal notranslate"><span class="pre">e.args[0]</span></code> dará el mensaje como una cadena de <em>bytes</em>.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="multiprocessing.AuthenticationError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">AuthenticationError</span></span><a class="headerlink" href="#multiprocessing.AuthenticationError" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Lanzada cuando hay un error de autenticación.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="multiprocessing.TimeoutError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">TimeoutError</span></span><a class="headerlink" href="#multiprocessing.TimeoutError" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Lanzada por métodos con un tiempo de espera (<em>timeout</em>) cuando este expira.</p>
</dd></dl>

</section>
<section id="pipes-and-queues">
<h3>Tuberías (<em>Pipes</em>) y Colas (<em>Queues</em>)<a class="headerlink" href="#pipes-and-queues" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Cuando se usan múltiples procesos, uno generalmente usa el paso de mensajes para la comunicación entre procesos y evita tener que usar primitivas de sincronización como <em>locks</em>.</p>
<p>Para pasar mensajes se puede usar <a class="reference internal" href="#multiprocessing.Pipe" title="multiprocessing.Pipe"><code class="xref py py-func docutils literal notranslate"><span class="pre">Pipe()</span></code></a> (para una conexión entre dos procesos) o una cola (<em>queue</em>)(que permite múltiples productores y consumidores).</p>
<p>Los tipos <a class="reference internal" href="#multiprocessing.Queue" title="multiprocessing.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>, <a class="reference internal" href="#multiprocessing.SimpleQueue" title="multiprocessing.SimpleQueue"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleQueue</span></code></a> y <a class="reference internal" href="#multiprocessing.JoinableQueue" title="multiprocessing.JoinableQueue"><code class="xref py py-class docutils literal notranslate"><span class="pre">JoinableQueue</span></code></a> son colas multi-productor, multi-consumidor <abbr title="first-in, first-out">FIFO</abbr> (primero en entrar, primero en salir) modeladas en <a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.Queue</span></code></a> en la biblioteca estándar. Se diferencian en que <a class="reference internal" href="#multiprocessing.Queue" title="multiprocessing.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> carece de <a class="reference internal" href="queue.html#queue.Queue.task_done" title="queue.Queue.task_done"><code class="xref py py-meth docutils literal notranslate"><span class="pre">task_done()</span></code></a> y <a class="reference internal" href="queue.html#queue.Queue.join" title="queue.Queue.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code></a> métodos introducidos en Python 2.5 <a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.Queue</span></code></a> class.</p>
<p>Si usa <a class="reference internal" href="#multiprocessing.JoinableQueue" title="multiprocessing.JoinableQueue"><code class="xref py py-class docutils literal notranslate"><span class="pre">JoinableQueue</span></code></a>, entonces <strong>debe</strong> llamar a <a class="reference internal" href="#multiprocessing.JoinableQueue.task_done" title="multiprocessing.JoinableQueue.task_done"><code class="xref py py-meth docutils literal notranslate"><span class="pre">JoinableQueue.task_done()</span></code></a> para cada tarea eliminada de la cola (<em>queue</em>) o de lo contrario el semáforo utilizado para contar el número de tareas sin terminar puede eventualmente desbordarse, lanzando un excepción.</p>
<p>Tenga en cuenta que también se puede crear una cola compartida mediante el uso de un objeto de administrador – consulte <a class="reference internal" href="#multiprocessing-managers"><span class="std std-ref">Administradores (Managers)</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> utiliza las excepciones habituales <a class="reference internal" href="queue.html#queue.Empty" title="queue.Empty"><code class="xref py py-exc docutils literal notranslate"><span class="pre">queue.Empty</span></code></a> y <a class="reference internal" href="queue.html#queue.Full" title="queue.Full"><code class="xref py py-exc docutils literal notranslate"><span class="pre">queue.Full</span></code></a> para indicar un tiempo de espera. No están disponibles en el espacio de nombres <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a>, por lo que debe importarlos desde <a class="reference internal" href="queue.html#module-queue" title="queue: A synchronized queue class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">queue</span></code></a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Cuando un objeto se coloca en una cola (<em>queue</em>), el objeto se serializa (<em>pickled</em>) y luego un subproceso de fondo vacía los datos serializados a una tubería (<em>pipe</em>) subyacente. Esto tiene algunas consecuencias que son un poco sorprendentes, pero no deberían causar dificultades prácticas: si realmente causan molestias, se puede usar una cola creada con un <a class="reference internal" href="#multiprocessing-managers"><span class="std std-ref">manager</span></a>.</p>
<ol class="arabic simple">
<li><p>Después de poner un objeto en una cola vacía, puede haber un retraso infinitesimal antes de que el método de la cola <a class="reference internal" href="#multiprocessing.Queue.empty" title="multiprocessing.Queue.empty"><code class="xref py py-meth docutils literal notranslate"><span class="pre">empty()</span></code></a> retorne <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> y <a class="reference internal" href="#multiprocessing.Queue.get_nowait" title="multiprocessing.Queue.get_nowait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_nowait()</span></code></a> puede retornar sin lanzar <a class="reference internal" href="queue.html#queue.Empty" title="queue.Empty"><code class="xref py py-exc docutils literal notranslate"><span class="pre">queue.Empty</span></code></a>.</p></li>
<li><p>Si varios procesos están poniendo en cola objetos, es posible que los objetos se reciban en el otro extremo fuera de orden. Sin embargo, los objetos en cola por el mismo proceso siempre estarán en el orden esperado entre sí.</p></li>
</ol>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Si se termina un proceso usando <a class="reference internal" href="#multiprocessing.Process.terminate" title="multiprocessing.Process.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Process.terminate()</span></code></a> o <a class="reference internal" href="os.html#os.kill" title="os.kill"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.kill()</span></code></a> mientras intenta usar una clase <a class="reference internal" href="#multiprocessing.Queue" title="multiprocessing.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>, es probable que los datos de la cola(<em>queue</em>) se corrompan. Esto puede hacer que cualquier otro proceso obtenga una excepción cuando intente usar la cola más adelante.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Como se mencionó anteriormente, si un proceso hijo ha puesto elementos en una cola (<em>queue</em>) (y no ha utilizado <a class="reference internal" href="#multiprocessing.Queue.cancel_join_thread" title="multiprocessing.Queue.cancel_join_thread"><code class="xref py py-meth docutils literal notranslate"><span class="pre">JoinableQueue.cancel_join_thread</span></code></a>), entonces ese proceso no terminará hasta que todos los elementos almacenados en búfer hayan sido vaciados a la tubería (<em>pipe</em>).</p>
<p>Esto significa que si intenta unirse a ese proceso, puede obtener un punto muerto a menos que esté seguro de que todos los elementos que se han puesto en la cola (<em>queue</em>) se han consumido. Del mismo modo, si el proceso hijo no es <em>daemonic</em>, el proceso parental puede bloquearse en la salida cuando intenta unir todos sus elementos hijos no <em>daemonic</em>.</p>
<p>Tenga en cuenta que una cola (<em>queue</em>) creada con un administrador no tiene este problema. Consulte <a class="reference internal" href="#multiprocessing-programming"><span class="std std-ref">Pautas de programación</span></a>.</p>
</div>
<p>Para ver un ejemplo del uso de colas para la comunicación entre procesos, consulte <a class="reference internal" href="#multiprocessing-examples"><span class="std std-ref">Ejemplos</span></a>.</p>
<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.Pipe">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">Pipe</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">duplex</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Pipe" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un par de objetos <em>``(conn1, conn2)``</em> de la <a class="reference internal" href="#multiprocessing.connection.Connection" title="multiprocessing.connection.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> que representan los extremos de una tubería (<em>pipe</em>).</p>
<p>Si <em>duplex</em> es <code class="docutils literal notranslate"><span class="pre">True</span></code> (el valor predeterminado), entonces la tubería (<em>pipe</em>) es bidireccional. Si <em>duplex</em> es <code class="docutils literal notranslate"><span class="pre">False</span></code>, entonces la tubería es unidireccional: <code class="docutils literal notranslate"><span class="pre">conn1</span></code> solo se puede usar para recibir mensajes y <code class="docutils literal notranslate"><span class="pre">conn2</span></code> solo se puede usar para enviar mensajes.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="multiprocessing.Queue">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">Queue</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">maxsize</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Queue" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un proceso de cola (<em>queue</em>) compartida implementado utilizando una tubería (<em>pipe</em>) y algunos candados/semáforos (<em>locks/semaphores</em>). Cuando un proceso pone por primera vez un elemento en la cola, se inicia un hilo alimentador que transfiere objetos desde un búfer a la tubería.</p>
<p>Las excepciones habituales <a class="reference internal" href="queue.html#queue.Empty" title="queue.Empty"><code class="xref py py-exc docutils literal notranslate"><span class="pre">queue.Empty</span></code></a> y <a class="reference internal" href="queue.html#queue.Full" title="queue.Full"><code class="xref py py-exc docutils literal notranslate"><span class="pre">queue.Full</span></code></a> del módulo de la biblioteca estándar <a class="reference internal" href="queue.html#module-queue" title="queue: A synchronized queue class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">queue</span></code></a> se generan para indicar tiempos de espera.</p>
<p>La <a class="reference internal" href="#multiprocessing.Queue" title="multiprocessing.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> implementa todos los métodos de la <a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.Queue</span></code></a> excepto por <a class="reference internal" href="queue.html#queue.Queue.task_done" title="queue.Queue.task_done"><code class="xref py py-meth docutils literal notranslate"><span class="pre">task_done()</span></code></a> y <a class="reference internal" href="queue.html#queue.Queue.join" title="queue.Queue.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.Queue.qsize">
<span class="sig-name descname"><span class="pre">qsize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Queue.qsize" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el tamaño aproximado de la cola (<em>queue</em>). Debido a la semántica multiproceso/multiprocesamiento, este número no es confiable.</p>
<p>Tenga en cuenta que esto puede lanzar <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> en plataformas Unix como macOS donde <code class="docutils literal notranslate"><span class="pre">sem_getvalue()</span></code> no está implementado.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.Queue.empty">
<span class="sig-name descname"><span class="pre">empty</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Queue.empty" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si la cola (<em>queue</em>) está vacía, de lo contrario retorna <code class="docutils literal notranslate"><span class="pre">False</span></code> . Debido a la semántica multiproceso/multiprocesamiento, esto no es confiable.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.Queue.full">
<span class="sig-name descname"><span class="pre">full</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Queue.full" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si la cola (<em>queue</em>) está llena, de lo contrario retorna <code class="docutils literal notranslate"><span class="pre">False</span></code> . Debido a la semántica multiproceso/multiprocesamiento, esto no es confiable.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.Queue.put">
<span class="sig-name descname"><span class="pre">put</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">block</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Queue.put" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Pone <em>obj</em> en la cola. Si el argumento opcional <em>block</em> es <code class="docutils literal notranslate"><span class="pre">True</span></code> (el valor predeterminado) y <em>timeout</em> es <code class="docutils literal notranslate"><span class="pre">None</span></code> (el valor predeterminado), se bloquea si es necesario hasta que haya un espacio disponible. Si <em>timeout</em> es un número positivo, bloquea a lo sumo <em>timeout</em> segundos y genera la excepción <a class="reference internal" href="queue.html#queue.Full" title="queue.Full"><code class="xref py py-exc docutils literal notranslate"><span class="pre">queue.Full</span></code></a> si no hay espacio libre disponible en ese tiempo. De lo contrario (<em>block</em> es <code class="docutils literal notranslate"><span class="pre">False</span></code>), y coloca un elemento en la cola si hay un espacio libre disponible de inmediato, de lo contrario, genera la excepción <a class="reference internal" href="queue.html#queue.Full" title="queue.Full"><code class="xref py py-exc docutils literal notranslate"><span class="pre">queue.Full</span></code></a> (<em>timeout</em> se ignora en ese caso).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Si la cola (<em>queue</em>) está cerrada, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> se lanza en lugar de <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.Queue.put_nowait">
<span class="sig-name descname"><span class="pre">put_nowait</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Queue.put_nowait" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Equivalente a <code class="docutils literal notranslate"><span class="pre">put(obj,</span> <span class="pre">False)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.Queue.get">
<span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">block</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Queue.get" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Elimina y retorna un artículo de la cola (<em>queue</em>). Si un argumento opcional <em>block</em> es <code class="docutils literal notranslate"><span class="pre">True</span></code> (el valor predeterminado) y el <em>timeout</em> es <code class="docutils literal notranslate"><span class="pre">None</span></code> (el valor predeterminado), es bloqueado si es necesario hasta que un elemento esté disponible. Si el <em>timeout</em> es un número positivo, bloquea a lo sumo segundos y genera la excepción <a class="reference internal" href="queue.html#queue.Empty" title="queue.Empty"><code class="xref py py-exc docutils literal notranslate"><span class="pre">queue.Empty</span></code></a> si no había ningún elemento disponible dentro de ese tiempo. De lo contrario (el bloque es <code class="docutils literal notranslate"><span class="pre">False</span></code>), retorna un elemento si hay uno disponible de inmediato, de lo contrario, levante la excepción <a class="reference internal" href="queue.html#queue.Empty" title="queue.Empty"><code class="xref py py-exc docutils literal notranslate"><span class="pre">queue.Empty</span></code></a> (<em>timeout</em> se ignora en ese caso).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Si la cola está cerrada, se lanza <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> en lugar de <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.Queue.get_nowait">
<span class="sig-name descname"><span class="pre">get_nowait</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Queue.get_nowait" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Equivalente a <code class="docutils literal notranslate"><span class="pre">get(False)</span></code>.</p>
</dd></dl>

<p>La <a class="reference internal" href="#multiprocessing.Queue" title="multiprocessing.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">multiprocessing.Queue</span></code></a> tiene algunos métodos adicionales que no se encuentran en <a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.Queue</span></code></a>. Estos métodos suelen ser innecesarios para la mayoría de los códigos:</p>
<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.Queue.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Queue.close" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Indica que el proceso actual no colocará más datos en esta cola (<em>queue</em>). El subproceso en segundo plano se cerrará una vez que haya vaciado todos los datos almacenados en la tubería (<em>pipe</em>). Esto se llama automáticamente cuando la cola es recolectada por el recolector de basura.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.Queue.join_thread">
<span class="sig-name descname"><span class="pre">join_thread</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Queue.join_thread" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Unifica al hilo de fondo. Esto solo se puede usar después de que se ha llamado a <a class="reference internal" href="#multiprocessing.Queue.close" title="multiprocessing.Queue.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a>. Esto se bloquea hasta que salga el hilo de fondo, asegurando que todos los datos en el búfer se hayan vaciado a la tubería (<em>pipe</em>).</p>
<p>Por defecto, si un proceso no es el creador de la cola (<em>queue</em>), al salir intentará unirse al hilo de fondo de la cola. El proceso puede llamar a <a class="reference internal" href="#multiprocessing.Queue.cancel_join_thread" title="multiprocessing.Queue.cancel_join_thread"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancel_join_thread()</span></code></a> para hacer que el <a class="reference internal" href="#multiprocessing.Queue.join_thread" title="multiprocessing.Queue.join_thread"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join_thread()</span></code></a> no haga nada.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.Queue.cancel_join_thread">
<span class="sig-name descname"><span class="pre">cancel_join_thread</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Queue.cancel_join_thread" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Evita que <a class="reference internal" href="#multiprocessing.Queue.join_thread" title="multiprocessing.Queue.join_thread"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join_thread()</span></code></a> bloquee. En particular, esto evita que el subproceso en segundo plano se una automáticamente cuando finaliza el proceso; consulte <a class="reference internal" href="#multiprocessing.Queue.join_thread" title="multiprocessing.Queue.join_thread"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join_thread()</span></code></a>.</p>
<p>Un mejor nombre para este método podría ser <code class="docutils literal notranslate"><span class="pre">allow_exit_without_flush()</span></code>.  Es probable que provoque la pérdida de datos encolados, y es casi seguro que no necesitará usarlo. Realmente solo está allí si necesita que el proceso actual salga inmediatamente sin esperar a vaciar los datos en en la tubería (<em>pipe</em>) subyacente, y no le importan los datos perdidos.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La funcionalidad de esta clase requiere una implementación de semáforo compartido en funcionamiento en el sistema operativo que es huésped (<em>host</em>). Sin uno, la funcionalidad en esta clase se deshabilitará, y los intentos de instanciar a <a class="reference internal" href="#multiprocessing.Queue" title="multiprocessing.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> resultarán en <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>. Consulte <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3770">bpo-3770</a> para información adicional. Lo mismo es válido para cualquiera de los tipos de cola especializados que se enumeran a continuación.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="multiprocessing.SimpleQueue">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">SimpleQueue</span></span><a class="headerlink" href="#multiprocessing.SimpleQueue" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Es un tipo simplificado <a class="reference internal" href="#multiprocessing.Queue" title="multiprocessing.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>, muy similar a un <em>lock</em> de <a class="reference internal" href="#multiprocessing.Pipe" title="multiprocessing.Pipe"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipe</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.SimpleQueue.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.SimpleQueue.close" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Cierra la cola: libera recursos internos.</p>
<p>Una cola no se debe usar más después de ser cerrada. Por ejemplo los métodos <a class="reference internal" href="#multiprocessing.SimpleQueue.get" title="multiprocessing.SimpleQueue.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a>, <a class="reference internal" href="#multiprocessing.SimpleQueue.put" title="multiprocessing.SimpleQueue.put"><code class="xref py py-meth docutils literal notranslate"><span class="pre">put()</span></code></a> y <a class="reference internal" href="#multiprocessing.SimpleQueue.empty" title="multiprocessing.SimpleQueue.empty"><code class="xref py py-meth docutils literal notranslate"><span class="pre">empty()</span></code></a> no deben ser llamados.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.SimpleQueue.empty">
<span class="sig-name descname"><span class="pre">empty</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.SimpleQueue.empty" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si la cola (<em>queue</em>) está vacía, de otra manera retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.SimpleQueue.get">
<span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.SimpleQueue.get" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Eliminar y retornar un artículo de la cola (<em>queue</em>).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.SimpleQueue.put">
<span class="sig-name descname"><span class="pre">put</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.SimpleQueue.put" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Pone <em>item</em> en la cola.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="multiprocessing.JoinableQueue">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">JoinableQueue</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">maxsize</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.JoinableQueue" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p><a class="reference internal" href="#multiprocessing.JoinableQueue" title="multiprocessing.JoinableQueue"><code class="xref py py-class docutils literal notranslate"><span class="pre">JoinableQueue</span></code></a>, una subclase <a class="reference internal" href="#multiprocessing.Queue" title="multiprocessing.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> , es una cola (<em>queue</em>) que además tiene los métodos <a class="reference internal" href="#multiprocessing.JoinableQueue.task_done" title="multiprocessing.JoinableQueue.task_done"><code class="xref py py-meth docutils literal notranslate"><span class="pre">task_done()</span></code></a> y <a class="reference internal" href="#multiprocessing.JoinableQueue.join" title="multiprocessing.JoinableQueue.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.JoinableQueue.task_done">
<span class="sig-name descname"><span class="pre">task_done</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.JoinableQueue.task_done" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Indica que una tarea anteriormente en cola (<em>queue</em>) está completa. Usado por los consumidores de la cola. Por cada <a class="reference internal" href="#multiprocessing.Queue.get" title="multiprocessing.Queue.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> utilizado para recuperar una tarea, una llamada posterior a <a class="reference internal" href="#multiprocessing.JoinableQueue.task_done" title="multiprocessing.JoinableQueue.task_done"><code class="xref py py-meth docutils literal notranslate"><span class="pre">task_done()</span></code></a> le dice a la cola que el procesamiento de la tarea se ha completado.</p>
<p>Si un <a class="reference internal" href="queue.html#queue.Queue.join" title="queue.Queue.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code></a> se está bloqueando actualmente, se reanudará cuando se hayan procesado todos los elementos (lo que significa que <a class="reference internal" href="#multiprocessing.JoinableQueue.task_done" title="multiprocessing.JoinableQueue.task_done"><code class="xref py py-meth docutils literal notranslate"><span class="pre">task_done()</span></code></a> es llamado para cada elemento que había sido puesto en cola (<em>queue</em>) por <a class="reference internal" href="#multiprocessing.Queue.put" title="multiprocessing.Queue.put"><code class="xref py py-meth docutils literal notranslate"><span class="pre">put()</span></code></a>).</p>
<p>Lanza un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> si es llamado más veces que elementos hay en una cola.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.JoinableQueue.join">
<span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.JoinableQueue.join" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Se bloquea hasta que todos los elementos en una cola han sido recibidos y procesados.</p>
<p>El recuento de tareas no finalizadas aumenta cada vez que se agrega un elemento a la cola. El recuento disminuye cada vez que un consumidor llama a <a class="reference internal" href="#multiprocessing.JoinableQueue.task_done" title="multiprocessing.JoinableQueue.task_done"><code class="xref py py-meth docutils literal notranslate"><span class="pre">task_done()</span></code></a> para indicar que el artículo se recuperó y todo el trabajo en él está completo. Cuando el recuento de tareas inacabadas cae a cero, <a class="reference internal" href="queue.html#queue.Queue.join" title="queue.Queue.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code></a> se desbloquea.</p>
</dd></dl>

</dd></dl>

</section>
<section id="miscellaneous">
<h3>Miscelánea<a class="headerlink" href="#miscellaneous" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.active_children">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">active_children</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.active_children" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una lista con todos los hijos del proceso actual.</p>
<p>Llamar a esto tiene el efecto secundario de «unir» (<em>joining</em>) cualquier proceso que ya haya finalizado.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.cpu_count">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">cpu_count</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.cpu_count" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el número de CPU en el sistema.</p>
<p>Este número no es equivalente al número de CPU que puede utilizar el proceso actual. El número de CPU utilizables se puede obtener con <code class="docutils literal notranslate"><span class="pre">len(os.sched_getaffinity(0))</span></code></p>
<p>Cuando no se puede determinar el número de CPUs, se lanza un <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p><a class="reference internal" href="os.html#os.cpu_count" title="os.cpu_count"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.cpu_count()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.current_process">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">current_process</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.current_process" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el objeto de la <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> correspondiente al proceso actual.</p>
<p>Un análogo de la <a class="reference internal" href="threading.html#threading.current_thread" title="threading.current_thread"><code class="xref py py-func docutils literal notranslate"><span class="pre">threading.current_thread()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.parent_process">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">parent_process</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.parent_process" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el objeto de la <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> correspondiente al proceso parental de <a class="reference internal" href="#multiprocessing.current_process" title="multiprocessing.current_process"><code class="xref py py-func docutils literal notranslate"><span class="pre">current_process()</span></code></a>. Para el proceso principal, <code class="docutils literal notranslate"><span class="pre">parent_process</span></code> será <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.freeze_support">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">freeze_support</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.freeze_support" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Agrega soporte para cuando un programa que utiliza <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> se haya congelado para producir un ejecutable de Windows. (Ha sido probado con <strong>py2exe</strong>, <strong>PyInstaller</strong> y <strong>cx_Freeze</strong>.)</p>
<p>Es necesario llamar a esta función inmediatamente después de la línea principal del módulo <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code> . Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">freeze_support</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hello world!&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">freeze_support</span><span class="p">()</span>
    <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>Si se omite la línea <code class="docutils literal notranslate"><span class="pre">freeze_support()</span></code> entonces se intenta comenzar el ejecutable congelado que lanzará <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>.</p>
<p>La llamada de <code class="docutils literal notranslate"><span class="pre">freeze_support()</span></code> no tiene efecto cuando es invocada por cualquier sistema operativo que no sea Windows. Además, si el módulo ha sido ejecutado en un intérprete de Python en Windows (y el programa no se ha congelado) entonces <code class="docutils literal notranslate"><span class="pre">freeze_support()</span></code> no tiene efecto.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.get_all_start_methods">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">get_all_start_methods</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.get_all_start_methods" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una lista de los métodos de inicio admitidos, el primero de los cuales es el predeterminado. Los posibles métodos de inicio son <code class="docutils literal notranslate"><span class="pre">'fork'</span></code>, <code class="docutils literal notranslate"><span class="pre">'spawn'</span></code> y <code class="docutils literal notranslate"><span class="pre">'forkserver'</span></code>. En Windows solo está disponible <code class="docutils literal notranslate"><span class="pre">'spawn'</span></code>. En Unix, <code class="docutils literal notranslate"><span class="pre">'fork'</span></code> y <code class="docutils literal notranslate"><span class="pre">'spawn'</span></code> siempre son compatibles, siendo <code class="docutils literal notranslate"><span class="pre">'fork'</span></code> el valor predeterminado.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.get_context">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">get_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.get_context" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un objeto de contexto que tiene los mismos atributos que el módulo <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a>.</p>
<p>Si el método <em>method</em> es <code class="docutils literal notranslate"><span class="pre">None</span></code> entonces el contexto predeterminado es retornado. Por lo contrario, <em>method</em> debería ser <code class="docutils literal notranslate"><span class="pre">'fork'</span></code>, <code class="docutils literal notranslate"><span class="pre">'spawn'</span></code>, <code class="docutils literal notranslate"><span class="pre">'forkserver'</span></code>. Se lanza <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> if el método de inicio no esta disponible.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.get_start_method">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">get_start_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">allow_none</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.get_start_method" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el nombre del método de inicio que es utilizado para iniciar procesos.</p>
<p>Si el método de inicio no se ha solucionado y <em>allow_none</em> es falso, entonces el método de inicio se fija al predeterminado y se retorna el nombre. Si el método de inicio no se ha solucionado y <em>allow_none</em> es verdadero, se retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>El valor retornado puede ser <code class="docutils literal notranslate"><span class="pre">'fork'</span></code>, <code class="docutils literal notranslate"><span class="pre">'spawn'</span></code>, <code class="docutils literal notranslate"><span class="pre">'forkserver'</span></code> o <code class="docutils literal notranslate"><span class="pre">None</span></code>. En Unix <code class="docutils literal notranslate"><span class="pre">'fork'</span></code> es el valor predeterminado mientras que <code class="docutils literal notranslate"><span class="pre">'spawn'</span></code> lo es en Windows y macOS.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>En macOS, el método de inicio <em>spawn</em> ahora es el predeterminado. El método de inicio <em>fork</em> debe considerarse inseguro ya que puede provocar bloqueos del subproceso. Consulte <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=33725">bpo-33725</a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.set_executable">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">set_executable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">executable</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.set_executable" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establezca la ruta del intérprete de Python para usar al iniciar un proceso secundario. (Por defecto se usa <a class="reference internal" href="sys.html#sys.executable" title="sys.executable"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.executable</span></code></a>). Los integradores probablemente necesitarán hacer algo como</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">set_executable</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">exec_prefix</span><span class="p">,</span> <span class="s1">&#39;pythonw.exe&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>antes ellos pueden crear procesos hijos.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Ahora es compatible con Unix cuando se usa el método de inicio <code class="docutils literal notranslate"><span class="pre">'spawn'</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Acepta un <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.set_start_method">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">set_start_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.set_start_method" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Set the method which should be used to start child processes.
The <em>method</em> argument can be <code class="docutils literal notranslate"><span class="pre">'fork'</span></code>, <code class="docutils literal notranslate"><span class="pre">'spawn'</span></code> or <code class="docutils literal notranslate"><span class="pre">'forkserver'</span></code>.
Raises <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> if the start method has already been set and <em>force</em>
is not <code class="docutils literal notranslate"><span class="pre">True</span></code>.  If <em>method</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code> and <em>force</em> is <code class="docutils literal notranslate"><span class="pre">True</span></code> then the start
method is set to <code class="docutils literal notranslate"><span class="pre">None</span></code>.  If <em>method</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code> and <em>force</em> is <code class="docutils literal notranslate"><span class="pre">False</span></code>
then the context is set to the default context.</p>
<p>Tenga en cuenta que esto debería llamarse como máximo una vez, y debería protegerse dentro de la cláusula <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code> del módulo principal.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> no contiene análogos de <a class="reference internal" href="threading.html#threading.active_count" title="threading.active_count"><code class="xref py py-func docutils literal notranslate"><span class="pre">threading.active_count()</span></code></a>, <a class="reference internal" href="threading.html#threading.enumerate" title="threading.enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">threading.enumerate()</span></code></a>, <a class="reference internal" href="threading.html#threading.settrace" title="threading.settrace"><code class="xref py py-func docutils literal notranslate"><span class="pre">threading.settrace()</span></code></a>, <a class="reference internal" href="threading.html#threading.setprofile" title="threading.setprofile"><code class="xref py py-func docutils literal notranslate"><span class="pre">threading.setprofile()</span></code></a>, <a class="reference internal" href="threading.html#threading.Timer" title="threading.Timer"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Timer</span></code></a>, o <a class="reference internal" href="threading.html#threading.local" title="threading.local"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.local</span></code></a>.</p>
</div>
</section>
<section id="connection-objects">
<h3>Objetos de conexión <em>Connection Objects</em><a class="headerlink" href="#connection-objects" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Los objetos de conexión permiten el envío y la recepción de objetos serializables (<em>pickable</em>) o cadenas de caracteres seleccionables. Pueden considerarse como sockets conectados orientados a mensajes.</p>
<p>Los objetos de conexión usualmente son creados usando <a class="reference internal" href="#multiprocessing.Pipe" title="multiprocessing.Pipe"><code class="xref py py-func docutils literal notranslate"><span class="pre">Pipe</span></code></a> – ver también <a class="reference internal" href="#multiprocessing-listeners-clients"><span class="std std-ref">Oyentes y clientes (Listeners and Clients)</span></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="multiprocessing.connection.Connection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.connection.</span></span><span class="sig-name descname"><span class="pre">Connection</span></span><a class="headerlink" href="#multiprocessing.connection.Connection" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.connection.Connection.send">
<span class="sig-name descname"><span class="pre">send</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.Connection.send" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Envía un objeto al otro extremo de la conexión que debe leerse usando <a class="reference internal" href="#multiprocessing.connection.Connection.recv" title="multiprocessing.connection.Connection.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a>.</p>
<p>El objeto debe ser serializable (<em>pickable</em>). Los serializados (<em>pickable</em>) muy grandes (aproximadamente 32 <em>MiB+</em> , aunque depende del sistema operativo) pueden generar una excepción <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.connection.Connection.recv">
<span class="sig-name descname"><span class="pre">recv</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.Connection.recv" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un objeto enviado desde el otro extremo de la conexión usando <a class="reference internal" href="#multiprocessing.connection.Connection.send" title="multiprocessing.connection.Connection.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a>. Se bloquea hasta que haya algo para recibir. Se lanza <a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a> si no queda nada por recibir y el otro extremo está cerrado.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.connection.Connection.fileno">
<span class="sig-name descname"><span class="pre">fileno</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.Connection.fileno" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el descriptor de archivo o identificador utilizado por la conexión.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.connection.Connection.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.Connection.close" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Cierra la conexión.</p>
<p>Esto se llama automáticamente cuando la conexión es basura recolectada.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.connection.Connection.poll">
<span class="sig-name descname"><span class="pre">poll</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.Connection.poll" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna si hay datos disponibles para leer.</p>
<p>Si no se especifica <em>timeout</em>, se retornará de inmediato. Si <em>timeout</em> es un número, esto especifica el tiempo máximo en segundos para bloquear. Si <em>timeout</em> es <code class="docutils literal notranslate"><span class="pre">None</span></code>, se usa un tiempo de espera infinito.</p>
<p>Tenga en cuenta que se pueden sondear varios objetos de conexión a la vez utilizando <a class="reference internal" href="#multiprocessing.connection.wait" title="multiprocessing.connection.wait"><code class="xref py py-func docutils literal notranslate"><span class="pre">multiprocessing.connection.wait()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.connection.Connection.send_bytes">
<span class="sig-name descname"><span class="pre">send_bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.Connection.send_bytes" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Envía datos de <em>bytes</em> desde a <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> como un mensaje completo.</p>
<p>Si se da <em>offset</em>, los datos se leen desde esa posición en <em>buffer</em>. Si se da <em>size</em> entonces se leerán muchos <em>bytes</em> del búfer. Los <em>buffers</em> muy grandes (aproximadamente <em>32 MiB+</em>, aunque depende del sistema operativo) pueden generar una excepción <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.connection.Connection.recv_bytes">
<span class="sig-name descname"><span class="pre">recv_bytes</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">maxlength</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.Connection.recv_bytes" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un mensaje completo de datos de <em>bytes</em> enviados desde el otro extremo de la conexión como una cadena de caracteres. Se bloquea hasta que haya algo para recibir. Aumenta <a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a> si no queda nada por recibir y el otro extremo se ha cerrado.</p>
<p>Si se especifica <em>maxlength</em> y el mensaje es más largo que <em>maxlength</em>, entonces se lanza un <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> y la conexión ya no será legible.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Esta función solía lanzar un <a class="reference internal" href="exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IOError</span></code></a>, que ahora es un alias de <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.connection.Connection.recv_bytes_into">
<span class="sig-name descname"><span class="pre">recv_bytes_into</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.Connection.recv_bytes_into" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Lee en <em>buffer</em> un mensaje completo de datos de <em>bytes</em> enviados desde el otro extremo de la conexión y retorne el número de <em>bytes</em> en el mensaje. Se bloquea hasta que haya algo para recibir. Si no queda nada por recibir y el otro extremo está cerrándose se lanza <a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a>.</p>
<p><em>buffer</em> debe ser un escribible <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>. Si se proporciona <em>offset</em> el mensaje se escribirá en el búfer desde esa posición. La compensación debe ser un número entero no negativo menor que la longitud de <em>buffer</em> (en <em>bytes</em>).</p>
<p>Si el búfer es demasiado corto, se genera una excepción <code class="xref py py-exc docutils literal notranslate"><span class="pre">BufferTooShort</span></code> y el mensaje completo está disponible como <code class="docutils literal notranslate"><span class="pre">e.args[0]</span></code> donde <code class="docutils literal notranslate"><span class="pre">e</span></code> es la instancia de excepción.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Los objetos de conexión ahora pueden transferirse entre procesos usando <a class="reference internal" href="#multiprocessing.connection.Connection.send" title="multiprocessing.connection.Connection.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.send()</span></code></a> y <a class="reference internal" href="#multiprocessing.connection.Connection.recv" title="multiprocessing.connection.Connection.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.recv()</span></code></a>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3: </span>Los objetos de conexión ahora admiten el protocolo de administración de contexto – consulte <a class="reference internal" href="stdtypes.html#typecontextmanager"><span class="std std-ref">Tipos gestores de contexto</span></a>.  <a class="reference internal" href="stdtypes.html#contextmanager.__enter__" title="contextmanager.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> retorna el objeto de conexión, y <a class="reference internal" href="stdtypes.html#contextmanager.__exit__" title="contextmanager.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> llama a <a class="reference internal" href="#multiprocessing.connection.Connection.close" title="multiprocessing.connection.Connection.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a>.</p>
</div>
</dd></dl>

<p>Por ejemplo:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pipe</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">send</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
<span class="go">[1, &#39;hello&#39;, None]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">send_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;thank you&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">recv_bytes</span><span class="p">()</span>
<span class="go">b&#39;thank you&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr1</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr2</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">send_bytes</span><span class="p">(</span><span class="n">arr1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">recv_bytes_into</span><span class="p">(</span><span class="n">arr2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">count</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr1</span><span class="p">)</span> <span class="o">*</span> <span class="n">arr1</span><span class="o">.</span><span class="n">itemsize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr2</span>
<span class="go">array(&#39;i&#39;, [0, 1, 2, 3, 4, 0, 0, 0, 0, 0])</span>
</pre></div>
</div>
<div class="admonition warning" id="multiprocessing-recv-pickle-security">
<p class="admonition-title">Advertencia</p>
<p>El método <a class="reference internal" href="#multiprocessing.connection.Connection.recv" title="multiprocessing.connection.Connection.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.recv()</span></code></a> desempaqueta automáticamente los datos que recibe, lo que puede ser un riesgo de seguridad a menos que pueda confiar en el proceso que envió el mensaje.</p>
<p>Por lo tanto, a menos que el objeto de conexión se haya producido usando <code class="xref py py-func docutils literal notranslate"><span class="pre">Pipe()</span></code> solo debe usar los métodos <a class="reference internal" href="#multiprocessing.connection.Connection.recv" title="multiprocessing.connection.Connection.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a> y <a class="reference internal" href="#multiprocessing.connection.Connection.send" title="multiprocessing.connection.Connection.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> después de realizar algún tipo de autenticación. Consulte <a class="reference internal" href="#multiprocessing-auth-keys"><span class="std std-ref">Llaves de autentificación</span></a>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Si se mata un proceso mientras intenta leer o escribir en una tubería (<em>pipe</em>), entonces es probable que los datos en la tubería se corrompan, porque puede ser imposible estar seguro de dónde se encuentran los límites del mensaje.</p>
</div>
</section>
<section id="synchronization-primitives">
<h3>Primitivas de sincronización (<em>Synchronization primitives</em>)<a class="headerlink" href="#synchronization-primitives" title="Enlazar permanentemente con este título">¶</a></h3>
<p>En general, las primitivas de sincronización no son tan necesarias en un programa multiproceso como en un programa <em>multihilos</em> (<em>multithreaded</em>). Consulte la documentación para <a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> .</p>
<p>Tenga en cuenta que también se pueden crear primitivas de sincronización utilizando un objeto administrador – consulte <a class="reference internal" href="#multiprocessing-managers"><span class="std std-ref">Administradores (Managers)</span></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="multiprocessing.Barrier">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">Barrier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parties</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">action</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Barrier" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un objeto de barrera: un clon de <a class="reference internal" href="threading.html#threading.Barrier" title="threading.Barrier"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Barrier</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="multiprocessing.BoundedSemaphore">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">BoundedSemaphore</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.BoundedSemaphore" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un objeto semáforo (<em>semaphore object</em>) acotado: un análogo cercano de la <a class="reference internal" href="threading.html#threading.BoundedSemaphore" title="threading.BoundedSemaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.BoundedSemaphore</span></code></a>.</p>
<p>Existe una diferencia solitaria de su análogo cercano: el primer argumento de su método <code class="docutils literal notranslate"><span class="pre">acquire</span></code> es nombrado <em>block</em>, es consistente con <a class="reference internal" href="#multiprocessing.Lock.acquire" title="multiprocessing.Lock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Lock.acquire()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En macOS, esto no se puede distinguir de <a class="reference internal" href="#multiprocessing.Semaphore" title="multiprocessing.Semaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">Semaphore</span></code></a> porque <code class="docutils literal notranslate"><span class="pre">sem_getvalue()</span></code> no está implementado en esa plataforma.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="multiprocessing.Condition">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">Condition</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">lock</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Condition" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una variable de condición: un alias para la <a class="reference internal" href="threading.html#threading.Condition" title="threading.Condition"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Condition</span></code></a>.</p>
<p>Si se especifica <em>lock</em>, entonces debería ser una <a class="reference internal" href="#multiprocessing.Lock" title="multiprocessing.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a> o <a class="reference internal" href="#multiprocessing.RLock" title="multiprocessing.RLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">RLock</span></code></a> objeto de <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>El método <a class="reference internal" href="threading.html#threading.Condition.wait_for" title="threading.Condition.wait_for"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_for()</span></code></a> fue a añadido.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="multiprocessing.Event">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">Event</span></span><a class="headerlink" href="#multiprocessing.Event" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un clon de <a class="reference internal" href="threading.html#threading.Event" title="threading.Event"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Event</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="multiprocessing.Lock">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">Lock</span></span><a class="headerlink" href="#multiprocessing.Lock" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un objeto candado no recursivo: un análogo cercano de <a class="reference internal" href="threading.html#threading.Lock" title="threading.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Lock</span></code></a> . Una vez que un proceso o subproceso ha adquirido un bloqueo, los intentos posteriores de adquirirlo de cualquier proceso o subproceso se bloquearán hasta que se libere; cualquier proceso o hilo puede liberarlo. Los conceptos y comportamientos de <a class="reference internal" href="threading.html#threading.Lock" title="threading.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Lock</span></code></a> como se aplica a los subprocesos se replican aquí en <a class="reference internal" href="#multiprocessing.Lock" title="multiprocessing.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">multiprocessing.Lock</span></code></a> como se aplica a los procesos o subprocesos, excepto como se indica.</p>
<p>Tenga en cuenta que <a class="reference internal" href="#multiprocessing.Lock" title="multiprocessing.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a> es en realidad una función de fábrica que retorna una instancia de <code class="docutils literal notranslate"><span class="pre">multiprocessing.synchronize.Lock</span></code> inicializada con un contexto predeterminado.</p>
<p>La <a class="reference internal" href="#multiprocessing.Lock" title="multiprocessing.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a> soporta el protocolo <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">context manager</span></a> y, por lo tanto, se puede usar en la declaración <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.Lock.acquire">
<span class="sig-name descname"><span class="pre">acquire</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">block</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Lock.acquire" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Adquiriendo un candado (<em>lock</em>), bloqueante o no bloqueante.</p>
<p>Con el argumento <em>block</em> establecido en <code class="docutils literal notranslate"><span class="pre">True</span></code> (el valor predeterminado), la llamada al método se bloqueará hasta que el bloqueo esté en un estado desbloqueado, luego configúrelo como bloqueado y retorne <code class="docutils literal notranslate"><span class="pre">True</span></code>. Tenga en cuenta que el nombre de este primer argumento difiere del que aparece en <a class="reference internal" href="threading.html#threading.Lock.acquire" title="threading.Lock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">threading.Lock.acquire()</span></code></a>.</p>
<p>Con el argumento <em>block</em> establecido en <code class="docutils literal notranslate"><span class="pre">False</span></code>, la llamada al método no se bloquea. Si el bloqueo está actualmente en un estado bloqueado, retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>; de lo contrario, configure el bloqueo en un estado bloqueado y retorne <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>Cuando se invoca con un valor positivo de punto flotante para <em>timeout</em>, bloquea como máximo el número de segundos especificado por <em>timeout</em> siempre que no se pueda obtener el bloqueo. Las invocaciones con un valor negativo para <em>timeout</em> de cero. Las invocaciones con un valor <em>timeout</em> de <code class="docutils literal notranslate"><span class="pre">None</span></code> (el valor predeterminado) establecen el período de tiempo de espera en infinito. Tenga en cuenta que el tratamiento de valores negativos o <code class="docutils literal notranslate"><span class="pre">None</span></code> para <em>timeout</em> difiere del comportamiento implementado en <a class="reference internal" href="threading.html#threading.Lock.acquire" title="threading.Lock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">threading.Lock.acquire()</span></code></a>. El argumento <em>timeout</em> no tiene implicaciones prácticas si el argumento <em>block</em> se establece en <code class="docutils literal notranslate"><span class="pre">False</span></code> y, por lo tanto, se ignora. Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si se ha adquirido el candado o <code class="docutils literal notranslate"><span class="pre">False</span></code> si ha transcurrido el tiempo de espera.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.Lock.release">
<span class="sig-name descname"><span class="pre">release</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Lock.release" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Suelta un candado. Esto se puede llamar desde cualquier proceso o subproceso, no solo desde el proceso o subproceso que originalmente adquirió el candado.</p>
<p>El comportamiento es el mismo que en <a class="reference internal" href="threading.html#threading.Lock.release" title="threading.Lock.release"><code class="xref py py-meth docutils literal notranslate"><span class="pre">threading.Lock.release()</span></code></a> excepto que cuando se invoca en un bloqueo desbloqueado, se genera a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="multiprocessing.RLock">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">RLock</span></span><a class="headerlink" href="#multiprocessing.RLock" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un objeto de candado recursivo: un análogo cercano a <a class="reference internal" href="threading.html#threading.RLock" title="threading.RLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.RLock</span></code></a>. El proceso o el hilo que lo adquirió debe liberar un candado recursivo. Una vez que un proceso o subproceso ha adquirido un candado recursivo, el mismo proceso o subproceso puede volver a adquirirlo sin bloquearlo; ese proceso o hilo debe liberarlo una vez por cada vez que se haya adquirido.</p>
<p>Tenga en cuenta que <a class="reference internal" href="#multiprocessing.RLock" title="multiprocessing.RLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">RLock</span></code></a> es en realidad una función de fábrica que retorna una instancia de <code class="docutils literal notranslate"><span class="pre">multiprocessing.synchronize.RLock</span></code> inicializada con un contexto predeterminado.</p>
<p>La <a class="reference internal" href="#multiprocessing.RLock" title="multiprocessing.RLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">RLock</span></code></a> admite el protocolo <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">context manager</span></a> y, por lo tanto, puede usarse en <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.RLock.acquire">
<span class="sig-name descname"><span class="pre">acquire</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">block</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.RLock.acquire" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Adquiriendo un candado (<em>lock</em>), bloqueante o no bloqueante.</p>
<p>Cuando se invoca con el argumento <em>block</em> establecido en <code class="docutils literal notranslate"><span class="pre">True</span></code> , bloquea hasta que el candado esté en un estado desbloqueado (que no sea propiedad de ningún proceso o subproceso) a menos que el candado o el subproceso actual ya sea de su propiedad. El proceso o subproceso actual se apropia del candado (si aún no lo tiene) y el nivel de recursión dentro de este  aumenta en uno, lo que da como resultado un valor de retorno de <code class="docutils literal notranslate"><span class="pre">True</span></code>. Tenga en cuenta que hay varias diferencias en el comportamiento de este primer argumento en comparación con la implementación de <a class="reference internal" href="threading.html#threading.RLock.acquire" title="threading.RLock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">threading.RLock.acquire()</span></code></a>, comenzando con el nombre del argumento en sí.</p>
<p>Cuando se invoca con el argumento <em>block</em> establecido en <code class="docutils literal notranslate"><span class="pre">False</span></code>, no bloquea. Si el candado ya ha sido adquirido (y por lo tanto es propiedad) de otro proceso o subproceso, el proceso o subproceso actual no se apropia y el nivel de recursión dentro del candado no cambia, lo que resulta en un valor de retorno de <code class="docutils literal notranslate"><span class="pre">False</span></code>. Si el candado está en un estado desbloqueado, el proceso o subproceso actual toma posesión y el nivel de recurrencia se incrementa, lo que resulta en un valor de retorno de <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>El uso y los comportamientos del argumento <em>timeout</em> son los mismos que en <a class="reference internal" href="#multiprocessing.Lock.acquire" title="multiprocessing.Lock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Lock.acquire()</span></code></a>. Tenga en cuenta que algunos de estos comportamientos de <em>timeout</em> difieren de los comportamientos implementados en <a class="reference internal" href="threading.html#threading.RLock.acquire" title="threading.RLock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">threading.RLock.acquire()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.RLock.release">
<span class="sig-name descname"><span class="pre">release</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.RLock.release" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Libera un candado, disminuyendo el nivel de recursión. Si después del decremento el nivel de recursión es cero, restablece el candado a desbloqueado (que no sea propiedad de ningún proceso o subproceso) y si se bloquean otros procesos o subprocesos esperando que el candado se desbloquee, permite que continúe exactamente uno de ellos. Si después del decremento el nivel de recursión sigue siendo distinto de cero, el candado permanece bloqueado y pertenece al proceso de llamada o subproceso.</p>
<p>Solo llame a este método cuando el proceso o subproceso de llamada sea el propietario del candado. Se lanza un <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> si se llama a este método mediante un proceso o subproceso que no sea el propietario o si el candado está en un estado desbloqueado (sin propietario). Tenga en cuenta que el tipo de excepción planteada en esta situación difiere del comportamiento implementado en <a class="reference internal" href="threading.html#threading.RLock.release" title="threading.RLock.release"><code class="xref py py-meth docutils literal notranslate"><span class="pre">threading.RLock.release()</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="multiprocessing.Semaphore">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">Semaphore</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Semaphore" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un objeto semáforo: un análogo cercano de <a class="reference internal" href="threading.html#threading.Semaphore" title="threading.Semaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Semaphore</span></code></a>.</p>
<p>Existe una diferencia solitaria de su análogo cercano: el primer argumento de su método <code class="docutils literal notranslate"><span class="pre">acquire</span></code> es nombrado <em>block</em>, es consistente con <a class="reference internal" href="#multiprocessing.Lock.acquire" title="multiprocessing.Lock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Lock.acquire()</span></code></a>.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En macOS, <code class="docutils literal notranslate"><span class="pre">sem_timedwait</span></code> no es compatible, por lo que llamar a <code class="docutils literal notranslate"><span class="pre">acquire()</span></code> con un tiempo de espera emulará el comportamiento de esa función utilizando un bucle inactivo.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si la señal SIGINT generada por <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd></kbd> llega mientras el hilo principal está bloqueado por una llamada a <code class="xref py py-meth docutils literal notranslate"><span class="pre">BoundedSemaphore.acquire()</span></code>, <a class="reference internal" href="#multiprocessing.Lock.acquire" title="multiprocessing.Lock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Lock.acquire()</span></code></a>, <a class="reference internal" href="#multiprocessing.RLock.acquire" title="multiprocessing.RLock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">RLock.acquire()</span></code></a>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">Semaphore.acquire()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">Condition.acquire()</span></code> o <code class="xref py py-meth docutils literal notranslate"><span class="pre">Condition.wait()</span></code>, la llamada se interrumpirá inmediatamente y <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> se lanzará.</p>
<p>Esto difiere del comportamiento de <a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> donde SIGINT será ignorado mientras las llamadas de candado equivalentes están en progreso.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Parte de la funcionalidad de este paquete requiere una implementación de semáforo compartido que funcione en el sistema operativo. Sin uno, el módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing.synchronize</span></code> se desactivará, y los intentos de importarlo darán como resultado <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>. Consulte <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3770">bpo-3770</a> para información adicional.</p>
</div>
</section>
<section id="shared-ctypes-objects">
<h3>Objetos compartidos <a class="reference internal" href="ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a><a class="headerlink" href="#shared-ctypes-objects" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Es posible crear objetos compartidos utilizando memoria compartida que puede ser heredada por procesos secundarios.</p>
<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.Value">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">Value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">typecode_or_type</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Value" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un objeto <a class="reference internal" href="ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> asignado desde la memoria compartida. Por defecto, el valor de retorno es en realidad un contenedor sincronizado para el objeto. Se puede acceder al objeto en sí a través del atributo <em>value</em> de la <a class="reference internal" href="#multiprocessing.Value" title="multiprocessing.Value"><code class="xref py py-class docutils literal notranslate"><span class="pre">Value</span></code></a>.</p>
<p><em>typecode_or_type</em> determina el tipo del objeto retornado: es un tipo <em>ctypes</em> o un código de tipo de un carácter del tipo utilizado por el módulo <a class="reference internal" href="array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a>. <em>*args</em> se pasa al constructor para el tipo.</p>
<p>Si <em>lock</em> es <code class="docutils literal notranslate"><span class="pre">True</span></code> (el valor predeterminado), se crea un nuevo objeto de candado recursivo para sincronizar el acceso al valor. Si <em>lock</em> es un objeto <a class="reference internal" href="#multiprocessing.Lock" title="multiprocessing.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a> o <a class="reference internal" href="#multiprocessing.RLock" title="multiprocessing.RLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">RLock</span></code></a>, se usará para sincronizar el acceso al valor. Si <em>lock</em> es <code class="docutils literal notranslate"><span class="pre">False</span></code>, entonces el acceso al objeto retornado no estará protegido automáticamente por un candado, por lo que no será necesariamente «proceso-seguro».</p>
<p>Operaciones como <code class="docutils literal notranslate"><span class="pre">+=</span></code> que implican una lectura y escritura no son atómicas. Entonces, si, por ejemplo, desea incrementar atómicamente un valor compartido, es insuficiente simplemente hacer:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">counter</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Suponiendo que el candado asociado es recursivo (que es por defecto), puede hacer</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">counter</span><span class="o">.</span><span class="n">get_lock</span><span class="p">():</span>
    <span class="n">counter</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Véase que <em>lock</em> es un argumento de solo una palabra clave.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.Array">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">Array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">typecode_or_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size_or_initializer</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Array" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una matriz <em>ctypes</em> asignada desde la memoria compartida. Por defecto, el valor de retorno es en realidad un contenedor sincronizado para el arreglo.</p>
<p><em>typecode_or_type</em> determina el tipo de los elementos de la matriz retornada: es un tipo de tipo <em>ctypes</em> o un código de tipo de un carácter del tipo utilizado por el módulo <a class="reference internal" href="array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a>. Si <em>size_or_initializer</em> es un número entero, entonces determina la longitud de la matriz, y la matriz se pondrá a cero inicialmente. De lo contrario, <em>size_or_initializer</em> es una secuencia que se utiliza para inicializar la matriz y cuya longitud determina la longitud de la matriz.</p>
<p>Si <em>lock</em> es <code class="docutils literal notranslate"><span class="pre">True</span></code> (el valor predeterminado), se crea un nuevo objeto de bloqueo para sincronizar el acceso al valor. Si <em>lock</em> es un objeto <a class="reference internal" href="#multiprocessing.Lock" title="multiprocessing.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a> o <a class="reference internal" href="#multiprocessing.RLock" title="multiprocessing.RLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">RLock</span></code></a>, se usará para sincronizar el acceso al valor. Si <em>lock</em> es <code class="docutils literal notranslate"><span class="pre">False</span></code>, entonces el acceso al objeto retornado no estará protegido automáticamente por un candado, por lo que no será necesariamente «proceso seguro».</p>
<p>Véase que <em>lock</em> es un argumento de solo una palabra clave.</p>
<p>Tenga en cuenta que una matriz de <a class="reference internal" href="ctypes.html#ctypes.c_char" title="ctypes.c_char"><code class="xref py py-data docutils literal notranslate"><span class="pre">ctypes.c_char</span></code></a> tiene atributos <em>value</em> y <em>raw</em> que le permiten a uno usarlo para almacenar y recuperar cadenas de caracteres.</p>
</dd></dl>

<section id="module-multiprocessing.sharedctypes">
<span id="the-multiprocessing-sharedctypes-module"></span><h4>El módulo <a class="reference internal" href="#module-multiprocessing.sharedctypes" title="multiprocessing.sharedctypes: Allocate ctypes objects from shared memory."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing.sharedctypes</span></code></a><a class="headerlink" href="#module-multiprocessing.sharedctypes" title="Enlazar permanentemente con este título">¶</a></h4>
<p>El módulo <a class="reference internal" href="#module-multiprocessing.sharedctypes" title="multiprocessing.sharedctypes: Allocate ctypes objects from shared memory."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing.sharedctypes</span></code></a> proporciona funciones para asignar objetos <a class="reference internal" href="ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> de la memoria compartida que pueden ser heredados por procesos secundarios.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Aunque es posible almacenar un puntero en la memoria compartida, recuerde que esto se referirá a una ubicación en el espacio de direcciones de un proceso específico. Sin embargo, es muy probable que el puntero sea inválido en el contexto de un segundo proceso y tratar de desreferenciar el puntero del segundo proceso puede causar un bloqueo.</p>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.sharedctypes.RawArray">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.sharedctypes.</span></span><span class="sig-name descname"><span class="pre">RawArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">typecode_or_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size_or_initializer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.sharedctypes.RawArray" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una matriz <em>ctypes</em> asignada desde la memoria compartida.</p>
<p><em>typecode_or_type</em> determina el tipo de los elementos de la matriz retornada: es un tipo de tipo <em>ctypes</em> o un código de tipo de un carácter del tipo utilizado por el módulo <a class="reference internal" href="array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a>. Si <em>size_or_initializer</em> es un entero, entonces determina la longitud de la matriz, y la matriz se pondrá a cero inicialmente. De lo contrario, <em>size_or_initializer</em> es una secuencia que se usa para inicializar la matriz y cuya longitud determina la longitud del arreglo.</p>
<p>Tenga en cuenta que configurar y obtener un elemento es potencialmente no atómico – utiliza <a class="reference internal" href="#multiprocessing.sharedctypes.Array" title="multiprocessing.sharedctypes.Array"><code class="xref py py-func docutils literal notranslate"><span class="pre">Array()</span></code></a> en su lugar para asegurarse de que el acceso se sincronice automáticamente mediante un candado.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.sharedctypes.RawValue">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.sharedctypes.</span></span><span class="sig-name descname"><span class="pre">RawValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">typecode_or_type</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.sharedctypes.RawValue" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un objeto <em>ctypes</em> asignado desde la memoria compartida.</p>
<p><em>typecode_or_type</em> determina el tipo del objeto retornado: es un tipo <em>ctypes</em> o un código de tipo de un carácter del tipo utilizado por el módulo <a class="reference internal" href="array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a>. <em>*args</em> se pasa al constructor para el tipo.</p>
<p>Tenga en cuenta que configurar y obtener el valor es potencialmente no atómico – use <a class="reference internal" href="#multiprocessing.sharedctypes.Value" title="multiprocessing.sharedctypes.Value"><code class="xref py py-func docutils literal notranslate"><span class="pre">Value()</span></code></a> en su lugar para asegurarse de que el acceso se sincronice automáticamente mediante un candado.</p>
<p>Tenga en cuenta que una matriz de <a class="reference internal" href="ctypes.html#ctypes.c_char" title="ctypes.c_char"><code class="xref py py-data docutils literal notranslate"><span class="pre">ctypes.c_char</span></code></a> tiene atributos <code class="docutils literal notranslate"><span class="pre">value</span></code> y <code class="docutils literal notranslate"><span class="pre">raw</span></code> que le permiten a uno usarlo para almacenar y recuperar cadenas de caracteres – consulte la documentación para <a class="reference internal" href="ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.sharedctypes.Array">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.sharedctypes.</span></span><span class="sig-name descname"><span class="pre">Array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">typecode_or_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size_or_initializer</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.sharedctypes.Array" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Lo mismo que <a class="reference internal" href="#multiprocessing.sharedctypes.RawArray" title="multiprocessing.sharedctypes.RawArray"><code class="xref py py-func docutils literal notranslate"><span class="pre">RawArray()</span></code></a>, excepto que, dependiendo del valor de <em>lock</em>, se puede retornar un contenedor de sincronización seguro para el proceso en lugar de un arreglo de tipos crudos.</p>
<p>Si <em>lock</em> es <code class="docutils literal notranslate"><span class="pre">True</span></code> (el valor predeterminado), se crea un nuevo objeto candado para sincronizar el acceso al valor. Si <em>lock</em> es un objeto <a class="reference internal" href="#multiprocessing.Lock" title="multiprocessing.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a> o <a class="reference internal" href="#multiprocessing.RLock" title="multiprocessing.RLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">RLock</span></code></a>, se utilizará para sincronizar el acceso al valor. Si <em>lock</em> es <code class="docutils literal notranslate"><span class="pre">False</span></code>, entonces el acceso al objeto retornado no estará protegido automáticamente por un candado, por lo que no será necesariamente «seguro para el proceso».</p>
<p>Véase que <em>lock</em> es un argumento de solo una palabra clave.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.sharedctypes.Value">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.sharedctypes.</span></span><span class="sig-name descname"><span class="pre">Value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">typecode_or_type</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.sharedctypes.Value" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Lo mismo que <a class="reference internal" href="#multiprocessing.sharedctypes.RawValue" title="multiprocessing.sharedctypes.RawValue"><code class="xref py py-func docutils literal notranslate"><span class="pre">RawValue()</span></code></a> excepto que, dependiendo del valor de <em>lock</em>, se puede retornar una envoltura de sincronización segura para el proceso en lugar de un objeto <em>ctypes</em> sin procesar.</p>
<p>Si <em>lock</em> es <code class="docutils literal notranslate"><span class="pre">True</span></code> (el valor predeterminado), se crea un nuevo objeto candado para sincronizar el acceso al valor. Si <em>lock</em> es un objeto <a class="reference internal" href="#multiprocessing.Lock" title="multiprocessing.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a> o <a class="reference internal" href="#multiprocessing.RLock" title="multiprocessing.RLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">RLock</span></code></a>, se utilizará para sincronizar el acceso al valor. Si <em>lock</em> es <code class="docutils literal notranslate"><span class="pre">False</span></code>, entonces el acceso al objeto retornado no estará protegido automáticamente por un candado, por lo que no será necesariamente «seguro para el proceso».</p>
<p>Véase que <em>lock</em> es un argumento de solo una palabra clave.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.sharedctypes.copy">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.sharedctypes.</span></span><span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.sharedctypes.copy" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un objeto <em>ctypes</em> asignado de la memoria compartida, que es una copia del objeto <em>ctypes</em> <em>obj</em>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.sharedctypes.synchronized">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.sharedctypes.</span></span><span class="sig-name descname"><span class="pre">synchronized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">lock</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.sharedctypes.synchronized" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un objeto contenedor seguro para un objeto <em>ctypes</em> que usa <em>lock</em> para sincronizar el acceso. Si <em>lock</em> es <code class="docutils literal notranslate"><span class="pre">None</span></code> (el valor predeterminado), se crea automáticamente un objeto <a class="reference internal" href="#multiprocessing.RLock" title="multiprocessing.RLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">multiprocessing.RLock</span></code></a>.</p>
<p>Un contenedor sincronizado tendrá dos métodos además de los del objeto que envuelve: <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_obj()</span></code> retorna el objeto envuelto y <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_lock()</span></code> retorna el objeto de bloqueo utilizado para la sincronización.</p>
<p>Tenga en cuenta que acceder al objeto <em>ctypes</em> a través del contenedor puede ser mucho más lento que acceder al objeto <em>ctypes</em> sin formato.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Los objetos sincronizados admiten el protocolo: <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">context manager</span></a>.</p>
</div>
</dd></dl>

<p>La siguiente tabla compara la sintaxis para crear objetos <em>ctypes</em> compartidos desde la memoria compartida con la sintaxis <em>ctypes</em> normal. (En la tabla <code class="docutils literal notranslate"><span class="pre">MyStruct</span></code> hay alguna subclase de <a class="reference internal" href="ctypes.html#ctypes.Structure" title="ctypes.Structure"><code class="xref py py-class docutils literal notranslate"><span class="pre">ctypes.Structure</span></code></a>.)</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 27%" />
<col style="width: 36%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><em>ctypes</em></p></th>
<th class="head"><p><em>sharedctypes</em> usando <em>type</em></p></th>
<th class="head"><p><em>sharedctypes</em> usando <em>typecode</em></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>c_double(2.4)</em></p></td>
<td><p><em>RawValue(c_double, 2.4)</em></p></td>
<td><p><em>RawValue(“d”, 2.4)</em></p></td>
</tr>
<tr class="row-odd"><td><p><em>MyStruct(4, 6)</em></p></td>
<td><p><em>RawValue(MyStruct, 4, 6)</em></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><em>(c_short * 7)()</em></p></td>
<td><p><em>RawArray(c_short, 7)</em></p></td>
<td><p><em>RawArray(‘h’, 7)</em></p></td>
</tr>
<tr class="row-odd"><td><p><em>(c_int * 3)(9, 2, 8)</em></p></td>
<td><p><em>RawArray(c_int, (9, 2, 8))</em></p></td>
<td><p><em>RawArray(“i”, (9, 2, 8))</em></p></td>
</tr>
</tbody>
</table>
<p>A continuación se muestra un ejemplo donde un número de objetos <em>ctypes</em> son modificados por un proceso hijo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Lock</span>
<span class="kn">from</span> <span class="nn">multiprocessing.sharedctypes</span> <span class="kn">import</span> <span class="n">Value</span><span class="p">,</span> <span class="n">Array</span>
<span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="n">Structure</span><span class="p">,</span> <span class="n">c_double</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">c_double</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">c_double</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
    <span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="o">**=</span> <span class="mi">2</span>
    <span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="o">**=</span> <span class="mi">2</span>
    <span class="n">s</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
        <span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">**=</span> <span class="mi">2</span>
        <span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="o">**=</span> <span class="mi">2</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">Value</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">Value</span><span class="p">(</span><span class="n">c_double</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;hello world&#39;</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="n">lock</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">Point</span><span class="p">,</span> <span class="p">[(</span><span class="mf">1.875</span><span class="p">,</span><span class="o">-</span><span class="mf">6.25</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mf">5.75</span><span class="p">,</span><span class="mf">2.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">2.375</span><span class="p">,</span><span class="mf">9.5</span><span class="p">)],</span> <span class="n">lock</span><span class="o">=</span><span class="n">lock</span><span class="p">)</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">modify</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">A</span><span class="p">))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">([(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">])</span>
</pre></div>
</div>
<p>Los resultados impresos son</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>49
0.1111111111111111
HELLO WORLD
[(3.515625, 39.0625), (33.0625, 4.0), (5.640625, 90.25)]
</pre></div>
</div>
</section>
</section>
<section id="managers">
<span id="multiprocessing-managers"></span><h3>Administradores (<em>Managers</em>)<a class="headerlink" href="#managers" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Los administradores (<em>managers</em>) proporcionan una forma de crear datos que se pueden compartir entre diferentes procesos, incluido el intercambio en una red entre procesos que se ejecutan en diferentes máquinas. Un objeto administrador controla un proceso de servidor que gestiona <em>shared objects</em> (<em>objetos compartidos</em>). Otros procesos pueden acceder a los objetos compartidos mediante el uso de servidores proxy.</p>
<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.Manager">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">Manager</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.Manager" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un objeto iniciado <a class="reference internal" href="#multiprocessing.managers.SyncManager" title="multiprocessing.managers.SyncManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">SyncManager</span></code></a> que se puede usar para compartir objetos entre procesos. El objeto administrador retornado corresponde a un proceso hijo generado y tiene métodos que crearán objetos compartidos y retornarán los proxies correspondientes.</p>
</dd></dl>

<span class="target" id="module-multiprocessing.managers"></span><p>Los procesos del administrador se cerrarán tan pronto como se recolecte la basura o salga su proceso padre. Las clases de administrador se definen en el módulo <a class="reference internal" href="#module-multiprocessing.managers" title="multiprocessing.managers: Share data between process with shared objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing.managers</span></code></a>:</p>
<dl class="py class">
<dt class="sig sig-object py" id="multiprocessing.managers.BaseManager">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.managers.</span></span><span class="sig-name descname"><span class="pre">BaseManager</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">authkey</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">serializer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pickle'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.BaseManager" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crear un objeto <em>BaseManager</em>.</p>
<p>Una vez creado, debe llamar a <a class="reference internal" href="#multiprocessing.managers.BaseManager.start" title="multiprocessing.managers.BaseManager.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a> o <code class="docutils literal notranslate"><span class="pre">get_server().serve_forever()</span></code> para asegurarse de que el objeto de administrador se refiera a un proceso de administrador iniciado.</p>
<p><em>address</em> es la dirección en la que el proceso del administrador escucha las nuevas conexiones. Si <em>address</em> es <code class="docutils literal notranslate"><span class="pre">None</span></code>, se elige una arbitrariamente.</p>
<p><em>authkey</em> es la clave de autenticación que se utilizará para verificar la validez de las conexiones entrantes al proceso del servidor. Si <em>authkey</em> es <code class="docutils literal notranslate"><span class="pre">None</span></code>, entonces se usa <code class="docutils literal notranslate"><span class="pre">current_process().authkey</span></code>. De lo contrario, se usa <em>authkey</em> y debe ser una cadena de <em>bytes</em>.</p>
<p><em>serializer</em> debe ser <code class="docutils literal notranslate"><span class="pre">'pickle'</span></code> (usar serialización <a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a>) o <code class="docutils literal notranslate"><span class="pre">'xmlrpclib'</span></code> (usar serialización <a class="reference internal" href="xmlrpc.client.html#module-xmlrpc.client" title="xmlrpc.client: XML-RPC client access."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpc.client</span></code></a>).</p>
<p><em>ctx</em> es un objeto de contexto, o <code class="docutils literal notranslate"><span class="pre">None</span></code> (utilice el contexto actual). Consulte la función <code class="xref py py-func docutils literal notranslate"><span class="pre">get_context()</span></code>.</p>
<p><em>shutdown_timeout</em> es un tiempo de espera en segundos que se utiliza para esperar hasta que el proceso utilizado por el administrador se complete en el método <a class="reference internal" href="#multiprocessing.managers.BaseManager.shutdown" title="multiprocessing.managers.BaseManager.shutdown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shutdown()</span></code></a>. Si se agota el tiempo de apagado, el proceso finaliza. Si la finalización del proceso también supera el tiempo de espera, el proceso se cancela.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Se agregó el parámetro <em>shutdown_timeout</em>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.managers.BaseManager.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">initializer</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">initargs</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.BaseManager.start" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Se inicia un subproceso para iniciar el administrador. Si <em>initializer</em> no es <code class="docutils literal notranslate"><span class="pre">None</span></code>, entonces el subproceso llamará <code class="docutils literal notranslate"><span class="pre">initializer(*initargs)</span></code> cuando se inicie.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.managers.BaseManager.get_server">
<span class="sig-name descname"><span class="pre">get_server</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.BaseManager.get_server" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un objeto <code class="xref py py-class docutils literal notranslate"><span class="pre">Server</span></code> que representa el servidor real bajo el control del Administrador. El objeto <code class="xref py py-class docutils literal notranslate"><span class="pre">Server</span></code> admite el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">serve_forever()</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing.managers</span> <span class="kn">import</span> <span class="n">BaseManager</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">manager</span> <span class="o">=</span> <span class="n">BaseManager</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">50000</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">server</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">get_server</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">server</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">Server</span></code> tiene un atributo adicional <a class="reference internal" href="#multiprocessing.managers.BaseManager.address" title="multiprocessing.managers.BaseManager.address"><code class="xref py py-attr docutils literal notranslate"><span class="pre">address</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.managers.BaseManager.connect">
<span class="sig-name descname"><span class="pre">connect</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.BaseManager.connect" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Conecta un objeto de administrador (<em>manager</em>) local a un proceso de administrador remoto:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing.managers</span> <span class="kn">import</span> <span class="n">BaseManager</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">BaseManager</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">50000</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.managers.BaseManager.shutdown">
<span class="sig-name descname"><span class="pre">shutdown</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.BaseManager.shutdown" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Detiene el proceso utilizado por el gerente (<em>manager</em>). Esto solo está disponible si <a class="reference internal" href="#multiprocessing.managers.BaseManager.start" title="multiprocessing.managers.BaseManager.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a> se ha utilizado para iniciar el proceso del servidor.</p>
<p>Esto se puede llamar múltiples veces.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.managers.BaseManager.register">
<span class="sig-name descname"><span class="pre">register</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">typeid</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">callable</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">proxytype</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">exposed</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">method_to_typeid</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">create_method</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.BaseManager.register" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método de clase que puede usarse para registrar un tipo o invocarse con la clase de administrador (<em>manager</em>).</p>
<p><em>typeid</em> es un «identificador de tipo» que se utiliza para identificar un tipo particular de objeto compartido. Esto debe ser una cadena de caracteres.</p>
<p><em>callable</em> es un invocable utilizado para crear objetos para este identificador de tipo. Si una instancia de administrador se conectará al servidor utilizando el método <a class="reference internal" href="#multiprocessing.managers.BaseManager.connect" title="multiprocessing.managers.BaseManager.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a>, o si el argumento <em>create_method</em> es <code class="docutils literal notranslate"><span class="pre">False</span></code>, esto se puede dejar como <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p><em>proxytype</em> es una subclase de <a class="reference internal" href="#multiprocessing.managers.BaseProxy" title="multiprocessing.managers.BaseProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseProxy</span></code></a> que se usa para crear <em>proxies</em> para objetos compartidos con este <em>typeid</em>. Si <code class="docutils literal notranslate"><span class="pre">None</span></code>, se crea automáticamente una clase proxy.</p>
<p>Se utiliza <em>exposed</em> para especificar una secuencia de nombres de métodos a los que se debe permitir el acceso de los servidores proxy para este tipo de identificación utilizando <a class="reference internal" href="#multiprocessing.managers.BaseProxy._callmethod" title="multiprocessing.managers.BaseProxy._callmethod"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseProxy._callmethod()</span></code></a>. (Si <em>exposed</em> es <code class="docutils literal notranslate"><span class="pre">None</span></code>, entonces <code class="xref py py-attr docutils literal notranslate"><span class="pre">proxytype._exposed_</span></code> se usa en su lugar si existe). En el caso de que no se especifique una lista expuesta, todos los «métodos públicos» del objeto compartido serán accesibles . (Aquí un «método público» significa cualquier atributo que tenga un método <a class="reference internal" href="../reference/datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> y cuyo nombre no comience con <code class="docutils literal notranslate"><span class="pre">'_'</span></code>.)</p>
<p>El <em>method_to_typeid</em> es una asignación utilizada para especificar el tipo de retorno de los métodos expuestos que deberían retornar un proxy. Asigna nombres de métodos a cadenas <em>typeid</em>. (Si <em>method_to_typeid</em> es <code class="docutils literal notranslate"><span class="pre">None</span></code> entonces <code class="xref py py-attr docutils literal notranslate"><span class="pre">proxytype._method_to_typeid</span></code> se usa en su lugar si existe). Si el nombre de un método no es una clave de esta asignación o si la asignación es <code class="docutils literal notranslate"><span class="pre">None</span></code> entonces el objeto retornado por el método se copiará por valor.</p>
<p><em>create_method</em> determina si un método debe crearse con el nombre <em>typeid</em> que se puede usar para indicarle al proceso del servidor que cree un nuevo objeto compartido y retornando un proxy para él. Por defecto es <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd></dl>

<p><a class="reference internal" href="#multiprocessing.managers.BaseManager" title="multiprocessing.managers.BaseManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseManager</span></code></a> las instancias también tienen una propiedad de solo lectura:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="multiprocessing.managers.BaseManager.address">
<span class="sig-name descname"><span class="pre">address</span></span><a class="headerlink" href="#multiprocessing.managers.BaseManager.address" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La dirección utilizada por el administrador.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Los objetos de administrador admiten el protocolo de gestión de contexto; consulte <a class="reference internal" href="stdtypes.html#typecontextmanager"><span class="std std-ref">Tipos gestores de contexto</span></a>. <a class="reference internal" href="stdtypes.html#contextmanager.__enter__" title="contextmanager.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> inicia el proceso del servidor (si aún no se ha iniciado) y luego retorna el objeto de administrador. <code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code> llama <a class="reference internal" href="#multiprocessing.managers.BaseManager.shutdown" title="multiprocessing.managers.BaseManager.shutdown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shutdown()</span></code></a>.</p>
<p>En versiones anteriores <a class="reference internal" href="stdtypes.html#contextmanager.__enter__" title="contextmanager.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> no iniciaba el proceso del servidor del administrador si aún no se había iniciado.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="multiprocessing.managers.SyncManager">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.managers.</span></span><span class="sig-name descname"><span class="pre">SyncManager</span></span><a class="headerlink" href="#multiprocessing.managers.SyncManager" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una subclase de <a class="reference internal" href="#multiprocessing.managers.BaseManager" title="multiprocessing.managers.BaseManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseManager</span></code></a> que se puede utilizar para la sincronización de procesos. Los objetos de este tipo son retornados por <a class="reference internal" href="#multiprocessing.Manager" title="multiprocessing.Manager"><code class="xref py py-func docutils literal notranslate"><span class="pre">multiprocessing.Manager()</span></code></a>.</p>
<p>Sus métodos crean y retornan <a class="reference internal" href="#multiprocessing-proxy-objects"><span class="std std-ref">Objetos Proxy (Proxy Objects)</span></a> para varios tipos de datos de uso común que se sincronizarán entre procesos. Esto incluye notablemente listas compartidas y diccionarios.</p>
<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.managers.SyncManager.Barrier">
<span class="sig-name descname"><span class="pre">Barrier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parties</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">action</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.Barrier" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p><a class="reference internal" href="threading.html#threading.Barrier" title="threading.Barrier"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Barrier</span></code></a> crea un objeto compartido y retorna un proxy para él.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.managers.SyncManager.BoundedSemaphore">
<span class="sig-name descname"><span class="pre">BoundedSemaphore</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.BoundedSemaphore" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un objeto compartido <a class="reference internal" href="threading.html#threading.BoundedSemaphore" title="threading.BoundedSemaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.BoundedSemaphore</span></code></a> y retorna un proxy para él.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.managers.SyncManager.Condition">
<span class="sig-name descname"><span class="pre">Condition</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">lock</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.Condition" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un objeto compartido <a class="reference internal" href="threading.html#threading.Condition" title="threading.Condition"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Condition</span></code></a> y retorna un proxy para él.</p>
<p>Si se proporciona <em>lock</em>, debería ser un proxy para un objeto <a class="reference internal" href="threading.html#threading.Lock" title="threading.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Lock</span></code></a> o <a class="reference internal" href="threading.html#threading.RLock" title="threading.RLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.RLock</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>El método <a class="reference internal" href="threading.html#threading.Condition.wait_for" title="threading.Condition.wait_for"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_for()</span></code></a> fue a añadido.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.managers.SyncManager.Event">
<span class="sig-name descname"><span class="pre">Event</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.Event" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un objeto compartido <a class="reference internal" href="threading.html#threading.Event" title="threading.Event"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Event</span></code></a> y retorna un proxy para él.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.managers.SyncManager.Lock">
<span class="sig-name descname"><span class="pre">Lock</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.Lock" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un objeto compartido <a class="reference internal" href="threading.html#threading.Lock" title="threading.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Lock</span></code></a> y retorna un proxy para él.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.managers.SyncManager.Namespace">
<span class="sig-name descname"><span class="pre">Namespace</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.Namespace" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un objeto compartido <a class="reference internal" href="#multiprocessing.managers.Namespace" title="multiprocessing.managers.Namespace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Namespace</span></code></a> y retorna un proxy para él.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.managers.SyncManager.Queue">
<span class="sig-name descname"><span class="pre">Queue</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">maxsize</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.Queue" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un objeto compartido <a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.Queue</span></code></a> y retorna un proxy para él.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.managers.SyncManager.RLock">
<span class="sig-name descname"><span class="pre">RLock</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.RLock" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un objeto compartido <a class="reference internal" href="threading.html#threading.RLock" title="threading.RLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.RLock</span></code></a> y retorna un proxy para él.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.managers.SyncManager.Semaphore">
<span class="sig-name descname"><span class="pre">Semaphore</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.Semaphore" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un objeto compartido <a class="reference internal" href="threading.html#threading.Semaphore" title="threading.Semaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Semaphore</span></code></a> y retorna un proxy para él.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.managers.SyncManager.Array">
<span class="sig-name descname"><span class="pre">Array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">typecode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.Array" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un arreglo y retorna un proxy para ello.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.managers.SyncManager.Value">
<span class="sig-name descname"><span class="pre">Value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">typecode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.Value" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un objeto con un atributo de escritura <code class="docutils literal notranslate"><span class="pre">value</span></code> y retorna un proxy para él.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.managers.SyncManager.dict">
<span class="sig-name descname"><span class="pre">dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.dict" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Crea un objeto compartido <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> y retorna un proxy para él.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.managers.SyncManager.list">
<span class="sig-name descname"><span class="pre">list</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.SyncManager.list" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Crea un objeto compartido <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> y retorna un proxy para él.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Los objetos compartidos pueden anidarse. Por ejemplo, un objeto contenedor compartido, como una lista compartida, puede contener otros objetos compartidos que serán administrados y sincronizados por <a class="reference internal" href="#multiprocessing.managers.SyncManager" title="multiprocessing.managers.SyncManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">SyncManager</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="multiprocessing.managers.Namespace">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.managers.</span></span><span class="sig-name descname"><span class="pre">Namespace</span></span><a class="headerlink" href="#multiprocessing.managers.Namespace" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un tipo que puede registrarse con <a class="reference internal" href="#multiprocessing.managers.SyncManager" title="multiprocessing.managers.SyncManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">SyncManager</span></code></a>.</p>
<p>Un objeto de espacio de nombres no tiene métodos públicos, pero tiene atributos de escritura. Su representación muestra los valores de sus atributos.</p>
<p>Sin embargo, cuando se usa un proxy para un objeto de espacio de nombres, un atributo que comience con <code class="docutils literal notranslate"><span class="pre">'_'</span></code> será un atributo del proxy y no un atributo del referente:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">manager</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Global</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">Namespace</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Global</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Global</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Global</span><span class="o">.</span><span class="n">_z</span> <span class="o">=</span> <span class="mf">12.3</span>    <span class="c1"># this is an attribute of the proxy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Global</span><span class="p">)</span>
<span class="go">Namespace(x=10, y=&#39;hello&#39;)</span>
</pre></div>
</div>
</dd></dl>

<section id="customized-managers">
<h4>Administradores customizables (<em>Customized managers</em>)<a class="headerlink" href="#customized-managers" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Para crear su propio administrador, uno crea una subclase de <a class="reference internal" href="#multiprocessing.managers.BaseManager" title="multiprocessing.managers.BaseManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseManager</span></code></a> y utiliza el método de clase <a class="reference internal" href="#multiprocessing.managers.BaseManager.register" title="multiprocessing.managers.BaseManager.register"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register()</span></code></a> para registrar nuevos tipos o llamadas con la clase de administrador. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing.managers</span> <span class="kn">import</span> <span class="n">BaseManager</span>

<span class="k">class</span> <span class="nc">MathsClass</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>

<span class="k">class</span> <span class="nc">MyManager</span><span class="p">(</span><span class="n">BaseManager</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">MyManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;Maths&#39;</span><span class="p">,</span> <span class="n">MathsClass</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">MyManager</span><span class="p">()</span> <span class="k">as</span> <span class="n">manager</span><span class="p">:</span>
        <span class="n">maths</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">Maths</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">maths</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>         <span class="c1"># prints 7</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">maths</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>         <span class="c1"># prints 56</span>
</pre></div>
</div>
</section>
<section id="using-a-remote-manager">
<h4>Utilizando un administrador remoto<a class="headerlink" href="#using-a-remote-manager" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Es posible ejecutar un servidor administrador en una máquina y hacer que los clientes lo usen desde otras máquinas (suponiendo que los cortafuegos involucrados lo permitan).</p>
<p>La ejecución de los siguientes comandos crea un servidor para una única cola compartida a la que los clientes remotos pueden acceder:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing.managers</span> <span class="kn">import</span> <span class="n">BaseManager</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">QueueManager</span><span class="p">(</span><span class="n">BaseManager</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QueueManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;get_queue&#39;</span><span class="p">,</span> <span class="n">callable</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span><span class="n">queue</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">QueueManager</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">50000</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;abracadabra&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get_server</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<p>Un cliente puede tener accesos al servidor de la siguiente manera:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing.managers</span> <span class="kn">import</span> <span class="n">BaseManager</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">QueueManager</span><span class="p">(</span><span class="n">BaseManager</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QueueManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;get_queue&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">QueueManager</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;foo.bar.org&#39;</span><span class="p">,</span> <span class="mi">50000</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;abracadabra&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">queue</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get_queue</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Otro cliente puede también usarlo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing.managers</span> <span class="kn">import</span> <span class="n">BaseManager</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">QueueManager</span><span class="p">(</span><span class="n">BaseManager</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QueueManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;get_queue&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">QueueManager</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;foo.bar.org&#39;</span><span class="p">,</span> <span class="mi">50000</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;abracadabra&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">queue</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get_queue</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="go">&#39;hello&#39;</span>
</pre></div>
</div>
<p>Los procesos locales también pueden acceder a esa cola (<em>queue</em>), utilizando el código de arriba en el cliente para acceder de forma remota:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Queue</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing.managers</span> <span class="kn">import</span> <span class="n">BaseManager</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Worker</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span>
<span class="gp">... </span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;local hello&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">Worker</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">QueueManager</span><span class="p">(</span><span class="n">BaseManager</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QueueManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;get_queue&#39;</span><span class="p">,</span> <span class="n">callable</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">queue</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">QueueManager</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">50000</span><span class="p">),</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;abracadabra&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get_server</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
</section>
</section>
<section id="proxy-objects">
<span id="multiprocessing-proxy-objects"></span><h3>Objetos Proxy (<em>Proxy Objects</em>)<a class="headerlink" href="#proxy-objects" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Un proxy es un objeto que <em>se refiere</em> a un objeto compartido que vive (presumiblemente) en un proceso diferente. Se dice que el objeto compartido es el <em>referente</em> del proxy. Varios objetos proxy pueden tener el mismo referente.</p>
<p>Un objeto proxy tiene métodos que invocan los métodos correspondientes de su referente (aunque no todos los métodos del referente estarán necesariamente disponibles a través del proxy). De esta manera, un proxy se puede usar al igual que su referente:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Manager</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">manager</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">list</span><span class="p">([</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="go">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
<span class="go">&lt;ListProxy object, typeid &#39;list&#39; at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="go">16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[4, 9, 16]</span>
</pre></div>
</div>
<p>Tenga en cuenta que la aplicación <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> a un proxy retornará la representación del referente, mientras que la aplicación <a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> retornará la representación del proxy.</p>
<p>Una característica importante de los objetos proxy es que son seleccionables para que puedan pasarse entre procesos. Como tal, un referente puede contener <a class="reference internal" href="#multiprocessing-proxy-objects"><span class="std std-ref">Objetos Proxy (Proxy Objects)</span></a>. Esto permite anidar estas listas administradas, dictados y otros <a class="reference internal" href="#multiprocessing-proxy-objects"><span class="std std-ref">Objetos Proxy (Proxy Objects)</span></a>:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>         <span class="c1"># referent of a now contains referent of b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">[&lt;ListProxy object, typeid &#39;list&#39; at ...&gt;] []</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">)</span>
<span class="go">[&#39;hello&#39;] [&#39;hello&#39;]</span>
</pre></div>
</div>
<p>Del mismo modo, los proxies <em>dict</em> y <em>list</em> pueden estar anidados uno dentro del otro:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">l_outer</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">list</span><span class="p">([</span> <span class="n">manager</span><span class="o">.</span><span class="n">dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d_first_inner</span> <span class="o">=</span> <span class="n">l_outer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d_first_inner</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d_first_inner</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l_outer</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;c&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l_outer</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">26</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">l_outer</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">{&#39;a&#39;: 1, &#39;b&#39;: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">l_outer</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">{&#39;c&#39;: 3, &#39;z&#39;: 26}</span>
</pre></div>
</div>
<p>Si los objetos estándar (no proxy) <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> or <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> están contenidos en un referente, las modificaciones a esos valores mutables no se propagarán a través del administrador porque el proxy no tiene forma de saber cuándo los valores contenidos dentro son modificados. Sin embargo, almacenar un valor en un proxy de contenedor (que desencadena un <code class="docutils literal notranslate"><span class="pre">__setitem__</span></code> en el objeto proxy) se propaga a través del administrador y, por lo tanto, para modificar efectivamente dicho elemento, uno podría reasignar el valor modificado al proxy de contenedor:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># create a list proxy and append a mutable object (a dictionary)</span>
<span class="n">lproxy</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="n">lproxy</span><span class="o">.</span><span class="n">append</span><span class="p">({})</span>
<span class="c1"># now mutate the dictionary</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">lproxy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">d</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">d</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="c1"># at this point, the changes to d are not yet synced, but by</span>
<span class="c1"># updating the dictionary, the proxy is notified of the change</span>
<span class="n">lproxy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
</pre></div>
</div>
<p>Este enfoque es quizás menos conveniente que emplear anidado <a class="reference internal" href="#multiprocessing-proxy-objects"><span class="std std-ref">Objetos Proxy (Proxy Objects)</span></a> para la mayoría de los casos de uso, pero también demuestra un nivel de control sobre la sincronización.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Los tipos de proxy en <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> no hacen nada para admitir comparaciones por valor. Entonces, por ejemplo, tenemos:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">manager</span><span class="o">.</span><span class="n">list</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="go">False</span>
</pre></div>
</div>
<p>En su lugar, se debe usar una copia del referente al hacer comparaciones.</p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="multiprocessing.managers.BaseProxy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.managers.</span></span><span class="sig-name descname"><span class="pre">BaseProxy</span></span><a class="headerlink" href="#multiprocessing.managers.BaseProxy" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Los objetos proxy son instancias de subclases de <a class="reference internal" href="#multiprocessing.managers.BaseProxy" title="multiprocessing.managers.BaseProxy"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseProxy</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.managers.BaseProxy._callmethod">
<span class="sig-name descname"><span class="pre">_callmethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">methodname</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">kwds</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.BaseProxy._callmethod" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llama y retorna el resultado de un método del referente del proxy.</p>
<p>Si <code class="docutils literal notranslate"><span class="pre">proxy</span></code> es un proxy cuyo referente es <code class="docutils literal notranslate"><span class="pre">obj</span></code> entonces la expresión</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">proxy</span><span class="o">.</span><span class="n">_callmethod</span><span class="p">(</span><span class="n">methodname</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">)</span>
</pre></div>
</div>
<p>evaluará la expresión</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">methodname</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
</pre></div>
</div>
<p>en el proceso del administrador.</p>
<p>El valor retornado será una copia del resultado de la llamada o un proxy a un nuevo objeto compartido; consulte la documentación del argumento <em>method_to_typeid</em> de <a class="reference internal" href="#multiprocessing.managers.BaseManager.register" title="multiprocessing.managers.BaseManager.register"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseManager.register()</span></code></a>.</p>
<p>Si la llamada genera una excepción, entonces se vuelve a generar <a class="reference internal" href="#multiprocessing.managers.BaseProxy._callmethod" title="multiprocessing.managers.BaseProxy._callmethod"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_callmethod()</span></code></a>. Si se genera alguna otra excepción en el proceso del administrador, esto se convierte en una excepción <code class="xref py py-exc docutils literal notranslate"><span class="pre">RemoteError</span></code> y se genera mediante  <a class="reference internal" href="#multiprocessing.managers.BaseProxy._callmethod" title="multiprocessing.managers.BaseProxy._callmethod"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_callmethod()</span></code></a>.</p>
<p>Tenga en cuenta en particular que se lanzará una excepción si <em>methodname</em> no ha sido <em>exposed</em>.</p>
<p>Un ejemplo de uso de <a class="reference internal" href="#multiprocessing.managers.BaseProxy._callmethod" title="multiprocessing.managers.BaseProxy._callmethod"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_callmethod()</span></code></a>:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="o">.</span><span class="n">_callmethod</span><span class="p">(</span><span class="s1">&#39;__len__&#39;</span><span class="p">)</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="o">.</span><span class="n">_callmethod</span><span class="p">(</span><span class="s1">&#39;__getitem__&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">),))</span> <span class="c1"># equivalent to l[2:7]</span>
<span class="go">[2, 3, 4, 5, 6]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span><span class="o">.</span><span class="n">_callmethod</span><span class="p">(</span><span class="s1">&#39;__getitem__&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">20</span><span class="p">,))</span>          <span class="c1"># equivalent to l[20]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">IndexError</span>: <span class="n">list index out of range</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.managers.BaseProxy._getvalue">
<span class="sig-name descname"><span class="pre">_getvalue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.BaseProxy._getvalue" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia del referente.</p>
<p>Si el referente no se puede deserializar (<em>unpicklable</em>), esto lanzará una excepción.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.managers.BaseProxy.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.BaseProxy.__repr__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una representación de un objeto proxy.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.managers.BaseProxy.__str__">
<span class="sig-name descname"><span class="pre">__str__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.managers.BaseProxy.__str__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una representación del referente.</p>
</dd></dl>

</dd></dl>

<section id="cleanup">
<h4>Limpieza (<em>Cleanup</em>)<a class="headerlink" href="#cleanup" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Un objeto proxy utiliza una devolución de llamada (<em>callback</em>) de referencia débil (<em>weakref</em>) para que cuando sea recolectado por el recolector de basura se da de baja del administrador que posee su referente.</p>
<p>Un objeto compartido se elimina del proceso del administrador cuando ya no hay ningún proxy que se refiera a él.</p>
</section>
</section>
<section id="module-multiprocessing.pool">
<span id="process-pools"></span><h3>Piscinas de procesos (<em>Process Pools</em>)<a class="headerlink" href="#module-multiprocessing.pool" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Se puede crear un grupo de procesos que llevarán a cabo las tareas que se le presenten con la  <a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pool</span></code></a> class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="multiprocessing.pool.Pool">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.pool.</span></span><span class="sig-name descname"><span class="pre">Pool</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">processes</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">initializer</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">initargs</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">maxtasksperchild</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">context</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un objeto de grupo de procesos que controla un grupo de procesos de trabajo a los que se pueden enviar trabajos. Admite resultados asincrónicos con tiempos de espera y devoluciones de llamada y tiene una implementación de mapa paralelo.</p>
<p><em>processes</em> es el número de procesos de trabajo a utilizar. Si <em>processes</em> es <code class="docutils literal notranslate"><span class="pre">None</span></code> , se utiliza el número retornado por <a class="reference internal" href="os.html#os.cpu_count" title="os.cpu_count"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.cpu_count()</span></code></a>.</p>
<p>Si <em>initializer</em> no es <code class="docutils literal notranslate"><span class="pre">None</span></code>, cada proceso de trabajo llamará <code class="docutils literal notranslate"><span class="pre">initializer(*initargs)</span></code> cuando se inicie.</p>
<p><em>maxtasksperchild</em> es el número de tareas que un proceso de trabajo puede completar antes de salir y ser reemplazado por un proceso de trabajo nuevo, para permitir que se liberen los recursos no utilizados. El valor predeterminado <em>maxtasksperchild</em> es <code class="docutils literal notranslate"><span class="pre">None</span></code>, lo que significa que los procesos de trabajo vivirán tanto tiempo como el grupo.</p>
<p><em>context</em> se puede utilizar para especificar el contexto utilizado para iniciar los procesos de trabajo. Por lo general, un grupo se crea utilizando la función <code class="xref py py-func docutils literal notranslate"><span class="pre">multiprocessing.Pool()</span></code> o el método de un objeto de contexto <a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Pool()</span></code></a>. En ambos casos, <em>context</em> se establece de manera adecuada.</p>
<p>Tenga en cuenta que los métodos del objeto de grupo solo deben ser invocados por el proceso que creó el grupo.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Los objetos <a class="reference internal" href="#module-multiprocessing.pool" title="multiprocessing.pool: Create pools of processes."><code class="xref py py-class docutils literal notranslate"><span class="pre">multiprocessing.pool</span></code></a> tienen recursos internos que necesitan ser administrados adecuadamente (como cualquier otro recurso) utilizando el grupo como administrador de contexto o llamando a <a class="reference internal" href="#multiprocessing.pool.Pool.close" title="multiprocessing.pool.Pool.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> y <a class="reference internal" href="#multiprocessing.pool.Pool.terminate" title="multiprocessing.pool.Pool.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">terminate()</span></code></a> manualmente. De lo contrario, el proceso puede demorarse en la finalización.</p>
<p>Tenga en cuenta que <strong>no es correcto</strong> confiar en el recolector de basura para destruir el grupo ya que <em>CPython</em> no asegura que se llamará al finalizador del grupo (consulte <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__del__()</span></code></a> para obtener más información).</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2: </span><em>maxtasksperchild</em></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4: </span><em>context</em></p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Los procesos de los trabajadores dentro de una <a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pool</span></code></a> normalmente viven durante la duración completa de la cola de trabajo de la piscina. Un patrón frecuente que se encuentra en otros sistemas (como <em>Apache, mod_wsgi,</em> etc.) para liberar recursos en poder de los trabajadores es permitir que un trabajador dentro de un grupo complete solo una cantidad determinada de trabajo antes de salir, limpiarse y generar un nuevo proceso para reemplazar el viejo. El argumento <em>maxtasksperchild</em> para <a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pool</span></code></a> expone esta capacidad al usuario final.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.pool.Pool.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">kwds</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool.apply" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llama a <em>func</em> con argumentos <em>args</em> y argumentos de palabras clave <em>kwds</em>. Se bloquea hasta que el resultado esté listo. Dados estos bloques, <a class="reference internal" href="#multiprocessing.pool.Pool.apply_async" title="multiprocessing.pool.Pool.apply_async"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply_async()</span></code></a> es más adecuado para realizar trabajos en paralelo. Además, <em>func</em> solo se ejecuta en uno de los trabajadores de piscina.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.pool.Pool.apply_async">
<span class="sig-name descname"><span class="pre">apply_async</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">kwds</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">error_callback</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool.apply_async" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una variante del método <a class="reference internal" href="#multiprocessing.pool.Pool.apply" title="multiprocessing.pool.Pool.apply"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code></a> que retorna un objeto <a class="reference internal" href="#multiprocessing.pool.AsyncResult" title="multiprocessing.pool.AsyncResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResult</span></code></a>.</p>
<p>Si se especifica <em>callback</em>, debería ser un invocable que acepte un único argumento. Cuando el resultado está listo, se le aplica <em>callback</em>, a menos que la llamada falle, en cuyo caso se aplica <em>error_callback</em>.</p>
<p>Si se especifica <em>error_callback</em>, debería ser un invocable que acepte un único argumento. Si la función de destino falla, se llama a <em>error_callback</em> con la instancia de excepción.</p>
<p>Las devoluciones de llamada deben completarse inmediatamente ya que de lo contrario el hilo que maneja los resultados se bloqueará.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.pool.Pool.map">
<span class="sig-name descname"><span class="pre">map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">chunksize</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool.map" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un equivalente paralelo de la función incorporada <a class="reference internal" href="functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> (aunque solo admite un argumento <em>iterable</em>, para varios iterables consulte <a class="reference internal" href="#multiprocessing.pool.Pool.starmap" title="multiprocessing.pool.Pool.starmap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">starmap()</span></code></a>). Bloquea hasta que el resultado esté listo.</p>
<p>Este método corta el iterable en varios trozos que envía al grupo de procesos como tareas separadas. El tamaño (aproximado) de estos fragmentos se puede especificar estableciendo <em>chunksize</em> en un entero positivo.</p>
<p>Tenga en cuenta que puede causar un alto uso de memoria para iterables muy largos. Considere usar <a class="reference internal" href="#multiprocessing.pool.Pool.imap" title="multiprocessing.pool.Pool.imap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">imap()</span></code></a> o <a class="reference internal" href="#multiprocessing.pool.Pool.imap_unordered" title="multiprocessing.pool.Pool.imap_unordered"><code class="xref py py-meth docutils literal notranslate"><span class="pre">imap_unordered()</span></code></a> con la opción explícita <em>chunksize</em> para una mejor eficiencia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.pool.Pool.map_async">
<span class="sig-name descname"><span class="pre">map_async</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">chunksize</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">error_callback</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool.map_async" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una variante del método <a class="reference internal" href="#multiprocessing.pool.Pool.map" title="multiprocessing.pool.Pool.map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">map()</span></code></a> que retorna un objeto <a class="reference internal" href="#multiprocessing.pool.AsyncResult" title="multiprocessing.pool.AsyncResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResult</span></code></a>.</p>
<p>Si se especifica <em>callback</em>, debería ser un invocable que acepte un único argumento. Cuando el resultado está listo, se le aplica <em>callback</em>, a menos que la llamada falle, en cuyo caso se aplica <em>error_callback</em>.</p>
<p>Si se especifica <em>error_callback</em>, debería ser un invocable que acepte un único argumento. Si la función de destino falla, se llama a <em>error_callback</em> con la instancia de excepción.</p>
<p>Las devoluciones de llamada deben completarse inmediatamente ya que de lo contrario el hilo que maneja los resultados se bloqueará.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.pool.Pool.imap">
<span class="sig-name descname"><span class="pre">imap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">chunksize</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool.imap" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión más perezosa (<em>lazier</em>) de <a class="reference internal" href="#multiprocessing.pool.Pool.map" title="multiprocessing.pool.Pool.map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">map()</span></code></a>.</p>
<p>El argumento <em>chunksize</em> es el mismo que el utilizado por el método <a class="reference internal" href="#multiprocessing.pool.Pool.map" title="multiprocessing.pool.Pool.map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">map()</span></code></a>. Para iterables muy largos, usar un valor grande para <em>chunksize</em> puede hacer que el trabajo se complete <strong>much</strong> (<strong>mucho</strong>) más rápido que usar el valor predeterminado de <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p>Además, si <em>chunksize</em> es <code class="docutils literal notranslate"><span class="pre">1</span></code>, el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code> del iterador retornado por el método <a class="reference internal" href="#multiprocessing.pool.Pool.imap" title="multiprocessing.pool.Pool.imap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">imap()</span></code></a> tiene un parámetro opcional <em>timeout</em> :<code class="docutils literal notranslate"><span class="pre">next</span> <span class="pre">(timeout)</span></code> lanzará  <a class="reference internal" href="#multiprocessing.TimeoutError" title="multiprocessing.TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">multiprocessing.TimeoutError</span></code></a> si el resultado no puede retornarse dentro de <em>timeout</em> segundos.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.pool.Pool.imap_unordered">
<span class="sig-name descname"><span class="pre">imap_unordered</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">chunksize</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool.imap_unordered" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Lo mismo que <a class="reference internal" href="#multiprocessing.pool.Pool.imap" title="multiprocessing.pool.Pool.imap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">imap()</span></code></a>, excepto que el orden de los resultados del iterador retornado debe considerarse arbitrario. (Solo cuando hay un solo proceso de trabajo se garantiza que el orden sea «correcto»).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.pool.Pool.starmap">
<span class="sig-name descname"><span class="pre">starmap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">chunksize</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool.starmap" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Como <a class="reference internal" href="#multiprocessing.pool.Pool.map" title="multiprocessing.pool.Pool.map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">map()</span></code></a>, excepto que se espera que los elementos de <em>iterable</em> sean iterables que se desempaquetan como argumentos.</p>
<p>Por lo tanto, un <em>iterable</em> de <code class="docutils literal notranslate"><span class="pre">[(1,2),</span> <span class="pre">(3,</span> <span class="pre">4)]</span></code> da como resultado <code class="docutils literal notranslate"><span class="pre">[func(1,2),</span> <span class="pre">func(3,4)]</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.pool.Pool.starmap_async">
<span class="sig-name descname"><span class="pre">starmap_async</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">chunksize</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">error_callback</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool.starmap_async" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una combinación de <a class="reference internal" href="#multiprocessing.pool.Pool.starmap" title="multiprocessing.pool.Pool.starmap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">starmap()</span></code></a> y <a class="reference internal" href="#multiprocessing.pool.Pool.map_async" title="multiprocessing.pool.Pool.map_async"><code class="xref py py-meth docutils literal notranslate"><span class="pre">map_async()</span></code></a> que itera sobre <em>iterable</em> de iterables y llama a <em>func</em> con los iterables desempaquetados. Como resultado se retorna un objeto.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.pool.Pool.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool.close" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Impide que se envíen más tareas a la piscina (<em>pool</em>). Una vez que se hayan completado todas las tareas, se cerrarán los procesos de trabajo.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.pool.Pool.terminate">
<span class="sig-name descname"><span class="pre">terminate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool.terminate" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Detiene los procesos de trabajo inmediatamente sin completar el trabajo pendiente. Cuando el objeto del grupo es basura recolectada <a class="reference internal" href="#multiprocessing.pool.Pool.terminate" title="multiprocessing.pool.Pool.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">terminate()</span></code></a> se llamará inmediatamente.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.pool.Pool.join">
<span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.Pool.join" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Espera a que salgan los procesos de trabajo. Se debe llamar <a class="reference internal" href="#multiprocessing.pool.Pool.close" title="multiprocessing.pool.Pool.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> o <a class="reference internal" href="#multiprocessing.pool.Pool.terminate" title="multiprocessing.pool.Pool.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">terminate()</span></code></a> antes de usar <a class="reference internal" href="#multiprocessing.pool.Pool.join" title="multiprocessing.pool.Pool.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code></a>.</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3: </span>Los objetos de piscina (<em>pool</em>) ahora admiten el protocolo de administración de contexto; consulte <a class="reference internal" href="stdtypes.html#typecontextmanager"><span class="std std-ref">Tipos gestores de contexto</span></a>. <code class="xref py py-meth docutils literal notranslate"><span class="pre">__</span> <span class="pre">enter__()</span></code> retorna el objeto de grupo, y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__</span> <span class="pre">exit__()</span></code> llama <a class="reference internal" href="#multiprocessing.pool.Pool.terminate" title="multiprocessing.pool.Pool.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">terminate()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="multiprocessing.pool.AsyncResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.pool.</span></span><span class="sig-name descname"><span class="pre">AsyncResult</span></span><a class="headerlink" href="#multiprocessing.pool.AsyncResult" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La clase del resultado retornado por <a class="reference internal" href="#multiprocessing.pool.Pool.apply_async" title="multiprocessing.pool.Pool.apply_async"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Pool.apply_async()</span></code></a> y <a class="reference internal" href="#multiprocessing.pool.Pool.map_async" title="multiprocessing.pool.Pool.map_async"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Pool.map_async()</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.pool.AsyncResult.get">
<span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.AsyncResult.get" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el resultado cuando llegue. Si <em>timeout</em> no es <code class="docutils literal notranslate"><span class="pre">None</span></code> y el resultado no llega dentro de <em>timeout</em> segundos, entonces se lanza <a class="reference internal" href="#multiprocessing.TimeoutError" title="multiprocessing.TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">multiprocessing.TimeoutError</span></code></a>. Si la llamada remota generó una excepción, esa excepción se volverá a plantear mediante <a class="reference internal" href="#multiprocessing.pool.AsyncResult.get" title="multiprocessing.pool.AsyncResult.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.pool.AsyncResult.wait">
<span class="sig-name descname"><span class="pre">wait</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.AsyncResult.wait" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Espera hasta que el resultado esté disponible o hasta que pase <em>timeout</em> segundos.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.pool.AsyncResult.ready">
<span class="sig-name descname"><span class="pre">ready</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.AsyncResult.ready" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna si la llamada se ha completado.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.pool.AsyncResult.successful">
<span class="sig-name descname"><span class="pre">successful</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.AsyncResult.successful" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna si la llamada se completó sin generar una excepción. Lanzará <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> si el resultado no está listo.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Si el resultado no está listo <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> aparece en lugar de <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a>.</p>
</div>
</dd></dl>

</dd></dl>

<p>El siguiente ejemplo demuestra el uso de una piscina(<em>pool</em>):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>         <span class="c1"># start 4 worker processes</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="p">,))</span> <span class="c1"># evaluate &quot;f(10)&quot; asynchronously in a single process</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>        <span class="c1"># prints &quot;100&quot; unless your computer is *very* slow</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span>       <span class="c1"># prints &quot;[0, 1, 4,..., 81]&quot;</span>

        <span class="n">it</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>                     <span class="c1"># prints &quot;0&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>                     <span class="c1"># prints &quot;1&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>           <span class="c1"># prints &quot;4&quot; unless your computer is *very* slow</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="p">,))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>        <span class="c1"># raises multiprocessing.TimeoutError</span>
</pre></div>
</div>
</section>
<section id="module-multiprocessing.connection">
<span id="listeners-and-clients"></span><span id="multiprocessing-listeners-clients"></span><h3>Oyentes y clientes (<em>Listeners and Clients</em>)<a class="headerlink" href="#module-multiprocessing.connection" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Por lo general, el paso de mensajes entre procesos se realiza mediante colas o mediante objetos <a class="reference internal" href="#multiprocessing.connection.Connection" title="multiprocessing.connection.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a> retornados por <a class="reference internal" href="#multiprocessing.Pipe" title="multiprocessing.Pipe"><code class="xref py py-func docutils literal notranslate"><span class="pre">Pipe()</span></code></a>.</p>
<p>Sin embargo, el módulo <a class="reference internal" href="#module-multiprocessing.connection" title="multiprocessing.connection: API for dealing with sockets."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing.connection</span></code></a> permite cierta flexibilidad adicional. Básicamente proporciona una API orientada a mensajes de alto nivel para tratar con sockets o canalizaciones con nombre de Windows. También tiene soporte para <em>digest authentication</em> usando el módulo <a class="reference internal" href="hmac.html#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hmac</span></code></a>, y para sondear múltiples conexiones al mismo tiempo.</p>
<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.connection.deliver_challenge">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.connection.</span></span><span class="sig-name descname"><span class="pre">deliver_challenge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">connection</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">authkey</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.deliver_challenge" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Envía un mensaje generado aleatoriamente al otro extremo de la conexión y espera una respuesta.</p>
<p>Si la respuesta coincide con el resumen del mensaje utilizando <em>authkey</em> como clave, se envía un mensaje de bienvenida al otro extremo de la conexión. De lo contrario se lanza <a class="reference internal" href="#multiprocessing.AuthenticationError" title="multiprocessing.AuthenticationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AuthenticationError</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.connection.answer_challenge">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.connection.</span></span><span class="sig-name descname"><span class="pre">answer_challenge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">connection</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">authkey</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.answer_challenge" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Recibe un mensaje, calcula el resumen del mensaje usando <em>authkey</em> como la clave y luego envía el resumen de vuelta.</p>
<p>Si no se recibe un mensaje de bienvenida, se lanza <a class="reference internal" href="#multiprocessing.AuthenticationError" title="multiprocessing.AuthenticationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AuthenticationError</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.connection.Client">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.connection.</span></span><span class="sig-name descname"><span class="pre">Client</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">family</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">authkey</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.Client" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Se intenta configurar una conexión con el oyente que utiliza la dirección <em>address</em>, retornando <a class="reference internal" href="#multiprocessing.connection.Connection" title="multiprocessing.connection.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a>.</p>
<p>El tipo de conexión está determinado por el argumento <em>family</em>, pero esto generalmente se puede omitir ya que generalmente se puede inferir del formato de <em>address</em>. (Consulte <a class="reference internal" href="#multiprocessing-address-formats"><span class="std std-ref">Formatos de dirección (Address formats)</span></a>)</p>
<p>Si se proporciona <em>authkey</em> y no <em>None</em>, debe ser una cadena de <em>bytes</em> y se utilizará como clave secreta para un desafío de autenticación basado en HMAC. No se realiza la autenticación si <em>authkey</em> es <em>None</em>. Si falla la autenticación se lanza <a class="reference internal" href="#multiprocessing.AuthenticationError" title="multiprocessing.AuthenticationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AuthenticationError</span></code></a>. Consulte <a class="reference internal" href="#multiprocessing-auth-keys"><span class="std std-ref">Llaves de autentificación</span></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="multiprocessing.connection.Listener">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.connection.</span></span><span class="sig-name descname"><span class="pre">Listener</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">family</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">backlog</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">authkey</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.Listener" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un contenedor para un <em>socket</em> vinculado o una tubería (<em>pipe</em>) con nombre de Windows que está “escuchando” las conexiones.</p>
<p><em>address</em> es la dirección que utilizará el <em>socket</em> vinculado o la conocida tubería (<em>pipe</em>) con nombre del objeto de escucha.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si se usa una dirección de “0.0.0.0” , la dirección no será un punto final conectable en Windows. Si necesita un punto final conectable, debe usar “127.0.0.1”.</p>
</div>
<p><em>family</em> es el tipo de socket (o tubería con nombre) a utilizar. Esta puede ser una de las cadenas de caracteres <code class="docutils literal notranslate"><span class="pre">'AF_INET'</span></code> (para un socket TCP), <code class="docutils literal notranslate"><span class="pre">'</span> <span class="pre">AF_UNIX'</span></code> (para un socket de dominio Unix) o <code class="docutils literal notranslate"><span class="pre">'AF_PIPE'</span></code> (para una tubería con nombre de Windows) . De estos, solo el primero está garantizado para estar disponible. Si <em>family</em> es <code class="docutils literal notranslate"><span class="pre">None</span></code> , <em>family</em> se deduce del formato de <em>address</em>. Si <em>address</em> también es <code class="docutils literal notranslate"><span class="pre">None</span></code> , se elige un valor predeterminado. Este valor predeterminado es <em>family</em> con la opción más rápida disponible. Consulte <a class="reference internal" href="#multiprocessing-address-formats"><span class="std std-ref">Formatos de dirección (Address formats)</span></a>. Tenga en cuenta que si <em>family</em> es <code class="docutils literal notranslate"><span class="pre">'AF_UNIX'</span></code> y la dirección es <code class="docutils literal notranslate"><span class="pre">None</span></code>, el <em>socket</em> se creará en un directorio temporal privado usando <a class="reference internal" href="tempfile.html#tempfile.mkstemp" title="tempfile.mkstemp"><code class="xref py py-func docutils literal notranslate"><span class="pre">tempfile.mkstemp()</span></code></a>.</p>
<p>Si el objeto de escucha utiliza un <em>socket</em>, entonces <em>backlog</em> (1 por defecto) se pasa al método <a class="reference internal" href="socket.html#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">listen()</span></code></a> del <em>socket</em> una vez que se ha vinculado.</p>
<p>Si se proporciona <em>authkey</em> y no <em>None</em>, debe ser una cadena de <em>bytes</em> y se utilizará como clave secreta para un desafío de autenticación basado en HMAC. No se realiza la autenticación si <em>authkey</em> es <em>None</em>. Si falla la autenticación se lanza <a class="reference internal" href="#multiprocessing.AuthenticationError" title="multiprocessing.AuthenticationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AuthenticationError</span></code></a>. Consulte <a class="reference internal" href="#multiprocessing-auth-keys"><span class="std std-ref">Llaves de autentificación</span></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.connection.Listener.accept">
<span class="sig-name descname"><span class="pre">accept</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.Listener.accept" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Acepta una conexión en el <em>socket</em> vinculado o canalización con nombre del objeto de escucha y retorne un objeto <a class="reference internal" href="#multiprocessing.connection.Connection" title="multiprocessing.connection.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a>. Si se intenta la autenticación y falla, entonces se lanza una <a class="reference internal" href="#multiprocessing.AuthenticationError" title="multiprocessing.AuthenticationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AuthenticationError</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="multiprocessing.connection.Listener.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.Listener.close" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Cierra el socket vinculado o la tubería con nombre del objeto de escucha. Esto se llama automáticamente cuando el oyente es recolectado por el recolector de basura. Sin embargo, es aconsejable llamarlo explícitamente.</p>
</dd></dl>

<p>Los objetos de escucha tienen las siguientes propiedades de solo lectura:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="multiprocessing.connection.Listener.address">
<span class="sig-name descname"><span class="pre">address</span></span><a class="headerlink" href="#multiprocessing.connection.Listener.address" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La dirección que está utilizando el objeto <em>Listener</em>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="multiprocessing.connection.Listener.last_accepted">
<span class="sig-name descname"><span class="pre">last_accepted</span></span><a class="headerlink" href="#multiprocessing.connection.Listener.last_accepted" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La dirección de donde vino la última conexión aceptada. Si esto no está disponible, entonces es <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3: </span>Los objetos de escucha ahora admiten el protocolo de gestión de contexto – consulte <a class="reference internal" href="stdtypes.html#typecontextmanager"><span class="std std-ref">Tipos gestores de contexto</span></a>. El objeto <em>lISTENER</em> retorna <a class="reference internal" href="stdtypes.html#contextmanager.__enter__" title="contextmanager.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a>, y <a class="reference internal" href="stdtypes.html#contextmanager.__exit__" title="contextmanager.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> llama a <a class="reference internal" href="#multiprocessing.connection.Listener.close" title="multiprocessing.connection.Listener.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.connection.wait">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.connection.</span></span><span class="sig-name descname"><span class="pre">wait</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.wait" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Espera hasta que un objeto en <em>object_list</em> esté listo. Retorna la lista de esos objetos en <em>object_list</em> que están listos. Si <em>timeout</em> es flotante, la llamada se bloquea durante como máximo tantos segundos. Si <em>timeout</em> es <code class="docutils literal notranslate"><span class="pre">`None</span></code>, se bloqueará por un período ilimitado. Un tiempo de espera negativo es equivalente a un tiempo de espera cero.</p>
<p>Tanto para Unix como para Windows, un objeto puede aparecer en <em>object_list</em> si este es</p>
<ul class="simple">
<li><p>un objeto legible de <a class="reference internal" href="#multiprocessing.connection.Connection" title="multiprocessing.connection.Connection"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code></a>;</p></li>
<li><p>un objeto conectado y legible de <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a>; o</p></li>
<li><p>el atributo <a class="reference internal" href="#multiprocessing.Process.sentinel" title="multiprocessing.Process.sentinel"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sentinel</span></code></a> de un objeto <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a>.</p></li>
</ul>
<p>Un objeto de conexión o <em>socket</em> está listo cuando hay datos disponibles para leer, o el otro extremo se ha cerrado.</p>
<p><strong>Unix</strong>: <code class="docutils literal notranslate"><span class="pre">wait(object_list,</span> <span class="pre">timeout)</span></code> es casi equivalente a <code class="docutils literal notranslate"><span class="pre">select.select(object_list,</span> <span class="pre">[],</span> <span class="pre">[],</span> <span class="pre">timeout)</span></code>. La diferencia es que si se interrumpe <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select.select()</span></code></a> por una señal, este lanza <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> con un número de error <code class="docutils literal notranslate"><span class="pre">EINTR</span></code>, a diferencia de <a class="reference internal" href="#multiprocessing.connection.wait" title="multiprocessing.connection.wait"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait()</span></code></a>.</p>
<p><strong>Windows</strong>: Un elemento en <em>object_list</em> debe ser un identificador de número entero que se pueda esperar (de acuerdo con la definición utilizada por la documentación de la función <em>Win32</em> <code class="docutils literal notranslate"><span class="pre">WaitForMultipleObjects()</span></code>) o puede ser un objeto con un <code class="xref py py-meth docutils literal notranslate"><span class="pre">fileno()</span></code> Método que retorna un manejador de tubo o manejador de tubería. (Tenga en cuenta que las manijas de las tuberías y las manijas de los zócalos son <strong>no</strong> manijas aptas)</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<p><strong>Ejemplos</strong></p>
<p>El siguiente código de servidor crea un escucha que utiliza <code class="docutils literal notranslate"><span class="pre">'secret</span> <span class="pre">password'</span></code> como clave de autenticación. Luego espera una conexión y envía algunos datos al cliente:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing.connection</span> <span class="kn">import</span> <span class="n">Listener</span>
<span class="kn">from</span> <span class="nn">array</span> <span class="kn">import</span> <span class="n">array</span>

<span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">6000</span><span class="p">)</span>     <span class="c1"># family is deduced to be &#39;AF_INET&#39;</span>

<span class="k">with</span> <span class="n">Listener</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;secret password&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">listener</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">listener</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;connection accepted from&#39;</span><span class="p">,</span> <span class="n">listener</span><span class="o">.</span><span class="n">last_accepted</span><span class="p">)</span>

        <span class="n">conn</span><span class="o">.</span><span class="n">send</span><span class="p">([</span><span class="mf">2.25</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;junk&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span>

        <span class="n">conn</span><span class="o">.</span><span class="n">send_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>

        <span class="n">conn</span><span class="o">.</span><span class="n">send_bytes</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">42</span><span class="p">,</span> <span class="mi">1729</span><span class="p">]))</span>
</pre></div>
</div>
<p>El siguiente código se conecta al servidor y recibe algunos datos del servidor:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing.connection</span> <span class="kn">import</span> <span class="n">Client</span>
<span class="kn">from</span> <span class="nn">array</span> <span class="kn">import</span> <span class="n">array</span>

<span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">6000</span><span class="p">)</span>

<span class="k">with</span> <span class="n">Client</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">authkey</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;secret password&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">recv</span><span class="p">())</span>                  <span class="c1"># =&gt; [2.25, None, &#39;junk&#39;, float]</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">recv_bytes</span><span class="p">())</span>            <span class="c1"># =&gt; &#39;hello&#39;</span>

    <span class="n">arr</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">recv_bytes_into</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>    <span class="c1"># =&gt; 8</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>                          <span class="c1"># =&gt; array(&#39;i&#39;, [42, 1729, 0, 0, 0])</span>
</pre></div>
</div>
<p>El siguiente código utiliza <a class="reference internal" href="#multiprocessing.connection.wait" title="multiprocessing.connection.wait"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait()</span></code></a> para esperar mensajes de múltiples procesos a la vez:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Pipe</span><span class="p">,</span> <span class="n">current_process</span>
<span class="kn">from</span> <span class="nn">multiprocessing.connection</span> <span class="kn">import</span> <span class="n">wait</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">w</span><span class="o">.</span><span class="n">send</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">current_process</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
    <span class="n">w</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">readers</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">duplex</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">readers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">foo</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">w</span><span class="p">,))</span>
        <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="c1"># We close the writable end of the pipe now to be sure that</span>
        <span class="c1"># p is the only process which owns a handle for it.  This</span>
        <span class="c1"># ensures that when p closes its handle for the writable end,</span>
        <span class="c1"># wait() will promptly report the readable end as being ready.</span>
        <span class="n">w</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">readers</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">wait</span><span class="p">(</span><span class="n">readers</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">EOFError</span><span class="p">:</span>
                <span class="n">readers</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</pre></div>
</div>
<section id="address-formats">
<span id="multiprocessing-address-formats"></span><h4>Formatos de dirección (<em>Address formats</em>)<a class="headerlink" href="#address-formats" title="Enlazar permanentemente con este título">¶</a></h4>
<ul class="simple">
<li><p>Una dirección <code class="docutils literal notranslate"><span class="pre">'AF_INET'</span></code> es una tupla de la forma <code class="docutils literal notranslate"><span class="pre">(hostname,</span> <span class="pre">port)</span></code> donde <em>hostname</em> es una cadena de caracteres y <em>port</em> es un número entero.</p></li>
<li><p>Una dirección <code class="docutils literal notranslate"><span class="pre">'AF_UNIX'</span></code> es una cadena que representa un nombre de archivo en el sistema de archivos.</p></li>
<li><p>Una dirección <code class="docutils literal notranslate"><span class="pre">'AF_PIPE'</span></code> es una cadena con el formato <code class="samp docutils literal notranslate"><span class="pre">r'\\.\pipe\</span><em><span class="pre">PipeName</span></em><span class="pre">'</span></code>. Para usar <a class="reference internal" href="#multiprocessing.connection.Client" title="multiprocessing.connection.Client"><code class="xref py py-func docutils literal notranslate"><span class="pre">Client()</span></code></a> para conectarse a una tubería con nombre en una computadora remota llamada <em>ServerName</em>, se debe usar una dirección de la forma <code class="samp docutils literal notranslate"><span class="pre">r'\\</span><em><span class="pre">ServerName</span></em><span class="pre">\pipe\</span><em><span class="pre">PipeName</span></em><span class="pre">'</span></code> en cambio.</p></li>
</ul>
<p>Tenga en cuenta que cualquier cadena que comience con dos barras inclinadas invertidas se asume por defecto como una dirección <code class="docutils literal notranslate"><span class="pre">'AF_PIPE'</span></code> en lugar de una dirección <code class="docutils literal notranslate"><span class="pre">'AF_UNIX'</span></code>.</p>
</section>
</section>
<section id="authentication-keys">
<span id="multiprocessing-auth-keys"></span><h3>Llaves de autentificación<a class="headerlink" href="#authentication-keys" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Cuando uno usa <a class="reference internal" href="#multiprocessing.connection.Connection.recv" title="multiprocessing.connection.Connection.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.recv</span></code></a>, los datos recibidos se desbloquean automáticamente. Desafortunadamente, la eliminación de datos de una fuente no confiable es un riesgo de seguridad. Por lo tanto <a class="reference internal" href="#multiprocessing.connection.Listener" title="multiprocessing.connection.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a> y <a class="reference internal" href="#multiprocessing.connection.Client" title="multiprocessing.connection.Client"><code class="xref py py-func docutils literal notranslate"><span class="pre">Client()</span></code></a> usan el módulo <a class="reference internal" href="hmac.html#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hmac</span></code></a> para proporcionar autenticación de resumen.</p>
<p>Una clave de autenticación es una cadena de bytes que se puede considerar como una contraseña: una vez que se establece una conexión, ambos extremos exigirán pruebas de que el otro conoce la clave de autenticación. (Demostrar que ambos extremos están usando la misma clave <strong>no</strong> implica enviar la clave a través de la conexión).</p>
<p>Si se solicita la autenticación pero no se especifica una clave de autenticación, se utiliza el valor de retorno de <code class="docutils literal notranslate"><span class="pre">current_process().authkey</span></code> (consulte <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> ). Este valor será heredado automáticamente por cualquier objeto <code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code> que crea el proceso actual. Esto significa que (por defecto) todos los procesos de un programa multiproceso compartirán una única clave de autenticación que se puede usar al configurar conexiones entre ellos.</p>
<p>Las claves de autenticación adecuadas también se pueden generar utilizando <a class="reference internal" href="os.html#os.urandom" title="os.urandom"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.urandom()</span></code></a>.</p>
</section>
<section id="logging">
<h3><em>Logging</em><a class="headerlink" href="#logging" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Existe cierto soporte para el registro. Sin embargo, tenga en cuenta que el paquete <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> no utiliza candados compartidos de proceso, por lo que es posible (dependiendo del tipo de controlador) que los mensajes de diferentes procesos se mezclen.</p>
<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.get_logger">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">get_logger</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.get_logger" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el registrador utilizado por <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a>. Si es necesario, se creará uno nuevo.</p>
<p>Cuando se creó por primera vez, el registrador tiene nivel <code class="xref py py-data docutils literal notranslate"><span class="pre">logging.NOTSET</span></code> y no tiene un controlador predeterminado. Los mensajes enviados a este registrador no se propagarán por defecto al registrador raíz.</p>
<p>Tenga en cuenta que en Windows los procesos hijos solo heredarán el nivel del registrador del proceso parental – no se heredará ninguna otra personalización del registrador.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="multiprocessing.log_to_stderr">
<span class="sig-prename descclassname"><span class="pre">multiprocessing.</span></span><span class="sig-name descname"><span class="pre">log_to_stderr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.log_to_stderr" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta función realiza una llamada a <a class="reference internal" href="#multiprocessing.get_logger" title="multiprocessing.get_logger"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_logger()</span></code></a> pero además de retornar el registrador creado por get_logger, agrega un controlador que envía la salida a <a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a> usando el formato <code class="docutils literal notranslate"><span class="pre">'[%(levelname)s/%(processName)s]</span> <span class="pre">%(message)s'</span></code>. Puede modificar <code class="docutils literal notranslate"><span class="pre">levelname</span></code> del registrador pasando un argumento <code class="docutils literal notranslate"><span class="pre">level</span></code>.</p>
</dd></dl>

<p>A continuación se muestra una sesión de ejemplo con el registro activado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">multiprocessing</span><span class="o">,</span> <span class="nn">logging</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logger</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">log_to_stderr</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;doomed&#39;</span><span class="p">)</span>
<span class="go">[WARNING/MainProcess] doomed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span>
<span class="go">[INFO/SyncManager-...] child process calling self.run()</span>
<span class="go">[INFO/SyncManager-...] created temp directory /.../pymp-...</span>
<span class="go">[INFO/SyncManager-...] manager serving at &#39;/.../listener-...&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">m</span>
<span class="go">[INFO/MainProcess] sending shutdown message to manager</span>
<span class="go">[INFO/SyncManager-...] manager exiting with exitcode 0</span>
</pre></div>
</div>
<p>Para obtener una tabla completa de niveles de registro, consulte el módulo <a class="reference internal" href="logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a>.</p>
</section>
<section id="module-multiprocessing.dummy">
<span id="the-multiprocessing-dummy-module"></span><h3>El módulo <a class="reference internal" href="#module-multiprocessing.dummy" title="multiprocessing.dummy: Dumb wrapper around threading."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing.dummy</span></code></a><a class="headerlink" href="#module-multiprocessing.dummy" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El <a class="reference internal" href="#module-multiprocessing.dummy" title="multiprocessing.dummy: Dumb wrapper around threading."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing.dummy</span></code></a> replica la API de <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> pero no es más que un contenedor alrededor del módulo <a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a>.</p>
<p>En particular, la función <code class="docutils literal notranslate"><span class="pre">Pool</span></code> ofrecida por <a class="reference internal" href="#module-multiprocessing.dummy" title="multiprocessing.dummy: Dumb wrapper around threading."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing.dummy</span></code></a> retorna un instancia de <a class="reference internal" href="#multiprocessing.pool.ThreadPool" title="multiprocessing.pool.ThreadPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPool</span></code></a>, la cual es un subclase de <a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pool</span></code></a> que soporta todas las mismas llamadas, pero usa un <em>pool</em> de hebras trabajadoras en vez de procesos trabajadores.</p>
<dl class="py class">
<dt class="sig sig-object py" id="multiprocessing.pool.ThreadPool">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">multiprocessing.pool.</span></span><span class="sig-name descname"><span class="pre">ThreadPool</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">processes</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">initializer</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">initargs</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.pool.ThreadPool" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un objeto de <em>pool</em> de hebras que controla un <em>pool</em> de hebras trabajadoras a las cuales se pueden enviar trabajos. La interfaz de las instancias de <a class="reference internal" href="#multiprocessing.pool.ThreadPool" title="multiprocessing.pool.ThreadPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPool</span></code></a> son totalmente compatibles con las instancias de <a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pool</span></code></a>, y sus recursos también deben ser debidamente administrador, ya sea usando el <em>pool</em> como un gestor de contexto, o llamando a <a class="reference internal" href="#multiprocessing.pool.Pool.close" title="multiprocessing.pool.Pool.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> y <a class="reference internal" href="#multiprocessing.pool.Pool.terminate" title="multiprocessing.pool.Pool.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">terminate()</span></code></a> manualmente.</p>
<p><em>processes</em> es el número de hebras de trabajo a utilizar. Si <em>processes</em> es <code class="docutils literal notranslate"><span class="pre">None</span></code> , se utiliza el número retornado por <a class="reference internal" href="os.html#os.cpu_count" title="os.cpu_count"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.cpu_count()</span></code></a>.</p>
<p>Si <em>initializer</em> no es <code class="docutils literal notranslate"><span class="pre">None</span></code>, cada proceso de trabajo llamará <code class="docutils literal notranslate"><span class="pre">initializer(*initargs)</span></code> cuando se inicie.</p>
<p>A diferencia de <a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pool</span></code></a>, <em>maxtasksperchild</em> and <em>context</em> no se pueden entregar.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Un <a class="reference internal" href="#multiprocessing.pool.ThreadPool" title="multiprocessing.pool.ThreadPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPool</span></code></a> comparte la misma interfaz que <a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pool</span></code></a>, la cual está diseñada alrededor de un <em>pool</em> de procesos, y precede la introducción del módulo <a class="reference internal" href="concurrent.futures.html#module-concurrent.futures" title="concurrent.futures: Execute computations concurrently using threads or processes."><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures</span></code></a>. Como tal, hereda algunas operaciones que no tienen sentido para un <em>pool</em> basado en hebras, y tiene su propio tipo para representar el estado de trabajos asíncronos, <a class="reference internal" href="#multiprocessing.pool.AsyncResult" title="multiprocessing.pool.AsyncResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResult</span></code></a>, el cual no es entendido por otras librerías.</p>
<p>Los usuarios deberían por lo general preferir usar <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures.ThreadPoolExecutor</span></code></a>, el cual tiene una interfaz más simple que fue diseñada alrededor de hebras desde un principio, y que retorna instancias de <a class="reference internal" href="concurrent.futures.html#concurrent.futures.Future" title="concurrent.futures.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures.Future</span></code></a>, las que son compatibles con muchas más librerías, incluyendo <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a>.</p>
</div>
</div></blockquote>
</dd></dl>

</section>
</section>
<section id="programming-guidelines">
<span id="multiprocessing-programming"></span><h2>Pautas de programación<a class="headerlink" href="#programming-guidelines" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Hay ciertas pautas y expresiones idiomáticas que deben tenerse en cuenta al usar <a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> .</p>
<section id="all-start-methods">
<h3>Todos los métodos de inicio<a class="headerlink" href="#all-start-methods" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Lo siguiente se aplica a todos los métodos de inicio.</p>
<p>Evita estado compartido</p>
<blockquote>
<div><p>En la medida de lo posible, se debe tratar de evitar el desplazamiento de grandes cantidades de datos entre procesos.</p>
<p>Probablemente sea mejor seguir usando colas (<em>queues</em>) o tuberías (<em>pipes</em>) para la comunicación entre procesos en lugar de usar las primitivas de sincronización de nivel inferior.</p>
</div></blockquote>
<p>Serialización (<em>picklability</em>)</p>
<blockquote>
<div><p>Asegúrese que todos los argumentos de los métodos de <em>proxies</em> son serializables (<em>pickable</em>)</p>
</div></blockquote>
<p>Seguridad de hilos de <em>proxies</em></p>
<blockquote>
<div><p>No usa un objeto proxy de más de un hilo a menos que lo proteja con un candado (<em>lock</em>).</p>
<p>(Nunca hay un problema con diferentes procesos que usan el <em>mismo</em> proxy.)</p>
</div></blockquote>
<p>Uniéndose a procesos zombies</p>
<blockquote>
<div><p>En Unix, cuando un proceso finaliza pero no se ha unido, se convierte en un zombie. Nunca debería haber muchos porque cada vez que se inicia un nuevo proceso (o se llama <a class="reference internal" href="#multiprocessing.active_children" title="multiprocessing.active_children"><code class="xref py py-func docutils literal notranslate"><span class="pre">active_children()</span></code></a>) se unirán todos los procesos completados que aún no se hayan unido. También llamando a un proceso terminado <a class="reference internal" href="#multiprocessing.Process.is_alive" title="multiprocessing.Process.is_alive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Process.is_alive</span></code></a> se unirá al proceso. Aun así, probablemente sea una buena práctica unir explícitamente todos los procesos que comience.</p>
</div></blockquote>
<p>Mejor heredar que serializar/deserializar (<em>pickle/unpickle</em>)</p>
<blockquote>
<div><p>Cuando se usan los métodos de inicio <em>spawn</em> o <em>forkserver</em>, muchos tipos de <code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocesamiento</span></code> deben ser seleccionables para que los procesos secundarios puedan usarlos. Sin embargo, generalmente se debe evitar enviar objetos compartidos a otros procesos mediante tuberías o colas. En su lugar, debe organizar el programa para que un proceso que necesita acceso a un recurso compartido creado en otro lugar pueda heredarlo de un proceso ancestro.</p>
</div></blockquote>
<p>Evita procesos de finalización</p>
<blockquote>
<div><p>El uso del método <a class="reference internal" href="#multiprocessing.Process.terminate" title="multiprocessing.Process.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Process.terminate</span></code></a> para detener un proceso puede causar que los recursos compartidos (como candados, semáforos, tuberías  y colas) que el proceso utiliza actualmente se rompan o no disponible para otros procesos.</p>
<p>Por lo tanto, probablemente sea mejor considerar usar <a class="reference internal" href="#multiprocessing.Process.terminate" title="multiprocessing.Process.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Process.terminate</span></code></a> en procesos que nunca usan recursos compartidos.</p>
</div></blockquote>
<p>Unirse a procesos que usan colas</p>
<blockquote>
<div><p>Tenga en cuenta que un proceso que ha puesto elementos en una cola esperará antes de finalizar hasta que todos los elementos almacenados en búfer sean alimentados por el hilo «alimentador» a la tubería subyacente. (El proceso secundario puede llamar al método <a class="reference internal" href="#multiprocessing.Queue.cancel_join_thread" title="multiprocessing.Queue.cancel_join_thread"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Queue.cancel_join_thread</span></code></a> de la cola para evitar este comportamiento).</p>
<p>Esto significa que siempre que use una cola debe asegurarse de que todos los elementos que se hayan puesto en la cola se eliminarán antes de unirse al proceso. De lo contrario, no puede estar seguro de que los procesos que han puesto elementos en la cola finalizarán. Recuerde también que los procesos no demoníacos se unirán automáticamente.</p>
<p>Un ejemplo que de bloqueo mutuo (<em>deadlock</em>) es el siguiente</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Queue</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;X&#39;</span> <span class="o">*</span> <span class="mi">1000000</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">queue</span><span class="p">,))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>                    <span class="c1"># this deadlocks</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
<p>Una solución aquí sería intercambiar las dos últimas líneas (o simplemente eliminar la línea <code class="docutils literal notranslate"><span class="pre">p.join()</span></code>).</p>
</div></blockquote>
<p>Se pasan recursos explícitamente a procesos hijos</p>
<blockquote>
<div><p>En Unix que utiliza el método de inicio <em>fork</em>, un proceso secundario puede hacer uso de un recurso compartido creado en un proceso primario utilizando un recurso global. Sin embargo, es mejor pasar el objeto como argumento al constructor para el proceso secundario.</p>
<p>Además de hacer que el código (potencialmente) sea compatible con Windows y los otros métodos de inicio, esto también garantiza que mientras el proceso secundario siga vivo, el objeto no se recolectará en el proceso primario. Esto podría ser importante si se libera algún recurso cuando el objeto es basura recolectada en el proceso padre.</p>
<p>Entonces por ejemplo</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Lock</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="o">...</span> <span class="n">do</span> <span class="n">something</span> <span class="n">using</span> <span class="s2">&quot;lock&quot;</span> <span class="o">...</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>debería ser reescrito como</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Lock</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="o">...</span> <span class="n">do</span> <span class="n">something</span> <span class="n">using</span> <span class="s2">&quot;l&quot;</span> <span class="o">...</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">lock</span><span class="p">,))</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<p>Tenga cuidado de reemplazar <a class="reference internal" href="sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin</span></code></a> con un <em>«file like object»</em></p>
<blockquote>
<div><p><a class="reference internal" href="#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> original e incondicionalmente llamado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
</pre></div>
</div>
<p>en el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">multiprocessing.Process._bootstrap()</span></code> — Esto dio lugar a problemas con los procesos en proceso. Esto ha sido cambiado a:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">sys</span><span class="o">.</span><span class="n">stdin</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">devnull</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">O_RDONLY</span><span class="p">),</span> <span class="n">closefd</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Lo que resuelve el problema fundamental de los procesos que chocan entre sí dando como resultado un error de descriptor de archivo incorrecto, pero presenta un peligro potencial para las aplicaciones que reemplazan <a class="reference internal" href="sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.stdin()</span></code></a> con un «objeto similar a un archivo» con almacenamiento en búfer de salida. Este peligro es que si varios procesos invocan <a class="reference internal" href="io.html#io.IOBase.close" title="io.IOBase.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> en este objeto similar a un archivo, podría ocasionar que los mismos datos se vacíen al objeto varias veces, lo que provocaría corrupción.</p>
<p>Si escribe un objeto similar a un archivo e implementa su propio almacenamiento en caché, puede hacer que sea seguro para la bifurcación (<em>fork-safe</em>) almacenando el pid cada vez que se agrega al caché y descartando el caché cuando cambia el pid. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@property</span>
<span class="k">def</span> <span class="nf">cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">pid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">pid</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pid</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pid</span> <span class="o">=</span> <span class="n">pid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span>
</pre></div>
</div>
<p>Para más información, consulte <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5155">bpo-5155</a>, <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5313">bpo-5313</a> y <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5331">bpo-5331</a></p>
</div></blockquote>
</section>
<section id="the-spawn-and-forkserver-start-methods">
<h3>Los métodos de inicio <em>spawn</em> y <em>forkserver</em><a class="headerlink" href="#the-spawn-and-forkserver-start-methods" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Hay algunas restricciones adicionales que no se aplican al método de inicio <em>fork</em>.</p>
<p>Más serialización (<em>pickability</em>)</p>
<blockquote>
<div><p>Asegúrese de que todos los argumentos para <code class="xref py py-meth docutils literal notranslate"><span class="pre">Process.__init__()</span></code> sean serializables (<em>picklable</em>). Además, si la subclase es <a class="reference internal" href="#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> asegúrese de que las instancias serán serializables cuando se llame al método <a class="reference internal" href="#multiprocessing.Process.start" title="multiprocessing.Process.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Process.start</span></code></a>.</p>
</div></blockquote>
<p>Variables globales</p>
<blockquote>
<div><p>Tenga en cuenta que si el código que se ejecuta en un proceso secundario intenta acceder a una variable global, entonces el valor que ve (si lo hay) puede no ser el mismo que el valor en el proceso primario en el momento en que fue llamado <a class="reference internal" href="#multiprocessing.Process.start" title="multiprocessing.Process.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Process.start</span></code></a>.</p>
<p>Sin embargo, las variables globales que son solo constantes de nivel de módulo no causan problemas.</p>
</div></blockquote>
<p id="multiprocessing-safe-main-import">Importando de manera segura el módulo principal</p>
<blockquote>
<div><p>Asegúrese de que un nuevo intérprete de Python pueda importar de forma segura el módulo principal sin causar efectos secundarios no deseados (como comenzar un nuevo proceso).</p>
<p>Por ejemplo, usando el método de inicio <em>spawn</em> o <em>forkserver</em> ejecutando este módulo fallaría produciendo <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">foo</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>En su lugar, se debe proteger el «punto de entrada» (<em>«entry point»</em>) del programa utilizando como sigue <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__':</span></code></p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">freeze_support</span><span class="p">,</span> <span class="n">set_start_method</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">freeze_support</span><span class="p">()</span>
    <span class="n">set_start_method</span><span class="p">(</span><span class="s1">&#39;spawn&#39;</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">foo</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
<p>(La línea <code class="docutils literal notranslate"><span class="pre">freeze_support()</span></code> puede omitirse si el programa se ejecuta normalmente en lugar de congelarse).</p>
<p>Esto permite que el intérprete de Python recién generado importe de forma segura el módulo y luego ejecute la función del módulo <code class="docutils literal notranslate"><span class="pre">foo()</span></code>.</p>
<p>Se aplican restricciones similares si se crea un grupo o administrador en el módulo principal.</p>
</div></blockquote>
</section>
</section>
<section id="examples">
<span id="multiprocessing-examples"></span><h2>Ejemplos<a class="headerlink" href="#examples" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Demostración de cómo crear y usar gerentes y proxies personalizados:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">freeze_support</span>
<span class="kn">from</span> <span class="nn">multiprocessing.managers</span> <span class="kn">import</span> <span class="n">BaseManager</span><span class="p">,</span> <span class="n">BaseProxy</span>
<span class="kn">import</span> <span class="nn">operator</span>

<span class="c1">##</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;you called Foo.f()&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;you called Foo.g()&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_h</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;you called Foo._h()&#39;</span><span class="p">)</span>

<span class="c1"># A simple generator function</span>
<span class="k">def</span> <span class="nf">baz</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span>

<span class="c1"># Proxy type for generator objects</span>
<span class="k">class</span> <span class="nc">GeneratorProxy</span><span class="p">(</span><span class="n">BaseProxy</span><span class="p">):</span>
    <span class="n">_exposed_</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;__next__&#39;</span><span class="p">]</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callmethod</span><span class="p">(</span><span class="s1">&#39;__next__&#39;</span><span class="p">)</span>

<span class="c1"># Function to return the operator module</span>
<span class="k">def</span> <span class="nf">get_operator_module</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">operator</span>

<span class="c1">##</span>

<span class="k">class</span> <span class="nc">MyManager</span><span class="p">(</span><span class="n">BaseManager</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="c1"># register the Foo class; make `f()` and `g()` accessible via proxy</span>
<span class="n">MyManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;Foo1&#39;</span><span class="p">,</span> <span class="n">Foo</span><span class="p">)</span>

<span class="c1"># register the Foo class; make `g()` and `_h()` accessible via proxy</span>
<span class="n">MyManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;Foo2&#39;</span><span class="p">,</span> <span class="n">Foo</span><span class="p">,</span> <span class="n">exposed</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;_h&#39;</span><span class="p">))</span>

<span class="c1"># register the generator function baz; use `GeneratorProxy` to make proxies</span>
<span class="n">MyManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="n">baz</span><span class="p">,</span> <span class="n">proxytype</span><span class="o">=</span><span class="n">GeneratorProxy</span><span class="p">)</span>

<span class="c1"># register get_operator_module(); make public functions accessible via proxy</span>
<span class="n">MyManager</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s1">&#39;operator&#39;</span><span class="p">,</span> <span class="n">get_operator_module</span><span class="p">)</span>

<span class="c1">##</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="n">manager</span> <span class="o">=</span> <span class="n">MyManager</span><span class="p">()</span>
    <span class="n">manager</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-&#39;</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>

    <span class="n">f1</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">Foo1</span><span class="p">()</span>
    <span class="n">f1</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
    <span class="n">f1</span><span class="o">.</span><span class="n">g</span><span class="p">()</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="s1">&#39;_h&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">f1</span><span class="o">.</span><span class="n">_exposed_</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">([</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">])</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-&#39;</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>

    <span class="n">f2</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">Foo2</span><span class="p">()</span>
    <span class="n">f2</span><span class="o">.</span><span class="n">g</span><span class="p">()</span>
    <span class="n">f2</span><span class="o">.</span><span class="n">_h</span><span class="p">()</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">f2</span><span class="o">.</span><span class="n">_exposed_</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">([</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;_h&#39;</span><span class="p">])</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-&#39;</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>

    <span class="n">it</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">baz</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&lt;</span><span class="si">%d</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-&#39;</span> <span class="o">*</span> <span class="mi">20</span><span class="p">)</span>

    <span class="n">op</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">operator</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;op.add(23, 45) =&#39;</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span> <span class="mi">45</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;op.pow(2, 94) =&#39;</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">94</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;op._exposed_ =&#39;</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">_exposed_</span><span class="p">)</span>

<span class="c1">##</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">freeze_support</span><span class="p">()</span>
    <span class="n">test</span><span class="p">()</span>
</pre></div>
</div>
<p>Usando <a class="reference internal" href="#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pool</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1">#</span>
<span class="c1"># Functions used by test code</span>
<span class="c1">#</span>

<span class="k">def</span> <span class="nf">calculate</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> says that </span><span class="si">%s%s</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
        <span class="n">multiprocessing</span><span class="o">.</span><span class="n">current_process</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
        <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">result</span>
        <span class="p">)</span>

<span class="k">def</span> <span class="nf">calculatestar</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">calculate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>

<span class="k">def</span> <span class="nf">plus</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mf">5.0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">pow3</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">3</span>

<span class="k">def</span> <span class="nf">noop</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="c1">#</span>
<span class="c1"># Test code</span>
<span class="c1">#</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="n">PROCESSES</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Creating pool with </span><span class="si">%d</span><span class="s1"> processes</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">PROCESSES</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">PROCESSES</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="c1">#</span>
        <span class="c1"># Tests</span>
        <span class="c1">#</span>

        <span class="n">TASKS</span> <span class="o">=</span> <span class="p">[(</span><span class="n">mul</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span> <span class="o">+</span> \
                <span class="p">[(</span><span class="n">plus</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">calculate</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">TASKS</span><span class="p">]</span>
        <span class="n">imap_it</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">calculatestar</span><span class="p">,</span> <span class="n">TASKS</span><span class="p">)</span>
        <span class="n">imap_unordered_it</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span><span class="p">(</span><span class="n">calculatestar</span><span class="p">,</span> <span class="n">TASKS</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Ordered results using pool.apply_async():&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Ordered results using pool.imap():&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">imap_it</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Unordered results using pool.imap_unordered():&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">imap_unordered_it</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Ordered results using pool.map() --- will block till complete:&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">calculatestar</span><span class="p">,</span> <span class="n">TASKS</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>

        <span class="c1">#</span>
        <span class="c1"># Test error handling</span>
        <span class="c1">#</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Testing error handling:&#39;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,)))</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Got ZeroDivisionError as expected from pool.apply()&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;expected ZeroDivisionError&#39;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))))</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Got ZeroDivisionError as expected from pool.map()&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;expected ZeroDivisionError&#39;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)))))</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Got ZeroDivisionError as expected from list(pool.imap())&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;expected ZeroDivisionError&#39;</span><span class="p">)</span>

        <span class="n">it</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;expected ZeroDivisionError&#39;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">9</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Got ZeroDivisionError as expected from IMapIterator.next()&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>

        <span class="c1">#</span>
        <span class="c1"># Testing timeouts</span>
        <span class="c1">#</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Testing ApplyResult.get() with timeout:&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">calculate</span><span class="p">,</span> <span class="n">TASKS</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\t</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mf">0.02</span><span class="p">))</span>
                <span class="k">break</span>
            <span class="k">except</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">TimeoutError</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Testing IMapIterator.next() with timeout:&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="n">it</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">calculatestar</span><span class="p">,</span> <span class="n">TASKS</span><span class="p">)</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\t</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="mf">0.02</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">except</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">TimeoutError</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">multiprocessing</span><span class="o">.</span><span class="n">freeze_support</span><span class="p">()</span>
    <span class="n">test</span><span class="p">()</span>
</pre></div>
</div>
<p>Un ejemplo que muestra cómo usar las colas para alimentar tareas a una colección de procesos de trabajo y recopilar los resultados:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Queue</span><span class="p">,</span> <span class="n">current_process</span><span class="p">,</span> <span class="n">freeze_support</span>

<span class="c1">#</span>
<span class="c1"># Function run by worker processes</span>
<span class="c1">#</span>

<span class="k">def</span> <span class="nf">worker</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="s1">&#39;STOP&#39;</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">calculate</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># Function used to calculate result</span>
<span class="c1">#</span>

<span class="k">def</span> <span class="nf">calculate</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> says that </span><span class="si">%s%s</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> \
        <span class="p">(</span><span class="n">current_process</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># Functions referenced by tasks</span>
<span class="c1">#</span>

<span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>

<span class="k">def</span> <span class="nf">plus</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="n">NUMBER_OF_PROCESSES</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">TASKS1</span> <span class="o">=</span> <span class="p">[(</span><span class="n">mul</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)]</span>
    <span class="n">TASKS2</span> <span class="o">=</span> <span class="p">[(</span><span class="n">plus</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>

    <span class="c1"># Create queues</span>
    <span class="n">task_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="n">done_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

    <span class="c1"># Submit tasks</span>
    <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">TASKS1</span><span class="p">:</span>
        <span class="n">task_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

    <span class="c1"># Start worker processes</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NUMBER_OF_PROCESSES</span><span class="p">):</span>
        <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">worker</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">task_queue</span><span class="p">,</span> <span class="n">done_queue</span><span class="p">))</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="c1"># Get and print results</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Unordered results:&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">TASKS1</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">done_queue</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>

    <span class="c1"># Add more tasks using `put()`</span>
    <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">TASKS2</span><span class="p">:</span>
        <span class="n">task_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

    <span class="c1"># Get and print some more results</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">TASKS2</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">done_queue</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>

    <span class="c1"># Tell child processes to stop</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NUMBER_OF_PROCESSES</span><span class="p">):</span>
        <span class="n">task_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;STOP&#39;</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">freeze_support</span><span class="p">()</span>
    <span class="n">test</span><span class="p">()</span>
</pre></div>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code> — Paralelismo basado en procesos</a><ul>
<li><a class="reference internal" href="#introduction">Introducción</a><ul>
<li><a class="reference internal" href="#the-process-class">La clase <code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a></li>
<li><a class="reference internal" href="#contexts-and-start-methods">Contextos y métodos de inicio</a></li>
<li><a class="reference internal" href="#exchanging-objects-between-processes">Intercambiando objetos entre procesos</a></li>
<li><a class="reference internal" href="#synchronization-between-processes">Sincronización entre procesos</a></li>
<li><a class="reference internal" href="#sharing-state-between-processes">Compartiendo estado entre procesos</a></li>
<li><a class="reference internal" href="#using-a-pool-of-workers">Usando una piscina de trabajadores (<em>pool of workers</em>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference">Referencia</a><ul>
<li><a class="reference internal" href="#process-and-exceptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code> y excepciones</a></li>
<li><a class="reference internal" href="#pipes-and-queues">Tuberías (<em>Pipes</em>) y Colas (<em>Queues</em>)</a></li>
<li><a class="reference internal" href="#miscellaneous">Miscelánea</a></li>
<li><a class="reference internal" href="#connection-objects">Objetos de conexión <em>Connection Objects</em></a></li>
<li><a class="reference internal" href="#synchronization-primitives">Primitivas de sincronización (<em>Synchronization primitives</em>)</a></li>
<li><a class="reference internal" href="#shared-ctypes-objects">Objetos compartidos <code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a><ul>
<li><a class="reference internal" href="#module-multiprocessing.sharedctypes">El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing.sharedctypes</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#managers">Administradores (<em>Managers</em>)</a><ul>
<li><a class="reference internal" href="#customized-managers">Administradores customizables (<em>Customized managers</em>)</a></li>
<li><a class="reference internal" href="#using-a-remote-manager">Utilizando un administrador remoto</a></li>
</ul>
</li>
<li><a class="reference internal" href="#proxy-objects">Objetos Proxy (<em>Proxy Objects</em>)</a><ul>
<li><a class="reference internal" href="#cleanup">Limpieza (<em>Cleanup</em>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-multiprocessing.pool">Piscinas de procesos (<em>Process Pools</em>)</a></li>
<li><a class="reference internal" href="#module-multiprocessing.connection">Oyentes y clientes (<em>Listeners and Clients</em>)</a><ul>
<li><a class="reference internal" href="#address-formats">Formatos de dirección (<em>Address formats</em>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#authentication-keys">Llaves de autentificación</a></li>
<li><a class="reference internal" href="#logging"><em>Logging</em></a></li>
<li><a class="reference internal" href="#module-multiprocessing.dummy">El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing.dummy</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#programming-guidelines">Pautas de programación</a><ul>
<li><a class="reference internal" href="#all-start-methods">Todos los métodos de inicio</a></li>
<li><a class="reference internal" href="#the-spawn-and-forkserver-start-methods">Los métodos de inicio <em>spawn</em> y <em>forkserver</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Ejemplos</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="threading.html"
                          title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code> — Paralelismo basado en hilos</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="multiprocessing.shared_memory.html"
                          title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing.shared_memory</span></code> — Shared memory for direct access across processes</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/library/multiprocessing.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="multiprocessing.shared_memory.html" title="multiprocessing.shared_memory — Shared memory for direct access across processes"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="threading.html" title="threading — Paralelismo basado en hilos"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="concurrency.html" >Ejecución concurrente</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code> — Paralelismo basado en procesos</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 23, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>