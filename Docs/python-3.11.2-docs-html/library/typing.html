
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="typing — Soporte para type hints" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/typing.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Source code: Lib/typing.py Este módulo entrega soporte en tiempo de ejecución para indicadores de tipo. El soporte fundamental se encuentra en los tipos Any, Union, Callable, TypeVar, y Generic. Pa..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Source code: Lib/typing.py Este módulo entrega soporte en tiempo de ejecución para indicadores de tipo. El soporte fundamental se encuentra en los tipos Any, Union, Callable, TypeVar, y Generic. Pa..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>typing — Soporte para type hints &#8212; documentación de Python - 3.11.2</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=2d3badd06fe70b34b68db01f99471ce1624ffe4a" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.11.2"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="pydoc — Generador de documentación y Sistema de ayuda en línea" href="pydoc.html" />
    <link rel="prev" title="Herramientas de desarrollo" href="development.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/typing.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> — Soporte para <em>type hints</em></a><ul>
<li><a class="reference internal" href="#relevant-peps">PEPs relevantes</a></li>
<li><a class="reference internal" href="#type-aliases">Alias de tipo</a></li>
<li><a class="reference internal" href="#newtype">NewType</a></li>
<li><a class="reference internal" href="#callable">Callable</a></li>
<li><a class="reference internal" href="#generics">Genéricos</a></li>
<li><a class="reference internal" href="#user-defined-generic-types">Tipos genéricos definidos por el usuario</a></li>
<li><a class="reference internal" href="#the-any-type">El tipo <code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a></li>
<li><a class="reference internal" href="#nominal-vs-structural-subtyping">Subtipado nominal vs estructural</a></li>
<li><a class="reference internal" href="#module-contents">Contenido del módulo</a><ul>
<li><a class="reference internal" href="#special-typing-primitives">Primitivos especiales de tipado</a><ul>
<li><a class="reference internal" href="#special-types">Tipos especiales</a></li>
<li><a class="reference internal" href="#special-forms">Formas especiales</a></li>
<li><a class="reference internal" href="#building-generic-types">Construir tipos genéricos</a></li>
<li><a class="reference internal" href="#other-special-directives">Otras directivas especiales</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generic-concrete-collections">Colecciones genéricas concretas</a><ul>
<li><a class="reference internal" href="#corresponding-to-built-in-types">Correspondientes a tipos integrados</a></li>
<li><a class="reference internal" href="#corresponding-to-types-in-collections">Correspondiente a tipos en <code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a></li>
<li><a class="reference internal" href="#other-concrete-types">Otros tipos concretos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#abstract-base-classes">Clase base abstracta para tipos genéricos</a><ul>
<li><a class="reference internal" href="#corresponding-to-collections-in-collections-abc">Correspondientes a las colecciones en <code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a></li>
<li><a class="reference internal" href="#corresponding-to-other-types-in-collections-abc">Correspondiente a otros tipos en <code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a></li>
<li><a class="reference internal" href="#asynchronous-programming">Programación asíncrona</a></li>
<li><a class="reference internal" href="#context-manager-types">Tipos del administrador de contextos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#protocols">Protocolos</a></li>
<li><a class="reference internal" href="#functions-and-decorators">Funciones y decoradores</a></li>
<li><a class="reference internal" href="#introspection-helpers">Ayudas de introspección</a></li>
<li><a class="reference internal" href="#constant">Constantes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deprecation-timeline-of-major-features">Línea de tiempo de obsolescencia de características principales</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="development.html"
                          title="capítulo anterior">Herramientas de desarrollo</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="pydoc.html"
                          title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code> — Generador de documentación y Sistema de ayuda en línea</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/library/typing.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="pydoc.html" title="pydoc — Generador de documentación y Sistema de ayuda en línea"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="development.html" title="Herramientas de desarrollo"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" accesskey="U">Herramientas de desarrollo</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> — Soporte para <em>type hints</em></a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-typing">
<span id="typing-support-for-type-hints"></span><h1><a class="reference internal" href="#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> — Soporte para <em>type hints</em><a class="headerlink" href="#module-typing" title="Enlazar permanentemente con este título">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
<p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.11/Lib/typing.py">Lib/typing.py</a></p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En tiempo de ejecución, Python no impone las anotaciones de tipado en funciones y variables. Pueden ser utilizadas por herramientas de terceros como validadores de tipado, IDEs, linters, etc.</p>
</div>
<hr class="docutils" />
<p>Este módulo entrega soporte en tiempo de ejecución para indicadores de tipo. El soporte fundamental se encuentra en los tipos <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>, <a class="reference internal" href="#typing.Union" title="typing.Union"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code></a>, <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a>, <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>, y <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>. Para una especificación completa, por favor ver <span class="target" id="index-182"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>. Para una introducción simplificada a los indicadores de tipo, véase <span class="target" id="index-183"></span><a class="pep reference external" href="https://peps.python.org/pep-0483/"><strong>PEP 483</strong></a>.</p>
<p>La siguiente función toma y retorna una cadena de texto, que se anota de la siguiente manera:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">greeting</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s1">&#39;Hello &#39;</span> <span class="o">+</span> <span class="n">name</span>
</pre></div>
</div>
<p>En la función <code class="docutils literal notranslate"><span class="pre">greeting</span></code>, se espera que el argumento <code class="docutils literal notranslate"><span class="pre">name</span></code>  sea de tipo <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> y que el tipo retornado sea <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>. Los subtipos también son aceptados como argumento válido.</p>
<p>Frecuentemente se agregan nuevas funcionalidades al módulo <code class="docutils literal notranslate"><span class="pre">typing</span></code>. El paquete <a class="reference external" href="https://pypi.org/project/typing-extensions/">typing_extensions</a> provee backports de estas nuevas funcionalidades para versiones más antiguas de Python.</p>
<p>For a summary of deprecated features and a deprecation timeline, please see
<a class="reference internal" href="#deprecation-timeline-of-major-features">Deprecation Timeline of Major Features</a>.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>La documentación en <a class="reference external" href="https://typing.readthedocs.io/">https://typing.readthedocs.io/</a> es una referencia útil sobre características de sistemas de tipos, herramientas útiles relativas al tipado, y mejores prácticas de tipado.</p>
</div>
<section id="relevant-peps">
<span id="id1"></span><h2>PEPs relevantes<a class="headerlink" href="#relevant-peps" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Desde la introducción inicial de los indicadores de tipo en <span class="target" id="index-184"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> y <span class="target" id="index-185"></span><a class="pep reference external" href="https://peps.python.org/pep-0483/"><strong>PEP 483</strong></a>, un número de PEPs han modificado y mejorado el sistema de anotaciones de tipos de Python. Éstos incluyen:</p>
<ul class="simple">
<li><dl class="simple">
<dt><span class="target" id="index-186"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a>: Sintaxis para anotaciones de variables</dt><dd><p><em>Introduce</em> sintaxis para anotar variables fuera de definiciones de funciones, y <a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-187"></span><a class="pep reference external" href="https://peps.python.org/pep-0544/"><strong>PEP 544</strong></a>: Protocolos: herencia estructural («duck typing» estático)</dt><dd><p><em>Introduce</em> <a class="reference internal" href="#typing.Protocol" title="typing.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> y el decorador <a class="reference internal" href="#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;runtime_checkable</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-188"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a>: Indicadores de tipo genéricos en las colecciones estándar</dt><dd><p><em>Introduce</em> <a class="reference internal" href="types.html#types.GenericAlias" title="types.GenericAlias"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.GenericAlias</span></code></a> y la habilidad de utilizar clases de la librería estándar como <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">tipos genéricos</span></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-189"></span><a class="pep reference external" href="https://peps.python.org/pep-0586/"><strong>PEP 586</strong></a>: Tipos literales</dt><dd><p><em>Introduce</em> <a class="reference internal" href="#typing.Literal" title="typing.Literal"><code class="xref py py-data docutils literal notranslate"><span class="pre">Literal</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-190"></span><a class="pep reference external" href="https://peps.python.org/pep-0589/"><strong>PEP 589</strong></a>: TypedDict: Indicadores de tipo para diccionarios con un conjunto de llaves fijo</dt><dd><p><em>Introduce</em> <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-191"></span><a class="pep reference external" href="https://peps.python.org/pep-0591/"><strong>PEP 591</strong></a>: Agregar un cualificador final a typing</dt><dd><p><em>Introduce</em> <a class="reference internal" href="#typing.Final" title="typing.Final"><code class="xref py py-data docutils literal notranslate"><span class="pre">Final</span></code></a> y el decorador <a class="reference internal" href="#typing.final" title="typing.final"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;final</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-192"></span><a class="pep reference external" href="https://peps.python.org/pep-0593/"><strong>PEP 593</strong></a>: Anotaciones flexibles para funciones y variables</dt><dd><p><em>Introduce</em> <a class="reference internal" href="#typing.Annotated" title="typing.Annotated"><code class="xref py py-data docutils literal notranslate"><span class="pre">Annotated</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-193"></span><a class="pep reference external" href="https://peps.python.org/pep-0604/"><strong>PEP 604</strong></a>: Permitir la escritura de tipos unión como <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">Y</span></code></dt><dd><p><em>Introduce</em> <a class="reference internal" href="types.html#types.UnionType" title="types.UnionType"><code class="xref py py-data docutils literal notranslate"><span class="pre">types.UnionType</span></code></a> y la habilidad de usar el operador binario de disyunción <code class="docutils literal notranslate"><span class="pre">|</span></code> para significar una <a class="reference internal" href="stdtypes.html#types-union"><span class="std std-ref">unión de tipos</span></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-194"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a>: Variables de especificación de parámetros</dt><dd><p><em>Introduce</em> <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> y <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-195"></span><a class="pep reference external" href="https://peps.python.org/pep-0613/"><strong>PEP 613</strong></a>: Alias de tipo explícitos</dt><dd><p><em>Introduce</em> <a class="reference internal" href="#typing.TypeAlias" title="typing.TypeAlias"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeAlias</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-196"></span><a class="pep reference external" href="https://peps.python.org/pep-0646/"><strong>PEP 646</strong></a>: Genéricos variádicos</dt><dd><p><em>Introduce</em> <a class="reference internal" href="#typing.TypeVarTuple" title="typing.TypeVarTuple"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeVarTuple</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-197"></span><a class="pep reference external" href="https://peps.python.org/pep-0647/"><strong>PEP 647</strong></a>: Protecciones de tipo definidas por le usuarie</dt><dd><p><em>Introduce</em> <a class="reference internal" href="#typing.TypeGuard" title="typing.TypeGuard"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeGuard</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-198"></span><a class="pep reference external" href="https://peps.python.org/pep-0655/"><strong>PEP 655</strong></a>: Marcar elementos individuales de un TypedDict como requeridos o potencialmente ausentes</dt><dd><p><em>Introduce</em> <a class="reference internal" href="#typing.Required" title="typing.Required"><code class="xref py py-data docutils literal notranslate"><span class="pre">Required</span></code></a> y <a class="reference internal" href="#typing.NotRequired" title="typing.NotRequired"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotRequired</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-199"></span><a class="pep reference external" href="https://peps.python.org/pep-0673/"><strong>PEP 673</strong></a>: Tipo Self</dt><dd><p><em>Introduce</em> <a class="reference internal" href="#typing.Self" title="typing.Self"><code class="xref py py-data docutils literal notranslate"><span class="pre">Self</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-200"></span><a class="pep reference external" href="https://peps.python.org/pep-0675/"><strong>PEP 675</strong></a>: Tipo para cadenas de caracteres literales arbitrarias</dt><dd><p><em>Introduce</em> <a class="reference internal" href="#typing.LiteralString" title="typing.LiteralString"><code class="xref py py-data docutils literal notranslate"><span class="pre">LiteralString</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><span class="target" id="index-19"></span><a class="pep reference external" href="https://peps.python.org/pep-0681/"><strong>PEP 681</strong></a>: Data Class Transforms</dt><dd><p><em>Introduce</em> el decorador <a class="reference internal" href="#typing.dataclass_transform" title="typing.dataclass_transform"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;dataclass_transform</span></code></a></p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="type-aliases">
<span id="id2"></span><h2>Alias de tipo<a class="headerlink" href="#type-aliases" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Un alias de tipo se define asignando el tipo al alias. En este ejemplo, <code class="docutils literal notranslate"><span class="pre">Vector</span></code> y <code class="docutils literal notranslate"><span class="pre">List[float]</span></code> serán tratados como sinónimos intercambiables:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Vector</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="n">scalar</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">vector</span><span class="p">:</span> <span class="n">Vector</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">scalar</span> <span class="o">*</span> <span class="n">num</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">vector</span><span class="p">]</span>

<span class="c1"># passes type checking; a list of floats qualifies as a Vector.</span>
<span class="n">new_vector</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.2</span><span class="p">,</span> <span class="mf">5.4</span><span class="p">])</span>
</pre></div>
</div>
<p>Los alias de tipo son útiles para simplificar firmas de tipo complejas. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span>

<span class="n">ConnectionOptions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">Address</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="n">Server</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Address</span><span class="p">,</span> <span class="n">ConnectionOptions</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">broadcast_message</span><span class="p">(</span><span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">servers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Server</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># The static type checker will treat the previous type signature as</span>
<span class="c1"># being exactly equivalent to this one.</span>
<span class="k">def</span> <span class="nf">broadcast_message</span><span class="p">(</span>
        <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">servers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Nótese que <code class="docutils literal notranslate"><span class="pre">None</span></code> como indicador de tipo es un caso especial y es substituido por <code class="docutils literal notranslate"><span class="pre">type(None)</span></code>.</p>
</section>
<section id="newtype">
<span id="distinct"></span><h2>NewType<a class="headerlink" href="#newtype" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Utilícese la clase auxiliar <a class="reference internal" href="#typing.NewType" title="typing.NewType"><code class="xref py py-class docutils literal notranslate"><span class="pre">NewType</span></code></a> para crear tipos distintos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">some_id</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">524313</span><span class="p">)</span>
</pre></div>
</div>
<p>El validador estático de tipos tratará el nuevo tipo como si fuera una subclase del tipo original. Esto es útil para capturar errores lógicos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_user_name</span><span class="p">(</span><span class="n">user_id</span><span class="p">:</span> <span class="n">UserId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># passes type checking</span>
<span class="n">user_a</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="n">UserId</span><span class="p">(</span><span class="mi">42351</span><span class="p">))</span>

<span class="c1"># fails type checking; an int is not a UserId</span>
<span class="n">user_b</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Se pueden realizar todas las operaciones de <code class="docutils literal notranslate"><span class="pre">int</span></code> en una variable de tipo <code class="docutils literal notranslate"><span class="pre">UserId</span></code>, pero el resultado siempre será de tipo <code class="docutils literal notranslate"><span class="pre">int</span></code>. Esto permite pasar un <code class="docutils literal notranslate"><span class="pre">UserId</span></code> allí donde se espere un <code class="docutils literal notranslate"><span class="pre">int</span></code>, pero evitará la creación accidental de un <code class="docutils literal notranslate"><span class="pre">UserId</span></code> de manera incorrecta:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># &#39;output&#39; is of type &#39;int&#39;, not &#39;UserId&#39;</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">23413</span><span class="p">)</span> <span class="o">+</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">54341</span><span class="p">)</span>
</pre></div>
</div>
<p>Tenga en cuenta que estas validaciones solo las aplica el verificador de tipo estático. En tiempo de ejecución, la declaración <code class="docutils literal notranslate"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived',</span> <span class="pre">Base)</span></code> hará que <code class="docutils literal notranslate"><span class="pre">Derived</span></code> sea una clase que retorna inmediatamente cualquier parámetro que le pase. Eso significa que la expresión <code class="docutils literal notranslate"><span class="pre">Derived(some_value)</span></code> no crea una nueva clase ni introduce mucha sobrecarga más allá de la de una llamada de función regular.</p>
<p>Más concretamente, la expresión <code class="docutils literal notranslate"><span class="pre">some_value</span> <span class="pre">is</span> <span class="pre">Derived(some_value)</span></code> será siempre verdadera en tiempo de ejecución.</p>
<p>No es válido crear un subtipo de <code class="docutils literal notranslate"><span class="pre">Derived</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="c1"># Fails at runtime and does not pass type checking</span>
<span class="k">class</span> <span class="nc">AdminUserId</span><span class="p">(</span><span class="n">UserId</span><span class="p">):</span> <span class="k">pass</span>
</pre></div>
</div>
<p>Sin embargo, es posible crear un <a class="reference internal" href="#typing.NewType" title="typing.NewType"><code class="xref py py-class docutils literal notranslate"><span class="pre">NewType</span></code></a> basado en un <code class="docutils literal notranslate"><span class="pre">NewType</span></code> “derivado”:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="n">ProUserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;ProUserId&#39;</span><span class="p">,</span> <span class="n">UserId</span><span class="p">)</span>
</pre></div>
</div>
<p>y la comprobación de tipo para <code class="docutils literal notranslate"><span class="pre">ProUserId</span></code> funcionará como se espera.</p>
<p>Véase <span class="target" id="index-201"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> para más detalle.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Recuérdese que el uso de alias de tipo implica que los dos tipos son <em>equivalentes</em> entre sí. Haciendo <code class="docutils literal notranslate"><span class="pre">Alias</span> <span class="pre">=</span> <span class="pre">Original</span></code> provocará que el Validador estático de tipos trate <code class="docutils literal notranslate"><span class="pre">Alias</span></code> como algo <em>exactamente equivalente</em> a <code class="docutils literal notranslate"><span class="pre">Original</span></code> en todos los casos. Esto es útil para cuando se quiera simplificar indicadores de tipo complejos.</p>
<p>En cambio, <code class="docutils literal notranslate"><span class="pre">NewType</span></code> declara un tipo que es <em>subtipo</em> de otro. Haciendo <code class="docutils literal notranslate"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived',</span> <span class="pre">Original)</span></code> hará que el Validador estático de tipos trate <code class="docutils literal notranslate"><span class="pre">Derived</span></code> como una <em>subclase</em> de <code class="docutils literal notranslate"><span class="pre">Original</span></code>, lo que implica que un valor de tipo <code class="docutils literal notranslate"><span class="pre">Original</span></code> no puede ser usado allí donde se espere un valor de tipo <code class="docutils literal notranslate"><span class="pre">Derived</span></code>. Esto es útil para prevenir errores lógicos con un coste de ejecución mínimo.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span><code class="docutils literal notranslate"><span class="pre">NewType</span></code> es ahora una clase en lugar de una función. Existe un costo de tiempo de ejecución adicional cuando se llama a <code class="docutils literal notranslate"><span class="pre">NewType</span></code> a través de una función normal. Sin embargo, este costo se reducirá en 3.11.0.</p>
</div>
</section>
<section id="callable">
<h2>Callable<a class="headerlink" href="#callable" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Entidades que esperen llamadas a funciones con interfaces específicas puede ser anotadas usando <code class="docutils literal notranslate"><span class="pre">Callable[[Arg1Type,</span> <span class="pre">Arg2Type],</span> <span class="pre">ReturnType]</span></code>.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span>

<span class="k">def</span> <span class="nf">feeder</span><span class="p">(</span><span class="n">get_next_item</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Body</span>

<span class="k">def</span> <span class="nf">async_query</span><span class="p">(</span><span class="n">on_success</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span>
                <span class="n">on_error</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Body</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">on_update</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Body</span>
<span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Awaitable</span><span class="p">[</span><span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="n">on_update</span>
</pre></div>
</div>
<p>Es posible declarar el tipo de retorno de un <em>callable</em> (invocable) sin especificar tipos en los parámetros substituyendo la lista de argumentos por unos puntos suspensivos (…) en el indicador de tipo: <code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">ReturnType]</span></code>.</p>
<p>Los invocables que toman otros invocables como argumentos pueden indicar que sus tipos de parámetros dependen unos de otros utilizando <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a>. Además, si ese invocable agrega o elimina argumentos de otros invocables, se puede utilizar el operador <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a>. Toman la forma <code class="docutils literal notranslate"><span class="pre">Callable[ParamSpecVariable,</span> <span class="pre">ReturnType]</span></code> y <code class="docutils literal notranslate"><span class="pre">Callable[Concatenate[Arg1Type,</span> <span class="pre">Arg2Type,</span> <span class="pre">...,</span> <span class="pre">ParamSpecVariable],</span> <span class="pre">ReturnType]</span></code> respectivamente.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span><code class="docutils literal notranslate"><span class="pre">Callable</span></code> ahora es compatible con <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> y <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a>. Consulte <span class="target" id="index-202"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a> para obtener más información.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>La documentación de <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> y <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Concatenate</span></code></a> proporciona ejemplos de uso en <code class="docutils literal notranslate"><span class="pre">Callable</span></code>.</p>
</div>
</section>
<section id="generics">
<span id="id3"></span><h2>Genéricos<a class="headerlink" href="#generics" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Ya que no es posible inferir estáticamente y de una manera genérica la información de tipo de objetos dentro de contenedores, las clases base abstractas han sido mejoradas para permitir sintaxis de subíndice para denotar los tipos esperados en elementos contenedores.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="k">def</span> <span class="nf">notify_by_email</span><span class="p">(</span><span class="n">employees</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Employee</span><span class="p">],</span>
                    <span class="n">overrides</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>Los genéricos se pueden parametrizar usando una nueva <em>factory</em> disponible en <em>typing</em> llamada <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>      <span class="c1"># Declare type variable</span>

<span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>   <span class="c1"># Generic function</span>
    <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="user-defined-generic-types">
<span id="user-defined-generics"></span><h2>Tipos genéricos definidos por el usuario<a class="headerlink" href="#user-defined-generic-types" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Una clase definida por el usuario puede ser definida como una clase genérica.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="kn">from</span> <span class="nn">logging</span> <span class="kn">import</span> <span class="n">Logger</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LoggedVar</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">logger</span><span class="p">:</span> <span class="n">Logger</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Set &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">new</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Get &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Generic[T]</span></code> como clase base define que la clase <code class="docutils literal notranslate"><span class="pre">LoggedVar</span></code> toma un solo parámetro <code class="docutils literal notranslate"><span class="pre">T</span></code>. Esto también implica que <code class="docutils literal notranslate"><span class="pre">T</span></code> es un tipo válido dentro del cuerpo de la clase.</p>
<p>La clase base <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> define <code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> para que <code class="docutils literal notranslate"><span class="pre">LoggedVar[T]</span></code> sea válido como tipo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>

<span class="k">def</span> <span class="nf">zero_all_vars</span><span class="p">(</span><span class="nb">vars</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">LoggedVar</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="n">var</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Un tipo genérico puede tener un numero cualquiera de variables de tipo. Se permiten todas las variaciones de <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> para ser usadas como parámetros de un tipo genérico:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">contravariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">bytes</span><span class="p">],</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">WeirdTrio</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">S</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Cada argumento de variable de tipo en una clase <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> debe ser distinto. Así, no será válido:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Pair</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>   <span class="c1"># INVALID</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Se puede utilizar herencia múltiple con <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sized</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LinkedList</span><span class="p">(</span><span class="n">Sized</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Cuando se hereda de clases genéricas, se pueden fijar algunas variables de tipo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MyDict</span><span class="p">(</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>En este caso <code class="docutils literal notranslate"><span class="pre">MyDict</span></code> tiene un solo parámetro, <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<p>Al usar una clase genérica sin especificar parámetros de tipo se asume <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> para todas las posiciones. En el siguiente ejemplo, <code class="docutils literal notranslate"><span class="pre">MyIterable</span></code> no es genérico pero hereda implícitamente de <code class="docutils literal notranslate"><span class="pre">Iterable[Any]</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>

<span class="k">class</span> <span class="nc">MyIterable</span><span class="p">(</span><span class="n">Iterable</span><span class="p">):</span> <span class="c1"># Same as Iterable[Any]</span>
</pre></div>
</div>
<p>Son posibles los alias de tipos genéricos definidos por el usuario. Ejemplos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">)</span>
<span class="n">Response</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">S</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span>

<span class="c1"># Return type here is same as Iterable[str] | int</span>
<span class="k">def</span> <span class="nf">response</span><span class="p">(</span><span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Response</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)</span>
<span class="n">Vec</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]]</span>

<span class="k">def</span> <span class="nf">inproduct</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="c1"># Same as Iterable[tuple[T, T]]</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> ya no posee una metaclase personalizable.</p>
</div>
<p>Los genéricos definidos por el usuario para expresiones de parámetros también se admiten a través de variables de especificación de parámetros con el formato <code class="docutils literal notranslate"><span class="pre">Generic[P]</span></code>. El comportamiento es coherente con las variables de tipo descritas anteriormente, ya que el módulo typing trata las variables de especificación de parámetros como una variable de tipo especializada. La única excepción a esto es que se puede usar una lista de tipos para sustituir un <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">ParamSpec</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Z</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">P</span><span class="p">]):</span> <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Z</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span>
<span class="go">__main__.Z[int, (&lt;class &#39;dict&#39;&gt;, &lt;class &#39;float&#39;&gt;)]</span>
</pre></div>
</div>
<p>Además, un genérico con una sola variable de especificación de parámetro aceptará listas de parámetros en los formatos <code class="docutils literal notranslate"><span class="pre">X[[Type1,</span> <span class="pre">Type2,</span> <span class="pre">...]]</span></code> y también <code class="docutils literal notranslate"><span class="pre">X[Type1,</span> <span class="pre">Type2,</span> <span class="pre">...]</span></code> por razones estéticas. Internamente, este último se convierte en el primero y, por lo tanto, son equivalentes:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">P</span><span class="p">]):</span> <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="go">__main__.X[(&lt;class &#39;int&#39;&gt;, &lt;class &#39;str&#39;&gt;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span>
<span class="go">__main__.X[(&lt;class &#39;int&#39;&gt;, &lt;class &#39;str&#39;&gt;)]</span>
</pre></div>
</div>
<p>Téngase presente que los genéricos con <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> pueden no tener el <code class="docutils literal notranslate"><span class="pre">__parameters__</span></code> correcto después de la sustitución en algunos casos porque están destinados principalmente a la verificación de tipos estáticos.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> ahora se puede parametrizar sobre expresiones de parámetros. Consulte <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> y <span class="target" id="index-203"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a> para obtener más detalles.</p>
</div>
<p>A user-defined generic class can have ABCs as base classes without a metaclass
conflict. Generic metaclasses are not supported. The outcome of parameterizing
generics is cached, and most types in the typing module are <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> and
comparable for equality.</p>
</section>
<section id="the-any-type">
<h2>El tipo <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a><a class="headerlink" href="#the-any-type" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Un caso especial de tipo es <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>. Un Validador estático de tipos tratará cualquier tipo como compatible con <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>, y <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> como compatible con todos los tipos.</p>
<p>Esto significa que es posible realizar cualquier operación o llamada a un método en un valor de tipo <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> y asignarlo a cualquier variable:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span>

<span class="n">a</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>          <span class="c1"># OK</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>           <span class="c1"># OK</span>

<span class="n">s</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">a</span>           <span class="c1"># OK</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Passes type checking; &#39;item&#39; could be any type,</span>
    <span class="c1"># and that type might have a &#39;bar&#39; method</span>
    <span class="n">item</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Nótese que no se realiza comprobación de tipo cuando se asigna un valor de tipo <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> a un tipo más preciso. Por ejemplo, el Validador estático de tipos no reportó ningún error cuando se asignó <code class="docutils literal notranslate"><span class="pre">a</span></code> a <code class="docutils literal notranslate"><span class="pre">s</span></code>, aún cuando se declaró <code class="docutils literal notranslate"><span class="pre">s</span></code> como de tipo <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> y recibió un valor <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> en tiempo de ejecución!</p>
<p>Además, todas las funciones sin un tipo de retorno o tipos en los parámetros serán asignadas implícitamente a <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> por defecto:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>

<span class="c1"># A static type checker will treat the above</span>
<span class="c1"># as having the same signature as:</span>
<span class="k">def</span> <span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>
</pre></div>
</div>
<p>Este comportamiento permite que <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> sea usado como una <em>vía de escape</em> cuando es necesario mezclar código tipado estática y dinámicamente.</p>
<p>Compárese el comportamiento de <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> con el de <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>. De manera similar a <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>, todo tipo es un subtipo de <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>. Sin embargo, en oposición a <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>, lo contrario no es cierto: <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> <em>no</em> es un subtipo de ningún otro tipo.</p>
<p>Esto implica que cuando el tipo de un valor es <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>, un validador de tipos rechazará prácticamente todas las operaciones con él, y al asignarlo a una variable (o usarlo como valor de retorno) de un tipo más preciso será un error de tipo. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hash_a</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Fails type checking; an object does not have a &#39;magic&#39; method.</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">hash_b</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Passes type checking</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="c1"># Passes type checking, since ints and strs are subclasses of object</span>
<span class="n">hash_a</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_a</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>

<span class="c1"># Passes type checking, since Any is compatible with all types</span>
<span class="n">hash_b</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_b</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Úsese <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> para indicar que un valor puede ser de cualquier tipo de manera segura. Úsese <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> para indicar que un valor es de tipado dinámico.</p>
</section>
<section id="nominal-vs-structural-subtyping">
<h2>Subtipado nominal vs estructural<a class="headerlink" href="#nominal-vs-structural-subtyping" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Inicialmente, el <span class="target" id="index-204"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> definió el uso de <em>subtipado nominal</em> para el sistema de tipado estático de Python. Esto implica que una clase <code class="docutils literal notranslate"><span class="pre">A</span></code> será permitida allí donde se espere una clase <code class="docutils literal notranslate"><span class="pre">B</span></code> si y solo si <code class="docutils literal notranslate"><span class="pre">A</span></code> es una subclase de <code class="docutils literal notranslate"><span class="pre">B</span></code>.</p>
<p>Este requisito también se aplicaba anteriormente a clases base abstractas (ABC), tales como <a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a>. El problema con esta estrategia es que una clase debía de ser marcada explícitamente para proporcionar tal funcionalidad, lo que resulta poco <em>pythónico</em> (idiomático) y poco ajustado a lo que uno normalmente haría en un código Python tipado dinámicamente. Por ejemplo, esto sí se ajusta al <span class="target" id="index-205"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sized</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Iterator</span>

<span class="k">class</span> <span class="nc">Bucket</span><span class="p">(</span><span class="n">Sized</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> <span class="o">...</span>
</pre></div>
</div>
<p>El <span class="target" id="index-206"></span><a class="pep reference external" href="https://peps.python.org/pep-0544/"><strong>PEP 544</strong></a> permite resolver este problema al permitir escribir el código anterior sin una clase base explícita en la definición de la clase, permitiendo que el Validador estático de tipo considere implícitamente que <code class="docutils literal notranslate"><span class="pre">Bucket</span></code> es un subtipo tanto de <code class="docutils literal notranslate"><span class="pre">Sized</span></code> como de <code class="docutils literal notranslate"><span class="pre">Iterable[int]</span></code>. Esto se conoce como tipado <em>estructural</em> (o <em>duck-typing</em> estático):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Iterable</span>

<span class="k">class</span> <span class="nc">Bucket</span><span class="p">:</span>  <span class="c1"># Note: no base classes</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">collect</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">Bucket</span><span class="p">())</span>  <span class="c1"># Passes type check</span>
</pre></div>
</div>
<p>Asimismo, creando subclases de la clase especial  <a class="reference internal" href="#typing.Protocol" title="typing.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>, el usuario puede definir nuevos protocolos personalizados y beneficiarse del tipado estructural (véanse los ejemplos de abajo).</p>
</section>
<section id="module-contents">
<h2>Contenido del módulo<a class="headerlink" href="#module-contents" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El módulo define las siguientes clases, funciones y decoradores.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Este módulo define algunos tipos que son subclases de clases que ya existen en la librería estándar, y que además extienden <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> para soportar variables de tipo dentro de <code class="docutils literal notranslate"><span class="pre">[]</span></code>. Estos tipos se vuelven redundantes en Python 3.9 ya que las clases correspondientes fueron mejoradas para soportar <code class="docutils literal notranslate"><span class="pre">[]</span></code>.</p>
<p>Los tipos redundantes están descontinuados con Python 3.9 pero el intérprete no mostrará ninguna advertencia. Se espera que los verificadores de tipo marquen estos tipos como obsoletos cuando el programa a verificar apunte a Python 3.9 o superior.</p>
<p>Los tipos obsoletos serán removidos del módulo <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> en la primera versión de Python que sea lanzada 5 años después del lanzamiento de Python 3.9.0. Véase los detalles en <span class="target" id="index-207"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> – <em>Sugerencias de tipo genéricas en las Colecciones Estándar</em>.</p>
</div>
<section id="special-typing-primitives">
<h3>Primitivos especiales de tipado<a class="headerlink" href="#special-typing-primitives" title="Enlazar permanentemente con este título">¶</a></h3>
<section id="special-types">
<h4>Tipos especiales<a class="headerlink" href="#special-types" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Estos pueden ser usados como tipos en anotaciones y no soportan <code class="docutils literal notranslate"><span class="pre">[]</span></code>.</p>
<dl class="py data">
<dt class="sig sig-object py" id="typing.Any">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Any</span></span><a class="headerlink" href="#typing.Any" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Tipo especial que indica un tipo sin restricciones.</p>
<ul class="simple">
<li><p>Todos los tipos son compatibles con <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>.</p></li>
<li><p><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> es compatible con todos los tipos.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> can now be used as a base class. This can be useful for
avoiding type checker errors with classes that can duck type anywhere or
are highly dynamic.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.LiteralString">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">LiteralString</span></span><a class="headerlink" href="#typing.LiteralString" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Tipo especial que solo incluye a las cadenas de texto literales. Una cadena de texto literal es compatible con <code class="docutils literal notranslate"><span class="pre">LiteralString</span></code>, así como otro <code class="docutils literal notranslate"><span class="pre">LiteralString</span></code> también lo es, pero un objeto tipado como <code class="docutils literal notranslate"><span class="pre">str</span></code> no lo es. Una cadena de texto que ha sido creada componiendo objetos tipados como <code class="docutils literal notranslate"><span class="pre">LiteralString</span></code> también es válida como <code class="docutils literal notranslate"><span class="pre">LiteralString</span></code>.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run_query</span><span class="p">(</span><span class="n">sql</span><span class="p">:</span> <span class="n">LiteralString</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">...</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">caller</span><span class="p">(</span><span class="n">arbitrary_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">literal_string</span><span class="p">:</span> <span class="n">LiteralString</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">run_query</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM students&quot;</span><span class="p">)</span>  <span class="c1"># ok</span>
    <span class="n">run_query</span><span class="p">(</span><span class="n">literal_string</span><span class="p">)</span>  <span class="c1"># ok</span>
    <span class="n">run_query</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM &quot;</span> <span class="o">+</span> <span class="n">literal_string</span><span class="p">)</span>  <span class="c1"># ok</span>
    <span class="n">run_query</span><span class="p">(</span><span class="n">arbitrary_string</span><span class="p">)</span>  <span class="c1"># type checker error</span>
    <span class="n">run_query</span><span class="p">(</span>  <span class="c1"># type checker error</span>
        <span class="sa">f</span><span class="s2">&quot;SELECT * FROM students WHERE name = </span><span class="si">{</span><span class="n">arbitrary_string</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>Ésto es util para APIs sensibles donde cadenas de texto arbitrarias generadas por usuarios podrían generar problemas. Por ejemplo, los dos casos que aparecen arriba que generar errores en el verificador de tipos podrían ser vulnerables a un ataque de inyección de SQL.</p>
<p>Véase <span class="target" id="index-208"></span><a class="pep reference external" href="https://peps.python.org/pep-0675/"><strong>PEP 675</strong></a> para más detalle.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.11.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Never">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Never</span></span><a class="headerlink" href="#typing.Never" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El <a class="reference external" href="https://en.wikipedia.org/wiki/Bottom_type">bottom type</a> (tipo vacío), un tipo que no tiene miembros.</p>
<p>Puede ser utilizado para definir una función que nunca debe ser llamada, o una función que nunca retorna:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Never</span>

<span class="k">def</span> <span class="nf">never_call_me</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">Never</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">int_or_str</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">never_call_me</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>  <span class="c1"># type checker error</span>
    <span class="k">match</span> <span class="n">arg</span><span class="p">:</span>
        <span class="k">case</span> <span class="nb">int</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s an int&quot;</span><span class="p">)</span>
        <span class="k">case</span> <span class="nb">str</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s a str&quot;</span><span class="p">)</span>
        <span class="k">case</span> <span class="k">_</span><span class="p">:</span>
            <span class="n">never_call_me</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>  <span class="c1"># ok, arg is of type Never</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.11: </span>En versiones antiguas de Python, es posible utilizar <a class="reference internal" href="#typing.NoReturn" title="typing.NoReturn"><code class="xref py py-data docutils literal notranslate"><span class="pre">NoReturn</span></code></a> para expresar el mismo concepto. Se agregó <code class="docutils literal notranslate"><span class="pre">Never</span></code> para hacer más explicito el significado intencionado .</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.NoReturn">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">NoReturn</span></span><a class="headerlink" href="#typing.NoReturn" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Tipo especial que indica que una función nunca retorna un valor. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NoReturn</span>

<span class="k">def</span> <span class="nf">stop</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;no way&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>También puede usarse <code class="docutils literal notranslate"><span class="pre">NoReturn</span></code> como <a class="reference external" href="https://en.wikipedia.org/wiki/Bottom_type">bottom type</a>, un tipo que no tiene valores. Comenzando con Python 3.11, debe usarse, en cambio, el tipo <a class="reference internal" href="#typing.Never" title="typing.Never"><code class="xref py py-data docutils literal notranslate"><span class="pre">Never</span></code></a> para este concepto. Los Validadores de tipo deben tratar a ambos como equivalentes.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.4.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.2.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Self">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Self</span></span><a class="headerlink" href="#typing.Self" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Special type to represent the current enclosed class.
For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Self</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
   <span class="k">def</span> <span class="nf">return_self</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
      <span class="o">...</span>
      <span class="k">return</span> <span class="bp">self</span>
</pre></div>
</div>
<p>Esta anotación es semánticamente equivalente a lo siguiente, aunque de una manera más sucinta:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>

<span class="n">Self</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;Self&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Foo&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
   <span class="k">def</span> <span class="nf">return_self</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
      <span class="o">...</span>
      <span class="k">return</span> <span class="bp">self</span>
</pre></div>
</div>
<p>En general, si actualmente algo sigue el patrón de:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
   <span class="k">def</span> <span class="nf">return_self</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Foo&quot;</span><span class="p">:</span>
      <span class="o">...</span>
      <span class="k">return</span> <span class="bp">self</span>
</pre></div>
</div>
<p>Se debiese usar <a class="reference internal" href="#typing.Self" title="typing.Self"><code class="xref py py-data docutils literal notranslate"><span class="pre">Self</span></code></a>, ya que llamadas a <code class="docutils literal notranslate"><span class="pre">SubclassOfFoo.return_self</span></code> tendrían <code class="docutils literal notranslate"><span class="pre">Foo</span></code> como valor de retorno, y no <code class="docutils literal notranslate"><span class="pre">SubclassOfFoo</span></code>.</p>
<p>Otros casos de uso comunes incluyen:</p>
<ul class="simple">
<li><p><a class="reference internal" href="functions.html#classmethod" title="classmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">classmethod</span></code></a> usados como constructores alternativos y retornan instancias del parámetro <code class="docutils literal notranslate"><span class="pre">cls</span></code>.</p></li>
<li><p>Anotar un método <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> que retorna self.</p></li>
</ul>
<p>Véase <span class="target" id="index-209"></span><a class="pep reference external" href="https://peps.python.org/pep-0673/"><strong>PEP 673</strong></a> para más detalle.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.11.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.TypeAlias">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeAlias</span></span><a class="headerlink" href="#typing.TypeAlias" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Anotación especial para declarar explícitamente un <a class="reference internal" href="#type-aliases"><span class="std std-ref">alias de tipo</span></a>. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeAlias</span>

<span class="n">Factors</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
<p>Consulte <span class="target" id="index-210"></span><a class="pep reference external" href="https://peps.python.org/pep-0613/"><strong>PEP 613</strong></a> para obtener más detalles sobre los alias de tipos explícitos.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</dd></dl>

</section>
<section id="special-forms">
<h4>Formas especiales<a class="headerlink" href="#special-forms" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Estas se pueden usar como anotaciones de tipo usando <code class="docutils literal notranslate"><span class="pre">[]</span></code>, cada cual tiene una sintaxis única.</p>
<dl class="py data">
<dt class="sig sig-object py" id="typing.Tuple">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Tuple</span></span><a class="headerlink" href="#typing.Tuple" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El tipo Tuple, <code class="docutils literal notranslate"><span class="pre">Tuple[X,</span> <span class="pre">Y]</span></code> es el tipo de una tupla de dos ítems con el primer ítem de tipo X y el segundo de tipo Y. El tipo de una tupla vacía se puede escribir así: <code class="docutils literal notranslate"><span class="pre">Tuple[()]</span></code>.</p>
<p>Ejemplo: <code class="docutils literal notranslate"><span class="pre">Tuple[T1,</span> <span class="pre">T2]</span></code> es una tupla de dos elementos con sus correspondientes variables de tipo T1 y T2. <code class="docutils literal notranslate"><span class="pre">Tuple[int,</span> <span class="pre">float,</span> <span class="pre">str]</span></code> es un tupla con un número entero, un número de punto flotante y una cadena de texto.</p>
<p>Para especificar una tupla de longitud variable y tipo homogéneo, se usan puntos suspensivos, p. ej. <code class="docutils literal notranslate"><span class="pre">Tuple[int,</span> <span class="pre">...]</span></code>. Un simple <a class="reference internal" href="#typing.Tuple" title="typing.Tuple"><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code></a> es equivalente a <code class="docutils literal notranslate"><span class="pre">Tuple[Any,</span> <span class="pre">...]</span></code> y, a su vez, a <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.tuple</span></code></a> ahora soporta el uso de subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-211"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Union">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Union</span></span><a class="headerlink" href="#typing.Union" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Tipo de unión; <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">Y]</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">Y</span></code> y significa X o Y.</p>
<p>Para definir una unión, use p. ej. <code class="docutils literal notranslate"><span class="pre">Union[int,</span> <span class="pre">str]</span></code> o la abreviatura <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">|</span> <span class="pre">str</span></code>. Se recomienda el uso de la abreviatura. Detalles:</p>
<ul>
<li><p>Los argumentos deben ser tipos y haber al menos uno.</p></li>
<li><p>Las uniones de uniones se simplifican (se aplanan), p. ej.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>Las uniones con un solo argumento se eliminan, p. ej.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span>  <span class="c1"># The constructor actually returns int</span>
</pre></div>
</div>
</li>
<li><p>Argumentos repetidos se omiten, p. ej.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span>
</pre></div>
</div>
</li>
<li><p>Cuando se comparan uniones, el orden de los argumentos se ignoran, p. ej.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>No es posible crear una subclase o instanciar un <code class="docutils literal notranslate"><span class="pre">Union</span></code>.</p></li>
<li><p>No es posible escribir <code class="docutils literal notranslate"><span class="pre">Union[X][Y]</span></code>.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>No elimina subclases explícitas de una unión en tiempo de ejecución.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Las uniones ahora se pueden escribir como <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">Y</span></code>. Consulte <a class="reference internal" href="stdtypes.html#types-union"><span class="std std-ref">union type expressions</span></a>.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Optional">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Optional</span></span><a class="headerlink" href="#typing.Optional" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Tipo Optional.</p>
<p><code class="docutils literal notranslate"><span class="pre">Optional[X]</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">None</span></code> (o <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">None]</span></code>).</p>
<p>Nótese que no es lo mismo que un argumento opcional, que es aquel que tiene un valor por defecto. Un argumento opcional con un valor por defecto no necesita el indicador <code class="docutils literal notranslate"><span class="pre">Optional</span></code> en su anotación de tipo simplemente por que sea opcional. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Por otro lado, si se permite un valor <code class="docutils literal notranslate"><span class="pre">None</span></code>, es apropiado el uso de <code class="docutils literal notranslate"><span class="pre">Optional</span></code>, independientemente de que sea opcional o no. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Optional ahora se puede escribir como <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">None</span></code>. Consulte <a class="reference internal" href="stdtypes.html#types-union"><span class="std std-ref">union type expressions</span></a>.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Callable">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Callable</span></span><a class="headerlink" href="#typing.Callable" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Tipo Callable (invocable); <code class="docutils literal notranslate"><span class="pre">Callable[[int],</span> <span class="pre">str]</span></code> es una función de (int) -&gt; str.</p>
<p>La sintaxis de subíndice (con corchetes <em>[]</em>) debe usarse siempre con dos valores: la lista de argumentos y el tipo de retorno. La lista de argumentos debe ser una lista de tipos o unos puntos suspensivos; el tipo de retorno debe ser un único tipo.</p>
<p>No existe una sintaxis para indicar argumentos opcionales o con clave (<em>keyword</em>); tales funciones rara vez se utilizan como tipos para llamadas. <code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">ReturnType]</span></code> (puntos suspensivos) se puede usar para indicar que un <em>callable</em> admite un número indeterminado de argumentos y retorna <code class="docutils literal notranslate"><span class="pre">ReturnType</span></code>. Un simple <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a> es equivalente a <code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">Any]</span></code> y, a su vez, a <a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a>.</p>
<p>Los invocables que toman otros invocables como argumentos pueden indicar que sus tipos de parámetros dependen unos de otros utilizando <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a>. Además, si ese invocable agrega o elimina argumentos de otros invocables, se puede utilizar el operador <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a>. Toman la forma <code class="docutils literal notranslate"><span class="pre">Callable[ParamSpecVariable,</span> <span class="pre">ReturnType]</span></code> y <code class="docutils literal notranslate"><span class="pre">Callable[Concatenate[Arg1Type,</span> <span class="pre">Arg2Type,</span> <span class="pre">...,</span> <span class="pre">ParamSpecVariable],</span> <span class="pre">ReturnType]</span></code> respectivamente.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-212"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span><code class="docutils literal notranslate"><span class="pre">Callable</span></code> ahora es compatible con <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> y <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a>. Consulte <span class="target" id="index-213"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a> para obtener más información.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>La documentación de <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> y <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Concatenate</span></code></a> proporciona ejemplos de uso con <code class="docutils literal notranslate"><span class="pre">Callable</span></code>.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Concatenate">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Concatenate</span></span><a class="headerlink" href="#typing.Concatenate" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Se utiliza con <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a> y <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> para escribir anotar un invocable de orden superior que agrega, elimina o transforma parámetros de otro invocable. El uso tiene el formato <code class="docutils literal notranslate"><span class="pre">Concatenate[Arg1Type,</span> <span class="pre">Arg2Type,</span> <span class="pre">...,</span> <span class="pre">ParamSpecVariable]</span></code>. Actualmente, <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> solo es válido cuando se utiliza como primer argumento de un <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a>. El último parámetro de <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> debe ser un <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> o unos puntos suspensivos (<code class="docutils literal notranslate"><span class="pre">...</span></code>).</p>
<p>Por ejemplo, para anotar un decorador <code class="docutils literal notranslate"><span class="pre">with_lock</span></code> que proporciona un <a class="reference internal" href="threading.html#threading.Lock" title="threading.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Lock</span></code></a> a la función decorada, <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> puede usarse para indicar que <code class="docutils literal notranslate"><span class="pre">with_lock</span></code> espera un invocable que toma un <code class="docutils literal notranslate"><span class="pre">Lock</span></code> como primer argumento y retorna un invocable con un tipo de firma diferente. En este caso, el <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> indica que los tipos de parámetros de los invocables retornados dependen de los tipos de parámetros de los invocables que se pasan en</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Lock</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Concatenate</span><span class="p">,</span> <span class="n">ParamSpec</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>

<span class="c1"># Use this lock to ensure that only one thread is executing a function</span>
<span class="c1"># at any time.</span>
<span class="n">my_lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">with_lock</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="n">Concatenate</span><span class="p">[</span><span class="n">Lock</span><span class="p">,</span> <span class="n">P</span><span class="p">],</span> <span class="n">R</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">R</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;A type-safe decorator which provides a lock.&#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span><span class="p">:</span>
        <span class="c1"># Provide the lock as the first argument.</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">my_lock</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span>

<span class="nd">@with_lock</span>
<span class="k">def</span> <span class="nf">sum_threadsafe</span><span class="p">(</span><span class="n">lock</span><span class="p">:</span> <span class="n">Lock</span><span class="p">,</span> <span class="n">numbers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;Add a list of numbers together in a thread-safe manner.&#39;&#39;&#39;</span>
    <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>

<span class="c1"># We don&#39;t need to pass in the lock ourselves thanks to the decorator.</span>
<span class="n">sum_threadsafe</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<ul class="simple">
<li><p><span class="target" id="index-214"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a> - Variables de especificación de parámetros (el PEP que introdujo <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> y <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code>).</p></li>
<li><p><a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> y <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Callable</span></code></a>.</p></li>
</ul>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Type">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[CT_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Type" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una variable indicada como <code class="docutils literal notranslate"><span class="pre">C</span></code> puede aceptar valores de tipo <code class="docutils literal notranslate"><span class="pre">C</span></code>. Sin embargo, un variable indicada como <code class="docutils literal notranslate"><span class="pre">Type[C]</span></code> puede aceptar valores que son clases en sí mismas – específicamente, aceptará el <em>objeto clase</em> de <code class="docutils literal notranslate"><span class="pre">C</span></code>. Por ejemplo.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>         <span class="c1"># Has type &#39;int&#39;</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">int</span>       <span class="c1"># Has type &#39;Type[int]&#39;</span>
<span class="n">c</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>   <span class="c1"># Also has type &#39;Type[int]&#39;</span>
</pre></div>
</div>
<p>Nótese que <code class="docutils literal notranslate"><span class="pre">Type[C]</span></code> es covariante:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">:</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">BasicUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">ProUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>
<span class="k">class</span> <span class="nc">TeamUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>

<span class="c1"># Accepts User, BasicUser, ProUser, TeamUser, ...</span>
<span class="k">def</span> <span class="nf">make_new_user</span><span class="p">(</span><span class="n">user_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">User</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">User</span><span class="p">:</span>
    <span class="c1"># ...</span>
    <span class="k">return</span> <span class="n">user_class</span><span class="p">()</span>
</pre></div>
</div>
<p>El hecho de que <code class="docutils literal notranslate"><span class="pre">Type[C]</span></code> sea covariante implica que todas las subclases de <code class="docutils literal notranslate"><span class="pre">C</span></code> deben implementar la misma interfaz del constructor y las mismas interfaces de los métodos de clase que <code class="docutils literal notranslate"><span class="pre">C</span></code>. El validador de tipos marcará cualquier incumplimiento de esto, pero permitirá llamadas al constructor que coincida con la llamada al constructor de la clase base indicada. El modo en que el validador de tipos debe gestionar este caso particular podría cambiar en futuras revisiones de <span class="target" id="index-215"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>.</p>
<p>Lo únicos parámetros válidos de <a class="reference internal" href="#typing.Type" title="typing.Type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Type</span></code></a> son clases, <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>, <a class="reference internal" href="#generics"><span class="std std-ref">type variables</span></a>, y uniones de cualquiera de los tipos anteriores. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">new_non_team_user</span><span class="p">(</span><span class="n">user_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">BasicUser</span> <span class="o">|</span> <span class="n">ProUser</span><span class="p">]):</span> <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Type[Any]</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">Type</span></code>, que a su vez es equivalente a <code class="docutils literal notranslate"><span class="pre">type</span></code>, que es la raíz de la jerarquía de metaclases de Python.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></a> ahora soporta el uso de subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-216"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Literal">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Literal</span></span><a class="headerlink" href="#typing.Literal" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un tipo que puede ser utilizado para indicar a los validadores de tipos que una variable o un parámetro de una función tiene un valor equivalente al valor literal proveído (o uno de los proveídos). Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">validate_simple</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">]:</span>  <span class="c1"># always returns True</span>
    <span class="o">...</span>

<span class="n">MODE</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">open_helper</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="n">MODE</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>

<span class="n">open_helper</span><span class="p">(</span><span class="s1">&#39;/some/path&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>  <span class="c1"># Passes type check</span>
<span class="n">open_helper</span><span class="p">(</span><span class="s1">&#39;/other/path&#39;</span><span class="p">,</span> <span class="s1">&#39;typo&#39;</span><span class="p">)</span>  <span class="c1"># Error in type checker</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code> no puede ser derivado. En tiempo de ejecución, se permite un valor arbitrario como argumento de tipo de <code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code>, pero los validadores de tipos pueden imponer sus restricciones. Véase <span class="target" id="index-217"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> para más detalles sobre tipos literales.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.9.1: </span><code class="docutils literal notranslate"><span class="pre">Literal</span></code> ahora elimina los parámetros duplicados. Las comparaciones de igualdad de los objetos <code class="docutils literal notranslate"><span class="pre">Literal</span></code> ya no dependen del orden. Los objetos <code class="docutils literal notranslate"><span class="pre">Literal</span></code> ahora lanzarán una excepción <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> durante las comparaciones de igualdad si uno de sus parámetros no es <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.ClassVar">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ClassVar</span></span><a class="headerlink" href="#typing.ClassVar" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Construcción especial para tipado para marcar variables de clase.</p>
<p>Tal y como introduce <span class="target" id="index-218"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a>, una anotación de variable rodeada por ClassVar indica que la intención de un atributo dado es ser usado como variable de clase y que no debería ser modificado en las instancias de esa misma clase. Uso:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Starship</span><span class="p">:</span>
    <span class="n">stats</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># class variable</span>
    <span class="n">damage</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>                     <span class="c1"># instance variable</span>
</pre></div>
</div>
<p><a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> solo acepta tipos y no admite más niveles de subíndices.</p>
<p><a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> no es un clase en sí misma, y no debe ser usado con <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> o <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>. <a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> no modifica el comportamiento de Python en tiempo de ejecución pero puede ser utilizado por validadores de terceros. Por ejemplo, un validador de tipos puede marcar el siguiente código como erróneo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">enterprise_d</span> <span class="o">=</span> <span class="n">Starship</span><span class="p">(</span><span class="mi">3000</span><span class="p">)</span>
<span class="n">enterprise_d</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># Error, setting class variable on instance</span>
<span class="n">Starship</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>     <span class="c1"># This is OK</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.3.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Final">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Final</span></span><a class="headerlink" href="#typing.Final" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un construcción especial para tipado que indica a los validadores de tipo que un nombre no puede ser reasignado o sobrescrito en una subclase. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">MAX_SIZE</span><span class="p">:</span> <span class="n">Final</span> <span class="o">=</span> <span class="mi">9000</span>
<span class="n">MAX_SIZE</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Error reported by type checker</span>

<span class="k">class</span> <span class="nc">Connection</span><span class="p">:</span>
    <span class="n">TIMEOUT</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>

<span class="k">class</span> <span class="nc">FastConnector</span><span class="p">(</span><span class="n">Connection</span><span class="p">):</span>
    <span class="n">TIMEOUT</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Error reported by type checker</span>
</pre></div>
</div>
<p>No hay comprobación en tiempo de ejecución para estas propiedades. Véase <span class="target" id="index-219"></span><a class="pep reference external" href="https://peps.python.org/pep-0591/"><strong>PEP 591</strong></a> para más detalles.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Required">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Required</span></span><a class="headerlink" href="#typing.Required" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.NotRequired">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">NotRequired</span></span><a class="headerlink" href="#typing.NotRequired" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Constructos de tipado especiales que marcan llaves individuales de un <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> como requeridas o no requeridas respectivamente.</p>
<p>Véase <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> y <span class="target" id="index-220"></span><a class="pep reference external" href="https://peps.python.org/pep-0655/"><strong>PEP 655</strong></a> para más detalle.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.11.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Annotated">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Annotated</span></span><a class="headerlink" href="#typing.Annotated" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un tipo introducido en <span class="target" id="index-221"></span><a class="pep reference external" href="https://peps.python.org/pep-0593/"><strong>PEP 593</strong></a> (<code class="docutils literal notranslate"><span class="pre">Anotaciones</span> <span class="pre">flexibles</span> <span class="pre">de</span> <span class="pre">función</span> <span class="pre">y</span> <span class="pre">variable</span></code>), para decorar tipos existentes con metadatos específicos del contexto (posiblemente múltiples partes del mismo, ya que <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> es variádico). En concreto, un tipo <code class="docutils literal notranslate"><span class="pre">T</span></code> puede ser anotado con el metadato <code class="docutils literal notranslate"><span class="pre">x</span></code> a través del <em>typehint</em> <code class="docutils literal notranslate"><span class="pre">Annotated[T,x]</span></code>. Estos metadatos se pueden utilizar para el análisis estático o en tiempo de ejecución. Si una librería (o herramienta) encuentra un <em>typehint</em> <code class="docutils literal notranslate"><span class="pre">Annotated[T,x]</span></code> y no encuentra una lógica especial para el metadato <code class="docutils literal notranslate"><span class="pre">x</span></code>, este debería ignorarlo o simplemente tratar el tipo como <code class="docutils literal notranslate"><span class="pre">T</span></code>. A diferencia de la funcionalidad <code class="docutils literal notranslate"><span class="pre">no_type_check</span></code>, que actualmente existe en el módulo <code class="docutils literal notranslate"><span class="pre">typing</span></code>, que deshabilita completamente la comprobación de anotaciones de tipo en una función o clase, el tipo <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> permite tanto la comprobación de tipos estático de <code class="docutils literal notranslate"><span class="pre">T</span></code> (la cuál ignoraría <code class="docutils literal notranslate"><span class="pre">x</span></code> de forma segura) en conjunto con el acceso a <code class="docutils literal notranslate"><span class="pre">x</span></code> en tiempo de ejecución dentro de una aplicación específica.</p>
<p>En última instancia, la responsabilidad de cómo interpretar las anotaciones (si es que la hay) es de la herramienta o librería que encuentra el tipo <code class="docutils literal notranslate"><span class="pre">Annotated</span></code>. Una herramienta o librería que encuentra un tipo <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> puede escanear las anotaciones para determinar si son de interés. (por ejemplo, usando <code class="docutils literal notranslate"><span class="pre">isinstance()</span></code>).</p>
<p>Cuando una herramienta o librería no soporta anotaciones o encuentra una anotación desconocida, simplemente debe ignorarla o tratar la anotación como el tipo subyacente.</p>
<p>Depende de la herramienta que consume las anotaciones decidir si el cliente puede tener varias anotaciones en un tipo y cómo combinar esas anotaciones.</p>
<p>Dado que el tipo <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> permite colocar varias anotaciones del mismo (o diferente) tipo(s) en cualquier nodo, las herramientas o librerías que consumen dichas anotaciones están a cargo de ocuparse de potenciales duplicados. Por ejemplo, si se está realizando un análisis de rango, esto se debería permitir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T1</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]</span>
<span class="n">T2</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">T1</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<p>Pasar <code class="docutils literal notranslate"><span class="pre">include_extras=True</span></code> a <a class="reference internal" href="#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_type_hints()</span></code></a> permite acceder a las anotaciones extra en tiempo de ejecución.</p>
<p>Los detalles de la sintaxis:</p>
<ul>
<li><p>El primer argumento en <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> debe ser un tipo válido</p></li>
<li><p>Se permiten varias anotaciones de tipo (<code class="docutils literal notranslate"><span class="pre">Annotated</span></code> admite argumentos variádicos):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Annotated</span></code> debe ser llamado con al menos dos argumentos (<code class="docutils literal notranslate"><span class="pre">Annotated[int]</span></code> no es válido)</p></li>
<li><p>Se mantiene el orden de las anotaciones y se toma en cuenta para chequeos de igualdad:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">),</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>Los tipos <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> anidados son aplanados con los metadatos ordenados empezando por la anotación más interna:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Annotated</span><span class="p">[</span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)],</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span> <span class="o">==</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>Anotaciones duplicadas no son removidas:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Anotated</span></code> puede ser usado con alias anidados y genéricos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="n">Vec</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]],</span> <span class="n">MaxLen</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">Vec</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>

<span class="n">V</span> <span class="o">==</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">MaxLen</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
</pre></div>
</div>
</li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.TypeGuard">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeGuard</span></span><a class="headerlink" href="#typing.TypeGuard" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Formulario de mecanografía especial utilizado para anotar el tipo de retorno de una función de protección de tipo definida por el usuario. <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> solo acepta un argumento de tipo único. En tiempo de ejecución, las funciones marcadas de esta manera deberían retornar un booleano.</p>
<p><code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> tiene como objetivo beneficiar a <em>type narrowing</em>, una técnica utilizada por los verificadores de tipo estático para determinar un tipo más preciso de una expresión dentro del flujo de código de un programa. Por lo general, el estrechamiento de tipos se realiza analizando el flujo de código condicional y aplicando el estrechamiento a un bloque de código. La expresión condicional aquí a veces se denomina «protección de tipo»:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_str</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">float</span><span class="p">):</span>
    <span class="c1"># &quot;isinstance&quot; type guard</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># Type of ``val`` is narrowed to ``str``</span>
        <span class="o">...</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Else, type of ``val`` is narrowed to ``float``.</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>A veces sería conveniente utilizar una función booleana definida por el usuario como protección de tipos. Dicha función debería usar <code class="docutils literal notranslate"><span class="pre">TypeGuard[...]</span></code> como su tipo de retorno para alertar a los verificadores de tipo estático sobre esta intención.</p>
<p>El uso de <code class="docutils literal notranslate"><span class="pre">-&gt;</span> <span class="pre">TypeGuard</span></code> le dice al verificador de tipo estático que para una función determinada:</p>
<ol class="arabic simple">
<li><p>El valor de retorno es un booleano.</p></li>
<li><p>Si el valor de retorno es <code class="docutils literal notranslate"><span class="pre">True</span></code>, el tipo de su argumento es el tipo dentro de <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code>.</p></li>
</ol>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_str_list</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">object</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">TypeGuard</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
    <span class="sd">&#39;&#39;&#39;Determines whether all objects in the list are strings&#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">val</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">func1</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">object</span><span class="p">]):</span>
    <span class="k">if</span> <span class="n">is_str_list</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="c1"># Type of ``val`` is narrowed to ``list[str]``.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Type of ``val`` remains as ``list[object]``.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not a list of strings!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Si <code class="docutils literal notranslate"><span class="pre">is_str_list</span></code> es un método de clase o instancia, entonces el tipo en <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> se asigna al tipo del segundo parámetro después de <code class="docutils literal notranslate"><span class="pre">cls</span></code> o <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>En resumen, la forma <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">foo(arg:</span> <span class="pre">TypeA)</span> <span class="pre">-&gt;</span> <span class="pre">TypeGuard[TypeB]:</span> <span class="pre">...</span></code> significa que si <code class="docutils literal notranslate"><span class="pre">foo(arg)</span></code> retorna <code class="docutils literal notranslate"><span class="pre">True</span></code>, entonces <code class="docutils literal notranslate"><span class="pre">arg</span></code> se estrecha de <code class="docutils literal notranslate"><span class="pre">TypeA</span></code> a <code class="docutils literal notranslate"><span class="pre">TypeB</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>No es necesario que <code class="docutils literal notranslate"><span class="pre">TypeB</span></code> sea una forma más estrecha de <code class="docutils literal notranslate"><span class="pre">TypeA</span></code>; incluso puede ser una forma más amplia. La razón principal es permitir cosas como reducir <code class="docutils literal notranslate"><span class="pre">List[object]</span></code> a <code class="docutils literal notranslate"><span class="pre">List[str]</span></code> aunque este último no sea un subtipo del primero, ya que <code class="docutils literal notranslate"><span class="pre">List</span></code> es invariante. La responsabilidad de escribir protecciones de tipo seguras se deja al usuario.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> también funciona con variables de tipo. Véase <span class="target" id="index-222"></span><a class="pep reference external" href="https://peps.python.org/pep-0647/"><strong>PEP 647</strong></a> para más detalles.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</dd></dl>

</section>
<section id="building-generic-types">
<h4>Construir tipos genéricos<a class="headerlink" href="#building-generic-types" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Estos no son utilizados en anotaciones. Son utilizados como bloques para crear tipos genéricos.</p>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Generic">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Generic</span></span><a class="headerlink" href="#typing.Generic" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Clase base abstracta para tipos genéricos.</p>
<p>Un tipo genérico se declara habitualmente heredando de una instancia de esta clase con una o más variables de tipo. Por ejemplo, un tipo de mapeo genérico se podría definir como:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mapping</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">KT</span><span class="p">,</span> <span class="n">VT</span><span class="p">]):</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VT</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="c1"># Etc.</span>
</pre></div>
</div>
<p>Entonces, esta clase se puede usar como sigue:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">lookup_name</span><span class="p">(</span><span class="n">mapping</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="n">Y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Y</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.TypeVar">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeVar</span></span><a class="headerlink" href="#typing.TypeVar" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Variable de tipo.</p>
<p>Uso:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>  <span class="c1"># Can be anything</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>  <span class="c1"># Can be any subtype of str</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>  <span class="c1"># Must be exactly str or bytes</span>
</pre></div>
</div>
<p>Las variables de tipo son principalmente para ayudar a los validadores estáticos de tipos. Sirven tanto como de parámetros para tipos genéricos como para definición de funciones genéricas. Véase <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> para más información sobre tipos genéricos. Las funciones genéricas funcionan de la siguiente manera:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Return a list containing n references to x.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>


<span class="k">def</span> <span class="nf">print_capitalized</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">S</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">S</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Print x capitalized, and return x.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">capitalize</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">A</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">A</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Add two strings or bytes objects together.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>Nótese que las variables de tipo pueden ser <em>bound</em> (delimitadas), <em>constrained</em> (restringidas), o ninguna, pero no pueden ser al mismo tiempo delimitadas <em>y</em> restringidas.</p>
<p>Las variables de tipo delimitadas y las variables de tipo restringidas tienen semánticas distintas en varios aspectos importantes. Usar una variable de tipo <em>bound</em> (delimitada) significa que la <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code> será resuelta utilizando el tipo más específico posible:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">print_capitalized</span><span class="p">(</span><span class="s1">&#39;a string&#39;</span><span class="p">)</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># revealed type is str</span>

<span class="k">class</span> <span class="nc">StringSubclass</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">print_capitalized</span><span class="p">(</span><span class="n">StringSubclass</span><span class="p">(</span><span class="s1">&#39;another string&#39;</span><span class="p">))</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># revealed type is StringSubclass</span>

<span class="n">z</span> <span class="o">=</span> <span class="n">print_capitalized</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>  <span class="c1"># error: int is not a subtype of str</span>
</pre></div>
</div>
<p>Las variables de tipo pueden estar delimitadas por tipos concretos, tipos abstractos (ABCs o <em>protocols</em>) e incluso uniones de tipos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">U</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="nb">str</span><span class="o">|</span><span class="nb">bytes</span><span class="p">)</span>  <span class="c1"># Can be any subtype of the union str|bytes</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">SupportsAbs</span><span class="p">)</span>  <span class="c1"># Can be anything with an __abs__ method</span>
</pre></div>
</div>
<p>Sin embargo, usar una variable de tipo <em>constrained</em> significa que la <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code> sólo podrá ser determinada como exactamente una de las restricciones dadas:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">)</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># revealed type is str</span>

<span class="n">b</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">StringSubclass</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">),</span> <span class="n">StringSubclass</span><span class="p">(</span><span class="s1">&#39;two&#39;</span><span class="p">))</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># revealed type is str, despite StringSubclass being passed in</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;two&#39;</span><span class="p">)</span>  <span class="c1"># error: type variable &#39;A&#39; can be either str or bytes in a function call, but not both</span>
</pre></div>
</div>
<p>En tiempo de ejecución, <code class="docutils literal notranslate"><span class="pre">isinstance(x,</span> <span class="pre">T)</span></code> lanzará una excepción  <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.  En general, <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> y <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> no se deben usar con variables de tipo.</p>
<p>Las variables de tipo pueden ser marcadas como covariantes o contravariantes pasando <code class="docutils literal notranslate"><span class="pre">covariant=True</span></code> o <code class="docutils literal notranslate"><span class="pre">contravariant=True</span></code>, respectivamente. Véase <span class="target" id="index-223"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> para más detalles. Por defecto, las variables de tipo son invariantes.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.TypeVarTuple">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeVarTuple</span></span><a class="headerlink" href="#typing.TypeVarTuple" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Tupla de variables de tipo. Una versión especializada de <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span> <span class="pre">variables</span></code></a> que permite genéricos <em>variádicos</em>.</p>
<p>Una variable de tipo normal permite parametrizar con un solo tipo. Una tupla de variables de tipo, en contraste, permite la parametrización con un número <em>arbitrario</em> de tipos, al actuar como un número <em>arbitrario</em> de variables de tipo envueltas en una tupla. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s1">&#39;Ts&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">,</span> <span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="c1"># T is bound to int, Ts is bound to ()</span>
<span class="c1"># Return value is (1,), which has type tuple[int]</span>
<span class="n">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,))</span>

<span class="c1"># T is bound to int, Ts is bound to (str,)</span>
<span class="c1"># Return value is (&#39;spam&#39;, 1), which has type tuple[str, int]</span>
<span class="n">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;spam&#39;</span><span class="p">))</span>

<span class="c1"># T is bound to int, Ts is bound to (str, float)</span>
<span class="c1"># Return value is (&#39;spam&#39;, 3.0, 1), which has type tuple[str, float, int]</span>
<span class="n">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">))</span>

<span class="c1"># This fails to type check (and fails at runtime)</span>
<span class="c1"># because tuple[()] is not compatible with tuple[T, *Ts]</span>
<span class="c1"># (at least one element is required)</span>
<span class="n">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">())</span>
</pre></div>
</div>
<p>Nótese el uso del operador de desempaquetado <code class="docutils literal notranslate"><span class="pre">*</span></code> en <code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">*Ts]</span></code>. Conceptualmente, puede pensarse en <code class="docutils literal notranslate"><span class="pre">Ts</span></code> como una tupla de variables de tipo <code class="docutils literal notranslate"><span class="pre">(T1,</span> <span class="pre">T2,</span> <span class="pre">...)</span></code>. <code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">*Ts]</span></code> se convertiría en <code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">*(T1,</span> <span class="pre">T2,</span> <span class="pre">...)]</span></code>, lo que es equivalente a <code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">T1,</span> <span class="pre">T2,</span> <span class="pre">...]</span></code>. (Nótese que en versiones más antiguas de Python, ésto puede verse escrito usando en cambio <a class="reference internal" href="#typing.Unpack" title="typing.Unpack"><code class="xref py py-data docutils literal notranslate"><span class="pre">Unpack</span></code></a>, en la forma <code class="docutils literal notranslate"><span class="pre">Unpack[Ts]</span></code>.)</p>
<p>Type variable tuples must <em>always</em> be unpacked. This helps distinguish type
variable tuples from normal type variables:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="n">Ts</span>          <span class="c1"># Not valid</span>
<span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Ts</span><span class="p">]</span>   <span class="c1"># Not valid</span>
<span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]</span>  <span class="c1"># The correct way to do it</span>
</pre></div>
</div>
<p>Las tuplas de variables de tipo pueden ser utilizadas en los mismos contextos que las variables de tipo normales. Por ejemplo en definiciones de clases, argumentos y tipos de retorno:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Shape</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s1">&#39;Shape&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Array</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">]):</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Array[*Shape]&quot;</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span> <span class="nf">get_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">]:</span> <span class="o">...</span>
</pre></div>
</div>
<p>Las tuplas de variables de tipo pueden ser combinadas sin problema con variables de tipo normales:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">DType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;DType&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Array</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">DType</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape</span><span class="p">]):</span>  <span class="c1"># This is fine</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Array2</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">,</span> <span class="n">DType</span><span class="p">]):</span>  <span class="c1"># This would also be fine</span>
    <span class="k">pass</span>

<span class="n">float_array_1d</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Height</span><span class="p">]</span> <span class="o">=</span> <span class="n">Array</span><span class="p">()</span>     <span class="c1"># Totally fine</span>
<span class="n">int_array_2d</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Height</span><span class="p">,</span> <span class="n">Width</span><span class="p">]</span> <span class="o">=</span> <span class="n">Array</span><span class="p">()</span>  <span class="c1"># Yup, fine too</span>
</pre></div>
</div>
<p>Sin embargo, nótese que en una determinada lista de argumentos de tipo o de parámetros de tipo puede haber como máximo una tupla de variables de tipo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">]</span>                     <span class="c1"># Not valid</span>
<span class="k">class</span> <span class="nc">Array</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape</span><span class="p">]):</span>  <span class="c1"># Not valid</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Finalmente, una tupla de variables de tipo desempaquetada puede ser utilizada como la anotación de tipo de <code class="docutils literal notranslate"><span class="pre">*args</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">call_soon</span><span class="p">(</span>
        <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="o">*</span><span class="n">Ts</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="o">*</span><span class="n">Ts</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="n">callback</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p>En contraste con las anotaciones no-desempaquetadas de <code class="docutils literal notranslate"><span class="pre">*args</span></code>, por ej. <code class="docutils literal notranslate"><span class="pre">*args:</span> <span class="pre">int</span></code>, que especificaría que <em>todos</em> los argumentos son <code class="docutils literal notranslate"><span class="pre">int</span></code> - <code class="docutils literal notranslate"><span class="pre">*args:</span> <span class="pre">*Ts</span></code> permite referenciar los tipos de los argumentos <em>individuales</em> en <code class="docutils literal notranslate"><span class="pre">*args</span></code>. Aquí, ésto permite asegurarse de que los tipos de los <code class="docutils literal notranslate"><span class="pre">*args</span></code> que son pasados a <code class="docutils literal notranslate"><span class="pre">call_soon</span></code> calcen con los tipos de los argumentos (posicionales) de <code class="docutils literal notranslate"><span class="pre">callback</span></code>.</p>
<p>Véase <span class="target" id="index-224"></span><a class="pep reference external" href="https://peps.python.org/pep-0646/"><strong>PEP 646</strong></a> para obtener más detalles sobre las tuplas de variables de tipo.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.11.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Unpack">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Unpack</span></span><a class="headerlink" href="#typing.Unpack" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un operador de tipado que conceptualmente marca en un objeto el hecho de haber sido desempaquetado. Por ejemplo, el uso del operador de desempaquetado <code class="docutils literal notranslate"><span class="pre">*</span></code> en una <a class="reference internal" href="#typing.TypeVarTuple" title="typing.TypeVarTuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span> <span class="pre">variable</span> <span class="pre">tuple</span></code></a> es equivalente al uso de <code class="docutils literal notranslate"><span class="pre">Unpack</span></code> para marcar en una tupla de variables de tipo el haber sido desempaquetada:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Ts</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s1">&#39;Ts&#39;</span><span class="p">)</span>
<span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]</span>
<span class="c1"># Effectively does:</span>
<span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Unpack</span><span class="p">[</span><span class="n">Ts</span><span class="p">]]</span>
</pre></div>
</div>
<p>De hecho, es posible utilizar <code class="docutils literal notranslate"><span class="pre">Unpack</span></code> indistintamente de <code class="docutils literal notranslate"><span class="pre">*</span></code> en el contexto de tipos. <code class="docutils literal notranslate"><span class="pre">Unpack</span></code> puede ser visto siendo usado explícitamente en versiones más antiguas de Python, donde <code class="docutils literal notranslate"><span class="pre">*</span></code> no podía ser usado en ciertos lugares:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># In older versions of Python, TypeVarTuple and Unpack</span>
<span class="c1"># are located in the `typing_extensions` backports package.</span>
<span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">TypeVarTuple</span><span class="p">,</span> <span class="n">Unpack</span>

<span class="n">Ts</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s1">&#39;Ts&#39;</span><span class="p">)</span>
<span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]</span>         <span class="c1"># Syntax error on Python &lt;= 3.10!</span>
<span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Unpack</span><span class="p">[</span><span class="n">Ts</span><span class="p">]]</span>  <span class="c1"># Semantically equivalent, and backwards-compatible</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.11.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ParamSpec">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ParamSpec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covariant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contravariant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ParamSpec" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Variable de especificación de parámetros. Una versión especializada de <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span> <span class="pre">variables</span></code></a>.</p>
<p>Uso:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Las variables de especificación de parámetros existen principalmente para el beneficio de los verificadores de tipo estático. Se utilizan para reenviar los tipos de parámetros de un invocable a otro invocable, un patrón que se encuentra comúnmente en funciones y decoradores de orden superior. Solo son válidos cuando se utilizan en <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code>, o como primer argumento de <code class="docutils literal notranslate"><span class="pre">Callable</span></code>, o como parámetros para genéricos definidos por el usuario. Consulte <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> para obtener más información sobre tipos genéricos.</p>
<p>Por ejemplo, para agregar un registro básico a una función, se puede crear un decorador <code class="docutils literal notranslate"><span class="pre">add_logging</span></code> para registrar llamadas a funciones. La variable de especificación de parámetros le dice al verificador de tipo que el invocable pasado al decorador y el nuevo invocable retornado por él tienen parámetros de tipo interdependientes:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">ParamSpec</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add_logging</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;A type-safe decorator to add logging to a function.&#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> was called&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span>

<span class="nd">@add_logging</span>
<span class="k">def</span> <span class="nf">add_two</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;Add two numbers together.&#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p>Sin <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code>, la forma más sencilla de anotar esto anteriormente era usar un <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> con <code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">Any]</span></code> enlazado. Sin embargo, esto causa dos problemas:</p>
<ol class="arabic simple">
<li><p>El verificador de tipo no puede verificar la función <code class="docutils literal notranslate"><span class="pre">inner</span></code> porque <code class="docutils literal notranslate"><span class="pre">*args</span></code> y <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> deben escribirse <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>.</p></li>
<li><p>Es posible que se requiera <a class="reference internal" href="#typing.cast" title="typing.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> en el cuerpo del decorador <code class="docutils literal notranslate"><span class="pre">add_logging</span></code> al retornar la función <code class="docutils literal notranslate"><span class="pre">inner</span></code>, o se debe indicar al verificador de tipo estático que ignore el <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">inner</span></code>.</p></li>
</ol>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.ParamSpec.args">
<span class="sig-name descname"><span class="pre">args</span></span><a class="headerlink" href="#typing.ParamSpec.args" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.ParamSpec.kwargs">
<span class="sig-name descname"><span class="pre">kwargs</span></span><a class="headerlink" href="#typing.ParamSpec.kwargs" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Dado que <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> captura tanto parámetros posicionales como de palabras clave, <code class="docutils literal notranslate"><span class="pre">P.args</span></code> y <code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> se pueden utilizar para dividir un <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> en sus componentes. <code class="docutils literal notranslate"><span class="pre">P.args</span></code> representa la tupla de parámetros posicionales en una llamada determinada y solo debe usarse para anotar <code class="docutils literal notranslate"><span class="pre">*args</span></code>. <code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> representa la asignación de parámetros de palabras clave a sus valores en una llamada determinada y solo debe usarse para anotar <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>. Ambos atributos requieren que el parámetro anotado esté dentro del alcance. En tiempo de ejecución, <code class="docutils literal notranslate"><span class="pre">P.args</span></code> y <code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> son instancias respectivamente de <a class="reference internal" href="#typing.ParamSpecArgs" title="typing.ParamSpecArgs"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpecArgs</span></code></a> y <a class="reference internal" href="#typing.ParamSpecKwargs" title="typing.ParamSpecKwargs"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpecKwargs</span></code></a>.</p>
</dd></dl>

<p>Las variables de especificación de parámetros creadas con <code class="docutils literal notranslate"><span class="pre">covariant=True</span></code> o <code class="docutils literal notranslate"><span class="pre">contravariant=True</span></code> se pueden utilizar para declarar tipos genéricos covariantes o contravariantes. También se acepta el argumento <code class="docutils literal notranslate"><span class="pre">bound</span></code>, similar a <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>. Sin embargo, la semántica real de estas palabras clave aún no se ha decidido.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Solo las variables de especificación de parámetros definidas en el ámbito global pueden ser serializadas.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<ul class="simple">
<li><p><span class="target" id="index-225"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a> - Variables de especificación de parámetros (el PEP que introdujo <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> y <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code>).</p></li>
<li><p><a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Callable</span></code></a> y <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Concatenate</span></code></a>.</p></li>
</ul>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.ParamSpecArgs">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ParamSpecArgs</span></span><a class="headerlink" href="#typing.ParamSpecArgs" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.ParamSpecKwargs">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ParamSpecKwargs</span></span><a class="headerlink" href="#typing.ParamSpecKwargs" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Argumentos y atributos de argumentos de palabras clave de un <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a>. El atributo <code class="docutils literal notranslate"><span class="pre">P.args</span></code> de un <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> es una instancia de <code class="docutils literal notranslate"><span class="pre">ParamSpecArgs</span></code> y <code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> es una instancia de <code class="docutils literal notranslate"><span class="pre">ParamSpecKwargs</span></code>. Están pensados para la introspección en tiempo de ejecución y no tienen un significado especial para los verificadores de tipo estático.</p>
<p>Llamar a <a class="reference internal" href="#typing.get_origin" title="typing.get_origin"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_origin()</span></code></a> en cualquiera de estos objetos retornará el <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> original:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s2">&quot;P&quot;</span><span class="p">)</span>
<span class="n">get_origin</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>  <span class="c1"># returns P</span>
<span class="n">get_origin</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>  <span class="c1"># returns P</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.AnyStr">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AnyStr</span></span><a class="headerlink" href="#typing.AnyStr" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> es una <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">constrained</span> <span class="pre">type</span> <span class="pre">variable</span></code></a> definida como <code class="docutils literal notranslate"><span class="pre">AnyStr</span> <span class="pre">=</span> <span class="pre">TypeVar('AnyStr',</span> <span class="pre">str,</span> <span class="pre">bytes)</span></code>.</p>
<p>Su objetivo es ser usada por funciones que pueden aceptar cualquier tipo de cadena de texto sin permitir mezclar diferentes tipos al mismo tiempo. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="n">concat</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># Ok, output has type &#39;unicode&#39;</span>
<span class="n">concat</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># Ok, output has type &#39;bytes&#39;</span>
<span class="n">concat</span><span class="p">(</span><span class="sa">u</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># Error, cannot mix unicode and bytes</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Protocol">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Protocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Generic</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Protocol" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Clase base para clases protocolo. Las clases protocolo se definen así:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Proto</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>Tales clases son usadas principalmente con validadores estáticos de tipos que detectan subtipado estructural (<em>duck-typing</em> estático), por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Proto</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span>

<span class="n">func</span><span class="p">(</span><span class="n">C</span><span class="p">())</span>  <span class="c1"># Passes static type check</span>
</pre></div>
</div>
<p>Véase <span class="target" id="index-226"></span><a class="pep reference external" href="https://peps.python.org/pep-0544/"><strong>PEP 544</strong></a> para más detalles. Las clases protocolo decoradas con <a class="reference internal" href="#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-func docutils literal notranslate"><span class="pre">runtime_checkable()</span></code></a> (descrito más adelante) se comportan como protocolos simplistas en tiempo de ejecución que solo comprueban la presencia de atributos dados, ignorando su firma de tipo.</p>
<p>Las clases protocolo pueden ser genéricas, por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GenProto</span><span class="p">(</span><span class="n">Protocol</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.runtime_checkable">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">runtime_checkable</span></span><a class="headerlink" href="#typing.runtime_checkable" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Marca una clase protocolo como aplicable en tiempo de ejecución (lo convierte en un <em>runtime protocol</em>).</p>
<p>Tal protocolo se puede usar con <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> y <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>. Esto lanzará una excepción <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> cuando se aplique a una clase que no es un protocolo. Esto permite una comprobación estructural simple, muy semejante a «one trick ponies» en <a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> con <a class="reference internal" href="#typing.Iterable" title="typing.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a>. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@runtime_checkable</span>
<span class="k">class</span> <span class="nc">Closable</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>

<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/some/file&#39;</span><span class="p">),</span> <span class="n">Closable</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><a class="reference internal" href="#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-func docutils literal notranslate"><span class="pre">runtime_checkable()</span></code></a> will check only the presence of the required
methods, not their type signatures. For example, <a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a>
is a class, therefore it passes an <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>
check against <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code></a>.  However, the
<code class="docutils literal notranslate"><span class="pre">ssl.SSLObject.__init__</span></code> method exists only to raise a
<a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> with a more informative message, therefore making
it impossible to call (instantiate) <a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

</section>
<section id="other-special-directives">
<h4>Otras directivas especiales<a class="headerlink" href="#other-special-directives" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Estos no son utilizados en anotaciones. Son utilizados como bloques para crear tipos genéricos.</p>
<dl class="py class">
<dt class="sig sig-object py" id="typing.NamedTuple">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">NamedTuple</span></span><a class="headerlink" href="#typing.NamedTuple" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Versión para anotación de tipos de <a class="reference internal" href="collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a>.</p>
<p>Uso:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p>Esto es equivalente a:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Employee</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Employee&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Para proporcionar a un campo un valor por defecto se puede asignar en el cuerpo de la clase:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">employee</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="s1">&#39;Guido&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">employee</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">3</span>
</pre></div>
</div>
<p>Los campos con un valor por defecto deben ir después de los campos sin valor por defecto.</p>
<p>La clase resultante tiene un atributo extra <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> que proporciona un diccionario que mapea el nombre de los campos con sus respectivos tipos. (Los nombres de los campos están en el atributo <code class="docutils literal notranslate"><span class="pre">_fields</span></code> y sus valores por defecto en el atributo <code class="docutils literal notranslate"><span class="pre">_field_defaults</span></code>, ambos parte de la API <a class="reference internal" href="collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">namedtuple()</span></code></a>.)</p>
<p>Las subclases de <code class="docutils literal notranslate"><span class="pre">NamedTuple</span></code> también pueden tener <em>docstrings</em> y métodos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents an employee.&quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;Employee </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">, id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1">&gt;&#39;</span>
</pre></div>
</div>
<p>Las subclases de <code class="docutils literal notranslate"><span class="pre">NamedTuple</span></code> pueden ser genéricas:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Group</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">T</span>
    <span class="n">group</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
</pre></div>
</div>
<p>Uso retrocompatible:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Employee</span> <span class="o">=</span> <span class="n">NamedTuple</span><span class="p">(</span><span class="s1">&#39;Employee&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Soporte añadido para la sintaxis de anotación de variables propuesto en <span class="target" id="index-227"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6.1: </span>Soporte añadido para valores por defecto, métodos y <em>docstrings</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Los atributos <code class="docutils literal notranslate"><span class="pre">_field_types</span></code> y <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> son simples diccionarios en vez de instancias de <code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.9: </span>Se remueve el atributo <code class="docutils literal notranslate"><span class="pre">_field_types</span></code> en favor del atributo más estándar <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> que tiene la misma información.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Se agrega soporte para <em>namedtuples</em> genéricas.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.NewType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">NewType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.NewType" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase auxiliar para indicar un tipo diferenciado a un comprobador de tipos, consulte <a class="reference internal" href="#distinct"><span class="std std-ref">NewType</span></a>. En tiempo de ejecución, retorna un objeto que retorna su argumento cuando se llama. Uso:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">first_user</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span><code class="docutils literal notranslate"><span class="pre">NewType</span></code> es ahora una clase en lugar de una función.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.TypedDict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypedDict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypedDict" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Es una construcción especial para añadir indicadores de tipo a un diccionario. En tiempo de ejecución es un <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> simple.</p>
<p><code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> crea un tipo de diccionario que espera que todas sus instancias tenga un cierto conjunto de claves, donde cada clave está asociada con un valor de un tipo determinado. Esta exigencia no se comprueba en tiempo de ejecución y solo es aplicada por validadores de tipo. Uso:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">label</span><span class="p">:</span> <span class="nb">str</span>

<span class="n">a</span><span class="p">:</span> <span class="n">Point2D</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;good&#39;</span><span class="p">}</span>  <span class="c1"># OK</span>
<span class="n">b</span><span class="p">:</span> <span class="n">Point2D</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;bad&#39;</span><span class="p">}</span>           <span class="c1"># Fails type check</span>

<span class="k">assert</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Para permitir el uso de esta característica con versiones más antiguas de Python que no tienen soporte para <span class="target" id="index-228"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a>, <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> soporta adicionalmente dos formas sintácticas equivalentes:</p>
<ul>
<li><p>El uso de un <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> literal como segundo argumento:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">})</span>
</pre></div>
</div>
</li>
<li><p>El uso de argumentos nombrados:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<div class="deprecated-removed">
<p><span class="versionmodified">Obsoleto desde la versión 3.11, se eliminará en la versión 3.13: </span>La sintaxis de argumentos nombrados está obsoleta desde la versión 3.11 y será removida en la versión 3.13. Además, podría no estar soportada por los validadores estáticos de tipo.</p>
</div>
<p>También es preferible el uso de la sintaxis funcional cuando cualquiera de las llaves no sean <a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><span class="std std-ref">identifiers</span></a> válidos, por ejemplo porque son palabras clave o contienen guiones. Ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># raises SyntaxError</span>
<span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="ow">in</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># &#39;in&#39; is a keyword</span>
    <span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># name with hyphens</span>

<span class="c1"># OK, functional syntax</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;x-y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">})</span>
</pre></div>
</div>
<p>De forma predeterminada, todas las llaves deben estar presentes en un <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>. Es posible marcar llaves individuales como <em>no requeridas</em> utilizando <a class="reference internal" href="#typing.NotRequired" title="typing.NotRequired"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotRequired</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">label</span><span class="p">:</span> <span class="n">NotRequired</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>

<span class="c1"># Alternative syntax</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="n">NotRequired</span><span class="p">[</span><span class="nb">str</span><span class="p">]})</span>
</pre></div>
</div>
<p>Esto significa que en un <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> que sea una instancia de <code class="docutils literal notranslate"><span class="pre">Point2D</span></code>, será posible omitir la llave <code class="docutils literal notranslate"><span class="pre">label</span></code>.</p>
<p>Además, es posible marcar todas las llaves como no-requeridas por defecto, al especificar un valor de <code class="docutils literal notranslate"><span class="pre">False</span></code> en el argumento <em>total</em>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>

<span class="c1"># Alternative syntax</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">},</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Esto significa que un <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> <code class="docutils literal notranslate"><span class="pre">Point2D</span></code> puede tener cualquiera de las llaves omitidas. Solo se espera que un verificador de tipo admita un <code class="docutils literal notranslate"><span class="pre">False</span></code> literal o <code class="docutils literal notranslate"><span class="pre">True</span></code> como valor del argumento <code class="docutils literal notranslate"><span class="pre">total</span></code>. <code class="docutils literal notranslate"><span class="pre">True</span></code> es el predeterminado y hace que todos los elementos definidos en el cuerpo de la clase sean obligatorios.</p>
<p>Las llaves individuales de un <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> <code class="docutils literal notranslate"><span class="pre">total=False</span></code> pueden ser marcadas como requeridas utilizando <a class="reference internal" href="#typing.Required" title="typing.Required"><code class="xref py py-data docutils literal notranslate"><span class="pre">Required</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Required</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Required</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">label</span><span class="p">:</span> <span class="nb">str</span>

<span class="c1"># Alternative syntax</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">Required</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">Required</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">},</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Es posible que un tipo <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> herede de uno o más tipos <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> usando la sintaxis de clase. Uso:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point3D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">):</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Point3D</span></code> tiene tres elementos: <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> y <code class="docutils literal notranslate"><span class="pre">z</span></code>. Lo que es equivalente a la siguiente definición:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point3D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p>Un <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> no puede heredar de una clase que no sea una subclase de <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>, exceptuando <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">X</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">class</span> <span class="nc">Y</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">class</span> <span class="nc">Z</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># A non-TypedDict class</span>

<span class="k">class</span> <span class="nc">XY</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># OK</span>

<span class="k">class</span> <span class="nc">XZ</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Z</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># raises TypeError</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">XT</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span> <span class="k">pass</span>  <span class="c1"># raises TypeError</span>
</pre></div>
</div>
<p>Un <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> puede ser genérico:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Group</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">T</span>
    <span class="n">group</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> can be introspected via annotations dicts
(see <a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">Prácticas recomendadas para las anotaciones</span></a> for more information on annotations best practices),
<a class="reference internal" href="#typing.TypedDict.__total__" title="typing.TypedDict.__total__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__total__</span></code></a>, <a class="reference internal" href="#typing.TypedDict.__required_keys__" title="typing.TypedDict.__required_keys__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__required_keys__</span></code></a>, and <a class="reference internal" href="#typing.TypedDict.__optional_keys__" title="typing.TypedDict.__optional_keys__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__optional_keys__</span></code></a>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypedDict.__total__">
<span class="sig-name descname"><span class="pre">__total__</span></span><a class="headerlink" href="#typing.TypedDict.__total__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Point2D.__total__</span></code> entrega el valor del argumento <code class="docutils literal notranslate"><span class="pre">total</span></code>. Ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypedDict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point2D</span><span class="o">.</span><span class="n">__total__</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point2D</span><span class="o">.</span><span class="n">__total__</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point3D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point3D</span><span class="o">.</span><span class="n">__total__</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypedDict.__required_keys__">
<span class="sig-name descname"><span class="pre">__required_keys__</span></span><a class="headerlink" href="#typing.TypedDict.__required_keys__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypedDict.__optional_keys__">
<span class="sig-name descname"><span class="pre">__optional_keys__</span></span><a class="headerlink" href="#typing.TypedDict.__optional_keys__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Point2D.__required_keys__</span></code> y <code class="docutils literal notranslate"><span class="pre">Point2D.__optional_keys__</span></code> retornan objetos de la clase <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>, que contienen las llaves requeridas y no requeridas, respectivamente.</p>
<p>Las llaves marcadas con <a class="reference internal" href="#typing.Required" title="typing.Required"><code class="xref py py-data docutils literal notranslate"><span class="pre">Required</span></code></a> siempre aparecerán en <code class="docutils literal notranslate"><span class="pre">__required_keys__</span></code> y las llaves marcadas con <a class="reference internal" href="#typing.NotRequired" title="typing.NotRequired"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotRequired</span></code></a> siempre aparecerán en <code class="docutils literal notranslate"><span class="pre">__optional_keys__</span></code>.</p>
<p>Para retrocompatibilidad con Python 3.10 y versiones más antiguas, es posible utilizar herencia para declarar tanto las llaves requeridas como las no requeridas en el mismo <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>. Ésto se logra declarando un <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> con un valor para el argumento <code class="docutils literal notranslate"><span class="pre">total</span></code> y luego heredando de él en otro <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> con un valor distinto para <code class="docutils literal notranslate"><span class="pre">total</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">... </span>    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Point3D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point3D</span><span class="o">.</span><span class="n">__required_keys__</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;z&#39;</span><span class="p">})</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point3D</span><span class="o">.</span><span class="n">__optional_keys__</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">})</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

<p>Véase <span class="target" id="index-229"></span><a class="pep reference external" href="https://peps.python.org/pep-0589/"><strong>PEP 589</strong></a> para más ejemplos y reglas detalladas del uso de <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Se agrega soporte para marcar llaves individuales como <a class="reference internal" href="#typing.Required" title="typing.Required"><code class="xref py py-data docutils literal notranslate"><span class="pre">Required</span></code></a> o <a class="reference internal" href="#typing.NotRequired" title="typing.NotRequired"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotRequired</span></code></a>. Véase <span class="target" id="index-230"></span><a class="pep reference external" href="https://peps.python.org/pep-0655/"><strong>PEP 655</strong></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Se agrega soporte para <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> genéricos.</p>
</div>
</dd></dl>

</section>
</section>
<section id="generic-concrete-collections">
<h3>Colecciones genéricas concretas<a class="headerlink" href="#generic-concrete-collections" title="Enlazar permanentemente con este título">¶</a></h3>
<section id="corresponding-to-built-in-types">
<h4>Correspondientes a tipos integrados<a class="headerlink" href="#corresponding-to-built-in-types" title="Enlazar permanentemente con este título">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Dict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">dict,</span> <span class="pre">MutableMapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Dict" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>. Útil para anotar tipos de retorno. Para anotar argumentos es preferible usar un tipo abstracto de colección como <a class="reference internal" href="#typing.Mapping" title="typing.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code></a>.</p>
<p>Este tipo se puede usar de la siguiente manera:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">count_words</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.dict</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-231"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.List">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">List</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">list,</span> <span class="pre">MutableSequence[T]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.List" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Versión genérica de <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>. Útil para anotar tipos de retorno. Para anotar argumentos es preferible usar un tipo abstracto de colección como  <a class="reference internal" href="#typing.Sequence" title="typing.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> o <a class="reference internal" href="#typing.Iterable" title="typing.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a>.</p>
<p>Este tipo se puede usar del siguiente modo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">vec2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">keep_positives</span><span class="p">(</span><span class="n">vector</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">vector</span> <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.list</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-232"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Set">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">set,</span> <span class="pre">MutableSet[T]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Set" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.set</span></code></a>. Útil para anotar tipos de retornos. Para anotar argumentos es preferible usar un tipo abstracto de colección como <a class="reference internal" href="#typing.AbstractSet" title="typing.AbstractSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractSet</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.set</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-233"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.FrozenSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">FrozenSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">frozenset,</span> <span class="pre">AbstractSet[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.FrozenSet" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.frozenset</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.frozenset</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-234"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><a class="reference internal" href="#typing.Tuple" title="typing.Tuple"><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code></a> es una forma especial.</p>
</div>
</section>
<section id="corresponding-to-types-in-collections">
<h4>Correspondiente a tipos en <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a><a class="headerlink" href="#corresponding-to-types-in-collections" title="Enlazar permanentemente con este título">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.DefaultDict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">DefaultDict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">collections.defaultdict,</span> <span class="pre">MutableMapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.DefaultDict" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-235"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.OrderedDict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">OrderedDict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">collections.OrderedDict,</span> <span class="pre">MutableMapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.OrderedDict" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-236"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ChainMap">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ChainMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">collections.ChainMap,</span> <span class="pre">MutableMapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ChainMap" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.html#collections.ChainMap" title="collections.ChainMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.ChainMap</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.4.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.1.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.html#collections.ChainMap" title="collections.ChainMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.ChainMap</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-237"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Counter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Counter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">collections.Counter,</span> <span class="pre">Dict[T,</span> <span class="pre">int]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Counter" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.4.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.1.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)`. Véase <span class="target" id="index-238"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Deque">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Deque</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">deque,</span> <span class="pre">MutableSequence[T]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Deque" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.deque</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.4.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.1.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.deque</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-239"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

</section>
<section id="other-concrete-types">
<h4>Otros tipos concretos<a class="headerlink" href="#other-concrete-types" title="Enlazar permanentemente con este título">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.IO">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">IO</span></span><a class="headerlink" href="#typing.IO" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="typing.TextIO">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TextIO</span></span><a class="headerlink" href="#typing.TextIO" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="typing.BinaryIO">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">BinaryIO</span></span><a class="headerlink" href="#typing.BinaryIO" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El tipo genérico <code class="docutils literal notranslate"><span class="pre">IO[AnyStr]</span></code> y sus subclases <code class="docutils literal notranslate"><span class="pre">TextIO(IO[str])</span></code> y <code class="docutils literal notranslate"><span class="pre">BinaryIO(IO[bytes])</span></code> representan los tipos de flujos de E/S como los retornados por <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Obsoleto desde la versión 3.8, se eliminará en la versión 3.13: </span>El espacio de nombres <code class="docutils literal notranslate"><span class="pre">typing.io</span></code> está obsoleto y se eliminará. En su lugar, estos tipos deben importarse directamente desde <code class="docutils literal notranslate"><span class="pre">typing</span></code>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Pattern">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Pattern</span></span><a class="headerlink" href="#typing.Pattern" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="typing.Match">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Match</span></span><a class="headerlink" href="#typing.Match" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Estos alias de tipo corresponden a los tipos retornados de <a class="reference internal" href="re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> y <a class="reference internal" href="re.html#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a>. Estos tipos (y las funciones correspondientes) son genéricos en <code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> y se pueden hacer específicos escribiendo <code class="docutils literal notranslate"><span class="pre">Pattern[str]</span></code>, <code class="docutils literal notranslate"><span class="pre">Pattern[bytes]</span></code>, <code class="docutils literal notranslate"><span class="pre">Match[str]</span></code> o <code class="docutils literal notranslate"><span class="pre">Match[bytes]</span></code>.</p>
<div class="deprecated-removed">
<p><span class="versionmodified">Obsoleto desde la versión 3.8, se eliminará en la versión 3.13: </span>El espacio de nombres <code class="docutils literal notranslate"><span class="pre">typing.re</span></code> está obsoleto y se eliminará. En su lugar, estos tipos deben importarse directamente desde <code class="docutils literal notranslate"><span class="pre">typing</span></code>.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span>Las clases <code class="docutils literal notranslate"><span class="pre">Pattern</span></code> y <code class="docutils literal notranslate"><span class="pre">Match</span></code> de <a class="reference internal" href="re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> ahora soportan <code class="docutils literal notranslate"><span class="pre">[]</span></code>. Véase <span class="target" id="index-240"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Text">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Text</span></span><a class="headerlink" href="#typing.Text" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">Text</span></code> es un alias para <code class="docutils literal notranslate"><span class="pre">str</span></code>. Ésta disponible para proporcionar un mecanismo compatible hacia delante para código en Python 2: en Python 2, <code class="docutils literal notranslate"><span class="pre">Text</span></code> es un alias de <code class="docutils literal notranslate"><span class="pre">unicode</span></code>.</p>
<p>Úsese <code class="docutils literal notranslate"><span class="pre">Text</span></code> para indicar que un valor debe contener una cadena de texto Unicode de manera que sea compatible con Python 2 y Python 3:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_unicode_checkmark</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Text</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Text</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">text</span> <span class="o">+</span> <span class="sa">u</span><span class="s1">&#39; </span><span class="se">\u2713</span><span class="s1">&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.11: </span>Ya no se soporta Python 2, y la mayoría de los validadores de tipo tampoco dan soporte a la validación de tipos en código escrito en Python 2. Actualmente no está planificado remover el alias, pero se alienta a los usuarios a utilizar <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> en vez de <code class="docutils literal notranslate"><span class="pre">Text</span></code> allí donde sea posible.</p>
</div>
</dd></dl>

</section>
</section>
<section id="abstract-base-classes">
<h3>Clase base abstracta para tipos genéricos<a class="headerlink" href="#abstract-base-classes" title="Enlazar permanentemente con este título">¶</a></h3>
<section id="corresponding-to-collections-in-collections-abc">
<h4>Correspondientes a las colecciones en <a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a><a class="headerlink" href="#corresponding-to-collections-in-collections-abc" title="Enlazar permanentemente con este título">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.AbstractSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AbstractSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Collection[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AbstractSet" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Set</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Set</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-241"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ByteString">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ByteString</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Sequence[int]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ByteString" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.abc.html#collections.abc.ByteString" title="collections.abc.ByteString"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ByteString</span></code></a>.</p>
<p>Este tipo representa a los tipos <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>, y <a class="reference internal" href="stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> de secuencias de bytes.</p>
<p>Como abreviación para este tipo, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> se puede usar para anotar argumentos de cualquiera de los tipos mencionados arriba.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.ByteString" title="collections.abc.ByteString"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ByteString</span></code></a> ahora soporta la sintaxis de subíndice (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-242"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Collection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Collection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Sized,</span> <span class="pre">Iterable[T_co],</span> <span class="pre">Container[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Collection" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.abc.html#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Collection</span></code></a></p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.0.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Collection</span></code></a> ahora soporta la sintaxis de subíndice (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-243"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Container">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Container</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Container" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.abc.html#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Container</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Container</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-244"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ItemsView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ItemsView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">MappingView,</span> <span class="pre">AbstractSet[tuple[KT_co,</span> <span class="pre">VT_co]]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ItemsView" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.abc.html#collections.abc.ItemsView" title="collections.abc.ItemsView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ItemsView</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.ItemsView" title="collections.abc.ItemsView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ItemsView</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-245"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.KeysView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">KeysView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">MappingView,</span> <span class="pre">AbstractSet[KT_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.KeysView" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.abc.html#collections.abc.KeysView" title="collections.abc.KeysView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.KeysView</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.KeysView" title="collections.abc.KeysView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.KeysView</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-246"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Mapping">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Mapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Collection[KT],</span> <span class="pre">Generic[KT,</span> <span class="pre">VT_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Mapping" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a>. Este tipo se puede usar de la siguiente manera:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_position_in_index</span><span class="p">(</span><span class="n">word_list</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">word_list</span><span class="p">[</span><span class="n">word</span><span class="p">]</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-247"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.MappingView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">MappingView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Sized</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MappingView" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.abc.html#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MappingView</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MappingView</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-248"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.MutableMapping">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">MutableMapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Mapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableMapping" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-249"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.MutableSequence">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">MutableSequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Sequence[T]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableSequence" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSequence</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSequence</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-250"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.MutableSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">MutableSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">AbstractSet[T]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableSet" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.abc.html#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSet</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSet</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-251"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Sequence">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Sequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Reversible[T_co],</span> <span class="pre">Collection[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Sequence" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-252"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ValuesView">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ValuesView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">MappingView,</span> <span class="pre">Collection[_VT_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ValuesView" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.abc.html#collections.abc.ValuesView" title="collections.abc.ValuesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ValuesView</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.ValuesView" title="collections.abc.ValuesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ValuesView</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-253"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

</section>
<section id="corresponding-to-other-types-in-collections-abc">
<h4>Correspondiente a otros tipos en <a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a><a class="headerlink" href="#corresponding-to-other-types-in-collections-abc" title="Enlazar permanentemente con este título">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Iterable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Iterable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Iterable" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterable</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterable</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-254"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Iterator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Iterable[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Iterator" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.abc.html#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterator</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterator</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-255"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Generator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Generator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Iterator[T_co],</span> <span class="pre">Generic[T_co,</span> <span class="pre">T_contra,</span> <span class="pre">V_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Generator" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un generador puede ser anotado con el tipo genérico <code class="docutils literal notranslate"><span class="pre">Generator[YieldType,</span> <span class="pre">SendType,</span> <span class="pre">ReturnType]</span></code>. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">echo_round</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">sent</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="nb">round</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;Done&#39;</span>
</pre></div>
</div>
<p>Nótese que en contraste con muchos otros genéricos en el módulo <em>typing</em>, el <code class="docutils literal notranslate"><span class="pre">SendType</span></code> de <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> se comporta como contravariante, no covariante ni invariante.</p>
<p>Si tu generador solo retornará valores con <em>yield</em>, establece <code class="docutils literal notranslate"><span class="pre">SendType</span></code> y <code class="docutils literal notranslate"><span class="pre">ReturnType</span></code> como <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Opcionalmente, anota tu generador con un tipo de retorno de <code class="docutils literal notranslate"><span class="pre">Iterable[YieldType]</span></code> o <code class="docutils literal notranslate"><span class="pre">Iterator[YieldType]</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Generator" title="collections.abc.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Generator</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-256"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Hashable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Hashable</span></span><a class="headerlink" href="#typing.Hashable" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un alias de <a class="reference internal" href="collections.abc.html#collections.abc.Hashable" title="collections.abc.Hashable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Hashable</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Reversible">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Reversible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Iterable[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Reversible" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.abc.html#collections.abc.Reversible" title="collections.abc.Reversible"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Reversible</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Reversible" title="collections.abc.Reversible"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Reversible</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-257"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Sized">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Sized</span></span><a class="headerlink" href="#typing.Sized" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un alias de <a class="reference internal" href="collections.abc.html#collections.abc.Sized" title="collections.abc.Sized"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sized</span></code></a>.</p>
</dd></dl>

</section>
<section id="asynchronous-programming">
<h4>Programación asíncrona<a class="headerlink" href="#asynchronous-programming" title="Enlazar permanentemente con este título">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Coroutine">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Coroutine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Awaitable[V_co],</span> <span class="pre">Generic[T_co,</span> <span class="pre">T_contra,</span> <span class="pre">V_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Coroutine" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.abc.html#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Coroutine</span></code></a>.y orden de las variables de tipo se corresponde con aquellas de <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>, por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Coroutine</span>
<span class="n">c</span><span class="p">:</span> <span class="n">Coroutine</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>  <span class="c1"># Some coroutine defined elsewhere</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;hi&#39;</span><span class="p">)</span>                   <span class="c1"># Inferred type of &#39;x&#39; is list[str]</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">bar</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="k">await</span> <span class="n">c</span>                    <span class="c1"># Inferred type of &#39;y&#39; is int</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Coroutine</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-258"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.AsyncGenerator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AsyncGenerator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">AsyncIterator[T_co],</span> <span class="pre">Generic[T_co,</span> <span class="pre">T_contra]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncGenerator" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un generador asíncrono se puede anotar con el tipo genérico <code class="docutils literal notranslate"><span class="pre">AsyncGenerator[YieldType,</span> <span class="pre">SendType]</span></code>. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">echo_round</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">sent</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">rounded</span> <span class="o">=</span> <span class="k">await</span> <span class="nb">round</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">rounded</span>
</pre></div>
</div>
<p>A diferencia de los generadores normales, los generadores asíncronos no pueden retornar un valor, por lo que no hay un parámetro de tipo <code class="docutils literal notranslate"><span class="pre">ReturnType</span></code>. Igual que <a class="reference internal" href="#typing.Generator" title="typing.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>, <code class="docutils literal notranslate"><span class="pre">SendType</span></code> se comporta como contravariante.</p>
<p>Si tu generador solo retornará valores con <em>yield</em>,  establece el <code class="docutils literal notranslate"><span class="pre">SendType</span></code> como <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</pre></div>
</div>
<p>Opcionalmente, anota el generador con un tipo de retorno <code class="docutils literal notranslate"><span class="pre">AsyncIterable[YieldType]</span></code> o <code class="docutils literal notranslate"><span class="pre">AsyncIterator[YieldType]</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.1.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsycGenerator</span></code> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-259"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.AsyncIterable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AsyncIterable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncIterable" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterable</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterable</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-260"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.AsyncIterator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AsyncIterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">AsyncIterable[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncIterator" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterator</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterator</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-261"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Awaitable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Awaitable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Awaitable" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="collections.abc.html#collections.abc.Awaitable" title="collections.abc.Awaitable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Awaitable</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Awaitable" title="collections.abc.Awaitable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Awaitable</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-262"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

</section>
<section id="context-manager-types">
<h4>Tipos del administrador de contextos<a class="headerlink" href="#context-manager-types" title="Enlazar permanentemente con este título">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.ContextManager">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ContextManager</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ContextManager" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="contextlib.html#contextlib.AbstractContextManager" title="contextlib.AbstractContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractContextManager</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.4.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.0.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="contextlib.html#contextlib.AbstractContextManager" title="contextlib.AbstractContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractContextManager</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-263"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.AsyncContextManager">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AsyncContextManager</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncContextManager" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una versión genérica de <a class="reference internal" href="contextlib.html#contextlib.AbstractAsyncContextManager" title="contextlib.AbstractAsyncContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractAsyncContextManager</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.4.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="contextlib.html#contextlib.AbstractAsyncContextManager" title="contextlib.AbstractAsyncContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractAsyncContextManager</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-264"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

</section>
</section>
<section id="protocols">
<h3>Protocolos<a class="headerlink" href="#protocols" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Estos protocolos se decoran con <a class="reference internal" href="#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-func docutils literal notranslate"><span class="pre">runtime_checkable()</span></code></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsAbs">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsAbs</span></span><a class="headerlink" href="#typing.SupportsAbs" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una ABC con un método abstracto <code class="docutils literal notranslate"><span class="pre">__abs__</span></code> que es covariante en su tipo retornado.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsBytes">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsBytes</span></span><a class="headerlink" href="#typing.SupportsBytes" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una ABC con un método abstracto <code class="docutils literal notranslate"><span class="pre">__bytes__</span></code>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsComplex">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsComplex</span></span><a class="headerlink" href="#typing.SupportsComplex" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una ABC con un método abstracto <code class="docutils literal notranslate"><span class="pre">__complex__</span></code>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsFloat">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsFloat</span></span><a class="headerlink" href="#typing.SupportsFloat" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una ABC con un método abstracto <code class="docutils literal notranslate"><span class="pre">__float__</span></code>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsIndex">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsIndex</span></span><a class="headerlink" href="#typing.SupportsIndex" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una ABC con un método abstracto <code class="docutils literal notranslate"><span class="pre">__index__</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsInt">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsInt</span></span><a class="headerlink" href="#typing.SupportsInt" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una ABC con un método abstracto <code class="docutils literal notranslate"><span class="pre">__int__</span></code>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsRound">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsRound</span></span><a class="headerlink" href="#typing.SupportsRound" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una ABC con un método abstracto <code class="docutils literal notranslate"><span class="pre">__round__</span></code> que es covariantes en su tipo retornado.</p>
</dd></dl>

</section>
<section id="functions-and-decorators">
<h3>Funciones y decoradores<a class="headerlink" href="#functions-and-decorators" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="typing.cast">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">cast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">typ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.cast" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convertir un valor a un tipo.</p>
<p>Esto retorna el valor sin modificar. Para el validador de tipos esto indica que el valor de retorno tiene el tipo señalado pero, de manera intencionada, no se comprobará en tiempo de ejecución (para maximizar la velocidad).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.assert_type">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">assert_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">typ</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.assert_type" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Solicitar a un validador de tipos que confirme que <em>val</em> tiene <em>typ</em> por tipo inferido.</p>
<p>Cuando el validador de tipos se encuentra con una llamada a <code class="docutils literal notranslate"><span class="pre">assert_type()</span></code>, emite un error si el valor no es del tipo especificado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>  <span class="c1"># OK, inferred type of `name` is `str`</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>  <span class="c1"># type checker error</span>
</pre></div>
</div>
<p>En tiempo de ejecución, ésto retorna el primer argumento sin modificar y sin efectos secundarios.</p>
<p>Esta función es útil para asegurarse de que la comprensión que el validador de tipos tiene sobre un <em>script</em> está alineada con las intenciones de le desarrolladores:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">complex_function</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">object</span><span class="p">):</span>
    <span class="c1"># Do some complex type-narrowing logic,</span>
    <span class="c1"># after which we hope the inferred type will be `int`</span>
    <span class="o">...</span>
    <span class="c1"># Test whether the type checker correctly understands our function</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.assert_never">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">assert_never</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.assert_never" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Solicitar a un validador estático de tipos confirmar que una línea de código no es alcanzable.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">int_or_str</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">match</span> <span class="n">arg</span><span class="p">:</span>
        <span class="k">case</span> <span class="nb">int</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s an int&quot;</span><span class="p">)</span>
        <span class="k">case</span> <span class="nb">str</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s a str&quot;</span><span class="p">)</span>
        <span class="k">case</span> <span class="k">_</span> <span class="k">as</span> <span class="n">unreachable</span><span class="p">:</span>
            <span class="n">assert_never</span><span class="p">(</span><span class="n">unreachable</span><span class="p">)</span>
</pre></div>
</div>
<p>Aquí, las anotaciones permiten al validador de tipos inferir que el último caso nunca será ejecutado, porque <code class="docutils literal notranslate"><span class="pre">arg</span></code> es un <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> o un <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, y ambas opciones son cubiertas por los casos anteriores. Si un validador de tipos encuentra que una llamada a <code class="docutils literal notranslate"><span class="pre">assert_never()</span></code> es alcanzable, emitirá un error. Por ejemplo, si la anotación de tipos para <code class="docutils literal notranslate"><span class="pre">arg</span></code> fuera en cambio <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">|</span> <span class="pre">str</span> <span class="pre">|</span> <span class="pre">float</span></code>, el validador de tipos emitiría un error señalando que <code class="docutils literal notranslate"><span class="pre">unreachable</span></code> es de tipo <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>. Para que una llamada a <code class="docutils literal notranslate"><span class="pre">assert_never</span></code> pase la validación de tipos, el tipo inferido del argumento dado debe ser el tipo vacío, <a class="reference internal" href="#typing.Never" title="typing.Never"><code class="xref py py-data docutils literal notranslate"><span class="pre">Never</span></code></a>, y nada más.</p>
<p>En tiempo de ejecución, ésto lanza una excepción cuando es llamado.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p><a class="reference external" href="https://typing.readthedocs.io/en/latest/source/unreachable.html">Unreachable Code and Exhaustiveness Checking</a> contiene más información acerca de la verificación de exhaustividad con tipado estático.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.reveal_type">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">reveal_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.reveal_type" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Revela el tipo estático inferido de una expresión.</p>
<p>Cuando un validador estático de tipos se encuentra con una invocación a esta función, emite un diagnostico con el tipo del argumento. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Revealed type is &quot;builtins.int&quot;</span>
</pre></div>
</div>
<p>Ésto puede ser de utilidad cuando se desea <em>debuguear</em> cómo tu validador de tipos maneja una pieza particular de código.</p>
<p>Esta función retorna su argumento sin cambios, lo que permite su uso dentro de una expresión:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">reveal_type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Revealed type is &quot;builtins.int&quot;</span>
</pre></div>
</div>
<p>La mayoría de los validadores de tipos soportan <code class="docutils literal notranslate"><span class="pre">reveal_type()</span></code> en cualquier lugar, incluso si el nombre no ha sido importado desde <code class="docutils literal notranslate"><span class="pre">typing</span></code>. Importar el nombre desde <code class="docutils literal notranslate"><span class="pre">typing</span></code> permite que el código corra sin errores en tiempo de ejecución y comunica la intención de forma más clara.</p>
<p>En tiempo de ejecución, esta función imprime al <em>stderr</em> el tipo en tiempo de ejecución de su argumento y lo retorna in cambios:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">reveal_type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># prints &quot;Runtime type is int&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># prints &quot;1&quot;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.dataclass_transform">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">dataclass_transform</span></span><a class="headerlink" href="#typing.dataclass_transform" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Es posible utilizar <a class="reference internal" href="#typing.dataclass_transform" title="typing.dataclass_transform"><code class="xref py py-data docutils literal notranslate"><span class="pre">dataclass_transform</span></code></a> para decorar una clase, metaclase, o una función que es ella misma un decorador. La presencia de <code class="docutils literal notranslate"><span class="pre">&#64;dataclass_transform()</span></code> indica a un validador estático de tipos que el objeto decorado ejecuta, en tiempo de ejecución, «magia» que transforma una clase, dándole comportamientos similares a los que tiene <a class="reference internal" href="dataclasses.html#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclasses.dataclass()</span></code></a>.</p>
<p>Ejemplo de uso con una función-decorador:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>

<span class="nd">@dataclass_transform</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">create_model</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">type</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="bp">cls</span>

<span class="nd">@create_model</span>
<span class="k">class</span> <span class="nc">CustomerModel</span><span class="p">:</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
</pre></div>
</div>
<p>En una clase base:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass_transform</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">ModelBase</span><span class="p">:</span> <span class="o">...</span>

<span class="k">class</span> <span class="nc">CustomerModel</span><span class="p">(</span><span class="n">ModelBase</span><span class="p">):</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
</pre></div>
</div>
<p>En una metaclase:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass_transform</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">ModelMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span> <span class="o">...</span>

<span class="k">class</span> <span class="nc">ModelBase</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ModelMeta</span><span class="p">):</span> <span class="o">...</span>

<span class="k">class</span> <span class="nc">CustomerModel</span><span class="p">(</span><span class="n">ModelBase</span><span class="p">):</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
</pre></div>
</div>
<p>Las clases <code class="docutils literal notranslate"><span class="pre">CustomerModel</span></code> definidas arribe serán tratadas por los validadores de tipo de forma similar a las clases que sean creadas con  <a class="reference internal" href="dataclasses.html#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;dataclasses.dataclass</span></code></a>. Por ejemplo, los validadores de tipo asumirán que estas clases tienen métodos <code class="docutils literal notranslate"><span class="pre">__init__</span></code> que aceptan <code class="docutils literal notranslate"><span class="pre">id</span></code> y <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
<p>La clase, metaclase o función decorada puede aceptar los siguientes argumentos booleanos, de los cuales los validadores de tipos asumirán que tienen el mismo efecto que tendrían en el decorador <a class="reference internal" href="dataclasses.html#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;dataclasses.dataclass</span></code></a>: <code class="docutils literal notranslate"><span class="pre">init</span></code>, <code class="docutils literal notranslate"><span class="pre">eq</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span></code>, <code class="docutils literal notranslate"><span class="pre">unsafe_hash</span></code>, <code class="docutils literal notranslate"><span class="pre">frozen</span></code>, <code class="docutils literal notranslate"><span class="pre">match_args</span></code>, <code class="docutils literal notranslate"><span class="pre">kw_only</span></code>, y <code class="docutils literal notranslate"><span class="pre">slots</span></code>. Debe ser posible evaluar estáticamente el valor de estos argumentos (<code class="docutils literal notranslate"><span class="pre">True</span></code> o <code class="docutils literal notranslate"><span class="pre">False</span></code>).</p>
<p>Es posible utilizar los argumentos del decorador <code class="docutils literal notranslate"><span class="pre">dataclass_transform</span></code> para personalizar los comportamientos por defecto de la clase, metaclase o función decorada:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eq_default</span></code> indica si, cuando el invocador haya omitido el parámetro <code class="docutils literal notranslate"><span class="pre">eq</span></code>, el valor de éste debe tomarse por <code class="docutils literal notranslate"><span class="pre">True</span></code> o <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">order_default</span></code> indica si, cuando el invocador haya omitido el parámetro <code class="docutils literal notranslate"><span class="pre">order</span></code>, el valor de éste debe tomarse por <code class="docutils literal notranslate"><span class="pre">True</span></code> o <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">kw_only_default</span></code> indica si, cuando el invocador haya omitido el parámetro <code class="docutils literal notranslate"><span class="pre">kw_only</span></code>, el valor de éste debe tomarse por <code class="docutils literal notranslate"><span class="pre">True</span></code> o <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">field_specifiers</span></code> (especificadores de campos) especifica una lista estática de clases o funciones soportadas que describen campos, de manera similar a <code class="docutils literal notranslate"><span class="pre">dataclasses.field()</span></code>.</p></li>
<li><p>Es posible pasar arbitrariamente otros argumentos nombrados para permitir posibles extensiones futuras.</p></li>
</ul>
<p>Los validadores de tipos reconocen los siguientes argumentos opcionales en especificadores de campos:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">init</span></code> indica si el campo debe ser incluido en el método <code class="docutils literal notranslate"><span class="pre">__init__</span></code> sintetizado. Si no es especificado, <code class="docutils literal notranslate"><span class="pre">init</span></code> será <code class="docutils literal notranslate"><span class="pre">True</span></code> por defecto.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">default</span></code> provee el valor por defecto para el campo.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">default_factory</span></code> provee un <em>callback</em> en tiempo de ejecución que retorna el valor por defecto para el campo. Si no se especifican <code class="docutils literal notranslate"><span class="pre">default</span></code> ni <code class="docutils literal notranslate"><span class="pre">default_factory</span></code>, se asumirá que el campo no tiene un valor por defecto y que un valor debe ser provisto cuando la clase sea instanciada.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">factory</span></code> es un alias para <code class="docutils literal notranslate"><span class="pre">default_factory</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">kw_only</span></code> indica si el campo debe ser marcado como exclusivamente de palabra clave. Si es <code class="docutils literal notranslate"><span class="pre">True</span></code>, el campo será exclusivamente de palabra clave. Si es <code class="docutils literal notranslate"><span class="pre">False</span></code> no lo será. Si no se especifica, se utilizará el valor para el parámetro <code class="docutils literal notranslate"><span class="pre">kw_only</span></code> especificado en el objeto decorado con <code class="docutils literal notranslate"><span class="pre">dataclass_transform</span></code>, o si éste tampoco está especificado, se utilizará el valor de <code class="docutils literal notranslate"><span class="pre">kw_only_default</span></code> en <code class="docutils literal notranslate"><span class="pre">dataclass_transform</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">alias</span></code> provee un nombre alternativo para el campo. Este nombre alternativo será utilizado en el método <code class="docutils literal notranslate"><span class="pre">__init__</span></code> sintetizado.</p></li>
</ul>
<p>En tiempo de ejecución, este decorador registra sus argumentos en el atributo <code class="docutils literal notranslate"><span class="pre">__dataclass_transform__</span></code> del objeto decorado. No tiene otro efecto en tiempo de ejecución.</p>
<p>Véase <span class="target" id="index-265"></span><a class="pep reference external" href="https://peps.python.org/pep-0681/"><strong>PEP 681</strong></a> para más detalle.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.overload">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">overload</span></span><a class="headerlink" href="#typing.overload" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El decorador <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> permite describir funciones y métodos que soportan diferentes combinaciones de tipos de argumento. A una serie de definiciones decoradas con <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> debe seguir exactamente una definición no decorada con <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> (para la misma función o método). Las definiciones decoradas con <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> son solo para beneficio del validador de tipos, ya que serán sobrescritas por la definición no decorada con <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>. Esta última se usa en tiempo de ejecución y debería ser ignorada por el validador de tipos. En tiempo de ejecución, llamar a una función decorada con <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> lanzará directamente <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>. Un ejemplo de sobrecarga que proporciona un tipo más preciso se puede expresar con una unión o una variable de tipo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">actual</span> <span class="n">implementation</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Véase <span class="target" id="index-266"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> para más detalle y comparación con otras semánticas de tipado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Ahora es posible introspectar en tiempo de ejecución las funciones sobrecargadas utilizando <a class="reference internal" href="#typing.get_overloads" title="typing.get_overloads"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_overloads()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.get_overloads">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">get_overloads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_overloads" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una secuencia de definiciones para <em>func</em> decoradas con <a class="reference internal" href="#typing.overload" title="typing.overload"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;overload</span></code></a>. <em>func</em> es el objeto función correspondiente a la implementación de la función sobrecargada. Por ejemplo, dada la definición de <code class="docutils literal notranslate"><span class="pre">process</span></code> en la documentación de <a class="reference internal" href="#typing.overload" title="typing.overload"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;overload</span></code></a>, <code class="docutils literal notranslate"><span class="pre">get_overloads(process)</span></code> retornará una secuencia de tres objetos función para las tres sobrecargas definidas. Si es llamada con una función que no tenga sobrecargas, <code class="docutils literal notranslate"><span class="pre">get_overloads()</span></code> retorna una secuencia vacía.</p>
<p><code class="docutils literal notranslate"><span class="pre">get_overloads()</span></code> puede ser utilizada para introspectar en tiempo de ejecución una función sobrecargada.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.clear_overloads">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">clear_overloads</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#typing.clear_overloads" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Limpia todas las sobrecargas registradas del registro interno. Ésto puede ser usado para recuperar memoria usada por el registro.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.final">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">final</span></span><a class="headerlink" href="#typing.final" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un decorador que indica a los validadores de tipos que el método decorado no se puede sobreescribir, o que la clase decorada no se puede derivar (<em>subclassed</em>). Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span><span class="p">:</span>
    <span class="nd">@final</span>
    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>
<span class="k">class</span> <span class="nc">Sub</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Error reported by type checker</span>
        <span class="o">...</span>

<span class="nd">@final</span>
<span class="k">class</span> <span class="nc">Leaf</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">class</span> <span class="nc">Other</span><span class="p">(</span><span class="n">Leaf</span><span class="p">):</span>  <span class="c1"># Error reported by type checker</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>No hay comprobación en tiempo de ejecución para estas propiedades. Véase <span class="target" id="index-267"></span><a class="pep reference external" href="https://peps.python.org/pep-0591/"><strong>PEP 591</strong></a> para más detalles.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>El decorador establecerá a <code class="docutils literal notranslate"><span class="pre">True</span></code> el atributo <code class="docutils literal notranslate"><span class="pre">__final__</span></code> en el objeto decorado. De este modo, es posible utilizar en tiempo de ejecución una verificación como <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">getattr(obj,</span> <span class="pre">&quot;__final__&quot;,</span> <span class="pre">False)</span></code> para determinar si un objeto <code class="docutils literal notranslate"><span class="pre">obj</span></code> has sido marcado como final. Si el objeto decorado no soporta el establecimiento de atributos, el decorador retorna el objeto sin cambios y sin levantar una excepción.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.no_type_check">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">no_type_check</span></span><a class="headerlink" href="#typing.no_type_check" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un decorador para indicar que las anotaciones no deben ser comprobadas como indicadores de tipo.</p>
<p>Esto funciona como un <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> (decorador) de clase o función. Con una clase, se aplica recursivamente a todos los métodos y clases definidos en dicha clase (pero no a lo métodos definidos en sus superclases y subclases).</p>
<p>Esto modifica la función o funciones <em>in situ</em>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.no_type_check_decorator">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">no_type_check_decorator</span></span><a class="headerlink" href="#typing.no_type_check_decorator" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un decorador que asigna a otro decorador el efecto de <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">no_type_check()</span></code></a> (no comprobar tipo).</p>
<p>Esto hace que el decorador decorado añada el efecto de <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">no_type_check()</span></code></a> a la función decorada.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.type_check_only">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">type_check_only</span></span><a class="headerlink" href="#typing.type_check_only" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un decorador que marca una clase o función como no disponible en tiempo de ejecución.</p>
<p>Este decorador no está disponible en tiempo de ejecución. Existe principalmente para marcar clases que se definen en archivos <em>stub</em> para cuando una implementación retorna una instancia de una clase privada:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@type_check_only</span>
<span class="k">class</span> <span class="nc">Response</span><span class="p">:</span>  <span class="c1"># private or not available at runtime</span>
    <span class="n">code</span><span class="p">:</span> <span class="nb">int</span>
    <span class="k">def</span> <span class="nf">get_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">fetch_response</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Response</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>Nótese que no se recomienda retornar instancias de clases privadas. Normalmente es preferible convertirlas en clases públicas.</p>
</dd></dl>

</section>
<section id="introspection-helpers">
<h3>Ayudas de introspección<a class="headerlink" href="#introspection-helpers" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="typing.get_type_hints">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">get_type_hints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">globalns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">localns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_extras</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_type_hints" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un diccionario que contiene indicaciones de tipo para una función, método, módulo o objeto clase.</p>
<p>Habitualmente, esto es lo mismo que <code class="docutils literal notranslate"><span class="pre">obj.__annotations__</span></code>. Además, las referencias hacia adelante codificadas como literales de texto se manejan evaluándolas en los espacios de nombres <code class="docutils literal notranslate"><span class="pre">globals</span></code> y <code class="docutils literal notranslate"><span class="pre">locals</span></code>. Para una clase <code class="docutils literal notranslate"><span class="pre">C</span></code>, se retorna un diccionario construido por la combinación de <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> y <code class="docutils literal notranslate"><span class="pre">C.__mro</span></code> en orden inverso.</p>
<p>La función reemplaza todos los <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">...]</span></code> con <code class="docutils literal notranslate"><span class="pre">T</span></code> de manera recursiva, a menos que <code class="docutils literal notranslate"><span class="pre">include_extras</span></code> se defina como <code class="docutils literal notranslate"><span class="pre">True</span></code> ( véase <a class="reference internal" href="#typing.Annotated" title="typing.Annotated"><code class="xref py py-class docutils literal notranslate"><span class="pre">Annotated</span></code></a> para más información). Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Student</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;some marker&#39;</span><span class="p">]</span>

<span class="n">get_type_hints</span><span class="p">(</span><span class="n">Student</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">}</span>
<span class="n">get_type_hints</span><span class="p">(</span><span class="n">Student</span><span class="p">,</span> <span class="n">include_extras</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">}</span>
<span class="n">get_type_hints</span><span class="p">(</span><span class="n">Student</span><span class="p">,</span> <span class="n">include_extras</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span>
    <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;some marker&#39;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><a class="reference internal" href="#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_type_hints()</span></code></a> no funciona con <a class="reference internal" href="#type-aliases"><span class="std std-ref">alias de tipo</span></a> importados que incluyen referencias hacia adelante. Habilitar la evaluación pospuesta de anotaciones (<span class="target" id="index-268"></span><a class="pep reference external" href="https://peps.python.org/pep-0563/"><strong>PEP 563</strong></a>) puede eliminar la necesidad de la mayoría de las referencias futuras.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.9: </span>Se agregan los parámetros <code class="docutils literal notranslate"><span class="pre">include_extras</span></code> como parte de <span class="target" id="index-269"></span><a class="pep reference external" href="https://peps.python.org/pep-0593/"><strong>PEP 593</strong></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Anteriormente, se agregaba <code class="docutils literal notranslate"><span class="pre">Optional[t]</span></code> en las anotaciones de funciones o métodos si se establecía un valor por defecto igual a <code class="docutils literal notranslate"><span class="pre">None</span></code>. Ahora la anotación es retornada sin cambios.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.get_args">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">get_args</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_args" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.get_origin">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">get_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_origin" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Provee introspección básica para tipos genéricos y construcciones especiales de tipado.</p>
<p>Para un objeto de escritura de la forma <code class="docutils literal notranslate"><span class="pre">X[Y,</span> <span class="pre">Z,</span> <span class="pre">...]</span></code>, estas funciones retornan <code class="docutils literal notranslate"><span class="pre">X</span></code> y <code class="docutils literal notranslate"><span class="pre">(Y,</span> <span class="pre">Z,</span> <span class="pre">...)</span></code>. Si <code class="docutils literal notranslate"><span class="pre">X</span></code> es un alias genérico para una clase incorporada o <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a>, se normaliza a la clase original. Si <code class="docutils literal notranslate"><span class="pre">X</span></code> es una unión o <a class="reference internal" href="#typing.Literal" title="typing.Literal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Literal</span></code></a> contenido en otro tipo genérico, el orden de <code class="docutils literal notranslate"><span class="pre">(Y,</span> <span class="pre">Z,</span> <span class="pre">...)</span></code> puede ser diferente del orden de los argumentos originales <code class="docutils literal notranslate"><span class="pre">[Y,</span> <span class="pre">Z,</span> <span class="pre">...]</span></code> debido al tipo de almacenamiento en caché. Para objetos no admitidos, retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> y <code class="docutils literal notranslate"><span class="pre">()</span></code> correspondientemente. Ejemplos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span>
<span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="ow">is</span> <span class="n">Union</span>
<span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.is_typeddict">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">is_typeddict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.is_typeddict" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Compruebe si un tipo es <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a>.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Film</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">title</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">year</span><span class="p">:</span> <span class="nb">int</span>

<span class="n">is_typeddict</span><span class="p">(</span><span class="n">Film</span><span class="p">)</span>  <span class="c1"># =&gt; True</span>
<span class="n">is_typeddict</span><span class="p">(</span><span class="nb">list</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span>  <span class="c1"># =&gt; False</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ForwardRef">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ForwardRef</span></span><a class="headerlink" href="#typing.ForwardRef" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase utilizada para la representación de escritura interna de referencias de cadena hacia adelante. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">List[&quot;SomeClass&quot;]</span></code> se transforma implícitamente en <code class="docutils literal notranslate"><span class="pre">List[ForwardRef(&quot;SomeClass&quot;)]</span></code>. Esta clase no debe ser instanciada por un usuario, pero puede ser utilizada por herramientas de introspección.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Los tipos genéricos de <span class="target" id="index-270"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a>, como <code class="docutils literal notranslate"><span class="pre">list[&quot;SomeClass&quot;]</span></code>, no se transformarán implícitamente en <code class="docutils literal notranslate"><span class="pre">list[ForwardRef(&quot;SomeClass&quot;)]</span></code> y, por lo tanto, no se resolverán automáticamente en <code class="docutils literal notranslate"><span class="pre">list[SomeClass]</span></code>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.4.</span></p>
</div>
</dd></dl>

</section>
<section id="constant">
<h3>Constantes<a class="headerlink" href="#constant" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py data">
<dt class="sig sig-object py" id="typing.TYPE_CHECKING">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TYPE_CHECKING</span></span><a class="headerlink" href="#typing.TYPE_CHECKING" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una constante especial que se asume como cierta (<code class="docutils literal notranslate"><span class="pre">True</span></code>) por validadores estáticos de tipos de terceros. Es falsa (<code class="docutils literal notranslate"><span class="pre">False</span></code>) en tiempo de ejecución. Uso:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">expensive_mod</span>

<span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="s1">&#39;expensive_mod.SomeType&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">local_var</span><span class="p">:</span> <span class="n">expensive_mod</span><span class="o">.</span><span class="n">AnotherType</span> <span class="o">=</span> <span class="n">other_fun</span><span class="p">()</span>
</pre></div>
</div>
<p>Nótese que la primera anotación de tipo debe estar rodeada por comillas, convirtiéndola en una «referencia directa», para ocultar al intérprete la referencia <code class="docutils literal notranslate"><span class="pre">expensive_mod</span></code> en tiempo de ejecución. Las anotaciones de tipo para variables locales no se evalúan, así que la segunda anotación no necesita comillas.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si se utiliza <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">annotations</span></code>, las anotaciones no son evaluadas al momento de la definición de funciones. En cambio, serán almacenadas como cadenas de texto en <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code>. Ésto vuelve innecesario el uso de comillas alrededor de la anotación (véase <span class="target" id="index-271"></span><a class="pep reference external" href="https://peps.python.org/pep-0563/"><strong>PEP 563</strong></a>).</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.2.</span></p>
</div>
</dd></dl>

</section>
</section>
<section id="deprecation-timeline-of-major-features">
<h2>Línea de tiempo de obsolescencia de características principales<a class="headerlink" href="#deprecation-timeline-of-major-features" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Algunas características de <code class="docutils literal notranslate"><span class="pre">typing</span></code> están obsoletas y podrán ser removidas en versiones futuras de Python. Lo que sigue es una tabla que resume las principales obsolescencias para su conveniencia. Ésto está sujeto a cambio y no todas las obsolescencias están representadas.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 18%" />
<col style="width: 23%" />
<col style="width: 19%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Característica</p></th>
<th class="head"><p>En desuso desde</p></th>
<th class="head"><p>Eliminación proyectada</p></th>
<th class="head"><p>PEP/issue</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>sub-módulos <code class="docutils literal notranslate"><span class="pre">typing.io</span></code> y <code class="docutils literal notranslate"><span class="pre">typing.re</span></code></p></td>
<td><p>3.8</p></td>
<td><p>3.13</p></td>
<td><p><a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=38291">bpo-38291</a></p></td>
</tr>
<tr class="row-odd"><td><p>Versiones <code class="docutils literal notranslate"><span class="pre">typing</span></code> de colecciones estándares</p></td>
<td><p>3.9</p></td>
<td><p>No decidido</p></td>
<td><p><span class="target" id="index-91"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">typing.Text</span></code></p></td>
<td><p>3.11</p></td>
<td><p>No decidido</p></td>
<td><p><a class="reference external" href="https://github.com/python/cpython/issues/92332">gh-92332</a></p></td>
</tr>
</tbody>
</table>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> — Soporte para <em>type hints</em></a><ul>
<li><a class="reference internal" href="#relevant-peps">PEPs relevantes</a></li>
<li><a class="reference internal" href="#type-aliases">Alias de tipo</a></li>
<li><a class="reference internal" href="#newtype">NewType</a></li>
<li><a class="reference internal" href="#callable">Callable</a></li>
<li><a class="reference internal" href="#generics">Genéricos</a></li>
<li><a class="reference internal" href="#user-defined-generic-types">Tipos genéricos definidos por el usuario</a></li>
<li><a class="reference internal" href="#the-any-type">El tipo <code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a></li>
<li><a class="reference internal" href="#nominal-vs-structural-subtyping">Subtipado nominal vs estructural</a></li>
<li><a class="reference internal" href="#module-contents">Contenido del módulo</a><ul>
<li><a class="reference internal" href="#special-typing-primitives">Primitivos especiales de tipado</a><ul>
<li><a class="reference internal" href="#special-types">Tipos especiales</a></li>
<li><a class="reference internal" href="#special-forms">Formas especiales</a></li>
<li><a class="reference internal" href="#building-generic-types">Construir tipos genéricos</a></li>
<li><a class="reference internal" href="#other-special-directives">Otras directivas especiales</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generic-concrete-collections">Colecciones genéricas concretas</a><ul>
<li><a class="reference internal" href="#corresponding-to-built-in-types">Correspondientes a tipos integrados</a></li>
<li><a class="reference internal" href="#corresponding-to-types-in-collections">Correspondiente a tipos en <code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a></li>
<li><a class="reference internal" href="#other-concrete-types">Otros tipos concretos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#abstract-base-classes">Clase base abstracta para tipos genéricos</a><ul>
<li><a class="reference internal" href="#corresponding-to-collections-in-collections-abc">Correspondientes a las colecciones en <code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a></li>
<li><a class="reference internal" href="#corresponding-to-other-types-in-collections-abc">Correspondiente a otros tipos en <code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a></li>
<li><a class="reference internal" href="#asynchronous-programming">Programación asíncrona</a></li>
<li><a class="reference internal" href="#context-manager-types">Tipos del administrador de contextos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#protocols">Protocolos</a></li>
<li><a class="reference internal" href="#functions-and-decorators">Funciones y decoradores</a></li>
<li><a class="reference internal" href="#introspection-helpers">Ayudas de introspección</a></li>
<li><a class="reference internal" href="#constant">Constantes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deprecation-timeline-of-major-features">Línea de tiempo de obsolescencia de características principales</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="development.html"
                          title="capítulo anterior">Herramientas de desarrollo</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="pydoc.html"
                          title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code> — Generador de documentación y Sistema de ayuda en línea</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/library/typing.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="pydoc.html" title="pydoc — Generador de documentación y Sistema de ayuda en línea"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="development.html" title="Herramientas de desarrollo"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" >Herramientas de desarrollo</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> — Soporte para <em>type hints</em></a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 23, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>