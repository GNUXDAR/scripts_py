
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>9. Clases &#8212; documentación de Python - 3.10.10</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.10.10"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="10. Pequeño paseo por la Biblioteca Estándar" href="stdlib.html" />
    <link rel="prev" title="8. Errores y excepciones" href="errors.html" />
    <link rel="canonical" href="https://docs.python.org/3/tutorial/classes.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#">9. Clases</a><ul>
<li><a class="reference internal" href="#a-word-about-names-and-objects">9.1. Unas palabras sobre nombres y objetos</a></li>
<li><a class="reference internal" href="#python-scopes-and-namespaces">9.2. Ámbitos y espacios de nombres en Python</a><ul>
<li><a class="reference internal" href="#scopes-and-namespaces-example">9.2.1. Ejemplo de ámbitos y espacios de nombre</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-first-look-at-classes">9.3. Un primer vistazo a las clases</a><ul>
<li><a class="reference internal" href="#class-definition-syntax">9.3.1. Sintaxis de definición de clases</a></li>
<li><a class="reference internal" href="#class-objects">9.3.2. Objetos clase</a></li>
<li><a class="reference internal" href="#instance-objects">9.3.3. Objetos instancia</a></li>
<li><a class="reference internal" href="#method-objects">9.3.4. Objetos método</a></li>
<li><a class="reference internal" href="#class-and-instance-variables">9.3.5. Variables de clase y de instancia</a></li>
</ul>
</li>
<li><a class="reference internal" href="#random-remarks">9.4. Algunas observaciones</a></li>
<li><a class="reference internal" href="#inheritance">9.5. Herencia</a><ul>
<li><a class="reference internal" href="#multiple-inheritance">9.5.1. Herencia múltiple</a></li>
</ul>
</li>
<li><a class="reference internal" href="#private-variables">9.6. Variables privadas</a></li>
<li><a class="reference internal" href="#odds-and-ends">9.7. Cambalache</a></li>
<li><a class="reference internal" href="#iterators">9.8. Iteradores</a></li>
<li><a class="reference internal" href="#generators">9.9. Generadores</a></li>
<li><a class="reference internal" href="#generator-expressions">9.10. Expresiones generadoras</a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="errors.html"
                        title="capítulo anterior"><span class="section-number">8. </span>Errores y excepciones</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="stdlib.html"
                        title="próximo capítulo"><span class="section-number">10. </span>Pequeño paseo por la Biblioteca Estándar</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/tutorial/classes.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="stdlib.html" title="10. Pequeño paseo por la Biblioteca Estándar"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="errors.html" title="8. Errores y excepciones"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">El tutorial de Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">9. </span>Clases</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="classes">
<span id="tut-classes"></span><h1><span class="section-number">9. </span>Clases<a class="headerlink" href="#classes" title="Enlazar permanentemente con este título">¶</a></h1>
<p>Las clases proveen una forma de empaquetar datos y funcionalidad juntos. Al crear una nueva clase, se crea un nuevo <em>tipo</em> de objeto, permitiendo crear nuevas <em>instancias</em> de ese tipo. Cada instancia de clase puede tener atributos adjuntos para mantener su estado. Las instancias de clase también pueden tener métodos (definidos por su clase) para modificar su estado.</p>
<p>Comparado con otros lenguajes de programación, el mecanismo de clases de Python agrega clases con un mínimo de nuevas sintaxis y semánticas.  Es una mezcla de los mecanismos de clases encontrados en C++ y Modula-3.  Las clases de Python proveen todas las características normales de la Programación Orientada a Objetos: el mecanismo de la herencia de clases permite múltiples clases base, una clase derivada puede sobre escribir cualquier método de su(s) clase(s) base, y un método puede llamar al método de la clase base con el mismo nombre.  Los objetos pueden tener una cantidad arbitraria de datos de cualquier tipo.  Igual que con los módulos, las clases participan de la naturaleza dinámica de Python: se crean en tiempo de ejecución, y pueden modificarse luego de la creación.</p>
<p>En terminología de C++, normalmente los miembros de las clases (incluyendo los miembros de datos), son <em>públicos</em> (excepto ver abajo <a class="reference internal" href="#tut-private"><span class="std std-ref">Variables privadas</span></a>), y todas las funciones miembro son <em>virtuales</em>.  Como en Modula-3, no hay atajos para hacer referencia a los miembros del objeto desde sus métodos: la función método se declara con un primer argumento explícito que representa al objeto, el cual se provee implícitamente por la llamada.  Como en Smalltalk, las clases mismas son objetos.  Esto provee una semántica para importar y renombrar.  A diferencia de C++ y Modula-3, los tipos de datos integrados pueden usarse como clases base para que el usuario los extienda.  También, como en C++ pero a diferencia de Modula-3, la mayoría de los operadores integrados con sintaxis especial (operadores aritméticos, de sub-índice, etc.) pueden volver a ser definidos por instancias de la clase.</p>
<p>(Sin haber una terminología universalmente aceptada sobre clases, haré uso ocasional de términos de Smalltalk y C++.  Usaría términos de Modula-3, ya que su semántica orientada a objetos es más cercana a Python que C++, pero no espero que muchos lectores hayan escuchado hablar de él.)</p>
<section id="a-word-about-names-and-objects">
<span id="tut-object"></span><h2><span class="section-number">9.1. </span>Unas palabras sobre nombres y objetos<a class="headerlink" href="#a-word-about-names-and-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los objetos tienen individualidad, y múltiples nombres (en muchos ámbitos) pueden vincularse al mismo objeto.  Esto se conoce como <em>aliasing</em> en otros lenguajes.  Normalmente no se aprecia esto a primera vista en Python, y puede ignorarse sin problemas cuando se maneja tipos básicos inmutables (números, cadenas, tuplas).  Sin embargo, el <em>aliasing</em>, o renombrado,  tiene un efecto posiblemente sorpresivo sobre la semántica de código Python que involucra objetos mutables como listas, diccionarios, y la mayoría de otros tipos.  Esto se usa normalmente para beneficio del programa, ya que los renombres funcionan como punteros en algunos aspectos.  Por ejemplo, pasar un objeto es barato ya que la implementación solamente pasa el puntero; y si una función modifica el objeto que fue pasado, el que la llama verá el cambio; esto elimina la necesidad de tener dos formas diferentes de pasar argumentos, como en Pascal.</p>
</section>
<section id="python-scopes-and-namespaces">
<span id="tut-scopes"></span><h2><span class="section-number">9.2. </span>Ámbitos y espacios de nombres en Python<a class="headerlink" href="#python-scopes-and-namespaces" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Antes de ver clases, primero debo decirte algo acerca de las reglas de ámbito de Python.  Las definiciones de clases hacen unos lindos trucos con los espacios de nombres, y necesitás saber cómo funcionan los alcances y espacios de nombres para entender por completo cómo es la cosa.  De paso, los conocimientos en este tema son útiles para cualquier programador Python avanzado.</p>
<p>Comencemos con unas definiciones.</p>
<p>Un <em>espacio de nombres</em> es una relación de nombres a objetos.  Muchos espacios de nombres están implementados en este momento como diccionarios de Python, pero eso no se nota para nada (excepto por el desempeño), y puede cambiar en el futuro.  Como ejemplos de espacios de nombres tenés: el conjunto de nombres incluidos (conteniendo funciones como <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a>, y los nombres de excepciones integradas); los nombres globales en un módulo; y los nombres locales en la invocación a una función.  Lo que es importante saber de los espacios de nombres es que no hay relación en absoluto entre los nombres de espacios de nombres distintos; por ejemplo, dos módulos diferentes pueden tener definidos los dos una función <code class="docutils literal notranslate"><span class="pre">maximizar</span></code> sin confusión; los usuarios de los módulos deben usar el nombre del módulo como prefijo.</p>
<p>Por cierto, yo uso la palabra <em>atributo</em> para cualquier cosa después de un punto; por ejemplo, en la expresión <code class="docutils literal notranslate"><span class="pre">z.real</span></code>, <code class="docutils literal notranslate"><span class="pre">real</span></code> es un atributo del objeto <code class="docutils literal notranslate"><span class="pre">z</span></code>.  Estrictamente hablando, las referencias a nombres en módulos son referencias a atributos: en la expresión <code class="docutils literal notranslate"><span class="pre">modulo.funcion</span></code>, <code class="docutils literal notranslate"><span class="pre">modulo</span></code> es un objeto módulo y <code class="docutils literal notranslate"><span class="pre">funcion</span></code> es un atributo de éste.  En este caso hay una relación directa entre los atributos del módulo y los nombres globales definidos en el módulo: ¡están compartiendo el mismo espacio de nombres! <a class="footnote-reference brackets" href="#id2" id="id1">1</a></p>
<p>Los atributos pueden ser de sólo lectura, o de escritura.  En el último caso es posible la asignación a atributos.  Los atributos de módulo pueden escribirse: <code class="docutils literal notranslate"><span class="pre">modulo.la_respuesta</span> <span class="pre">=</span> <span class="pre">42</span></code>.  Los atributos de escritura se pueden borrar también con la declaración <a class="reference internal" href="../reference/simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a>.  Por ejemplo, <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">modulo.la_respuesta</span></code> va a eliminar el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">la_respuesta</span></code> del objeto con nombre <code class="docutils literal notranslate"><span class="pre">modulo</span></code>.</p>
<p>Los espacios de nombres se crean en diferentes momentos y con diferentes tiempos de vida.  El espacio de nombres que contiene los nombres incluidos se crea cuando se inicia el intérprete, y nunca se borra.  El espacio de nombres global de un módulo se crea cuando se lee la definición de un módulo; normalmente, los espacios de nombres de módulos también duran hasta que el intérprete finaliza.  Las instrucciones ejecutadas en el nivel de llamadas superior del intérprete, ya sea desde un script o interactivamente, se consideran parte del módulo llamado <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a>, por lo tanto tienen su propio espacio de nombres global.  (Los nombres incluidos en realidad también viven en un módulo; este se llama <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a>.)</p>
<p>El espacio de nombres local a una función se crea cuando la función es llamada, y se elimina cuando la función retorna o lanza una excepción que no se maneje dentro de la función.  (Podríamos decir que lo que pasa en realidad es que ese espacio de nombres se «olvida».)  Por supuesto, las llamadas recursivas tienen cada una su propio espacio de nombres local.</p>
<p>Un <em>ámbito</em> es una región textual de un programa en Python donde un espacio de nombres es accesible directamente.  «Accesible directamente» significa que una referencia sin calificar a un nombre intenta encontrar dicho nombre dentro del espacio de nombres.</p>
<p>Aunque los alcances se determinan de forma estática, se utilizan de forma dinámica. En cualquier momento durante la ejecución, hay 3 o 4 ámbitos anidados cuyos espacios de nombres son directamente accesibles:</p>
<ul class="simple">
<li><p>el alcance más interno, que es inspeccionado primero, contiene los nombres locales</p></li>
<li><p>the scopes of any enclosing functions, which are searched starting with the
nearest enclosing scope, contain non-local, but also non-global names</p></li>
<li><p>el penúltimo alcance contiene nombres globales del módulo actual</p></li>
<li><p>el alcance más externo (el último inspeccionado) es el espacio de nombres que contiene los nombres integrados</p></li>
</ul>
<p>If a name is declared global, then all references and assignments go directly to
the next-to-last scope containing the module’s global names.  To rebind variables
found outside of the innermost scope, the <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> statement can be
used; if not declared nonlocal, those variables are read-only (an attempt to
write to such a variable will simply create a <em>new</em> local variable in the
innermost scope, leaving the identically named outer variable unchanged).</p>
<p>Habitualmente, el ámbito local referencia los nombres locales de la función actual.  Fuera de una función, el ámbito local referencia al mismo espacio de nombres que el ámbito global: el espacio de nombres del módulo. Las definiciones de clases crean un espacio de nombres más en el ámbito local.</p>
<p>Es importante notar que los alcances se determinan textualmente: el ámbito global de una función definida en un módulo es el espacio de nombres de ese módulo, no importa desde dónde o con qué alias se llame a la función.  Por otro lado, la búsqueda de nombres se hace dinámicamente, en tiempo de ejecución; sin embargo, la definición del lenguaje está evolucionando a hacer resolución de nombres estáticamente, en tiempo de «compilación», ¡así que no te confíes de la resolución de nombres dinámica! (De hecho, las variables locales ya se determinan estáticamente.)</p>
<p>Una peculiaridad especial de Python es que, si no hay una declaración <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> o <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> en efecto, las asignaciones a nombres siempre van al ámbito interno.  Las asignaciones no copian datos, solamente asocian nombres a objetos.  Lo mismo cuando se borra: la declaración <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x</span></code> quita la asociación de <code class="docutils literal notranslate"><span class="pre">x</span></code> del espacio de nombres referenciado por el ámbito local.  De hecho, todas las operaciones que introducen nuevos nombres usan el ámbito local: en particular, las instrucciones <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> y las definiciones de funciones asocian el módulo o nombre de la función al espacio de nombres en el ámbito local.</p>
<p>La declaración <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> puede usarse para indicar que ciertas variables viven en el ámbito global y deberían reasignarse allí; la declaración <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> indica que ciertas variables viven en un ámbito encerrado y deberían reasignarse allí.</p>
<section id="scopes-and-namespaces-example">
<span id="tut-scopeexample"></span><h3><span class="section-number">9.2.1. </span>Ejemplo de ámbitos y espacios de nombre<a class="headerlink" href="#scopes-and-namespaces-example" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Este es un ejemplo que muestra como hacer referencia a distintos ámbitos y espacios de nombres, y cómo las declaraciones <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> y <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> afectan la asignación de variables:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">scope_test</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">do_local</span><span class="p">():</span>
        <span class="n">spam</span> <span class="o">=</span> <span class="s2">&quot;local spam&quot;</span>

    <span class="k">def</span> <span class="nf">do_nonlocal</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">spam</span>
        <span class="n">spam</span> <span class="o">=</span> <span class="s2">&quot;nonlocal spam&quot;</span>

    <span class="k">def</span> <span class="nf">do_global</span><span class="p">():</span>
        <span class="k">global</span> <span class="n">spam</span>
        <span class="n">spam</span> <span class="o">=</span> <span class="s2">&quot;global spam&quot;</span>

    <span class="n">spam</span> <span class="o">=</span> <span class="s2">&quot;test spam&quot;</span>
    <span class="n">do_local</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After local assignment:&quot;</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>
    <span class="n">do_nonlocal</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After nonlocal assignment:&quot;</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>
    <span class="n">do_global</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After global assignment:&quot;</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>

<span class="n">scope_test</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;In global scope:&quot;</span><span class="p">,</span> <span class="n">spam</span><span class="p">)</span>
</pre></div>
</div>
<p>El resultado del código ejemplo es:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam
</pre></div>
</div>
<p>Notá como la asignación <em>local</em> (que es el comportamiento normal) no cambió la vinculación de <em>algo</em> de <em>prueba_ambitos</em>.  La asignación <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> cambió la vinculación de <em>algo</em> de <em>prueba_ambitos</em>, y la asignación <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a> cambió la vinculación a nivel de módulo.</p>
<p>También podés ver que no había vinculación para <em>algo</em> antes de la asignación <a class="reference internal" href="../reference/simple_stmts.html#global"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">global</span></code></a>.</p>
</section>
</section>
<section id="a-first-look-at-classes">
<span id="tut-firstclasses"></span><h2><span class="section-number">9.3. </span>Un primer vistazo a las clases<a class="headerlink" href="#a-first-look-at-classes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las clases introducen un poquito de sintaxis nueva, tres nuevos tipos de objetos y algo de semántica nueva.</p>
<section id="class-definition-syntax">
<span id="tut-classdefinition"></span><h3><span class="section-number">9.3.1. </span>Sintaxis de definición de clases<a class="headerlink" href="#class-definition-syntax" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La forma más sencilla de definición de una clase se ve así:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ClassName</span><span class="p">:</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="n">N</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Las definiciones de clases, al igual que las definiciones de funciones (instrucciones <a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a>) deben ejecutarse antes de que tengan efecto alguno.  (Es concebible poner una definición de clase dentro de una rama de un <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>, o dentro de una función.)</p>
<p>En la práctica, las declaraciones dentro de una clase son definiciones de funciones, pero otras declaraciones son permitidas, y a veces resultan útiles; veremos esto más adelante.  Las definiciones de funciones dentro de una clase normalmente tienen una lista de argumentos peculiar, dictada por las convenciones de invocación de métodos; a esto también lo veremos más adelante.</p>
<p>Cuando se ingresa una definición de clase, se crea un nuevo espacio de nombres, el cual se usa como ámbito local; por lo tanto, todas las asignaciones a variables locales van a este nuevo espacio de nombres.  En particular, las definiciones de funciones asocian el nombre de las funciones nuevas allí.</p>
<p>Cuando una definición de clase se finaliza normalmente se crea un <em>objeto clase</em>.  Básicamente, este objeto envuelve los contenidos del espacio de nombres creado por la definición de la clase; aprenderemos más acerca de los objetos clase en la sección siguiente.  El ámbito local original (el que tenía efecto justo antes de que ingrese la definición de la clase) es restablecido, y el objeto clase se asocia allí al nombre que se le puso a la clase en el encabezado de su definición (<code class="xref py py-class docutils literal notranslate"><span class="pre">Clase</span></code> en el ejemplo).</p>
</section>
<section id="class-objects">
<span id="tut-classobjects"></span><h3><span class="section-number">9.3.2. </span>Objetos clase<a class="headerlink" href="#class-objects" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Los objetos clase soportan dos tipos de operaciones: hacer referencia a atributos e instanciación.</p>
<p>Para <em>hacer referencia a atributos</em> se usa la sintaxis estándar de todas las referencias a atributos en Python: <code class="docutils literal notranslate"><span class="pre">objeto.nombre</span></code>.  Los nombres de atributo válidos son todos los nombres que estaban en el espacio de nombres de la clase cuando ésta se creó.  Por lo tanto, si la definición de la clase es así:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A simple example class&quot;&quot;&quot;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">12345</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>
</pre></div>
</div>
<p>…entonces <code class="docutils literal notranslate"><span class="pre">MiClase.i</span></code> y <code class="docutils literal notranslate"><span class="pre">MiClase.f</span></code> son referencias de atributos válidas, que retornan un entero y un objeto función respectivamente.  Los atributos de clase también pueden ser asignados, o sea que podés cambiar el valor de <code class="docutils literal notranslate"><span class="pre">MiClase.i</span></code> mediante asignación.  <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> también es un atributo válido, que retorna la documentación asociada a la clase: <code class="docutils literal notranslate"><span class="pre">&quot;Simple</span> <span class="pre">clase</span> <span class="pre">de</span> <span class="pre">ejemplo&quot;</span></code>.</p>
<p>La <em>instanciación</em> de clases usa la notación de funciones.  Hacé de cuenta que el objeto de clase es una función sin parámetros que retorna una nueva instancia de la clase.  Por ejemplo (para la clase de más arriba):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
</pre></div>
</div>
<p>…crea una nueva <em>instancia</em> de la clase y asigna este objeto a la variable local <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>La operación de instanciación («llamar» a un objeto clase) crea un objeto vacío.  Muchas clases necesitan crear objetos con instancias en un estado inicial particular.  Por lo tanto una clase puede definir un método especial llamado <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code>, de esta forma:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
<p>When a class defines an <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> method, class instantiation
automatically invokes <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> for the newly created class instance.  So
in this example, a new, initialized instance can be obtained by:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
</pre></div>
</div>
<p>Por supuesto, el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> puede tener argumentos para mayor flexibilidad.  En ese caso, los argumentos que se pasen al operador de instanciación de la clase van a parar al método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code>.  Por ejemplo,</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Complex</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">realpart</span><span class="p">,</span> <span class="n">imagpart</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">realpart</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">imagpart</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Complex</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">i</span>
<span class="go">(3.0, -4.5)</span>
</pre></div>
</div>
</section>
<section id="instance-objects">
<span id="tut-instanceobjects"></span><h3><span class="section-number">9.3.3. </span>Objetos instancia<a class="headerlink" href="#instance-objects" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Ahora, ¿Qué podemos hacer con los objetos instancia?  La única operación que es entendida por los objetos instancia es la referencia de atributos.  Hay dos tipos de nombres de atributos válidos, atributos de datos y métodos.</p>
<p>Los <em>atributos de datos</em> se corresponden con las «variables de instancia» en Smalltalk, y con las «variables miembro» en C++.  Los atributos de datos no necesitan ser declarados; tal como las variables locales son creados la primera vez que se les asigna algo.  Por ejemplo, si <code class="docutils literal notranslate"><span class="pre">x</span></code> es la instancia de <code class="xref py py-class docutils literal notranslate"><span class="pre">MiClase</span></code> creada más arriba, el siguiente pedazo de código va a imprimir el valor <code class="docutils literal notranslate"><span class="pre">16</span></code>, sin dejar ningún rastro:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
    <span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">counter</span> <span class="o">*</span> <span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">counter</span><span class="p">)</span>
<span class="k">del</span> <span class="n">x</span><span class="o">.</span><span class="n">counter</span>
</pre></div>
</div>
<p>El otro tipo de atributo de instancia es el <em>método</em>.  Un método es una función que «pertenece a» un objeto.  En Python, el término método no está limitado a instancias de clase: otros tipos de objetos pueden tener métodos también.  Por ejemplo, los objetos lista tienen métodos llamados append, insert, remove, sort, y así sucesivamente.  Pero, en la siguiente explicación, usaremos el término método para referirnos exclusivamente a métodos de objetos instancia de clase, a menos que se especifique explícitamente lo contrario.</p>
<p id="index-0">Los nombres válidos de métodos de un objeto instancia dependen de su clase. Por definición, todos los atributos de clase que son objetos funciones definen métodos correspondientes de sus instancias.  Entonces, en nuestro ejemplo, <code class="docutils literal notranslate"><span class="pre">x.f</span></code> es una referencia a un método válido, dado que <code class="docutils literal notranslate"><span class="pre">MiClase.f</span></code> es una función, pero <code class="docutils literal notranslate"><span class="pre">x.i</span></code> no lo es, dado que <code class="docutils literal notranslate"><span class="pre">MiClase.i</span></code> no lo es.  Pero <code class="docutils literal notranslate"><span class="pre">x.f</span></code> no es la misma cosa que <code class="docutils literal notranslate"><span class="pre">MiClase.f</span></code>; es un <em>objeto método</em>, no un objeto función.</p>
</section>
<section id="method-objects">
<span id="tut-methodobjects"></span><h3><span class="section-number">9.3.4. </span>Objetos método<a class="headerlink" href="#method-objects" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Generalmente, un método es llamado luego de ser vinculado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
<p>En el ejemplo <code class="xref py py-class docutils literal notranslate"><span class="pre">MiClase</span></code>, esto retorna la cadena <code class="docutils literal notranslate"><span class="pre">'hola</span> <span class="pre">mundo'</span></code>. Pero no es necesario llamar al método justo en ese momento: <code class="docutils literal notranslate"><span class="pre">x.f</span></code> es un objeto método, y puede ser guardado y llamado más tarde.  Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">xf</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">f</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">xf</span><span class="p">())</span>
</pre></div>
</div>
<p>…continuará imprimiendo <code class="docutils literal notranslate"><span class="pre">hola</span> <span class="pre">mundo</span></code> hasta el fin de los días.</p>
<p>¿Qué sucede exactamente cuando un método es llamado?  Debés haber notado que <code class="docutils literal notranslate"><span class="pre">x.f()</span></code> fue llamado más arriba sin ningún argumento, a pesar de que la definición de función de <code class="xref py py-meth docutils literal notranslate"><span class="pre">f()</span></code> especificaba un argumento.  ¿Qué pasó con ese argumento?  Seguramente Python lanza una excepción cuando una función que requiere un argumento es llamada sin ninguno, aún si el argumento no es utilizado…</p>
<p>De hecho, tal vez hayas adivinado la respuesta: lo que tienen de especial los métodos es que el objeto es pasado como el primer argumento de la función. En nuestro ejemplo, la llamada <code class="docutils literal notranslate"><span class="pre">x.f()</span></code> es exactamente equivalente a <code class="docutils literal notranslate"><span class="pre">MiClase.f(x)</span></code>.  En general, llamar a un método con una lista de <em>n</em> argumentos es equivalente a llamar a la función correspondiente con una lista de argumentos que es creada insertando el objeto del método antes del primer argumento.</p>
<p>Si todavía no entiendes como funcionan los métodos, una mirada a su implementación quizás pueda aclarar dudas. Cuando un atributo sin datos de una instancia es referenciado, la clase de la instancia es accedida. Si el nombre indica un atributo de clase válido que sea un objeto función, se crea un objeto método empaquetando (apunta a) la instancia y al objeto función, juntados en un objeto abstracto: este es el objeto método. Cuando el objeto método es llamado con una lista de argumentos, se crea una nueva lista de argumentos a partir del objeto instancia y la lista de argumentos. Finalmente el objeto función es llamado con esta nueva lista de argumentos.</p>
</section>
<section id="class-and-instance-variables">
<span id="tut-class-and-instance-variables"></span><h3><span class="section-number">9.3.5. </span>Variables de clase y de instancia<a class="headerlink" href="#class-and-instance-variables" title="Enlazar permanentemente con este título">¶</a></h3>
<p>En general, las variables de instancia son para datos únicos de cada instancia y las variables de clase son para atributos y métodos compartidos por todas las instancias de la clase:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dog</span><span class="p">:</span>

    <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;canine&#39;</span>         <span class="c1"># class variable shared by all instances</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>    <span class="c1"># instance variable unique to each instance</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Fido&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Buddy&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">kind</span>                  <span class="c1"># shared by all dogs</span>
<span class="s1">&#39;canine&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">kind</span>                  <span class="c1"># shared by all dogs</span>
<span class="s1">&#39;canine&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span>                  <span class="c1"># unique to d</span>
<span class="s1">&#39;Fido&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">name</span>                  <span class="c1"># unique to e</span>
<span class="s1">&#39;Buddy&#39;</span>
</pre></div>
</div>
<p>Como se vio en <a class="reference internal" href="#tut-object"><span class="std std-ref">Unas palabras sobre nombres y objetos</span></a>, los datos compartidos pueden tener efectos inesperados que involucren objetos <a class="reference internal" href="../glossary.html#term-mutable"><span class="xref std std-term">mutable</span></a> como ser listas y diccionarios. Por ejemplo, la lista <em>trucos</em> en el siguiente código no debería ser usada como variable de clase porque una sola lista sería compartida por todos las instancias de <em>Perro</em>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dog</span><span class="p">:</span>

    <span class="n">tricks</span> <span class="o">=</span> <span class="p">[]</span>             <span class="c1"># mistaken use of a class variable</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">add_trick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trick</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tricks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trick</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Fido&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Buddy&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">add_trick</span><span class="p">(</span><span class="s1">&#39;roll over&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">add_trick</span><span class="p">(</span><span class="s1">&#39;play dead&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">tricks</span>                <span class="c1"># unexpectedly shared by all dogs</span>
<span class="p">[</span><span class="s1">&#39;roll over&#39;</span><span class="p">,</span> <span class="s1">&#39;play dead&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>El diseño correcto de esta clase sería usando una variable de instancia:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dog</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tricks</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c1"># creates a new empty list for each dog</span>

    <span class="k">def</span> <span class="nf">add_trick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trick</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tricks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trick</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Fido&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">(</span><span class="s1">&#39;Buddy&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">add_trick</span><span class="p">(</span><span class="s1">&#39;roll over&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">add_trick</span><span class="p">(</span><span class="s1">&#39;play dead&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">tricks</span>
<span class="p">[</span><span class="s1">&#39;roll over&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">tricks</span>
<span class="p">[</span><span class="s1">&#39;play dead&#39;</span><span class="p">]</span>
</pre></div>
</div>
</section>
</section>
<section id="random-remarks">
<span id="tut-remarks"></span><h2><span class="section-number">9.4. </span>Algunas observaciones<a class="headerlink" href="#random-remarks" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Si el mismo nombre de atributo aparece tanto en la instancia como en la clase, la búsqueda del atributo prioriza la instancia:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Warehouse</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">purpose</span> <span class="o">=</span> <span class="s1">&#39;storage&#39;</span>
<span class="gp">... </span>   <span class="n">region</span> <span class="o">=</span> <span class="s1">&#39;west&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w1</span> <span class="o">=</span> <span class="n">Warehouse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">w1</span><span class="o">.</span><span class="n">purpose</span><span class="p">,</span> <span class="n">w1</span><span class="o">.</span><span class="n">region</span><span class="p">)</span>
<span class="go">storage west</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w2</span> <span class="o">=</span> <span class="n">Warehouse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w2</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="s1">&#39;east&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">w2</span><span class="o">.</span><span class="n">purpose</span><span class="p">,</span> <span class="n">w2</span><span class="o">.</span><span class="n">region</span><span class="p">)</span>
<span class="go">storage east</span>
</pre></div>
</div>
<p>A los atributos de datos los pueden hacer referencia tanto los métodos como los usuarios («clientes») ordinarios de un objeto.  En otras palabras, las clases no se usan para implementar tipos de datos abstractos puros.  De hecho, en Python no hay nada que haga cumplir el ocultar datos; todo se basa en convención.  (Por otro lado, la implementación de Python, escrita en C, puede ocultar por completo detalles de implementación y el control de acceso a un objeto si es necesario; esto se puede usar en extensiones a Python escritas en C.)</p>
<p>Los clientes deben usar los atributos de datos con cuidado; éstos pueden romper invariantes que mantienen los métodos si pisan los atributos de datos. Observá que los clientes pueden añadir sus propios atributos de datos a una instancia sin afectar la validez de sus métodos, siempre y cuando se eviten conflictos de nombres; de nuevo, una convención de nombres puede ahorrar un montón de dolores de cabeza.</p>
<p>No hay un atajo para hacer referencia a atributos de datos (¡u otros métodos!) desde dentro de un método.  A mi parecer, esto en realidad aumenta la legibilidad de los métodos: no existe posibilidad alguna de confundir variables locales con variables de instancia cuando repasamos un método.</p>
<p>A menudo, el primer argumento de un método se llama <code class="docutils literal notranslate"><span class="pre">self</span></code> (uno mismo).  Esto no es nada más que una convención: el nombre <code class="docutils literal notranslate"><span class="pre">self</span></code> no significa nada en especial para Python.  Observá que, sin embargo, si no seguís la convención tu código puede resultar menos legible a otros programadores de Python, y puede llegar a pasar que un programa <em>navegador de clases</em> pueda escribirse de una manera que dependa de dicha convención.</p>
<p>Cualquier objeto función que es un atributo de clase define un método para instancias de esa clase.  No es necesario que el la definición de la función esté textualmente dentro de la definición de la clase: asignando un objeto función a una variable local en la clase también está bien.  Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Function defined outside the class</span>
<span class="k">def</span> <span class="nf">f1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">f1</span>

    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">g</span>
</pre></div>
</div>
<p>Ahora <code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">g</span></code> y <code class="docutils literal notranslate"><span class="pre">h</span></code> son todos atributos de la clase <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> que hacen referencia a objetos función, y consecuentemente son todos métodos de las instancias de <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>; <code class="docutils literal notranslate"><span class="pre">h</span></code> siendo exactamente equivalente a <code class="docutils literal notranslate"><span class="pre">g</span></code>. Fijate que esta práctica normalmente sólo sirve para confundir al que lea un programa.</p>
<p>Los métodos pueden llamar a otros métodos de la instancia usando el argumento <code class="docutils literal notranslate"><span class="pre">self</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Bag</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">addtwice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Los métodos pueden hacer referencia a nombres globales de la misma manera que lo hacen las funciones comunes.  El ámbito global asociado a un método es el módulo que contiene su definición.  (Una clase nunca se usa como un ámbito global.)  Si bien es raro encontrar una buena razón para usar datos globales en un método, hay muchos usos legítimos del ámbito global: por lo menos, las funciones y módulos importados en el ámbito global pueden usarse por los métodos, al igual que las funciones y clases definidas en él. Habitualmente, la clase que contiene el método está definida en este ámbito global, y en la siguiente sección veremos algunas buenas razones por las que un método querría hacer referencia a su propia clase.</p>
<p>Todo valor es un objeto, y por lo tanto tiene una <em>clase</em> (también llamado su <em>tipo</em>). Ésta se almacena como <code class="docutils literal notranslate"><span class="pre">objeto.__class__</span></code>.</p>
</section>
<section id="inheritance">
<span id="tut-inheritance"></span><h2><span class="section-number">9.5. </span>Herencia<a class="headerlink" href="#inheritance" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Por supuesto, una característica del lenguaje no sería digna del nombre «clase» si no soportara herencia.  La sintaxis para una definición de clase derivada se ve así:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DerivedClassName</span><span class="p">(</span><span class="n">BaseClassName</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="n">N</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>El nombre <code class="xref py py-class docutils literal notranslate"><span class="pre">ClaseBase</span></code> debe estar definido en un ámbito que contenga a la definición de la clase derivada.  En el lugar del nombre de la clase base se permiten otras expresiones arbitrarias.  Esto puede ser útil, por ejemplo, cuando la clase base está definida en otro módulo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DerivedClassName</span><span class="p">(</span><span class="n">modname</span><span class="o">.</span><span class="n">BaseClassName</span><span class="p">):</span>
</pre></div>
</div>
<p>La ejecución de una definición de clase derivada procede de la misma forma que una clase base.  Cuando el objeto clase se construye, se tiene en cuenta a la clase base.  Esto se usa para resolver referencias a atributos: si un atributo solicitado no se encuentra en la clase, la búsqueda continúa por la clase base. Esta regla se aplica recursivamente si la clase base misma deriva de alguna otra clase.</p>
<p>No hay nada en especial en la instanciación de clases derivadas: <code class="docutils literal notranslate"><span class="pre">ClaseDerivada()</span></code> crea una nueva instancia de la clase.  Las referencias a métodos se resuelven de la siguiente manera: se busca el atributo de clase correspondiente, descendiendo por la cadena de clases base si es necesario, y la referencia al método es válida si se entrega un objeto función.</p>
<p>Las clases derivadas pueden redefinir métodos de su clase base.  Como los métodos no tienen privilegios especiales cuando llaman a otros métodos del mismo objeto, un método de la clase base que llame a otro método definido en la misma clase base puede terminar llamando a un método de la clase derivada que lo haya redefinido.  (Para los programadores de C++: en Python todos los métodos son en efecto <code class="docutils literal notranslate"><span class="pre">virtuales</span></code>.)</p>
<p>Un método redefinido en una clase derivada puede de hecho querer extender en vez de simplemente reemplazar al método de la clase base con el mismo nombre. Hay una manera simple de llamar al método de la clase base directamente: simplemente llamás a <code class="docutils literal notranslate"><span class="pre">ClaseBase.metodo(self,</span> <span class="pre">argumentos)</span></code>.  En ocasiones esto es útil para los clientes también.  (Observá que esto sólo funciona si la clase base es accesible como <code class="docutils literal notranslate"><span class="pre">ClaseBase</span></code> en el ámbito global.)</p>
<p>Python tiene dos funciones integradas que funcionan con herencia:</p>
<ul class="simple">
<li><p>Usar <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> para verificar el tipo de una instancia: <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">int)</span></code> será <code class="docutils literal notranslate"><span class="pre">True</span></code> sólo si <code class="docutils literal notranslate"><span class="pre">obj.__class__</span></code> es <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> o alguna clase derivada de <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>.</p></li>
<li><p>Usar <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> para verificar la herencia de clases: <code class="docutils literal notranslate"><span class="pre">issubclass(bool,</span> <span class="pre">int)</span></code> es <code class="docutils literal notranslate"><span class="pre">True</span></code> ya que <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> es una subclase de <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>. Sin embargo, <code class="docutils literal notranslate"><span class="pre">issubclass(float,</span> <span class="pre">int)</span></code> es <code class="docutils literal notranslate"><span class="pre">False</span></code> ya que <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> no es una subclase de <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>.</p></li>
</ul>
<section id="multiple-inheritance">
<span id="tut-multiple"></span><h3><span class="section-number">9.5.1. </span>Herencia múltiple<a class="headerlink" href="#multiple-inheritance" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Python también soporta una forma de herencia múltiple.  Una definición de clase con múltiples clases base se ve así:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DerivedClassName</span><span class="p">(</span><span class="n">Base1</span><span class="p">,</span> <span class="n">Base2</span><span class="p">,</span> <span class="n">Base3</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">.</span>
    <span class="o">&lt;</span><span class="n">statement</span><span class="o">-</span><span class="n">N</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Para la mayoría de los propósitos, en los casos más simples, podés pensar en la búsqueda de los atributos heredados de clases padres como primero en profundidad, de izquierda a derecha, sin repetir la misma clase cuando está dos veces en la jerarquía.  Por lo tanto, si un atributo no se encuentra en <code class="xref py py-class docutils literal notranslate"><span class="pre">ClaseDerivada</span></code>, se busca en <code class="xref py py-class docutils literal notranslate"><span class="pre">Base1</span></code>, luego (recursivamente) en las clases base de <code class="xref py py-class docutils literal notranslate"><span class="pre">Base1</span></code>, y sólo si no se encuentra allí se lo busca en <code class="xref py py-class docutils literal notranslate"><span class="pre">Base2</span></code>, y así sucesivamente.</p>
<p>En realidad es un poco más complejo que eso; el orden de resolución de métodos cambia dinámicamente para soportar las llamadas cooperativas a <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a>.  Este enfoque es conocido en otros lenguajes con herencia múltiple como «llámese al siguiente método» y es más poderoso que la llamada al superior que se encuentra en lenguajes con sólo herencia simple.</p>
<p>El ordenamiento dinámico es necesario porque todos los casos de herencia múltiple exhiben una o más relaciones en diamante (cuando se puede llegar al menos a una de las clases base por distintos caminos desde la clase de más abajo).  Por ejemplo, todas las clases heredan de <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>, por lo tanto cualquier caso de herencia múltiple provee más de un camino para llegar a <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>.  Para que las clases base no sean accedidas más de una vez, el algoritmo dinámico hace lineal el orden de búsqueda de manera que se preserve el orden de izquierda a derecha especificado en cada clase, que se llame a cada clase base sólo una vez, y que sea monótona (lo cual significa que una clase puede tener clases derivadas sin afectar el orden de precedencia de sus clases bases).  En conjunto, estas propiedades hacen posible diseñar clases confiables y extensibles con herencia múltiple. Para más detalles mirá  <a class="reference external" href="https://www.python.org/download/releases/2.3/mro/">https://www.python.org/download/releases/2.3/mro/</a>.</p>
</section>
</section>
<section id="private-variables">
<span id="tut-private"></span><h2><span class="section-number">9.6. </span>Variables privadas<a class="headerlink" href="#private-variables" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las variables «privadas» de instancia, que no pueden accederse excepto desde dentro de un objeto, no existen en Python.  Sin embargo, hay una convención que se sigue en la mayoría del código Python: un nombre prefijado con un guión bajo (por ejemplo, <code class="docutils literal notranslate"><span class="pre">_spam</span></code>) debería tratarse como una parte no pública de la API (más allá de que sea una función, un método, o un dato).  Debería considerarse un detalle de implementación y que está sujeto a cambios sin aviso.</p>
<p id="index-1">Ya que hay un caso de uso válido para los identificadores privados de clase (a saber: colisión de nombres con nombres definidos en las subclases), hay un soporte limitado para este mecanismo.  Cualquier identificador con la forma <code class="docutils literal notranslate"><span class="pre">__spam</span></code> (al menos dos guiones bajos al principio, como mucho un guión bajo al final) es textualmente reemplazado por <code class="docutils literal notranslate"><span class="pre">_nombredeclase__spam</span></code>, donde <code class="docutils literal notranslate"><span class="pre">nombredeclase</span></code> es el nombre de clase actual al que se le sacan guiones bajos del comienzo (si los tuviera).  Se modifica el nombre del identificador sin importar su posición sintáctica, siempre y cuando ocurra dentro de la definición de una clase.</p>
<p>La modificación de nombres es útil para dejar que las subclases sobreescriban los métodos sin romper las llamadas a los métodos desde la misma clase.  Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mapping</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__update</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">items_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="n">__update</span> <span class="o">=</span> <span class="n">update</span>   <span class="c1"># private copy of original update() method</span>

<span class="k">class</span> <span class="nc">MappingSubclass</span><span class="p">(</span><span class="n">Mapping</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="c1"># provides new signature for update()</span>
        <span class="c1"># but does not break __init__()</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">items_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</pre></div>
</div>
<p>El ejemplo de arriba funcionaría incluso si <code class="docutils literal notranslate"><span class="pre">MappingSubclass</span></code> introdujera un identificador <code class="docutils literal notranslate"><span class="pre">__update</span></code> ya que se reemplaza con <code class="docutils literal notranslate"><span class="pre">_Mapping__update</span></code> en la clase <code class="docutils literal notranslate"><span class="pre">Mapping</span></code>  y <code class="docutils literal notranslate"><span class="pre">_MappingSubclass__update</span></code> en la clase <code class="docutils literal notranslate"><span class="pre">MappingSubclass</span></code> respectivamente.</p>
<p>Hay que aclarar que las reglas de modificación de nombres están diseñadas principalmente para evitar accidentes; es posible acceder o modificar una variable que es considerada como privada.  Esto hasta puede resultar útil en circunstancias especiales, tales como en el depurador.</p>
<p>Notar que el código pasado a <code class="docutils literal notranslate"><span class="pre">exec</span></code> o <code class="docutils literal notranslate"><span class="pre">eval()</span></code> no considera que el nombre de clase de la clase que invoca sea la clase actual; esto es similar al efecto de la sentencia <code class="docutils literal notranslate"><span class="pre">global</span></code>, efecto que es de similar manera restringido a código que es compilado en conjunto.  La misma restricción aplica a <code class="docutils literal notranslate"><span class="pre">getattr()</span></code>, <code class="docutils literal notranslate"><span class="pre">setattr()</span></code> y <code class="docutils literal notranslate"><span class="pre">delattr()</span></code>, así como cuando se referencia a <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> directamente.</p>
</section>
<section id="odds-and-ends">
<span id="tut-odds"></span><h2><span class="section-number">9.7. </span>Cambalache<a class="headerlink" href="#odds-and-ends" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Sometimes it is useful to have a data type similar to the Pascal «record» or C
«struct», bundling together a few named data items. The idiomatic approach
is to use <a class="reference internal" href="../library/dataclasses.html#module-dataclasses" title="dataclasses: Generate special methods on user-defined classes."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dataclasses</span></code></a> for this purpose:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Employee</span><span class="p">:</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">dept</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">salary</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">john</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="s1">&#39;john&#39;</span><span class="p">,</span> <span class="s1">&#39;computer lab&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">john</span><span class="o">.</span><span class="n">dept</span>
<span class="go">&#39;computer lab&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">john</span><span class="o">.</span><span class="n">salary</span>
<span class="go">1000</span>
</pre></div>
</div>
<p>Algún código Python que espera un tipo abstracto de datos en particular puede frecuentemente recibir en cambio una clase que emula los métodos de aquel tipo de datos.  Por ejemplo, si tenés una función que formatea algunos datos a partir de un objeto archivo, podés definir una clase con métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code> que obtengan los datos de alguna cadena en memoria intermedia, y pasarlo como argumento.</p>
<p>Los objetos método de instancia tienen atributos también: <code class="docutils literal notranslate"><span class="pre">m.__self__</span></code> es el objeto instancia con el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">m()</span></code>, y <code class="docutils literal notranslate"><span class="pre">m.__func__</span></code> es el objeto función correspondiente al método.</p>
</section>
<section id="iterators">
<span id="tut-iterators"></span><h2><span class="section-number">9.8. </span>Iteradores<a class="headerlink" href="#iterators" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Es probable que hayas notado que la mayoría de los objetos contenedores pueden ser recorridos usando una sentencia <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;one&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">}:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="s2">&quot;123&quot;</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;myfile.txt&quot;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Este estilo de acceso es limpio, conciso y conveniente.  El uso de iteradores está impregnado y unifica a Python.  En bambalinas, la sentencia <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> llama a <a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> en el objeto contenedor.  La función retorna un objeto iterador que define el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code> que accede elementos en el contenedor de a uno por vez.  Cuando no hay más elementos, <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> lanza una excepción <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> que le avisa al bucle del <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> que hay que terminar.  Podés llamar al método <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> usando la función integrada <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a>; este ejemplo muestra como funciona todo esto:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span>
<span class="go">&lt;str_iterator object at 0x10c90e650&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">&#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">&#39;c&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
    <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<p>Habiendo visto la mecánica del protocolo de iteración, es fácil agregar comportamiento de iterador a tus clases.  Definí un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> que retorne un objeto con un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code>.  Si la clase define <code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code>, entonces alcanza con que <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> retorne <code class="docutils literal notranslate"><span class="pre">self</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Reverse</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Iterator for looping over a sequence backwards.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rev</span> <span class="o">=</span> <span class="n">Reverse</span><span class="p">(</span><span class="s1">&#39;spam&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">iter</span><span class="p">(</span><span class="n">rev</span><span class="p">)</span>
<span class="go">&lt;__main__.Reverse object at 0x00A1DB50&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">rev</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">m</span>
<span class="go">a</span>
<span class="go">p</span>
<span class="go">s</span>
</pre></div>
</div>
</section>
<section id="generators">
<span id="tut-generators"></span><h2><span class="section-number">9.9. </span>Generadores<a class="headerlink" href="#generators" title="Enlazar permanentemente con este título">¶</a></h2>
<p><a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">Generators</span></a> son una herramienta simple y poderosa para crear iteradores. Están escritas como funciones regulares pero usan la palabra clave <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> siempre que quieran retornar datos. Cada vez que se llama a <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a>, el generador se reanuda donde lo dejó (recuerda todos los valores de datos y qué instrucción se ejecutó por última vez). Un ejemplo muestra que los generadores pueden ser trivialmente fáciles de crear:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">reverse</span><span class="p">(</span><span class="s1">&#39;golf&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">f</span>
<span class="go">l</span>
<span class="go">o</span>
<span class="go">g</span>
</pre></div>
</div>
<p>Todo lo que puede ser hecho con generadores también puede ser hecho con iteradores basados en clases, como se describe en la sección anterior.  Lo que hace que los generadores sean tan compactos es que los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code> son creados automáticamente.</p>
<p>Otra característica clave es que las variables locales y el estado de la ejecución son guardados automáticamente entre llamadas.  Esto hace que la función sea más fácil de escribir y quede mucho más claro que hacerlo usando variables de instancia tales como <code class="docutils literal notranslate"><span class="pre">self.indice</span></code> y <code class="docutils literal notranslate"><span class="pre">self.datos</span></code>.</p>
<p>Además de la creación automática de métodos y el guardar el estado del programa, cuando los generadores terminan automáticamente lanzan <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>.  Combinadas, estas características facilitan la creación de iteradores, y hacen que no sea más esfuerzo que escribir una función regular.</p>
</section>
<section id="generator-expressions">
<span id="tut-genexps"></span><h2><span class="section-number">9.10. </span>Expresiones generadoras<a class="headerlink" href="#generator-expressions" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Algunos generadores simples pueden ser escritos de manera concisa como expresiones usando una sintaxis similar a las comprensiones de listas pero con paréntesis en lugar de corchetes. Estas expresiones están hechas para situaciones donde el generador es utilizado de inmediato por la función que lo encierra. Las expresiones generadoras son más compactas pero menos versátiles que las definiciones completas de generadores y tienden a ser más amigables con la memoria que sus comprensiones de listas equivalentes.</p>
<p>Ejemplos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>                 <span class="c1"># sum of squares</span>
<span class="go">285</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">xvec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yvec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xvec</span><span class="p">,</span> <span class="n">yvec</span><span class="p">))</span>         <span class="c1"># dot product</span>
<span class="go">260</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">unique_words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">word</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">page</span>  <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">valedictorian</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">student</span><span class="o">.</span><span class="n">gpa</span><span class="p">,</span> <span class="n">student</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">student</span> <span class="ow">in</span> <span class="n">graduates</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;golf&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[&#39;f&#39;, &#39;l&#39;, &#39;o&#39;, &#39;g&#39;]</span>
</pre></div>
</div>
<p class="rubric">Notas al pie</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Excepto por una cosa. Los objetos módulo tienen un atributo de sólo lectura secreto llamado <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> que retorna el diccionario usado para implementar el espacio de nombres del módulo; el nombre <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> es un atributo pero no un nombre global. Obviamente, usar esto viola la abstracción de la implementación del espacio de nombres, y debería ser restringido a cosas como depuradores post-mortem.</p>
</dd>
</dl>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#">9. Clases</a><ul>
<li><a class="reference internal" href="#a-word-about-names-and-objects">9.1. Unas palabras sobre nombres y objetos</a></li>
<li><a class="reference internal" href="#python-scopes-and-namespaces">9.2. Ámbitos y espacios de nombres en Python</a><ul>
<li><a class="reference internal" href="#scopes-and-namespaces-example">9.2.1. Ejemplo de ámbitos y espacios de nombre</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-first-look-at-classes">9.3. Un primer vistazo a las clases</a><ul>
<li><a class="reference internal" href="#class-definition-syntax">9.3.1. Sintaxis de definición de clases</a></li>
<li><a class="reference internal" href="#class-objects">9.3.2. Objetos clase</a></li>
<li><a class="reference internal" href="#instance-objects">9.3.3. Objetos instancia</a></li>
<li><a class="reference internal" href="#method-objects">9.3.4. Objetos método</a></li>
<li><a class="reference internal" href="#class-and-instance-variables">9.3.5. Variables de clase y de instancia</a></li>
</ul>
</li>
<li><a class="reference internal" href="#random-remarks">9.4. Algunas observaciones</a></li>
<li><a class="reference internal" href="#inheritance">9.5. Herencia</a><ul>
<li><a class="reference internal" href="#multiple-inheritance">9.5.1. Herencia múltiple</a></li>
</ul>
</li>
<li><a class="reference internal" href="#private-variables">9.6. Variables privadas</a></li>
<li><a class="reference internal" href="#odds-and-ends">9.7. Cambalache</a></li>
<li><a class="reference internal" href="#iterators">9.8. Iteradores</a></li>
<li><a class="reference internal" href="#generators">9.9. Generadores</a></li>
<li><a class="reference internal" href="#generator-expressions">9.10. Expresiones generadoras</a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="errors.html"
                        title="capítulo anterior"><span class="section-number">8. </span>Errores y excepciones</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="stdlib.html"
                        title="próximo capítulo"><span class="section-number">10. </span>Pequeño paseo por la Biblioteca Estándar</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/tutorial/classes.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="stdlib.html" title="10. Pequeño paseo por la Biblioteca Estándar"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="errors.html" title="8. Errores y excepciones"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >El tutorial de Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">9. </span>Clases</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 27, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>