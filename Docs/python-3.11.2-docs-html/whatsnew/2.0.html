
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="Qué hay de nuevo en Python 2.0" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/whatsnew/2.0.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Autor, A.M. Kuchling y Moshe Zadka,. Introducción: El 16 de octubre de 2000 se publicó una nueva versión de Python, la 2.0. Este artículo cubre las emocionantes nuevas características de la 2.0, de..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Autor, A.M. Kuchling y Moshe Zadka,. Introducción: El 16 de octubre de 2000 se publicó una nueva versión de Python, la 2.0. Este artículo cubre las emocionantes nuevas características de la 2.0, de..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>Qué hay de nuevo en Python 2.0 &#8212; documentación de Python - 3.11.2</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=2d3badd06fe70b34b68db01f99471ce1624ffe4a" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.11.2"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="Registro de cambios" href="changelog.html" />
    <link rel="prev" title="Qué hay de nuevo en Python 2.1" href="2.1.html" />
    <link rel="canonical" href="https://docs.python.org/3/whatsnew/2.0.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">Qué hay de nuevo en Python 2.0</a><ul>
<li><a class="reference internal" href="#introduction">Introducción</a></li>
<li><a class="reference internal" href="#what-about-python-1-6">¿Qué pasa con Python 1.6?</a></li>
<li><a class="reference internal" href="#new-development-process">Nuevo proceso de desarrollo</a></li>
<li><a class="reference internal" href="#unicode">Unicode</a></li>
<li><a class="reference internal" href="#list-comprehensions">Comprensión de listas</a></li>
<li><a class="reference internal" href="#augmented-assignment">Asignación aumentada</a></li>
<li><a class="reference internal" href="#string-methods">Métodos de cadena de caracteres</a></li>
<li><a class="reference internal" href="#garbage-collection-of-cycles">Recogida de basura de los ciclos</a></li>
<li><a class="reference internal" href="#other-core-changes">Otros cambios en el núcleo</a><ul>
<li><a class="reference internal" href="#minor-language-changes">Cambios menores del lenguaje</a></li>
<li><a class="reference internal" href="#changes-to-built-in-functions">Cambios en las funciones incorporadas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#porting-to-2-0">Adaptación a la versión 2.0</a></li>
<li><a class="reference internal" href="#extending-embedding-changes">Extensión/Incorporación de cambios</a></li>
<li><a class="reference internal" href="#distutils-making-modules-easy-to-install">Distutils: Facilitando la instalación de módulos</a></li>
<li><a class="reference internal" href="#xml-modules">Módulos XML</a><ul>
<li><a class="reference internal" href="#sax2-support">Soporte de SAX2</a></li>
<li><a class="reference internal" href="#dom-support">Soporte DOM</a></li>
<li><a class="reference internal" href="#relationship-to-pyxml">Relación con PyXML</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-changes">Cambios en los módulos</a></li>
<li><a class="reference internal" href="#new-modules">Nuevos módulos</a></li>
<li><a class="reference internal" href="#idle-improvements">Mejoras en IDLE</a></li>
<li><a class="reference internal" href="#deleted-and-deprecated-modules">Módulos eliminados y obsoletos</a></li>
<li><a class="reference internal" href="#acknowledgements">Agradecimientos</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="2.1.html"
                          title="capítulo anterior">Qué hay de nuevo en Python 2.1</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="changelog.html"
                          title="próximo capítulo">Registro de cambios</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/whatsnew/2.0.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="changelog.html" title="Registro de cambios"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="2.1.html" title="Qué hay de nuevo en Python 2.1"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Qué hay de nuevo en Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Qué hay de nuevo en Python 2.0</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-2-0">
<h1>Qué hay de nuevo en Python 2.0<a class="headerlink" href="#what-s-new-in-python-2-0" title="Enlazar permanentemente con este título">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Autor</dt>
<dd class="field-odd"><p>A.M. Kuchling y Moshe Zadka</p>
</dd>
</dl>
<section id="introduction">
<h2>Introducción<a class="headerlink" href="#introduction" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El 16 de octubre de 2000 se publicó una nueva versión de Python, la 2.0. Este artículo cubre las emocionantes nuevas características de la 2.0, destaca algunos otros cambios útiles y señala algunos cambios incompatibles que pueden requerir reescribir el código.</p>
<p>El desarrollo de Python nunca se detiene por completo entre versiones, y siempre se envía un flujo constante de correcciones de errores y mejoras. Una gran cantidad de correcciones menores, algunas optimizaciones, cadenas de documentación adicionales y mejores mensajes de error entraron en 2.0; enumerarlos a todos sería imposible, pero ciertamente son significativos. Consulte los registros de CVS disponibles públicamente si desea ver la lista completa. Este progreso se debe a que a los cinco desarrolladores que trabajan para PythonLabs ahora se les paga por dedicar sus días a corregir errores, y también a la mejora de la comunicación resultante de la migración a SourceForge.</p>
</section>
<section id="what-about-python-1-6">
<h2>¿Qué pasa con Python 1.6?<a class="headerlink" href="#what-about-python-1-6" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Python 1.6 puede considerarse como la versión de Python de las Obligaciones Contractuales. Después de que el equipo principal de desarrollo dejara el CNRI en mayo de 2000, el CNRI pidió que se creara una versión 1.6 que contuviera todo el trabajo sobre Python que se había realizado en el CNRI. Por lo tanto, Python 1.6 representa el estado del árbol CVS en mayo de 2000, siendo la novedad más importante el soporte de Unicode. El desarrollo continuó después de mayo, por supuesto, así que el árbol 1.6 recibió algunas correcciones para asegurar que es compatible con Python 2.0. 1.Por lo tanto, la 6 es parte de la evolución de Python, y no una rama lateral.</p>
<p>Entonces, ¿deberías interesarte mucho por Python 1.6?  Probablemente no. Las versiones 1.6final y 2.0beta1 se publicaron el mismo día (5 de septiembre de 2000), y el plan es finalizar Python 2.0 en un mes más o menos. Si tienes aplicaciones que mantener, no parece que tenga mucho sentido romper cosas al pasar a la 1.6, arreglarlas, y luego tener otra ronda de roturas dentro de un mes al pasar a la 2.0; es mejor pasar directamente a la 2.0. La mayoría de las características realmente interesantes descritas en este documento sólo están en la 2.0, porque se hizo mucho trabajo entre mayo y septiembre.</p>
</section>
<section id="new-development-process">
<h2>Nuevo proceso de desarrollo<a class="headerlink" href="#new-development-process" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El cambio más importante en Python 2.0 puede que no sea en el código en absoluto, sino en la forma de desarrollar Python: en mayo de 2000 los desarrolladores de Python comenzaron a utilizar las herramientas puestas a disposición por SourceForge para almacenar el código fuente, rastrear los informes de errores y gestionar la cola de envíos de parches. Para informar de errores o enviar parches para Python 2.0, utilice las herramientas de seguimiento de errores y gestión de parches disponibles en la página del proyecto Python, situada en <a class="reference external" href="https://sourceforge.net/projects/python/">https://sourceforge.net/projects/python/</a>.</p>
<p>El más importante de los servicios alojados ahora en SourceForge es el árbol CVS de Python, el repositorio de versiones controladas que contiene el código fuente de Python. Anteriormente, había unas 7 personas que tenían acceso de escritura al árbol CVS, y todos los parches tenían que ser inspeccionados y comprobados por una de las personas de esta corta lista. Obviamente, esto no era muy escalable. Al trasladar el árbol CVS a SourceForge, fue posible conceder acceso de escritura a más personas; en septiembre de 2000 había 27 personas que podían revisar los cambios, un aumento de cuatro veces. Esto hace posible cambios a gran escala que no se intentarían si tuvieran que pasar por el pequeño grupo de desarrolladores del núcleo. Por ejemplo, un día a Peter Schneider-Kamp se le ocurrió dejar de lado la compatibilidad con K&amp;R C y convertir el código fuente de Python a ANSI C. Después de obtener la aprobación en la lista de correo de python-dev, se lanzó a una ráfaga de revisiones que duró aproximadamente una semana, otros desarrolladores se unieron para ayudar, y el trabajo estaba hecho. Si sólo hubiera habido 5 personas con acceso de escritura, probablemente esa tarea habría sido considerada como «agradable, pero no vale la pena el tiempo y el esfuerzo necesarios» y nunca se habría realizado.</p>
<p>El cambio al uso de los servicios de SourceForge ha dado lugar a un notable aumento de la velocidad de desarrollo. Ahora los parches se envían, se comentan, son revisados por otras personas además del remitente original, y van de un lado a otro hasta que se considera que el parche merece ser revisado. Los errores se rastrean en una ubicación central y se pueden asignar a una persona específica para que los corrija, y podemos contar el número de errores abiertos para medir el progreso. Esto no ha tenido un coste: los desarrolladores tienen ahora más correo electrónico con el que lidiar, más listas de correo que seguir, y se han tenido que escribir herramientas especiales para el nuevo entorno. Por ejemplo, SourceForge envía por defecto mensajes de correo electrónico de notificación de parches y errores que son completamente inútiles, por lo que Ka-Ping Yee escribió un raspador de pantalla HTML que envía mensajes más útiles.</p>
<p>La facilidad para añadir código provocó algunos problemas iniciales de crecimiento, como el hecho de que el código se registrara antes de estar listo o sin obtener un acuerdo claro del grupo de desarrolladores. El proceso de aprobación que ha surgido es algo similar al utilizado por el grupo Apache. Los desarrolladores pueden votar +1, +0, -0 o -1 sobre un parche; +1 y -1 denotan aceptación o rechazo, mientras que +0 y -0 significan que el desarrollador es mayormente indiferente al cambio, aunque con un ligero sesgo positivo o negativo. El cambio más significativo con respecto al modelo de Apache es que la votación es esencialmente consultiva, lo que permite a Guido van Rossum, que tiene el estatus de Dictador Benevolente Vitalicio, saber cuál es la opinión general. Puede seguir ignorando el resultado de una votación y aprobar o rechazar un cambio aunque la comunidad no esté de acuerdo con él.</p>
<p>Producir un parche real es el último paso en la adición de una nueva característica, y suele ser fácil en comparación con la tarea anterior de llegar a un buen diseño. Las discusiones sobre nuevas funcionalidades a menudo pueden explotar en largos hilos de la lista de correo, haciendo que la discusión sea difícil de seguir, y nadie puede leer todos los mensajes en python-dev. Por lo tanto, se ha establecido un proceso relativamente formal para escribir Propuestas de Mejora de Python (PEPs), siguiendo el modelo del proceso RFC de Internet. Las PEP son borradores de documentos que describen una nueva característica propuesta, y se revisan continuamente hasta que la comunidad llega a un consenso, aceptando o rechazando la propuesta. Cita de la introducción de <span class="target" id="index-8"></span><a class="pep reference external" href="https://peps.python.org/pep-0001/"><strong>PEP 1</strong></a>, «PEP Purpose and Guidelines»:</p>
<blockquote class="epigraph">
<div><p>PEP son las siglas de Python Enhancement Proposal. Un PEP es un documento de diseño que proporciona información a la comunidad de Python, o que describe una nueva característica para Python. El PEP debe proporcionar una especificación técnica concisa de la característica y una justificación de la misma.</p>
<p>Pretendemos que los PEPs sean los mecanismos principales para proponer nuevas características, para recoger las opiniones de la comunidad sobre un tema y para documentar las decisiones de diseño que se han tomado en Python. El autor del PEP es responsable de crear consenso dentro de la comunidad y de documentar las opiniones discrepantes.</p>
</div></blockquote>
<p>Lea el resto de <span class="target" id="index-9"></span><a class="pep reference external" href="https://peps.python.org/pep-0001/"><strong>PEP 1</strong></a> para conocer los detalles del proceso editorial, el estilo y el formato de PEP. Los PEP se mantienen en el árbol CVS de Python en SourceForge, aunque no forman parte de la distribución de Python 2.0 y también están disponibles en formato HTML en <a class="reference external" href="https://peps.python.org/">https://peps.python.org/</a>. A partir de septiembre de 2000, hay 25 PEPS, que van desde <span class="target" id="index-10"></span><a class="pep reference external" href="https://peps.python.org/pep-0201/"><strong>PEP 201</strong></a>, «Iteración Lockstep», hasta PEP 225, «Operadores de elementos/objetos».</p>
</section>
<section id="unicode">
<h2>Unicode<a class="headerlink" href="#unicode" title="Enlazar permanentemente con este título">¶</a></h2>
<p>La mayor novedad de Python 2.0 es un nuevo tipo de datos fundamental: Las cadenas Unicode. Unicode utiliza números de 16 bits para representar los caracteres en lugar de los 8 bits utilizados por ASCII, lo que significa que se pueden admitir 65.536 caracteres distintos.</p>
<p>La interfaz final para el soporte de Unicode se alcanzó a través de innumerables discusiones, a menudo tormentosas, en la lista de correo de python-dev, y fue implementada en su mayor parte por Marc-André Lemburg, basándose en una implementación del tipo de cadena Unicode de Fredrik Lundh. Una explicación detallada de la interfaz fue escrita como <span class="target" id="index-11"></span><a class="pep reference external" href="https://peps.python.org/pep-0100/"><strong>PEP 100</strong></a>, «Python Unicode Integration». Este artículo se limitará a cubrir los puntos más significativos de las interfaces Unicode.</p>
<p>En el código fuente de Python, las cadenas Unicode se escriben como <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">&quot;cadena&quot;</span></code>. Los caracteres Unicode arbitrarios pueden escribirse utilizando una nueva secuencia de escape, <code class="docutils literal notranslate"><span class="pre">uHHHH</span></code>, donde <em>HHHH</em> es un número hexadecimal de 4 dígitos desde 0000 hasta FFFF. También se puede utilizar la secuencia de escape existente <code class="docutils literal notranslate"><span class="pre">xHHHH</span></code>, y se pueden utilizar escapes octales para caracteres hasta U+01FF, que se representa con <code class="docutils literal notranslate"><span class="pre">777</span></code>.</p>
<p>Las cadenas Unicode, al igual que las cadenas normales, son un tipo de secuencia inmutable. Pueden ser indexadas y cortadas, pero no modificadas en su lugar. Las cadenas Unicode tienen un método <code class="docutils literal notranslate"><span class="pre">encode(</span> <span class="pre">[encoding]</span> <span class="pre">)</span></code> que retorna una cadena de 8 bits en la codificación deseada. Las codificaciones son nombradas por cadenas, como <code class="docutils literal notranslate"><span class="pre">'ascii'</span></code>, <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>, <code class="docutils literal notranslate"><span class="pre">'iso-8859-1'</span></code>, o lo que sea. Se define una API de códecs para implementar y registrar nuevas codificaciones que luego están disponibles en todo el programa Python. Si no se especifica una codificación, la codificación por defecto suele ser ASCII de 7 bits, aunque puede cambiarse para tu instalación de Python llamando a la función <code class="docutils literal notranslate"><span class="pre">sys.setdefaultencoding(encoding)</span></code> en una versión personalizada de <code class="file docutils literal notranslate"><span class="pre">site.py</span></code>.</p>
<p>La combinación de cadenas de 8 bits y Unicode siempre fuerza conversión a Unicode, utilizando la codificación ASCII por defecto; el resultado de <code class="docutils literal notranslate"><span class="pre">'a'</span> <span class="pre">+</span> <span class="pre">u'bc'</span></code> es <code class="docutils literal notranslate"><span class="pre">u'abc'</span></code>.</p>
<p>Se han añadido nuevas funciones incorporadas y se han modificado las existentes para que sean compatibles con Unicode:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">unichr(ch)</span></code> retorna una cadena Unicode de 1 carácter, que contiene el carácter <em>ch</em>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ord(u)</span></code>, donde <em>u</em> es una cadena regular o Unicode de 1 carácter, retorna el número del carácter como un entero.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unicode(string</span> <span class="pre">[,</span> <span class="pre">encoding]</span> <span class="pre">[,</span> <span class="pre">errors]</span> <span class="pre">)</span></code> crea una cadena Unicode a partir de una cadena de 8 bits. <code class="docutils literal notranslate"><span class="pre">encoding</span></code> es una cadena que nombra la codificación a utilizar. El parámetro <code class="docutils literal notranslate"><span class="pre">errors</span></code> especifica el tratamiento de los caracteres que no son válidos para la codificación actual; pasar <code class="docutils literal notranslate"><span class="pre">'strict</span></code> como valor hace que se lance una excepción en cualquier error de codificación, mientras que <code class="docutils literal notranslate"><span class="pre">'ignore</span></code> hace que los errores se ignoren silenciosamente y <code class="docutils literal notranslate"><span class="pre">'replace</span></code> utiliza U+FFFD, el carácter oficial de reemplazo, en caso de cualquier problema.</p></li>
<li><p>La sentencia <code class="docutils literal notranslate"><span class="pre">exec</span></code>, y varias funciones integradas como <code class="docutils literal notranslate"><span class="pre">eval()</span></code>, <code class="docutils literal notranslate"><span class="pre">getattr()</span></code>, y <code class="docutils literal notranslate"><span class="pre">setattr()</span></code> también aceptarán cadenas Unicode así como cadenas regulares. (Es posible que en el proceso de corrección de esto se hayan pasado por alto algunas funciones incorporadas; si encuentra una función incorporada que acepte cadenas pero que no acepte cadenas Unicode en absoluto, por favor, infórmelo como un error)</p></li>
</ul>
<p>Un nuevo módulo, <a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code></a>, proporciona una interfaz para las propiedades de los caracteres Unicode. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">unicodedata.category(u'A')</span></code> retorna la cadena de 2 caracteres “Lu”, la “L” denota que es una letra, y la “u” significa que es mayúscula. <code class="docutils literal notranslate"><span class="pre">unicodedata.bidirectional(u'\u0660')</span></code> retorna “AN”, lo que significa que U+0660 es un número árabe.</p>
<p>El módulo <a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> contiene funciones para buscar codificaciones existentes y registrar otras nuevas. A menos que quiera implementar una nueva codificación, lo más habitual es que utilice la función <code class="docutils literal notranslate"><span class="pre">codecs.lookup(encoding)</span></code>, que retorna una tupla de 4 elementos: <code class="docutils literal notranslate"><span class="pre">(encode_func,</span> <span class="pre">decode_func,</span> <span class="pre">stream_reader,</span> <span class="pre">stream_writer)</span></code>.</p>
<ul class="simple">
<li><p><em>encode_func</em> es una función que toma una cadena Unicode, y retorna una 2-tupla <code class="docutils literal notranslate"><span class="pre">(string,</span> <span class="pre">length)</span></code>. <em>string</em> es una cadena de 8 bits que contiene una porción (tal vez toda) de la cadena Unicode convertida a la codificación dada, y <em>longitud</em> indica la cantidad de cadena Unicode convertida.</p></li>
<li><p><em>decode_func</em> es lo opuesto a <em>encode_func</em>, tomando una cadena de 8 bits y retornando una 2-tupla <code class="docutils literal notranslate"><span class="pre">(ustring,</span> <span class="pre">length)</span></code>, que consiste en la cadena Unicode resultante <em>ustring</em> y el entero <em>length</em> que dice cuánto de la cadena de 8 bits se consumió.</p></li>
<li><p><em>stream_reader</em> es una clase que soporta la decodificación de la entrada de un flujo. <em>stream_reader(file_obj)</em> retorna un objeto que soporta los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code>, <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">readlines()</span></code>. Todos estos métodos traducirán desde la codificación dada y retornarán cadenas Unicode.</p></li>
<li><p><em>stream_writer</em>, de forma similar, es una clase que soporta la codificación de la salida a un flujo. <em>stream_writer(file_obj)</em> retorna un objeto que soporta los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">writelines()</span></code>. Estos métodos esperan cadenas Unicode, traduciéndolas a la codificación dada en la salida.</p></li>
</ul>
<p>Por ejemplo, el siguiente código escribe una cadena Unicode en un archivo, codificándola como UTF-8:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">codecs</span>

<span class="n">unistr</span> <span class="o">=</span> <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u0660\u2000</span><span class="s1">ab ...&#39;</span>

<span class="p">(</span><span class="n">UTF8_encode</span><span class="p">,</span> <span class="n">UTF8_decode</span><span class="p">,</span>
 <span class="n">UTF8_streamreader</span><span class="p">,</span> <span class="n">UTF8_streamwriter</span><span class="p">)</span> <span class="o">=</span> <span class="n">codecs</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="s1">&#39;UTF-8&#39;</span><span class="p">)</span>

<span class="n">output</span> <span class="o">=</span> <span class="n">UTF8_streamwriter</span><span class="p">(</span> <span class="nb">open</span><span class="p">(</span> <span class="s1">&#39;/tmp/output&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="p">)</span>
<span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span> <span class="n">unistr</span> <span class="p">)</span>
<span class="n">output</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>El siguiente código leería la entrada UTF-8 del archivo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">input</span> <span class="o">=</span> <span class="n">UTF8_streamreader</span><span class="p">(</span> <span class="nb">open</span><span class="p">(</span> <span class="s1">&#39;/tmp/output&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="p">)</span>
<span class="nb">print</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
<span class="nb">input</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>Las expresiones regulares compatibles con Unicode están disponibles a través del módulo <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a>, que tiene una nueva implementación subyacente llamada SRE escrita por Fredrik Lundh de Secret Labs AB.</p>
<p>Se ha añadido una opción de línea de comandos <code class="docutils literal notranslate"><span class="pre">-U</span></code> que hace que el compilador de Python interprete todos los literales de cadena como literales de cadena Unicode. Esta opción está pensada para ser utilizada en las pruebas y para asegurar el futuro de su código Python, ya que alguna versión futura de Python puede dejar de soportar cadenas de 8 bits y proporcionar sólo cadenas Unicode.</p>
</section>
<section id="list-comprehensions">
<h2>Comprensión de listas<a class="headerlink" href="#list-comprehensions" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las listas son un tipo de datos muy útil en Python, y muchos programas manipulan una lista en algún momento. Dos operaciones comunes en las listas son hacer un bucle sobre ellas, y escoger los elementos que cumplen un cierto criterio, o aplicar alguna función a cada elemento. Por ejemplo, dada una lista de cadenas, podrías querer sacar todas las cadenas que contengan una determinada subcadena, o quitar los espacios en blanco de cada línea.</p>
<p>Las funciones <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> y <a class="reference internal" href="../library/functions.html#filter" title="filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">filter()</span></code></a> existentes pueden usarse para este propósito, pero requieren una función como uno de sus argumentos. Esto está bien si hay una función incorporada que se puede pasar directamente, pero si no la hay, hay que crear una pequeña función para hacer el trabajo requerido, y las reglas de ámbito de Python hacen que el resultado sea feo si la pequeña función necesita información adicional. Tomemos el primer ejemplo del párrafo anterior, encontrar todas las cadenas de la lista que contienen una subcadena dada. Podrías escribir lo siguiente para hacerlo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Given the list L, make a list of all strings</span>
<span class="c1"># containing the substring S.</span>
<span class="n">sublist</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">substring</span><span class="o">=</span><span class="n">S</span><span class="p">:</span>
                     <span class="n">string</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">substring</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                  <span class="n">L</span><span class="p">)</span>
</pre></div>
</div>
<p>Debido a las reglas de ámbito de Python, se utiliza un argumento por defecto para que la función anónima creada por la expresión <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> sepa qué subcadena se está buscando. Las comprensiones de lista hacen esto más limpio:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sublist</span> <span class="o">=</span> <span class="p">[</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">L</span> <span class="k">if</span> <span class="n">string</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">]</span>
</pre></div>
</div>
<p>Las comprensiones de listas tienen la forma:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="n">expression</span> <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">sequence1</span>
             <span class="k">for</span> <span class="n">expr2</span> <span class="ow">in</span> <span class="n">sequence2</span> <span class="o">...</span>
             <span class="k">for</span> <span class="n">exprN</span> <span class="ow">in</span> <span class="n">sequenceN</span>
             <span class="k">if</span> <span class="n">condition</span> <span class="p">]</span>
</pre></div>
</div>
<p>Las cláusulas <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code>…<code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code> contienen las secuencias a iterar. Las secuencias no tienen por qué tener la misma longitud, ya que no se itera sobre ellas en paralelo, sino de izquierda a derecha; esto se explica más claramente en los párrafos siguientes. Los elementos de la lista generada serán los valores sucesivos de la <em>expresión</em>. La cláusula final <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> es opcional; si está presente, la <em>expresión</em> sólo se evalúa y se añade al resultado si la <em>condición</em> es verdadera.</p>
<p>Para dejar muy clara la semántica, una comprensión de lista equivale al siguiente código de Python:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">expr1</span> <span class="ow">in</span> <span class="n">sequence1</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">expr2</span> <span class="ow">in</span> <span class="n">sequence2</span><span class="p">:</span>
    <span class="o">...</span>
        <span class="k">for</span> <span class="n">exprN</span> <span class="ow">in</span> <span class="n">sequenceN</span><span class="p">:</span>
             <span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">):</span>
                  <span class="c1"># Append the value of</span>
                  <span class="c1"># the expression to the</span>
                  <span class="c1"># resulting list.</span>
</pre></div>
</div>
<p>Esto significa que cuando hay múltiples cláusulas <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code>…<code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code>, la lista resultante será igual al producto de las longitudes de todas las secuencias. Si tiene dos listas de longitud 3, la lista de salida tendrá 9 elementos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">seq1</span> <span class="o">=</span> <span class="s1">&#39;abc&#39;</span>
<span class="n">seq2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq1</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">]</span>
<span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<p>Para evitar introducir una ambigüedad en la gramática de Python, si <em>expresión</em> está creando una tupla, debe estar rodeada de paréntesis. La primera comprensión de la lista a continuación es un error de sintaxis, mientras que la segunda es correcta:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Syntax error</span>
<span class="p">[</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq1</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">]</span>
<span class="c1"># Correct</span>
<span class="p">[</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq1</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">]</span>
</pre></div>
</div>
<p>La idea de las comprensiones de listas procede originalmente del lenguaje de programación funcional Haskell (<a class="reference external" href="https://www.haskell.org">https://www.haskell.org</a>). Greg Ewing fue el que más abogó por añadirlas a Python y escribió el parche inicial de comprensión de listas, que luego se discutió durante un tiempo aparentemente interminable en la lista de correo de python-dev y se mantuvo actualizada por Skip Montanaro.</p>
</section>
<section id="augmented-assignment">
<h2>Asignación aumentada<a class="headerlink" href="#augmented-assignment" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los operadores de asignación aumentados, otra característica largamente solicitada, han sido añadidos a Python 2.0. Los operadores de asignación aumentados incluyen <code class="docutils literal notranslate"><span class="pre">+=</span></code>, <code class="docutils literal notranslate"><span class="pre">-=</span></code>, <code class="docutils literal notranslate"><span class="pre">*=</span></code>, etc. Por ejemplo, la sentencia <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">2</span></code> incrementa el valor de la variable <code class="docutils literal notranslate"><span class="pre">a</span></code> en 2, lo que equivale a la sentencia algo más larga <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">2</span></code>.</p>
<p>La lista completa de operadores de asignación soportados es <code class="docutils literal notranslate"><span class="pre">+=</span></code>, <code class="docutils literal notranslate"><span class="pre">-=</span></code>, <code class="docutils literal notranslate"><span class="pre">*=</span></code>, <code class="docutils literal notranslate"><span class="pre">/=</span></code>, <code class="docutils literal notranslate"><span class="pre">%=</span></code>, <code class="docutils literal notranslate"><span class="pre">**=</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>, <code class="docutils literal notranslate"><span class="pre">|=</span></code>, <code class="docutils literal notranslate"><span class="pre">^=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>, y <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>. Las clases de Python pueden anular los operadores de asignación aumentados definiendo métodos llamados <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__isub__()</span></code>, etc. Por ejemplo, la siguiente clase <code class="xref py py-class docutils literal notranslate"><span class="pre">Number</span></code> almacena un número y soporta el uso de += para crear una nueva instancia con un valor incrementado.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Number</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">increment</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Number</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">increment</span><span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="n">Number</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">n</span> <span class="o">+=</span> <span class="mi">3</span>
<span class="nb">print</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span>
</pre></div>
</div>
<p>El método especial <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code> es llamado con el valor del incremento, y debe retornar una nueva instancia con un valor adecuadamente modificado; este valor de retorno se vincula como el nuevo valor de la variable del lado izquierdo.</p>
<p>Los operadores de asignación aumentada se introdujeron por primera vez en el lenguaje de programación C, y la mayoría de los lenguajes derivados de C, como <strong class="program">awk</strong>, C++, Java, Perl y PHP también los soportan. El parche de asignación aumentada fue implementado por Thomas Wouters.</p>
</section>
<section id="string-methods">
<h2>Métodos de cadena de caracteres<a class="headerlink" href="#string-methods" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Hasta ahora, la funcionalidad de manipulación de cadenas de caracteres estaba en el módulo <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a>, que normalmente era un front-end para el módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">strop</span></code> escrito en C. La adición de Unicode supuso una dificultad para el módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">strop</span></code>, porque todas las funciones tendrían que ser reescritas para aceptar cadenas de 8 bits o Unicode. Para funciones como <code class="xref py py-func docutils literal notranslate"><span class="pre">string.replace()</span></code>, que toma 3 argumentos de cadena, eso significa ocho posibles permutaciones, y el correspondiente código complicado.</p>
<p>En cambio, Python 2.0 traslada el problema al tipo de cadena de caracteres, haciendo que la funcionalidad de manipulación de cadenas esté disponible a través de métodos tanto en cadenas de 8 bits como en cadenas Unicode.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;andrew&#39;</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
<span class="go">&#39;Andrew&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;hostname&#39;</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;os&#39;</span><span class="p">,</span> <span class="s1">&#39;linux&#39;</span><span class="p">)</span>
<span class="go">&#39;hlinuxtname&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;moshe&#39;</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;sh&#39;</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Una cosa que no ha cambiado, a pesar de una notable broma de April Fools, es que las cadenas de Python son inmutables. Así, los métodos de cadenas retornan cadenas nuevas, y no modifican la cadena sobre la que operan.</p>
<p>El antiguo módulo <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a> sigue existiendo por compatibilidad con el pasado, pero actúa principalmente como un front-end para los nuevos métodos de cadena de caracteres.</p>
<p>Dos métodos que no tienen paralelo en las versiones anteriores a la 2.0, aunque existieron en JPython durante bastante tiempo, son <code class="xref py py-meth docutils literal notranslate"><span class="pre">startswith()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">endswith()</span></code>. <code class="docutils literal notranslate"><span class="pre">s.startswith(t)</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">s[:len(t)]</span> <span class="pre">==</span> <span class="pre">t</span></code>, mientras que <code class="docutils literal notranslate"><span class="pre">s.endswith(t)</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">s[-len(t):]</span> <span class="pre">==</span> <span class="pre">t</span></code>.</p>
<p>Otro método que merece una mención especial es <code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code>. El método <code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code> de una cadena recibe un parámetro, una secuencia de cadenas, y es equivalente a la función <code class="xref py py-func docutils literal notranslate"><span class="pre">string.join()</span></code> del antiguo módulo <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a>, con los argumentos invertidos. En otras palabras, <code class="docutils literal notranslate"><span class="pre">s.join(seq)</span></code> es equivalente a la antigua <code class="docutils literal notranslate"><span class="pre">string.join(seq,</span> <span class="pre">s)</span></code>.</p>
</section>
<section id="garbage-collection-of-cycles">
<h2>Recogida de basura de los ciclos<a class="headerlink" href="#garbage-collection-of-cycles" title="Enlazar permanentemente con este título">¶</a></h2>
<p>La implementación en C de Python utiliza el conteo de referencias para implementar la recolección de basura. Cada objeto de Python mantiene un recuento del número de referencias que apuntan a sí mismo, y ajusta el recuento a medida que se crean o destruyen referencias. Una vez que el recuento de referencias llega a cero, el objeto deja de ser accesible, ya que es necesario tener una referencia a un objeto para acceder a él, y si el recuento es cero, ya no existen referencias.</p>
<p>El conteo de referencias tiene algunas propiedades agradables: es fácil de entender e implementar, y la implementación resultante es portable, bastante rápida, y reacciona bien con otras bibliotecas que implementan sus propios esquemas de manejo de memoria. El mayor problema del conteo de referencias es que a veces no se da cuenta de que los objetos ya no son accesibles, lo que provoca una fuga de memoria. Esto ocurre cuando hay ciclos de referencias.</p>
<p>Consideremos el ciclo más simple posible, una instancia de clase que tiene una referencia a sí misma:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">instance</span> <span class="o">=</span> <span class="n">SomeClass</span><span class="p">()</span>
<span class="n">instance</span><span class="o">.</span><span class="n">myself</span> <span class="o">=</span> <span class="n">instance</span>
</pre></div>
</div>
<p>Después de ejecutar las dos líneas de código anteriores, la cuenta de referencias de <code class="docutils literal notranslate"><span class="pre">instance</span></code> es 2; una referencia es de la variable llamada <code class="docutils literal notranslate"><span class="pre">'instance</span></code>, y la otra es del atributo <code class="docutils literal notranslate"><span class="pre">myself</span></code> de la instancia.</p>
<p>Si la siguiente línea de código es <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">instance</span></code>, ¿qué ocurre?  La cuenta de referencias de <code class="docutils literal notranslate"><span class="pre">instance</span></code> se reduce en 1, por lo que tiene una cuenta de referencias de 1; la referencia en el atributo <code class="docutils literal notranslate"><span class="pre">myself</span></code> sigue existiendo. Sin embargo, la instancia ya no es accesible a través del código de Python, y podría ser eliminada. Varios objetos pueden participar en un ciclo si tienen referencias entre sí, haciendo que todos los objetos se filtren.</p>
<p>Python 2.0 soluciona este problema ejecutando periódicamente un algoritmo de detección de ciclos que busca los ciclos inaccesibles y borra los objetos implicados. Un nuevo módulo <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> proporciona funciones para realizar una recolección de basura, obtener estadísticas de depuración y afinar los parámetros del recolector.</p>
<p>Ejecutar el algoritmo de detección de ciclos lleva algo de tiempo, y por lo tanto resultará en una sobrecarga adicional. Se espera que después de que hayamos adquirido experiencia con la recogida de ciclos al utilizar la versión 2.0, Python 2.1 sea capaz de minimizar la sobrecarga con un cuidadoso ajuste. Todavía no es obvio cuánto rendimiento se pierde, porque la evaluación comparativa de esto es difícil y depende crucialmente de la frecuencia con la que el programa crea y destruye objetos. La detección de ciclos puede ser desactivada cuando Python es compilado, si no puede permitirse ni siquiera una pequeña penalización de velocidad o sospecha que la recolección de ciclos es un error, especificando la opción <code class="xref std std-option docutils literal notranslate"><span class="pre">--without-cycle-gc</span></code> cuando se ejecuta el script <strong class="program">configure</strong>.</p>
<p>Varias personas abordaron este problema y contribuyeron a una solución. Una primera implementación del enfoque de detección de ciclos fue escrita por Toby Kelsey. El algoritmo actual fue sugerido por Eric Tiedemann durante una visita al CNRI, y Guido van Rossum y Neil Schemenauer escribieron dos implementaciones diferentes, que posteriormente fueron integradas por Neil. Muchas otras personas ofrecieron sugerencias a lo largo del camino; los archivos de marzo de 2000 de la lista de correo python-dev contienen la mayor parte de la discusión relevante, especialmente en los hilos titulados «Colección de ciclos de referencia para Python» y «Finalización de nuevo».</p>
</section>
<section id="other-core-changes">
<h2>Otros cambios en el núcleo<a class="headerlink" href="#other-core-changes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Se han realizado varios cambios menores en la sintaxis y las funciones incorporadas de Python. Ninguno de los cambios es de gran alcance, pero son conveniencias prácticas.</p>
<section id="minor-language-changes">
<h3>Cambios menores del lenguaje<a class="headerlink" href="#minor-language-changes" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Una nueva sintaxis hace más conveniente llamar a una función dada con una tupla de argumentos y/o un diccionario de argumentos de palabras clave. En Python 1.5 y anteriores, se utilizaba la función incorporada <code class="xref py py-func docutils literal notranslate"><span class="pre">apply()</span></code>: <code class="docutils literal notranslate"><span class="pre">apply(f,</span> <span class="pre">args,</span> <span class="pre">kw)</span></code> llama a la función <code class="xref py py-func docutils literal notranslate"><span class="pre">f()</span></code> con la tupla de argumentos <em>args</em> y los argumentos de palabras clave en el diccionario <em>kw</em>. <code class="xref py py-func docutils literal notranslate"><span class="pre">apply()</span></code> es lo mismo en 2.0, pero gracias a un parche de Greg Ewing, <code class="docutils literal notranslate"><span class="pre">f(*args,</span> <span class="pre">**kw)</span></code> es una forma más corta y clara de conseguir el mismo efecto. Esta sintaxis es simétrica con la sintaxis para definir funciones:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="c1"># args is a tuple of positional args,</span>
    <span class="c1"># kw is a dictionary of keyword args</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>La sentencia <code class="docutils literal notranslate"><span class="pre">print</span></code> puede ahora tener su salida dirigida a un objeto tipo archivo siguiendo a <code class="docutils literal notranslate"><span class="pre">print</span></code> con <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span> <span class="pre">archivo</span></code>, similar al operador de redirección en los shells de Unix. Antes había que utilizar el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> del objeto tipo archivo, que carece de la comodidad y simplicidad de <code class="docutils literal notranslate"><span class="pre">print</span></code>, o bien asignar un nuevo valor a <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> y luego restaurar el valor anterior. Para enviar la salida al error estándar, es mucho más fácil escribir esto:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="o">&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Warning: action field not supplied&quot;</span>
</pre></div>
</div>
<p>Ahora se puede cambiar el nombre de los módulos al importarlos, utilizando la sintaxis <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">module</span> <span class="pre">as</span> <span class="pre">name</span></code> o <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">name</span> <span class="pre">as</span> <span class="pre">othername</span></code>. El parche fue enviado por Thomas Wouters.</p>
<p>Un nuevo estilo de formato está disponible cuando se utiliza el operador <code class="docutils literal notranslate"><span class="pre">%</span></code>; “%r” insertará el <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> de su argumento. Esto también se añadió por consideraciones de simetría, esta vez por simetría con el estilo de formato existente “%s”, que inserta el <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> de su argumento. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">'%r</span> <span class="pre">%s'</span> <span class="pre">%</span> <span class="pre">('abc',</span> <span class="pre">'abc')</span></code> retorna una cadena que contiene <code class="docutils literal notranslate"><span class="pre">'abc'</span> <span class="pre">abc</span></code>.</p>
<p>Anteriormente no había forma de implementar una clase que sobrepasara el operador incorporado de Python <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> e implementara una versión personalizada.``obj in seq`` retorna verdadero si <em>obj</em> está presente en la secuencia <em>seq</em>; Python lo calcula simplemente probando cada índice de la secuencia hasta que se encuentra <em>obj</em> o se encuentra un <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>. Moshe Zadka ha contribuido con un parche que añade un método mágico <code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code> para proporcionar una implementación personalizada para <code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code>. Además, los nuevos objetos incorporados escritos en C pueden definir lo que <code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code> significa para ellos a través de una nueva ranura en el protocolo de secuencia.</p>
<p>Las versiones anteriores de Python utilizaban un algoritmo recursivo para borrar objetos. Las estructuras de datos muy anidadas podían hacer que el intérprete llenara la pila de C y se bloqueara; Christian Tismer reescribió la lógica de borrado para solucionar este problema. En una nota relacionada, la comparación de objetos recursivos se repite infinitamente y se bloquea; Jeremy Hylton reescribió el código para que no se bloquee, produciendo un resultado útil. Por ejemplo, después de este código:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>La comparación <code class="docutils literal notranslate"><span class="pre">a==b</span></code> retorna verdadero, porque las dos estructuras de datos recursivas son isomorfas. Véase el hilo «trashcan and PR#7» en los archivos de abril de 2000 de la lista de correo de python-dev para la discusión que condujo a esta implementación, y algunos enlaces relevantes útiles. Tenga en cuenta que las comparaciones ahora también pueden generar excepciones. En versiones anteriores de Python, una operación de comparación como <code class="docutils literal notranslate"><span class="pre">cmp(a,b)</span></code> siempre producía una respuesta, incluso si un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__cmp__()</span></code> definido por el usuario encontraba un error, ya que la excepción resultante simplemente se tragaba en silencio.</p>
<p>Se ha trabajado en la migración de Python a Windows de 64 bits en el procesador Itanium, principalmente por Trent Mick de ActiveState. (Confusamente, <code class="docutils literal notranslate"><span class="pre">sys.platform</span></code> sigue siendo <code class="docutils literal notranslate"><span class="pre">'win32'</span></code> en Win64 porque parece que, para facilitar la migración, MS Visual C++ trata el código como de 32 bits en Itanium). PythonWin también es compatible con Windows CE; consulte la página de Python CE en <a class="reference external" href="https://pythonce.sourceforge.net/">https://pythonce.sourceforge.net/</a> para obtener más información.</p>
<p>Otra plataforma nueva es Darwin/MacOS X; el soporte inicial para ella está en Python 2.0. La carga dinámica funciona, si se especifica «configure –with-dyld –with-suffix=.x». Consulte el README de la distribución de fuentes de Python para obtener más instrucciones.</p>
<p>Se ha intentado aliviar uno de los defectos de Python, la a menudo confusa excepción <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> cuando el código hace referencia a una variable local antes de que se le haya asignado un valor. Por ejemplo, el siguiente código lanza una excepción en la sentencia <code class="docutils literal notranslate"><span class="pre">print</span></code> tanto en 1.5.2 como en 2.0; en 1.5.2 se lanza una excepción <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a>, mientras que en 2.0 se lanza una nueva excepción <a class="reference internal" href="../library/exceptions.html#UnboundLocalError" title="UnboundLocalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnboundLocalError</span></code></a>. <a class="reference internal" href="../library/exceptions.html#UnboundLocalError" title="UnboundLocalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnboundLocalError</span></code></a> es una subclase de <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a>, así que cualquier código existente que espere que se lance <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> debería seguir funcionando.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="nb">print</span> <span class="s2">&quot;i=&quot;</span><span class="p">,</span><span class="n">i</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
<p>Se han introducido dos nuevas excepciones, <a class="reference internal" href="../library/exceptions.html#TabError" title="TabError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TabError</span></code></a> y <a class="reference internal" href="../library/exceptions.html#IndentationError" title="IndentationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndentationError</span></code></a>. Ambas son subclases de <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>, y se lanzan cuando el código Python se encuentra con una sangría incorrecta.</p>
</section>
<section id="changes-to-built-in-functions">
<h3>Cambios en las funciones incorporadas<a class="headerlink" href="#changes-to-built-in-functions" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Se ha añadido un nuevo built-in, <code class="docutils literal notranslate"><span class="pre">zip(seq1,</span> <span class="pre">seq2,</span> <span class="pre">...)</span></code>. <a class="reference internal" href="../library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> retorna una lista de tuplas donde cada tupla contiene el i-ésimo elemento de cada una de las secuencias del argumento. La diferencia entre <a class="reference internal" href="../library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> y <code class="docutils literal notranslate"><span class="pre">map(None,</span> <span class="pre">seq1,</span> <span class="pre">seq2)</span></code> es que <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> rellena las secuencias con <code class="docutils literal notranslate"><span class="pre">None</span></code> si las secuencias no tienen la misma longitud, mientras que <a class="reference internal" href="../library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> trunca la lista retornada a la longitud de la secuencia argumental más corta.</p>
<p>Las funciones <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> y <code class="xref py py-func docutils literal notranslate"><span class="pre">long()</span></code> aceptan ahora un parámetro «base» opcional cuando el primer argumento es una cadena. <code class="docutils literal notranslate"><span class="pre">int('123',</span> <span class="pre">10)</span></code> retorna 123, mientras que <code class="docutils literal notranslate"><span class="pre">int('123',</span> <span class="pre">16)</span></code> retorna 291. <code class="docutils literal notranslate"><span class="pre">int(123,</span> <span class="pre">16)</span></code> lanza una excepción <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> con el mensaje «no se puede convertir una cadena con base explícita».</p>
<p>Se ha añadido al módulo <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> una nueva variable que contiene información más detallada sobre la versión. <code class="docutils literal notranslate"><span class="pre">sys.version_info</span></code> es una tupla <code class="docutils literal notranslate"><span class="pre">(major,</span> <span class="pre">minor,</span> <span class="pre">micro,</span> <span class="pre">level,</span> <span class="pre">serial)</span></code> Por ejemplo, en una hipotética 2.0.1beta1, <code class="docutils literal notranslate"><span class="pre">sys.version_info</span></code> sería <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">'beta',</span> <span class="pre">1)</span></code>. <em>level</em> es una cadena como <code class="docutils literal notranslate"><span class="pre">&quot;alpha&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;beta&quot;</span></code>, o <code class="docutils literal notranslate"><span class="pre">&quot;final&quot;</span></code> para una versión final.</p>
<p>Los diccionarios tienen un nuevo y extraño método, <code class="docutils literal notranslate"><span class="pre">setdefault(key,</span> <span class="pre">default)</span></code>, que se comporta de forma similar al método <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code> existente. Sin embargo, si falta la clave, <code class="xref py py-meth docutils literal notranslate"><span class="pre">setdefault()</span></code> retorna el valor de <em>default</em> como haría <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code>, y también lo inserta en el diccionario como valor de <em>key</em>. Así, las siguientes líneas de código:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nb">dict</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span> <span class="n">key</span> <span class="p">):</span> <span class="k">return</span> <span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</pre></div>
</div>
<p>puede reducirse a una única sentencia <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">dict.setdefault(key,</span> <span class="pre">[])</span></code>.</p>
<p>El intérprete establece una profundidad de recursión máxima para atrapar la recursión desbocada antes de llenar la pila de C y causar un volcado del núcleo o GPF. Anteriormente este límite se fijaba cuando se compilaba Python, pero en la versión 2.0 la profundidad máxima de recursión puede leerse y modificarse usando <a class="reference internal" href="../library/sys.html#sys.getrecursionlimit" title="sys.getrecursionlimit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getrecursionlimit()</span></code></a> y <a class="reference internal" href="../library/sys.html#sys.setrecursionlimit" title="sys.setrecursionlimit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setrecursionlimit()</span></code></a>. El valor por defecto es 1000, y se puede encontrar un valor máximo aproximado para una plataforma determinada ejecutando un nuevo script, <code class="file docutils literal notranslate"><span class="pre">Misc/find_recursionlimit.py</span></code>.</p>
</section>
</section>
<section id="porting-to-2-0">
<h2>Adaptación a la versión 2.0<a class="headerlink" href="#porting-to-2-0" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las nuevas versiones de Python se esfuerzan por ser compatibles con las anteriores, y el historial ha sido bastante bueno. Sin embargo, algunos cambios se consideran lo suficientemente útiles, normalmente porque corrigen decisiones de diseño iniciales que resultaron ser activamente erróneas, que no siempre se puede evitar romper la compatibilidad hacia atrás. Esta sección enumera los cambios en Python 2.0 que pueden hacer que el código Python antiguo se rompa.</p>
<p>El cambio que probablemente romperá la mayor parte del código es el endurecimiento de los argumentos aceptados por algunos métodos. Algunos métodos tomaban múltiples argumentos y los trataban como una tupla, particularmente varios métodos de lista como <code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">insert()</span></code>. En versiones anteriores de Python, si <code class="docutils literal notranslate"><span class="pre">L</span></code> es una lista, <code class="docutils literal notranslate"><span class="pre">L.append(</span> <span class="pre">1,2</span> <span class="pre">)</span></code> añade la tupla <code class="docutils literal notranslate"><span class="pre">(1,2)</span></code> a la lista. En Python 2.0 esto provoca una excepción <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> con el mensaje “append requiere exactamente 1 argumento; se han dado 2”. La solución es simplemente añadir un conjunto extra de paréntesis para pasar ambos valores como una tupla:  <code class="docutils literal notranslate"><span class="pre">L.append(</span> <span class="pre">(1,2)</span> <span class="pre">)</span></code>.</p>
<p>Las versiones anteriores de estos métodos eran más indulgentes porque utilizaban una antigua función de la interfaz C de Python para analizar sus argumentos; la versión 2.0 los moderniza para utilizar <code class="xref py py-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code>, la función actual de análisis de argumentos, que proporciona mensajes de error más útiles y trata las llamadas con múltiples argumentos como errores. Si es absolutamente necesario usar la versión 2.0 pero no puedes arreglar tu código, puedes editar <code class="file docutils literal notranslate"><span class="pre">Objects/listobject.c</span></code> y definir el símbolo del preprocesador <code class="docutils literal notranslate"><span class="pre">NO_STRICT_LIST_APPEND</span></code> para preservar el antiguo comportamiento; esto no es recomendable.</p>
<p>Algunas de las funciones del módulo <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> siguen siendo indulgentes en este sentido. Por ejemplo, <code class="xref py py-func docutils literal notranslate"><span class="pre">socket.connect(</span> <span class="pre">('hostname',</span> <span class="pre">25)</span> <span class="pre">)()</span></code> es la forma correcta, pasando una tupla que representa una dirección IP, pero <code class="xref py py-func docutils literal notranslate"><span class="pre">socket.connect(</span> <span class="pre">'hostname',</span> <span class="pre">25</span> <span class="pre">)()</span></code> también funciona. <code class="xref py py-func docutils literal notranslate"><span class="pre">socket.connect_ex()</span></code> y <code class="xref py py-func docutils literal notranslate"><span class="pre">socket.bind()</span></code> son igualmente fáciles de usar. 2.0alpha1 endureció estas funciones, pero como la documentación utilizaba la forma errónea de argumentos múltiples, mucha gente escribió código que se rompería con la comprobación más estricta. GvR se echó atrás en los cambios ante la reacción del público, así que para el módulo <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a>, la documentación se arregló y la forma de argumento múltiple simplemente se marcó como obsoleta; se <em>reforzará</em> de nuevo en una futura versión de Python.</p>
<p>El escape <code class="docutils literal notranslate"><span class="pre">\x</span></code> en los literales de cadena ahora toma exactamente 2 dígitos hexadecimales. Antes consumía todos los dígitos hexadecimales que seguían a la “x” y tomaba los 8 bits más bajos del resultado, por lo que <code class="docutils literal notranslate"><span class="pre">\x123456</span></code> era equivalente a <code class="docutils literal notranslate"><span class="pre">\x56</span></code>.</p>
<p>Las excepciones <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> y <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> tienen un mensaje de error más amigable, cuyo texto será algo así como <code class="docutils literal notranslate"><span class="pre">'Spam'</span> <span class="pre">instance</span> <span class="pre">has</span> <span class="pre">no</span> <span class="pre">attribute</span> <span class="pre">'eggs'</span></code> o <code class="docutils literal notranslate"><span class="pre">name</span> <span class="pre">'eggs'</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">defined</span></code>. Anteriormente, el mensaje de error era simplemente la falta del nombre del atributo <code class="docutils literal notranslate"><span class="pre">eggs</span></code>, y el código escrito para aprovechar este hecho se romperá en la versión 2.0.</p>
<p>Se ha trabajado para que los enteros y los enteros largos sean un poco más intercambiables. En la versión 1.5.2, se añadió soporte para archivos grandes en Solaris, para permitir la lectura de archivos de más de 2 GiB; esto hizo que el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">tell()</span></code> de los objetos de archivo retornara un entero largo en lugar de un entero normal. Algunos códigos restaban dos desplazamientos de archivos e intentaban utilizar el resultado para multiplicar una secuencia o cortar una cadena, pero esto generaba un <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>. En la versión 2.0, los enteros largos pueden utilizarse para multiplicar o cortar una secuencia, y se comportarán como se espera intuitivamente; <code class="docutils literal notranslate"><span class="pre">3L</span> <span class="pre">*</span> <span class="pre">'abc'</span></code> produce “abcabcabc”, y <code class="docutils literal notranslate"><span class="pre">(0,1,2,3)[2L:4L]</span></code> produce (2,3). Los enteros largos también pueden utilizarse en varios contextos en los que antes sólo se aceptaban enteros, como en el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">seek()</span></code> de los objetos de archivo, y en los formatos soportados por el operador <code class="docutils literal notranslate"><span class="pre">%</span></code> (<code class="docutils literal notranslate"><span class="pre">%d</span></code>, <code class="docutils literal notranslate"><span class="pre">%i</span></code>, <code class="docutils literal notranslate"><span class="pre">%x</span></code>, etc.). Por ejemplo, <code class="docutils literal notranslate"><span class="pre">&quot;%d&quot;</span> <span class="pre">%</span> <span class="pre">2L**64</span></code> producirá la cadena <code class="docutils literal notranslate"><span class="pre">18446744073709551616</span></code>.</p>
<p>El cambio más sutil de los enteros largos es que el <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> de un entero largo ya no tiene un carácter “L” al final, aunque <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> todavía lo incluye. La “L” molestaba a muchas personas que querían imprimir enteros largos con el mismo aspecto que los enteros normales, ya que tenían que esforzarse por cortar el carácter. Esto ya no es un problema en 2.0, pero el código que hace <code class="docutils literal notranslate"><span class="pre">str(longval)[:-1]</span></code> y asume que la “L” está ahí, ahora perderá el dígito final.</p>
<p>Tomar el <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> de un flotador utiliza ahora una precisión de formato diferente a la de <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a>. <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> utiliza la cadena de formato <code class="docutils literal notranslate"><span class="pre">%.17g</span></code> para el <code class="xref py py-func docutils literal notranslate"><span class="pre">sprintf()</span></code> de C, mientras que <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> utiliza <code class="docutils literal notranslate"><span class="pre">%.12g</span></code> como antes. El efecto es que <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> puede mostrar ocasionalmente más decimales que <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a>, para ciertos números. Por ejemplo, el número 8,1 no puede representarse exactamente en binario, por lo que <code class="docutils literal notranslate"><span class="pre">repr(8,1)</span></code> es <code class="docutils literal notranslate"><span class="pre">'8,09999999999996'</span></code>, mientras que str(8,1) es <code class="docutils literal notranslate"><span class="pre">'8,1'</span></code>.</p>
<p>La opción de línea de comandos <code class="docutils literal notranslate"><span class="pre">-X</span></code>, que convertía todas las excepciones estándar en cadenas en lugar de clases, ha sido eliminada; las excepciones estándar serán ahora siempre clases. El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">exceptions</span></code> que contiene las excepciones estándar ha sido traducido de Python a un módulo C integrado, escrito por Barry Warsaw y Fredrik Lundh.</p>
</section>
<section id="extending-embedding-changes">
<h2>Extensión/Incorporación de cambios<a class="headerlink" href="#extending-embedding-changes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Algunos de los cambios están bajo la cubierta, y sólo serán evidentes para la gente que escribe módulos de extensión de C o que incrusta un intérprete de Python en una aplicación más grande. Si no estás tratando con la API de C de Python, puedes saltarte esta sección.</p>
<p>El número de versión de la API C de Python se incrementó, por lo que las extensiones C compiladas para 1.5.2 deben ser recompiladas para que funcionen con 2.0. En Windows, no es posible que Python 2.0 importe una extensión de terceros construida para Python 1.5.x debido a cómo funcionan las DLL de Windows, por lo que Python lanzará una excepción y la importación fallará.</p>
<p>Los usuarios del módulo ExtensionClass de Jim Fulton estarán encantados de saber que se han añadido ganchos para que las ExtensionClasses sean ahora compatibles con <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> y <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>. Esto significa que ya no tiene que recordar escribir código como <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">type(obj)</span> <span class="pre">==</span> <span class="pre">myExtensionClass</span></code>, sino que puede utilizar el más natural <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">isinstance(obj,</span> <span class="pre">myExtensionClass)</span></code>.</p>
<p>El archivo <code class="file docutils literal notranslate"><span class="pre">Python/importdl.c</span></code>, que era una masa de #ifdefs para soportar la carga dinámica en muchas plataformas diferentes, fue limpiado y reorganizado por Greg Stein. <code class="file docutils literal notranslate"><span class="pre">importdl.c</span></code> es ahora bastante pequeño, y el código específico de la plataforma se ha movido a un montón de archivos <code class="file docutils literal notranslate"><span class="pre">Python/dynload_*.c</span></code>. Otra limpieza: también había una serie de archivos <code class="file docutils literal notranslate"><span class="pre">my*.h</span></code> en el directorio Include/ que contenían varios hacks de portabilidad; se han fusionado en un único archivo, <code class="file docutils literal notranslate"><span class="pre">Include/pyport.h</span></code>.</p>
<p>Se ha completado la tan esperada reestructuración de malloc de Vladimir Marangozov, para facilitar que el intérprete de Python utilice un asignador personalizado en lugar del estándar de C <code class="xref py py-func docutils literal notranslate"><span class="pre">malloc()</span></code>. Para la documentación, lea los comentarios en <code class="file docutils literal notranslate"><span class="pre">Include/pymem.h</span></code> y <code class="file docutils literal notranslate"><span class="pre">Include/objimpl.h</span></code>. Para ver las largas discusiones durante las cuales se elaboró la interfaz, consulte los archivos web de las listas “patches” y “python-dev” en python.org.</p>
<p>Las versiones recientes del entorno de desarrollo GUSI para MacOS soportan hilos POSIX. Por lo tanto, el soporte de hilos POSIX de Python ahora funciona en Macintosh. También se ha contribuido al soporte de hilos utilizando la biblioteca GNU <code class="docutils literal notranslate"><span class="pre">pth</span></code> del espacio de usuario.</p>
<p>También se ha mejorado el soporte de hilos en Windows. Windows soporta bloqueos de hilos que utilizan objetos del núcleo sólo en caso de contención; en el caso común cuando no hay contención, utilizan funciones más simples que son un orden de magnitud más rápido. Una versión con hilos de Python 1.5.2 en NT es dos veces más lenta que una versión sin hilos; con los cambios de la 2.0, la diferencia es sólo del 10%. Estas mejoras fueron aportadas por Yakov Markovitch.</p>
<p>El código fuente de Python 2.0 ahora sólo utiliza prototipos ANSI C, por lo que la compilación de Python ahora requiere un compilador ANSI C, y ya no puede hacerse utilizando un compilador que sólo soporte K&amp;R C.</p>
<p>Anteriormente, la máquina virtual de Python utilizaba números de 16 bits en su bytecode, lo que limitaba el tamaño de los archivos fuente. En particular, esto afectaba al tamaño máximo de las listas literales y los diccionarios en el código fuente de Python; ocasionalmente, las personas que generan código Python se encontraban con este límite. Un parche de Charles G. Waldman eleva el límite de <code class="docutils literal notranslate"><span class="pre">2^16</span></code> a <code class="docutils literal notranslate"><span class="pre">2^{32}</span></code>.</p>
<p>Se han añadido tres nuevas funciones para añadir constantes al diccionario de un módulo en el momento de la inicialización: <code class="xref py py-func docutils literal notranslate"><span class="pre">PyModule_AddObject()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">PyModule_AddIntConstant()</span></code>, y <code class="xref py py-func docutils literal notranslate"><span class="pre">PyModule_AddStringConstant()</span></code>. Cada una de estas funciones toma un objeto de módulo, una cadena C terminada en cero que contiene el nombre a añadir, y un tercer argumento para el valor a asignar al nombre. Este tercer argumento es, respectivamente, un objeto Python, un C long o una cadena C.</p>
<p>Se ha añadido una API envolvente para los manejadores de señales de estilo Unix. <code class="xref py py-func docutils literal notranslate"><span class="pre">PyOS_getsig()</span></code> obtiene un manejador de señales y <code class="xref py py-func docutils literal notranslate"><span class="pre">PyOS_setsig()</span></code> establecerá un nuevo manejador.</p>
</section>
<section id="distutils-making-modules-easy-to-install">
<h2>Distutils: Facilitando la instalación de módulos<a class="headerlink" href="#distutils-making-modules-easy-to-install" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Antes de Python 2.0, la instalación de módulos era un asunto tedioso – no había forma de averiguar automáticamente dónde se instalaba Python, o qué opciones del compilador se debían usar para los módulos de extensión. Los autores de software tenían que pasar por un arduo ritual de edición de Makefiles y archivos de configuración, que sólo funcionaban realmente en Unix y dejaban sin soporte a Windows y MacOS. Los usuarios de Python se enfrentaban a instrucciones de instalación muy diferentes que variaban entre los distintos paquetes de extensión, lo que hacía que la administración de una instalación de Python fuera una tarea ardua.</p>
<p>El SIG de utilidades de distribución, liderado por Greg Ward, ha creado las Distutils, un sistema para facilitar la instalación de paquetes. Forman el paquete <a class="reference internal" href="../library/distutils.html#module-distutils" title="distutils: Support for building and installing Python modules into an existing Python installation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">distutils</span></code></a>, una nueva parte de la biblioteca estándar de Python. En el mejor de los casos, la instalación de un módulo de Python desde el código fuente requerirá los mismos pasos: primero simplemente hay que desempaquetar el archivo tar o zip, y ejecutar «<code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">install</span></code>. La plataforma será detectada automáticamente, el compilador será reconocido, los módulos de extensión C serán compilados, y la distribución será instalada en el directorio apropiado. Los argumentos opcionales de la línea de comandos proporcionan más control sobre el proceso de instalación, el paquete distutils ofrece muchos lugares para anular los valores predeterminados - separando la construcción de la instalación, construyendo o instalando en directorios no predeterminados, y más.</p>
<p>Para usar las Distutils, necesitas escribir un script <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code>. Para el caso simple, cuando el software contiene sólo archivos .py, un <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> mínimo puede tener sólo unas pocas líneas:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span>
<span class="n">setup</span> <span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;1.0&quot;</span><span class="p">,</span>
       <span class="n">py_modules</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;module1&quot;</span><span class="p">,</span> <span class="s2">&quot;module2&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>El archivo <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> no es mucho más complicado si el software consta de unos pocos paquetes:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span>
<span class="n">setup</span> <span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;1.0&quot;</span><span class="p">,</span>
       <span class="n">packages</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;package&quot;</span><span class="p">,</span> <span class="s2">&quot;package.subpackage&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>Una extensión en C puede ser el caso más complicado; he aquí un ejemplo tomado del paquete PyXML:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">Extension</span>

<span class="n">expat_extension</span> <span class="o">=</span> <span class="n">Extension</span><span class="p">(</span><span class="s1">&#39;xml.parsers.pyexpat&#39;</span><span class="p">,</span>
     <span class="n">define_macros</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;XML_NS&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)],</span>
     <span class="n">include_dirs</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;extensions/expat/xmltok&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;extensions/expat/xmlparse&#39;</span> <span class="p">],</span>
     <span class="n">sources</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;extensions/pyexpat.c&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;extensions/expat/xmltok/xmltok.c&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;extensions/expat/xmltok/xmlrole.c&#39;</span><span class="p">,</span> <span class="p">]</span>
       <span class="p">)</span>
<span class="n">setup</span> <span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;PyXML&quot;</span><span class="p">,</span> <span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;0.5.4&quot;</span><span class="p">,</span>
       <span class="n">ext_modules</span> <span class="o">=</span><span class="p">[</span> <span class="n">expat_extension</span> <span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Las Distutils también pueden encargarse de crear distribuciones fuente y binarias. El comando «sdist», ejecutado por «<code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">sdist</span></code>, construye una distribución fuente como <code class="file docutils literal notranslate"><span class="pre">foo-1.0.tar.gz</span></code>. Añadir nuevos comandos no es difícil, ya se han aportado los comandos «bdist_rpm» y «bdist_wininst» para crear una distribución RPM y un instalador de Windows para el software, respectivamente. Los comandos para crear otros formatos de distribución, como los paquetes de Debian y los archivos <code class="file docutils literal notranslate"><span class="pre">.pkg</span></code> de Solaris, se encuentran en diversas etapas de desarrollo.</p>
<p>Todo esto está documentado en un nuevo manual, <em>Distribución de módulos de Python</em>, que se une al conjunto básico de documentación de Python.</p>
</section>
<section id="xml-modules">
<h2>Módulos XML<a class="headerlink" href="#xml-modules" title="Enlazar permanentemente con este título">¶</a></h2>
<p>La versión 1.5.2 de Python incluía un sencillo analizador XML en forma de módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">xmllib</span></code>, aportado por Sjoerd Mullender. Desde el lanzamiento de la versión 1.5.2, se han generalizado dos interfaces diferentes para el procesamiento de XML: SAX2 (versión 2 de la API Simple para XML) proporciona una interfaz basada en eventos con algunas similitudes con <code class="xref py py-mod docutils literal notranslate"><span class="pre">xmllib</span></code>, y el DOM (Modelo de Objetos de Documento) proporciona una interfaz basada en un árbol, transformando un documento XML en un árbol de nodos que puede ser atravesado y modificado. Python 2.0 incluye una interfaz SAX2 y una interfaz DOM reducida como parte del paquete <a class="reference internal" href="../library/xml.html#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a>. Aquí daremos una breve descripción de estas nuevas interfaces; consulte la documentación de Python o el código fuente para obtener detalles completos. El SIG XML de Python también está trabajando en la mejora de la documentación.</p>
<section id="sax2-support">
<h3>Soporte de SAX2<a class="headerlink" href="#sax2-support" title="Enlazar permanentemente con este título">¶</a></h3>
<p>SAX define una interfaz basada en eventos para analizar XML. Para usar SAX, debes escribir una clase manejadora de SAX. Las clases manejadoras heredan de varias clases proporcionadas por SAX, y sobrescriben varios métodos que luego serán llamados por el analizador XML. Por ejemplo, los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">startElement()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">endElement()</span></code> son llamados para cada etiqueta inicial y final encontrada por el analizador, el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">characters()</span></code> es llamado para cada trozo de datos de caracteres, etc.</p>
<p>La ventaja del enfoque basado en eventos es que todo el documento no tiene que residir en la memoria en un momento dado, lo cual es importante si estás procesando documentos realmente enormes. Sin embargo, escribir la clase manejadora de SAX puede ser muy complicado si se intenta modificar la estructura del documento de alguna manera elaborada.</p>
<p>Por ejemplo, este pequeño programa de ejemplo define un manejador que imprime un mensaje para cada etiqueta inicial y final, y luego analiza el archivo <code class="file docutils literal notranslate"><span class="pre">hamlet.xml</span></code> usándolo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xml</span> <span class="kn">import</span> <span class="n">sax</span>

<span class="k">class</span> <span class="nc">SimpleHandler</span><span class="p">(</span><span class="n">sax</span><span class="o">.</span><span class="n">ContentHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">startElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s1">&#39;Start of element:&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attrs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">endElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s1">&#39;End of element:&#39;</span><span class="p">,</span> <span class="n">name</span>

<span class="c1"># Create a parser object</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">sax</span><span class="o">.</span><span class="n">make_parser</span><span class="p">()</span>

<span class="c1"># Tell it what handler to use</span>
<span class="n">handler</span> <span class="o">=</span> <span class="n">SimpleHandler</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">setContentHandler</span><span class="p">(</span> <span class="n">handler</span> <span class="p">)</span>

<span class="c1"># Parse a file!</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span> <span class="s1">&#39;hamlet.xml&#39;</span> <span class="p">)</span>
</pre></div>
</div>
<p>Para más información, consulte la documentación de Python o el XML HOWTO en <a class="reference external" href="http://pyxml.sourceforge.net/topics/howto/xml-howto.html">http://pyxml.sourceforge.net/topics/howto/xml-howto.html</a>.</p>
</section>
<section id="dom-support">
<h3>Soporte DOM<a class="headerlink" href="#dom-support" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El Modelo de Objetos del Documento es una representación basada en un árbol para un documento XML. Una instancia de <code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code> de nivel superior es la raíz del árbol, y tiene un único hijo que es la instancia de <code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code> de nivel superior. Este <code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code> tiene nodos hijos que representan los datos de los caracteres y cualquier subelemento, que puede tener otros hijos propios, y así sucesivamente. Utilizando el DOM puedes recorrer el árbol resultante como quieras, acceder a los valores de los elementos y atributos, insertar y eliminar nodos y volver a convertir el árbol en XML.</p>
<p>El DOM es útil para modificar documentos XML, porque se puede crear un árbol DOM, modificarlo añadiendo nuevos nodos o reordenando subárboles, y luego producir un nuevo documento XML como salida. También se puede construir un árbol DOM manualmente y convertirlo en XML, lo que puede ser una forma más flexible de producir una salida XML que simplemente escribir <code class="docutils literal notranslate"><span class="pre">&lt;tag1&gt;</span></code>…<code class="docutils literal notranslate"><span class="pre">&lt;/tag1&gt;</span></code> un archivo.</p>
<p>La implementación del DOM incluida en Python se encuentra en el módulo <a class="reference internal" href="../library/xml.dom.minidom.html#module-xml.dom.minidom" title="xml.dom.minidom: Minimal Document Object Model (DOM) implementation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.dom.minidom</span></code></a>. Es una implementación ligera del DOM de nivel 1 con soporte para espacios de nombres XML. Las funciones <code class="xref py py-func docutils literal notranslate"><span class="pre">parse()</span></code> y <code class="xref py py-func docutils literal notranslate"><span class="pre">parseString()</span></code> se proporcionan para generar un árbol DOM:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xml.dom</span> <span class="kn">import</span> <span class="n">minidom</span>
<span class="n">doc</span> <span class="o">=</span> <span class="n">minidom</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;hamlet.xml&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">doc</span></code> es una instancia de <code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code>. El <code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code>, al igual que el resto de clases del DOM como el <code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code> y el <code class="xref py py-class docutils literal notranslate"><span class="pre">Text</span></code>, es una subclase de la clase base <code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code>. Por lo tanto, todos los nodos de un árbol DOM soportan ciertos métodos comunes, como <code class="xref py py-meth docutils literal notranslate"><span class="pre">toxml()</span></code> que retorna una cadena que contiene la representación XML del nodo y sus hijos. Cada clase también tiene métodos especiales propios; por ejemplo, las instancias <code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code> y <code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code> tienen un método para encontrar todos los elementos hijos con un nombre de etiqueta dado. Continuando con el ejemplo anterior de 2 líneas:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">perslist</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">getElementsByTagName</span><span class="p">(</span> <span class="s1">&#39;PERSONA&#39;</span> <span class="p">)</span>
<span class="nb">print</span> <span class="n">perslist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">toxml</span><span class="p">()</span>
<span class="nb">print</span> <span class="n">perslist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">toxml</span><span class="p">()</span>
</pre></div>
</div>
<p>Para el archivo XML <em>Hamlet</em>, las líneas anteriores dan como resultado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">PERSONA</span><span class="o">&gt;</span><span class="n">CLAUDIUS</span><span class="p">,</span> <span class="n">king</span> <span class="n">of</span> <span class="n">Denmark</span><span class="o">.</span> <span class="o">&lt;/</span><span class="n">PERSONA</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">PERSONA</span><span class="o">&gt;</span><span class="n">HAMLET</span><span class="p">,</span> <span class="n">son</span> <span class="n">to</span> <span class="n">the</span> <span class="n">late</span><span class="p">,</span> <span class="ow">and</span> <span class="n">nephew</span> <span class="n">to</span> <span class="n">the</span> <span class="n">present</span> <span class="n">king</span><span class="o">.&lt;/</span><span class="n">PERSONA</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>El elemento raíz del documento está disponible como <code class="docutils literal notranslate"><span class="pre">doc.documentElement</span></code>, y sus hijos pueden modificarse fácilmente borrando, añadiendo o eliminando nodos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">root</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">documentElement</span>

<span class="c1"># Remove the first child</span>
<span class="n">root</span><span class="o">.</span><span class="n">removeChild</span><span class="p">(</span> <span class="n">root</span><span class="o">.</span><span class="n">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>

<span class="c1"># Move the new first child to the end</span>
<span class="n">root</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span> <span class="n">root</span><span class="o">.</span><span class="n">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>

<span class="c1"># Insert the new first child (originally,</span>
<span class="c1"># the third child) before the 20th child.</span>
<span class="n">root</span><span class="o">.</span><span class="n">insertBefore</span><span class="p">(</span> <span class="n">root</span><span class="o">.</span><span class="n">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">root</span><span class="o">.</span><span class="n">childNodes</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Una vez más, te remito a la documentación de Python para obtener una lista completa de las diferentes clases <code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code> y sus diversos métodos.</p>
</section>
<section id="relationship-to-pyxml">
<h3>Relación con PyXML<a class="headerlink" href="#relationship-to-pyxml" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El Grupo de Interés Especial XML lleva un tiempo trabajando en código Python relacionado con XML. Su distribución de código, llamada PyXML, está disponible en las páginas web del SIG en <a class="reference external" href="https://www.python.org/community/sigs/current/xml-sig">https://www.python.org/community/sigs/current/xml-sig</a>. La distribución de PyXML también utiliza el nombre de paquete <code class="docutils literal notranslate"><span class="pre">xml</span></code>. Si has escrito programas que utilizan PyXML, probablemente te preguntes sobre su compatibilidad con el paquete 2.0 <a class="reference internal" href="../library/xml.html#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a>.</p>
<p>La respuesta es que el paquete <a class="reference internal" href="../library/xml.html#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a> de Python 2.0 no es compatible con PyXML, pero puede hacerse compatible instalando una versión reciente de PyXML. Muchas aplicaciones pueden arreglárselas con el soporte XML que se incluye en Python 2.0, pero las aplicaciones más complicadas requerirán que se instale el paquete PyXML completo. Cuando se instala, las versiones 0.6.0 o superiores de PyXML sustituyen al paquete <a class="reference internal" href="../library/xml.html#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a> que se entrega con Python, y son un estricto superconjunto del paquete estándar, añadiendo un montón de características adicionales. Algunas de las características adicionales de PyXML incluyen:</p>
<ul class="simple">
<li><p>4DOM, una implementación completa de DOM de FourThought, Inc.</p></li>
<li><p>El parser de validación xmlproc, escrito por Lars Marius Garshol.</p></li>
<li><p>El módulo acelerador del parser <code class="xref py py-mod docutils literal notranslate"><span class="pre">sgmlop</span></code>, escrito por Fredrik Lundh.</p></li>
</ul>
</section>
</section>
<section id="module-changes">
<h2>Cambios en los módulos<a class="headerlink" href="#module-changes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Se han realizado muchas mejoras y correcciones de errores en la extensa biblioteca estándar de Python; algunos de los módulos afectados son <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">ConfigParser</span></code>, <a class="reference internal" href="../library/cgi.html#module-cgi" title="cgi: Helpers for running Python scripts via the Common Gateway Interface. (obsoleto)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cgi</span></code></a>, <a class="reference internal" href="../library/calendar.html#module-calendar" title="calendar: Functions for working with calendars, including some emulation of the Unix cal program."><code class="xref py py-mod docutils literal notranslate"><span class="pre">calendar</span></code></a>, <a class="reference internal" href="../library/posix.html#module-posix" title="posix: The most common POSIX system calls (normally used via module os). (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">posix</span></code></a>, <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">xmllib</span></code>, <a class="reference internal" href="../library/aifc.html#module-aifc" title="aifc: Read and write audio files in AIFF or AIFC format. (obsoleto)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">aifc</span></code></a>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">chunk,</span> <span class="pre">wave</span></code>, <a class="reference internal" href="../library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a>, <a class="reference internal" href="../library/shelve.html#module-shelve" title="shelve: Python object persistence."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shelve</span></code></a>, y <a class="reference internal" href="../library/nntplib.html#module-nntplib" title="nntplib: NNTP protocol client (requires sockets). (obsoleto)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nntplib</span></code></a>. Consulte los registros de CVS para conocer los detalles exactos parche por parche.</p>
<p>Brian Gallew ha contribuido al soporte de OpenSSL para el módulo <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a>. OpenSSL es una implementación de Secure Socket Layer, que encripta los datos que se envían a través de un socket. Al compilar Python, puedes editar <code class="file docutils literal notranslate"><span class="pre">Modules/Setup</span></code> para incluir el soporte de SSL, que añade una función adicional al módulo <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a>: <code class="docutils literal notranslate"><span class="pre">socket.ssl(socket,</span> <span class="pre">keyfile,</span> <span class="pre">certfile)</span></code>, que toma un objeto socket y retorna un socket SSL. Los módulos <code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code> y <a class="reference internal" href="../library/urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> también han sido modificados para soportar URLs <code class="docutils literal notranslate"><span class="pre">https://</span></code>, aunque nadie ha implementado FTP o SMTP sobre SSL.</p>
<p>El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code> ha sido reescrito por Greg Stein para soportar HTTP/1.1. Se proporciona compatibilidad con la versión 1.5 de <code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code>, aunque el uso de las características de HTTP/1.1, como el pipelining, requerirá reescribir el código para utilizar un conjunto diferente de interfaces.</p>
<p>El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">Tkinter</span></code> soporta ahora la versión 8.1, 8.2 o 8.3 de Tcl/Tk, y se ha eliminado el soporte para las versiones 7.x más antiguas. El módulo Tkinter ahora soporta la visualización de cadenas Unicode en los widgets Tk. Además, Fredrik Lundh ha contribuido con una optimización que hace que operaciones como <code class="docutils literal notranslate"><span class="pre">create_line</span></code> y <code class="docutils literal notranslate"><span class="pre">create_polygon</span></code> sean mucho más rápidas, especialmente cuando se utilizan muchas coordenadas.</p>
<p>El módulo <a class="reference internal" href="../library/curses.html#module-curses" title="curses: An interface to the curses library, providing portable terminal handling. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">curses</span></code></a> ha sido ampliado en gran medida, a partir de la versión mejorada de Oliver Andrich, para proporcionar muchas funciones adicionales de los curses ncurses y SYSV, como el color, el soporte de conjuntos de caracteres alternativos, los pads y el soporte de ratón. Esto significa que el módulo ya no es compatible con los sistemas operativos que sólo tienen curses BSD, pero no parece haber ningún sistema operativo actualmente mantenido que caiga en esta categoría.</p>
<p>Como se mencionó en la discusión anterior sobre el soporte Unicode de la 2.0, la implementación subyacente de las expresiones regulares proporcionadas por el módulo <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> ha sido cambiada. SRE, un nuevo motor de expresiones regulares escrito por Fredrik Lundh y parcialmente financiado por Hewlett Packard, soporta la comparación con cadenas de 8 bits y cadenas Unicode.</p>
</section>
<section id="new-modules">
<h2>Nuevos módulos<a class="headerlink" href="#new-modules" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Se han añadido varios módulos nuevos. Nos limitaremos a enumerarlos con breves descripciones; consulte la documentación de la versión 2.0 para conocer los detalles de un módulo concreto.</p>
<ul class="simple">
<li><p><a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a>:  Para registrar las funciones que serán llamadas antes de que el intérprete de Python salga. El código que actualmente establece <code class="docutils literal notranslate"><span class="pre">sys.exitfunc</span></code> directamente debe cambiarse para usar el módulo <a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a> en su lugar, importando <a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a> y llamando a <a class="reference internal" href="../library/atexit.html#atexit.register" title="atexit.register"><code class="xref py py-func docutils literal notranslate"><span class="pre">atexit.register()</span></code></a> con la función a llamar al salir. (Contribución de Skip Montanaro)</p></li>
<li><p><a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings</span></code>, <a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code></a>:  Añadidos como parte del nuevo soporte de Unicode.</p></li>
<li><p><a class="reference internal" href="../library/filecmp.html#module-filecmp" title="filecmp: Compare files efficiently."><code class="xref py py-mod docutils literal notranslate"><span class="pre">filecmp</span></code></a>: Sustituye a los antiguos módulos <code class="xref py py-mod docutils literal notranslate"><span class="pre">cmp</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">cmpcache</span></code> y <code class="xref py py-mod docutils literal notranslate"><span class="pre">dircmp</span></code>, que han quedado obsoletos. (Contribución de Gordon MacMillan y Moshe Zadka)</p></li>
<li><p><a class="reference internal" href="../library/gettext.html#module-gettext" title="gettext: Multilingual internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gettext</span></code></a>: Este módulo proporciona soporte de internacionalización (I18N) y localización (L10N) para los programas de Python, proporcionando una interfaz a la biblioteca de catálogo de mensajes GNU gettext. (Integrado por Barry Warsaw, a partir de contribuciones separadas de Martin von Löwis, Peter Funk y James Henstridge)</p></li>
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">linuxaudiodev</span></code>: Soporte para el dispositivo <code class="file docutils literal notranslate"><span class="pre">/dev/audio</span></code> en Linux, un gemelo del módulo existente <code class="xref py py-mod docutils literal notranslate"><span class="pre">sunaudiodev</span></code>. (Contribuido por Peter Bosch, con correcciones de Jeremy Hylton)</p></li>
<li><p><a class="reference internal" href="../library/mmap.html#module-mmap" title="mmap: Interface to memory-mapped files for Unix and Windows."><code class="xref py py-mod docutils literal notranslate"><span class="pre">mmap</span></code></a>: Una interfaz para archivos mapeados en memoria tanto en Windows como en Unix. El contenido de un fichero puede ser mapeado directamente en memoria, en cuyo momento se comporta como una cadena mutable, por lo que su contenido puede ser leído y modificado. Incluso pueden pasarse a funciones que esperan cadenas ordinarias, como el módulo <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a>. (Contribución de Sam Rushing, con algunas extensiones de A.M. Kuchling)</p></li>
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyexpat</span></code>: Una interfaz para el analizador XML de Expat. (Contribuido por Paul Prescod.)</p></li>
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">robotparser</span></code>: Analiza un archivo <code class="file docutils literal notranslate"><span class="pre">robots.txt</span></code>, que se utiliza para escribir arañas web que evitan amablemente ciertas áreas de un sitio web. El analizador acepta el contenido de un archivo <code class="file docutils literal notranslate"><span class="pre">robots.txt</span></code>, construye un conjunto de reglas a partir de él y puede responder a preguntas sobre la capacidad de búsqueda de una URL determinada. (Contribución de Skip Montanaro)</p></li>
<li><p><a class="reference internal" href="../library/tabnanny.html#module-tabnanny" title="tabnanny: Tool for detecting white space related problems in Python source files in a directory tree."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tabnanny</span></code></a>: Un módulo/script para comprobar el código fuente de Python en busca de sangrías ambiguas. (Contribuido por Tim Peters.)</p></li>
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">UserString</span></code>: Una clase base útil para derivar objetos que se comportan como cadenas.</p></li>
<li><p><a class="reference internal" href="../library/webbrowser.html#module-webbrowser" title="webbrowser: Easy-to-use controller for web browsers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">webbrowser</span></code></a>: Un módulo que proporciona una forma independiente de la plataforma para lanzar un navegador web en una URL específica. Para cada plataforma, se prueban varios navegadores en un orden específico. El usuario puede modificar el navegador que se lanza estableciendo la variable de entorno <em>BROWSER</em>. (Originalmente inspirado por el parche de Eric S. Raymond a <a class="reference internal" href="../library/urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> que añadía una funcionalidad similar, pero el módulo final proviene de un código originalmente implementado por Fred Drake como <code class="file docutils literal notranslate"><span class="pre">Tools/idle/BrowserControl.py</span></code>, y adaptado para la biblioteca estándar por Fred)</p></li>
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">_winreg</span></code>: Una interfaz para el registro de Windows. <code class="xref py py-mod docutils literal notranslate"><span class="pre">_winreg</span></code> es una adaptación de las funciones que han formado parte de PythonWin desde 1995, pero ahora se ha añadido a la distribución principal, y se ha mejorado para soportar Unicode. <code class="xref py py-mod docutils literal notranslate"><span class="pre">_winreg</span></code> fue escrito por Bill Tutt y Mark Hammond.</p></li>
<li><p><a class="reference internal" href="../library/zipfile.html#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a>: Un módulo para leer y escribir archivos con formato ZIP. Se trata de archivos producidos por <strong class="program">PKZIP</strong> en DOS/Windows o <strong class="program">zip</strong> en Unix, que no deben confundirse con los archivos con formato <strong class="program">gzip</strong> (que son compatibles con el módulo <a class="reference internal" href="../library/gzip.html#module-gzip" title="gzip: Interfaces for gzip compression and decompression using file objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gzip</span></code></a>) (Contribución de James C. Ahlstrom.)</p></li>
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">imputil</span></code>: Un módulo que proporciona una forma más sencilla de escribir ganchos de importación personalizados, en comparación con el módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">ihooks</span></code> existente. (Implementado por Greg Stein, con mucha discusión en python-dev a lo largo del camino)</p></li>
</ul>
</section>
<section id="idle-improvements">
<h2>Mejoras en IDLE<a class="headerlink" href="#idle-improvements" title="Enlazar permanentemente con este título">¶</a></h2>
<p>IDLE es el IDE oficial de Python multiplataforma, escrito con Tkinter. Python 2.0 incluye IDLE 0.6, que añade una serie de nuevas características y mejoras. Una lista parcial:</p>
<ul class="simple">
<li><p>Mejoras y optimizaciones de la interfaz de usuario, especialmente en el área de resaltado de sintaxis y auto-indentación.</p></li>
<li><p>El navegador de clases muestra ahora más información, como las funciones de nivel superior de un módulo.</p></li>
<li><p>El ancho del tabulador es ahora una opción configurable por el usuario. Al abrir un archivo Python existente, IDLE detecta automáticamente las convenciones de sangría y se adapta.</p></li>
<li><p>Ahora hay soporte para llamar a los navegadores en varias plataformas, utilizado para abrir la documentación de Python en un navegador.</p></li>
<li><p>IDLE ahora tiene una línea de comandos, que es en gran medida similar al intérprete de Python vainilla.</p></li>
<li><p>Se añadieron consejos de llamada en muchos lugares.</p></li>
<li><p>Ahora IDLE puede instalarse como un paquete.</p></li>
<li><p>En la ventana del editor, ahora hay una barra de líneas/columnas en la parte inferior.</p></li>
<li><p>Tres nuevos comandos de teclado: Comprobar módulo (<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Alt</kbd>-<kbd class="kbd docutils literal notranslate">F5</kbd></kbd>), Importar módulo (<kbd class="kbd docutils literal notranslate">F5</kbd>) y Ejecutar script (<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd>-<kbd class="kbd docutils literal notranslate">F5</kbd></kbd>).</p></li>
</ul>
</section>
<section id="deleted-and-deprecated-modules">
<h2>Módulos eliminados y obsoletos<a class="headerlink" href="#deleted-and-deprecated-modules" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Se han eliminado algunos módulos porque son obsoletos, o porque ahora hay mejores formas de hacer lo mismo. El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">stdwin</span></code> ha desaparecido; era para un conjunto de herramientas de ventanas independientes de la plataforma que ya no se desarrolla.</p>
<p>Varios módulos han sido trasladados al subdirectorio <code class="file docutils literal notranslate"><span class="pre">lib-old</span></code>: <code class="xref py py-mod docutils literal notranslate"><span class="pre">cmp</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">cmpcache</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">dircmp</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">dump</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">find</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">grep</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">packmail</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">poly</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">util</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">whatsound</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">zmod</span></code>. Si tiene código que depende de un módulo que ha sido movido a <code class="file docutils literal notranslate"><span class="pre">lib-old</span></code>, puede simplemente añadir ese directorio a <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> para recuperarlo, pero se recomienda actualizar cualquier código que utilice estos módulos.</p>
</section>
<section id="acknowledgements">
<h2>Agradecimientos<a class="headerlink" href="#acknowledgements" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los autores desean agradecer a las siguientes personas sus sugerencias sobre varios borradores de este artículo: David Bolen, Mark Hammond, Gregg Hauser, Jeremy Hylton, Fredrik Lundh, Detlef Lannert, Aahz Maruch, Skip Montanaro, Vladimir Marangozov, Tobias Polzin, Guido van Rossum, Neil Schemenauer y Russ Schmidt.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">Qué hay de nuevo en Python 2.0</a><ul>
<li><a class="reference internal" href="#introduction">Introducción</a></li>
<li><a class="reference internal" href="#what-about-python-1-6">¿Qué pasa con Python 1.6?</a></li>
<li><a class="reference internal" href="#new-development-process">Nuevo proceso de desarrollo</a></li>
<li><a class="reference internal" href="#unicode">Unicode</a></li>
<li><a class="reference internal" href="#list-comprehensions">Comprensión de listas</a></li>
<li><a class="reference internal" href="#augmented-assignment">Asignación aumentada</a></li>
<li><a class="reference internal" href="#string-methods">Métodos de cadena de caracteres</a></li>
<li><a class="reference internal" href="#garbage-collection-of-cycles">Recogida de basura de los ciclos</a></li>
<li><a class="reference internal" href="#other-core-changes">Otros cambios en el núcleo</a><ul>
<li><a class="reference internal" href="#minor-language-changes">Cambios menores del lenguaje</a></li>
<li><a class="reference internal" href="#changes-to-built-in-functions">Cambios en las funciones incorporadas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#porting-to-2-0">Adaptación a la versión 2.0</a></li>
<li><a class="reference internal" href="#extending-embedding-changes">Extensión/Incorporación de cambios</a></li>
<li><a class="reference internal" href="#distutils-making-modules-easy-to-install">Distutils: Facilitando la instalación de módulos</a></li>
<li><a class="reference internal" href="#xml-modules">Módulos XML</a><ul>
<li><a class="reference internal" href="#sax2-support">Soporte de SAX2</a></li>
<li><a class="reference internal" href="#dom-support">Soporte DOM</a></li>
<li><a class="reference internal" href="#relationship-to-pyxml">Relación con PyXML</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-changes">Cambios en los módulos</a></li>
<li><a class="reference internal" href="#new-modules">Nuevos módulos</a></li>
<li><a class="reference internal" href="#idle-improvements">Mejoras en IDLE</a></li>
<li><a class="reference internal" href="#deleted-and-deprecated-modules">Módulos eliminados y obsoletos</a></li>
<li><a class="reference internal" href="#acknowledgements">Agradecimientos</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="2.1.html"
                          title="capítulo anterior">Qué hay de nuevo en Python 2.1</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="changelog.html"
                          title="próximo capítulo">Registro de cambios</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/whatsnew/2.0.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="changelog.html" title="Registro de cambios"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="2.1.html" title="Qué hay de nuevo en Python 2.1"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Qué hay de nuevo en Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Qué hay de nuevo en Python 2.0</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 23, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>