{">>>": {"title": ">>>", "body": "<main>\n<dd><p>El prompt en el shell interactivo de Python por omisi\u00f3n. Frecuentemente vistos en ejemplos de c\u00f3digo que pueden ser ejecutados interactivamente en el int\u00e9rprete.</p>\n</dd>\n</main>\n"}, "...": {"title": "...", "body": "<main>\n<dd><p>Puede referirse a:</p>\n<ul class=\"simple\">\n<li><p>El prompt en el shell interactivo de Python por omisi\u00f3n cuando se ingresa c\u00f3digo para un bloque indentado de c\u00f3digo, y cuando se encuentra entre dos delimitadores que emparejan (par\u00e9ntesis, corchetes, llaves o comillas triples), o despu\u00e9s de especificar un decorador.</p></li>\n<li><p>La constante incorporada <a class=\"reference internal\" href=\"library/constants.html#Ellipsis\" title=\"Ellipsis\"><code class=\"xref py py-const docutils literal notranslate\"><span class=\"pre\">Ellipsis</span></code></a>.</p></li>\n</ul>\n</dd>\n</main>\n"}, "2to3": {"title": "2to3", "body": "<main>\n<dd><p>Una herramienta que intenta convertir c\u00f3digo de Python 2.x a Python 3.x arreglando la mayor\u00eda de las incompatibilidades que pueden ser detectadas analizando el c\u00f3digo y recorriendo el \u00e1rbol de an\u00e1lisis sint\u00e1ctico.</p>\n<p>2to3 est\u00e1 disponible en la biblioteca est\u00e1ndar como <a class=\"reference internal\" href=\"library/2to3.html#module-lib2to3\" title=\"lib2to3: The 2to3 library\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">lib2to3</span></code></a>; un punto de entrada independiente es provisto como <code class=\"file docutils literal notranslate\"><span class=\"pre\">Tools/scripts/2to3</span></code>.  Vea <a class=\"reference internal\" href=\"library/2to3.html#to3-reference\"><span class=\"std std-ref\">2to3 \u2014 Traducci\u00f3n autom\u00e1tica de c\u00f3digo de Python 2 a 3</span></a>.</p>\n</dd>\n</main>\n"}, "clase base abstracta": {"title": "clase base abstracta", "body": "<main>\n<dd><p>Las clases base abstractas (ABC, por sus siglas en ingl\u00e9s <cite>Abstract Base Class</cite>) complementan al <a class=\"reference internal\" href=\"#term-duck-typing\"><span class=\"xref std std-term\">duck-typing</span></a> brindando un forma de definir interfaces con t\u00e9cnicas como <a class=\"reference internal\" href=\"library/functions.html#hasattr\" title=\"hasattr\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">hasattr()</span></code></a> que ser\u00edan confusas o sutilmente err\u00f3neas (por ejemplo con <a class=\"reference internal\" href=\"reference/datamodel.html#special-lookup\"><span class=\"std std-ref\">magic methods</span></a>). Las ABC introduce subclases virtuales, las cuales son clases que no heredan desde una clase pero a\u00fan as\u00ed son reconocidas por <a class=\"reference internal\" href=\"library/functions.html#isinstance\" title=\"isinstance\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">isinstance()</span></code></a> y <a class=\"reference internal\" href=\"library/functions.html#issubclass\" title=\"issubclass\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">issubclass()</span></code></a>; vea la documentaci\u00f3n del m\u00f3dulo <a class=\"reference internal\" href=\"library/abc.html#module-abc\" title=\"abc: Abstract base classes according to :pep:`3119`.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">abc</span></code></a>. Python viene con muchas ABC incorporadas para las estructuras de datos( en el m\u00f3dulo <a class=\"reference internal\" href=\"library/collections.abc.html#module-collections.abc\" title=\"collections.abc: Abstract base classes for containers\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">collections.abc</span></code></a>), n\u00fameros (en el m\u00f3dulo <a class=\"reference internal\" href=\"library/numbers.html#module-numbers\" title=\"numbers: Numeric abstract base classes (Complex, Real, Integral, etc.).\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">numbers</span></code></a> ) , flujos de datos (en el m\u00f3dulo <a class=\"reference internal\" href=\"library/io.html#module-io\" title=\"io: Core tools for working with streams.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">io</span></code></a> ) , buscadores y cargadores de importaciones (en el m\u00f3dulo <a class=\"reference internal\" href=\"library/importlib.html#module-importlib.abc\" title=\"importlib.abc: Abstract base classes related to import\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">importlib.abc</span></code></a> ) . Puede crear sus propios ABCs con el m\u00f3dulo <a class=\"reference internal\" href=\"library/abc.html#module-abc\" title=\"abc: Abstract base classes according to :pep:`3119`.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">abc</span></code></a>.</p>\n</dd>\n</main>\n"}, "anotaci\u00f3n": {"title": "anotaci\u00f3n", "body": "<main>\n<dd><p>Una etiqueta asociada a una variable, atributo de clase, par\u00e1metro de funci\u00f3n o valor de retorno, usado por convenci\u00f3n como un <a class=\"reference internal\" href=\"#term-type-hint\"><span class=\"xref std std-term\">type hint</span></a>.</p>\n<p>Las anotaciones de variables no pueden ser accedidas en tiempo de ejecuci\u00f3n, pero las anotaciones de variables globales, atributos de clase, y funciones son almacenadas en el atributo especial <code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">__annotations__</span></code> de m\u00f3dulos, clases y funciones, respectivamente.</p>\n<p>Consulte <a class=\"reference internal\" href=\"#term-variable-annotation\"><span class=\"xref std std-term\">variable annotation</span></a>, <a class=\"reference internal\" href=\"#term-function-annotation\"><span class=\"xref std std-term\">function annotation</span></a>, <span class=\"target\" id=\"index-74\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a> y <span class=\"target\" id=\"index-75\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0526/\"><strong>PEP 526</strong></a>, que describen esta funcionalidad. Consulte tambi\u00e9n <a class=\"reference internal\" href=\"howto/annotations.html#annotations-howto\"><span class=\"std std-ref\">Pr\u00e1cticas recomendadas para las anotaciones</span></a> para conocer las mejores pr\u00e1cticas sobre c\u00f3mo trabajar con anotaciones.</p>\n</dd>\n</main>\n"}, "argumento": {"title": "argumento", "body": "<main>\n<dd><p>Un valor pasado a una <a class=\"reference internal\" href=\"#term-function\"><span class=\"xref std std-term\">function</span></a> (o <a class=\"reference internal\" href=\"#term-method\"><span class=\"xref std std-term\">method</span></a>) cuando se llama a la funci\u00f3n. Hay dos clases de argumentos:</p>\n<ul>\n<li><p><em class=\"dfn\">argumento nombrado</em>: es un argumento precedido por un identificador (por ejemplo, <code class=\"docutils literal notranslate\"><span class=\"pre\">nombre=</span></code>) en una llamada a una funci\u00f3n o pasado como valor en un diccionario precedido por <code class=\"docutils literal notranslate\"><span class=\"pre\">**</span></code>. Por ejemplo <code class=\"docutils literal notranslate\"><span class=\"pre\">3</span></code> y <code class=\"docutils literal notranslate\"><span class=\"pre\">5</span></code> son argumentos nombrados en las llamadas a <a class=\"reference internal\" href=\"library/functions.html#complex\" title=\"complex\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">complex()</span></code></a>:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"nb\">complex</span><span class=\"p\">(</span><span class=\"n\">real</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">imag</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"nb\">complex</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"p\">{</span><span class=\"s1\">&#39;real&#39;</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"s1\">&#39;imag&#39;</span><span class=\"p\">:</span> <span class=\"mi\">5</span><span class=\"p\">})</span>\n</pre></div>\n</div>\n</li>\n<li><p><em class=\"dfn\">argumento posicional</em> son aquellos que no son nombrados. Los argumentos posicionales deben aparecer al principio de una lista de argumentos o ser pasados como elementos de un <a class=\"reference internal\" href=\"#term-iterable\"><span class=\"xref std std-term\">iterable</span></a> precedido por <code class=\"docutils literal notranslate\"><span class=\"pre\">*</span></code>. Por ejemplo, <code class=\"docutils literal notranslate\"><span class=\"pre\">3</span></code> y <code class=\"docutils literal notranslate\"><span class=\"pre\">5</span></code> son argumentos posicionales en las siguientes llamadas:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"nb\">complex</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"nb\">complex</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n</li>\n</ul>\n<p>Los argumentos son asignados a las variables locales en el cuerpo de la funci\u00f3n. Vea en la secci\u00f3n <a class=\"reference internal\" href=\"reference/expressions.html#calls\"><span class=\"std std-ref\">Invocaciones</span></a> las reglas que rigen estas asignaciones. Sint\u00e1cticamente, cualquier expresi\u00f3n puede ser usada para representar un argumento; el valor evaluado es asignado a la variable local.</p>\n<p>Vea tambi\u00e9n el <a class=\"reference internal\" href=\"#term-parameter\"><span class=\"xref std std-term\">parameter</span></a> en el glosario, la pregunta frecuente <a class=\"reference internal\" href=\"faq/programming.html#faq-argument-vs-parameter\"><span class=\"std std-ref\">la diferencia entre argumentos y par\u00e1metros</span></a>, y <span class=\"target\" id=\"index-76\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0362/\"><strong>PEP 362</strong></a>.</p>\n</dd>\n</main>\n"}, "administrador asincr\u00f3nico de contexto": {"title": "administrador asincr\u00f3nico de contexto", "body": "<main>\n<dd><p>Un objeto que controla el entorno visible en un sentencia <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-with\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">with</span></code></a> al definir los m\u00e9todos <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__aenter__()</span></code> <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__aexit__()</span></code>.   Introducido por <span class=\"target\" id=\"index-77\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "generador asincr\u00f3nico": {"title": "generador asincr\u00f3nico", "body": "<main>\n<dd><p>Una funci\u00f3n que retorna un <a class=\"reference internal\" href=\"#term-asynchronous-generator-iterator\"><span class=\"xref std std-term\">asynchronous generator iterator</span></a>. Es similar a una funci\u00f3n corrutina definida con <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-def\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">def</span></code></a> excepto que contiene expresiones <a class=\"reference internal\" href=\"reference/simple_stmts.html#yield\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">yield</span></code></a> para producir series de variables usadas en un ciclo <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">for</span></code></a>.</p>\n<p>Usualmente se refiere a una funci\u00f3n generadora asincr\u00f3nica, pero puede referirse a un <em>iterador generador asincr\u00f3nico</em> en ciertos contextos. En aquellos casos en los que el significado no est\u00e1 claro, usar los t\u00e9rminos completos evita la ambig\u00fcedad.</p>\n<p>Una funci\u00f3n generadora asincr\u00f3nica puede contener expresiones <a class=\"reference internal\" href=\"reference/expressions.html#await\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">await</span></code></a> as\u00ed como sentencias <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">for</span></code></a>, y <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-with\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">with</span></code></a>.</p>\n</dd>\n</main>\n"}, "iterador generador asincr\u00f3nico": {"title": "iterador generador asincr\u00f3nico", "body": "<main>\n<dd><p>Un objeto creado por una funci\u00f3n <a class=\"reference internal\" href=\"#term-asynchronous-generator\"><span class=\"xref std std-term\">asynchronous generator</span></a>.</p>\n<p>Este es un <a class=\"reference internal\" href=\"#term-asynchronous-iterator\"><span class=\"xref std std-term\">asynchronous iterator</span></a> el cual cuando es llamado usa el m\u00e9todo  <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__anext__()</span></code> retornando un objeto a la espera (<em>awaitable</em>) el cual ejecutar\u00e1 el cuerpo de la funci\u00f3n generadora asincr\u00f3nica hasta la siguiente expresi\u00f3n <a class=\"reference internal\" href=\"reference/simple_stmts.html#yield\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">yield</span></code></a>.</p>\n<p>Cada <a class=\"reference internal\" href=\"reference/simple_stmts.html#yield\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">yield</span></code></a> suspende temporalmente el procesamiento, recordando el estado local de ejecuci\u00f3n (incluyendo a las variables locales y las sentencias <cite>try</cite> pendientes). Cuando el <em>iterador del generador asincr\u00f3nico</em> vuelve efectivamente con otro objeto a la espera (<em>awaitable</em>) retornado por el m\u00e9todo  <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__anext__()</span></code>, retoma donde lo dej\u00f3. Vea <span class=\"target\" id=\"index-78\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a> y <span class=\"target\" id=\"index-79\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0525/\"><strong>PEP 525</strong></a>.</p>\n</dd>\n</main>\n"}, "iterable asincr\u00f3nico": {"title": "iterable asincr\u00f3nico", "body": "<main>\n<dd><p>Un objeto, que puede ser usado en una sentencia <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">for</span></code></a>. Debe retornar un <a class=\"reference internal\" href=\"#term-asynchronous-iterator\"><span class=\"xref std std-term\">asynchronous iterator</span></a> de su m\u00e9todo <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__aiter__()</span></code>. Introducido por <span class=\"target\" id=\"index-80\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "iterador asincr\u00f3nico": {"title": "iterador asincr\u00f3nico", "body": "<main>\n<dd><p>Un objeto que implementa los m\u00e9todos <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__aiter__()</span></code> y <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__anext__()</span></code>. <code class=\"docutils literal notranslate\"><span class=\"pre\">__anext__</span></code> debe retornar un objeto <a class=\"reference internal\" href=\"#term-awaitable\"><span class=\"xref std std-term\">awaitable</span></a>. <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">for</span></code></a> resuelve los esperables retornados por un m\u00e9todo de iterador asincr\u00f3nico <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__anext__()</span></code> hasta que lanza una excepci\u00f3n <a class=\"reference internal\" href=\"library/exceptions.html#StopAsyncIteration\" title=\"StopAsyncIteration\"><code class=\"xref py py-exc docutils literal notranslate\"><span class=\"pre\">StopAsyncIteration</span></code></a>. Introducido por <span class=\"target\" id=\"index-81\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "atributo": {"title": "atributo", "body": "<main>\n<dd><p>A value associated with an object which is usually referenced by name\nusing dotted expressions.\nFor example, if an object <em>o</em> has an attribute\n<em>a</em> it would be referenced as <em>o.a</em>.</p>\n<p>It is possible to give an object an attribute whose name is not an\nidentifier as defined by <a class=\"reference internal\" href=\"reference/lexical_analysis.html#identifiers\"><span class=\"std std-ref\">Identificadores y palabras clave</span></a>, for example using\n<a class=\"reference internal\" href=\"library/functions.html#setattr\" title=\"setattr\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">setattr()</span></code></a>, if the object allows it.\nSuch an attribute will not be accessible using a dotted expression,\nand would instead need to be retrieved with <a class=\"reference internal\" href=\"library/functions.html#getattr\" title=\"getattr\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">getattr()</span></code></a>.</p>\n</dd>\n</main>\n"}, "a la espera": {"title": "a la espera", "body": "<main>\n<dd><p>Es un objeto a la espera (<em>awaitable</em>) que puede ser usado en una expresi\u00f3n <a class=\"reference internal\" href=\"reference/expressions.html#await\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">await</span></code></a>. Puede ser una <a class=\"reference internal\" href=\"#term-coroutine\"><span class=\"xref std std-term\">coroutine</span></a> o un objeto con un m\u00e9todo <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__await__()</span></code>. Vea tambi\u00e9n <span class=\"target\" id=\"index-82\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "bdfl": {"title": "BDFL", "body": "<main>\n<dd><p>Sigla de <em>Benevolent Dictator For Life</em>, benevolente dictador vitalicio, es decir <a class=\"reference external\" href=\"https://gvanrossum.github.io/\">Guido van Rossum</a>, el creador de Python.</p>\n</dd>\n</main>\n"}, "archivo binario": {"title": "archivo binario", "body": "<main>\n<dd><p>Un <a class=\"reference internal\" href=\"#term-file-object\"><span class=\"xref std std-term\">file object</span></a> capaz de leer y escribir <a class=\"reference internal\" href=\"#term-bytes-like-object\"><span class=\"xref std std-term\">objetos tipo binarios</span></a>. Ejemplos de archivos binarios son los abiertos en modo binario (<code class=\"docutils literal notranslate\"><span class=\"pre\">'rb'</span></code>, <code class=\"docutils literal notranslate\"><span class=\"pre\">'wb'</span></code> o <code class=\"docutils literal notranslate\"><span class=\"pre\">'rb+'</span></code>), <code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.stdin.buffer</span></code>, <code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.stdout.buffer</span></code>, e instancias de <a class=\"reference internal\" href=\"library/io.html#io.BytesIO\" title=\"io.BytesIO\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">io.BytesIO</span></code></a> y de <a class=\"reference internal\" href=\"library/gzip.html#gzip.GzipFile\" title=\"gzip.GzipFile\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">gzip.GzipFile</span></code></a>.</p>\n<p>Vea tambi\u00e9n <a class=\"reference internal\" href=\"#term-text-file\"><span class=\"xref std std-term\">text file</span></a> para un objeto archivo capaz de leer y escribir objetos <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a>.</p>\n</dd>\n</main>\n"}, "referencia prestada": {"title": "referencia prestada", "body": "<main>\n<dd><p>En la API C de Python, una referencia prestada es una referencia a un objeto. No modifica el recuento de referencias de objetos. Se convierte en un puntero colgante si se destruye el objeto. Por ejemplo, una recolecci\u00f3n de basura puede eliminar el \u00faltimo <a class=\"reference internal\" href=\"#term-strong-reference\"><span class=\"xref std std-term\">strong reference</span></a> del objeto y as\u00ed destruirlo.</p>\n<p>Se recomienda llamar a <a class=\"reference internal\" href=\"c-api/refcounting.html#c.Py_INCREF\" title=\"Py_INCREF\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">Py_INCREF()</span></code></a> en la <a class=\"reference internal\" href=\"#term-borrowed-reference\"><span class=\"xref std std-term\">referencia prestada</span></a> para convertirla en una <a class=\"reference internal\" href=\"#term-strong-reference\"><span class=\"xref std std-term\">referencia fuerte</span></a> in situ, excepto cuando el objeto no se puede destruir antes del \u00faltimo uso de la referencia prestada. La funci\u00f3n <a class=\"reference internal\" href=\"c-api/refcounting.html#c.Py_NewRef\" title=\"Py_NewRef\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">Py_NewRef()</span></code></a> se puede utilizar para crear una nueva <a class=\"reference internal\" href=\"#term-strong-reference\"><span class=\"xref std std-term\">referencia fuerte</span></a>.</p>\n</dd>\n</main>\n"}, "objetos tipo binarios": {"title": "objetos tipo binarios", "body": "<main>\n<dd><p>Un objeto que soporta <a class=\"reference internal\" href=\"c-api/buffer.html#bufferobjects\"><span class=\"std std-ref\">Protocolo b\u00fafer</span></a>  y puede exportar un b\u00fafer C-<a class=\"reference internal\" href=\"#term-contiguous\"><span class=\"xref std std-term\">contiguous</span></a>. Esto incluye todas los objetos <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a>, <a class=\"reference internal\" href=\"library/stdtypes.html#bytearray\" title=\"bytearray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytearray</span></code></a>, y <a class=\"reference internal\" href=\"library/array.html#array.array\" title=\"array.array\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">array.array</span></code></a>, as\u00ed como muchos objetos comunes <a class=\"reference internal\" href=\"library/stdtypes.html#memoryview\" title=\"memoryview\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">memoryview</span></code></a>. Los objetos tipo binarios pueden ser usados para varias operaciones que usan datos binarios; \u00e9stas incluyen compresi\u00f3n, salvar a archivos binarios, y enviarlos a trav\u00e9s de un socket.</p>\n<p>Algunas operaciones necesitan que los datos binarios sean mutables. La documentaci\u00f3n frecuentemente se refiere a \u00e9stos como \u00abobjetos tipo binario de lectura y escritura\u00bb. Ejemplos de objetos de b\u00fafer mutables incluyen a <a class=\"reference internal\" href=\"library/stdtypes.html#bytearray\" title=\"bytearray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytearray</span></code></a> y <a class=\"reference internal\" href=\"library/stdtypes.html#memoryview\" title=\"memoryview\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">memoryview</span></code></a> de la <a class=\"reference internal\" href=\"library/stdtypes.html#bytearray\" title=\"bytearray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytearray</span></code></a>. Otras operaciones que requieren datos binarios almacenados en objetos inmutables (\u00abobjetos tipo binario de s\u00f3lo lectura\u00bb); ejemplos de \u00e9stos incluyen <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a> y <a class=\"reference internal\" href=\"library/stdtypes.html#memoryview\" title=\"memoryview\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">memoryview</span></code></a> del objeto <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a>.</p>\n</dd>\n</main>\n"}, "bytecode": {"title": "bytecode", "body": "<main>\n<dd><p>El c\u00f3digo fuente Python es compilado en <em>bytecode</em>, la representaci\u00f3n interna de un programa python en el int\u00e9rprete CPython. El <em>bytecode</em> tambi\u00e9n es guardado en cach\u00e9 en los archivos <cite>.pyc</cite> de tal forma que ejecutar el mismo archivo es m\u00e1s f\u00e1cil la segunda vez (la recompilaci\u00f3n desde el c\u00f3digo fuente a <em>bytecode</em> puede ser evitada). Este \u00ablenguaje intermedio\u00bb deber\u00e1 corren en una <a class=\"reference internal\" href=\"#term-virtual-machine\"><span class=\"xref std std-term\">virtual machine</span></a> que ejecute el c\u00f3digo de m\u00e1quina correspondiente a cada <em>bytecode</em>. Note que los <em>bytecodes</em> no tienen como requisito trabajar en las diversas m\u00e1quina virtuales de Python, ni de ser estable entre versiones Python.</p>\n<p>Una lista de las instrucciones en <em>bytecode</em> est\u00e1 disponible en la documentaci\u00f3n de <a class=\"reference internal\" href=\"library/dis.html#bytecodes\"><span class=\"std std-ref\">el m\u00f3dulo dis</span></a>.</p>\n</dd>\n</main>\n"}, "callable": {"title": "callable", "body": "<main>\n<dd><p>A callable is an object that can be called, possibly with a set\nof arguments (see <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a>), with the following syntax:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">callable</span><span class=\"p\">(</span><span class=\"n\">argument1</span><span class=\"p\">,</span> <span class=\"n\">argument2</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>A <a class=\"reference internal\" href=\"#term-function\"><span class=\"xref std std-term\">function</span></a>, and by extension a <a class=\"reference internal\" href=\"#term-method\"><span class=\"xref std std-term\">method</span></a>, is a callable.\nAn instance of a class that implements the <a class=\"reference internal\" href=\"reference/datamodel.html#object.__call__\" title=\"object.__call__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__call__()</span></code></a>\nmethod is also a callable.</p>\n</dd>\n</main>\n"}, "retrollamada": {"title": "retrollamada", "body": "<main>\n<dd><p>Una funci\u00f3n de subrutina que se pasa como un argumento para ejecutarse en alg\u00fan momento en el futuro.</p>\n</dd>\n</main>\n"}, "clase": {"title": "clase", "body": "<main>\n<dd><p>Una plantilla para crear objetos definidos por el usuario. Las definiciones de clase normalmente contienen definiciones de m\u00e9todos que operan una instancia de la clase.</p>\n</dd>\n</main>\n"}, "variable de clase": {"title": "variable de clase", "body": "<main>\n<dd><p>Una variable definida en una clase y prevista para ser modificada s\u00f3lo a nivel de clase (es decir, no en una instancia de la clase).</p>\n</dd>\n</main>\n"}, "n\u00famero complejo": {"title": "n\u00famero complejo", "body": "<main>\n<dd><p>Una extensi\u00f3n del sistema familiar de n\u00famero reales en el cual los n\u00fameros son expresados como la suma de una parte real y una parte imaginaria.  Los n\u00fameros imaginarios son m\u00faltiplos de la unidad imaginaria (la ra\u00edz cuadrada de <code class=\"docutils literal notranslate\"><span class=\"pre\">-1</span></code>), usualmente escrita como <code class=\"docutils literal notranslate\"><span class=\"pre\">i</span></code> en matem\u00e1ticas o <code class=\"docutils literal notranslate\"><span class=\"pre\">j</span></code> en ingenier\u00eda.  Python tiene soporte incorporado para n\u00fameros complejos, los cuales son escritos con la notaci\u00f3n mencionada al final.; la parte imaginaria es escrita con un sufijo <code class=\"docutils literal notranslate\"><span class=\"pre\">j</span></code>, por ejemplo, <code class=\"docutils literal notranslate\"><span class=\"pre\">3+1j</span></code>.  Para tener acceso a los equivalentes complejos del m\u00f3dulo <a class=\"reference internal\" href=\"library/math.html#module-math\" title=\"math: Mathematical functions (sin() etc.).\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">math</span></code></a> module, use <a class=\"reference internal\" href=\"library/cmath.html#module-cmath\" title=\"cmath: Mathematical functions for complex numbers.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">cmath</span></code></a>.  El uso de n\u00fameros complejos es matem\u00e1tica bastante avanzada.  Si no le parecen necesarios, puede ignorarlos sin inconvenientes.</p>\n</dd>\n</main>\n"}, "administrador de contextos": {"title": "administrador de contextos", "body": "<main>\n<dd><p>Un objeto que controla el entorno en la sentencia <a class=\"reference internal\" href=\"reference/compound_stmts.html#with\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">with</span></code></a> definiendo los m\u00e9todos <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__enter__()</span></code> y <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__exit__()</span></code>. Vea <span class=\"target\" id=\"index-83\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0343/\"><strong>PEP 343</strong></a>.</p>\n</dd>\n</main>\n"}, "variable de contexto": {"title": "variable de contexto", "body": "<main>\n<dd><p>Una variable que puede tener diferentes valores dependiendo del contexto. Esto es similar a un almacenamiento de hilo local <em>Thread-Local Storage</em> en el cual cada hilo de ejecuci\u00f3n puede tener valores diferentes para una variable. Sin embargo, con las variables de contexto, podr\u00eda haber varios contextos en un hilo de ejecuci\u00f3n y el uso principal de las variables de contexto es mantener registro de las variables en tareas concurrentes as\u00edncronas. Vea <a class=\"reference internal\" href=\"library/contextvars.html#module-contextvars\" title=\"contextvars: Context Variables\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">contextvars</span></code></a>.</p>\n</dd>\n</main>\n"}, "contiguo": {"title": "contiguo", "body": "<main>\n<dd><p id=\"index-10\">Un b\u00fafer es considerado contiguo con precisi\u00f3n si es <em>C-contiguo</em> o <em>Fortran contiguo</em>. Los b\u00faferes cero dimensionales con C y Fortran contiguos. En los arreglos unidimensionales, los \u00edtems deben ser dispuestos en memoria uno siguiente al otro, ordenados por \u00edndices que comienzan en cero. En arreglos unidimensionales C-contiguos, el \u00faltimo \u00edndice var\u00eda m\u00e1s velozmente en el orden de las direcciones de memoria. Sin embargo, en arreglos Fortran contiguos, el primer \u00edndice ver\u00eda m\u00e1s r\u00e1pidamente.</p>\n</dd>\n</main>\n"}, "corrutina": {"title": "corrutina", "body": "<main>\n<dd><p>Las corrutinas son una forma m\u00e1s generalizadas de las subrutinas. A las subrutinas se ingresa por un punto y se sale por otro punto. Las corrutinas pueden se iniciadas, finalizadas y reanudadas en muchos puntos diferentes. Pueden ser implementadas con la sentencia <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-def\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">def</span></code></a>. Vea adem\u00e1s <span class=\"target\" id=\"index-84\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "funci\u00f3n corrutina": {"title": "funci\u00f3n corrutina", "body": "<main>\n<dd><p>Un funci\u00f3n que retorna un objeto  <a class=\"reference internal\" href=\"#term-coroutine\"><span class=\"xref std std-term\">coroutine</span></a> . Una funci\u00f3n corrutina puede ser definida con la sentencia <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-def\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">def</span></code></a>, y puede contener las palabras claves <a class=\"reference internal\" href=\"reference/expressions.html#await\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">await</span></code></a>, <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">for</span></code></a>, y <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-with\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">with</span></code></a>. Las mismas son introducidas en <span class=\"target\" id=\"index-85\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "cpython": {"title": "CPython", "body": "<main>\n<dd><p>La implementaci\u00f3n can\u00f3nica del lenguaje de programaci\u00f3n Python, como se distribuye en <a class=\"reference external\" href=\"https://www.python.org\">python.org</a>. El t\u00e9rmino \u00abCPython\u00bb es usado cuando es necesario distinguir esta implementaci\u00f3n de otras como <em>Jython</em> o <em>IronPython</em>.</p>\n</dd>\n</main>\n"}, "decorador": {"title": "decorador", "body": "<main>\n<dd><p>Una funci\u00f3n que retorna otra funci\u00f3n, usualmente aplicada como una funci\u00f3n de transformaci\u00f3n empleando la sintaxis <code class=\"docutils literal notranslate\"><span class=\"pre\">&#64;envoltorio</span></code>. Ejemplos comunes de decoradores son  <a class=\"reference internal\" href=\"library/functions.html#classmethod\" title=\"classmethod\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">classmethod()</span></code></a> y <a class=\"reference internal\" href=\"library/functions.html#staticmethod\" title=\"staticmethod\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">staticmethod()</span></code></a>.</p>\n<p>La sintaxis del decorador es meramente az\u00facar sint\u00e1ctico, las definiciones de las siguientes dos funciones son sem\u00e1nticamente equivalentes:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n<span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"nb\">staticmethod</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n\n<span class=\"nd\">@staticmethod</span>\n<span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n</pre></div>\n</div>\n<p>El mismo concepto existe para clases, pero son menos usadas. Vea la documentaci\u00f3n de <a class=\"reference internal\" href=\"reference/compound_stmts.html#function\"><span class=\"std std-ref\">function definitions</span></a> y <a class=\"reference internal\" href=\"reference/compound_stmts.html#class\"><span class=\"std std-ref\">class definitions</span></a> para mayor detalle sobre decoradores.</p>\n</dd>\n</main>\n"}, "descriptor": {"title": "descriptor", "body": "<main>\n<dd><p>Cualquier objeto que define los m\u00e9todos <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__get__()</span></code>, <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__set__()</span></code>, o <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__delete__()</span></code>.   Cuando un atributo de clase es un descriptor, su conducta enlazada especial es disparada durante la b\u00fasqueda del atributo. Normalmente, usando <em>a.b</em> para consultar, establecer o borrar un atributo busca el objeto llamado <em>b</em> en el diccionario de clase de <em>a</em>, pero si <em>b</em> es un descriptor, el respectivo m\u00e9todo descriptor es llamado.  Entender descriptores es clave para lograr una comprensi\u00f3n profunda de Python porque son la base de muchas de las capacidades incluyendo funciones, m\u00e9todos, propiedades, m\u00e9todos de clase, m\u00e9todos est\u00e1ticos, y referencia a s\u00faper clases.</p>\n<p>Para obtener m\u00e1s informaci\u00f3n sobre los m\u00e9todos de los descriptores, consulte <a class=\"reference internal\" href=\"reference/datamodel.html#descriptors\"><span class=\"std std-ref\">Implementando descriptores</span></a> o <a class=\"reference internal\" href=\"howto/descriptor.html#descriptorhowto\"><span class=\"std std-ref\">Gu\u00eda pr\u00e1ctica de uso de los descriptores</span></a>.</p>\n</dd>\n</main>\n"}, "diccionario": {"title": "diccionario", "body": "<main>\n<dd><p>Un arreglo asociativo, con claves arbitrarias que son asociadas a valores. Las claves pueden ser cualquier objeto con los m\u00e9todos <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__hash__()</span></code> y <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__eq__()</span></code> . Son llamadas hash en Perl.</p>\n</dd>\n</main>\n"}, "comprensi\u00f3n de diccionarios": {"title": "comprensi\u00f3n de diccionarios", "body": "<main>\n<dd><p>Una forma compacta de procesar todos o parte de los elementos en un iterable y retornar un diccionario con los resultados. <code class=\"docutils literal notranslate\"><span class=\"pre\">results</span> <span class=\"pre\">=</span> <span class=\"pre\">{n:</span> <span class=\"pre\">n</span> <span class=\"pre\">**</span> <span class=\"pre\">2</span> <span class=\"pre\">for</span> <span class=\"pre\">n</span> <span class=\"pre\">in</span> <span class=\"pre\">range(10)}</span></code> genera un diccionario que contiene la clave <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span></code> asignada al valor <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span> <span class=\"pre\">**</span> <span class=\"pre\">2</span></code>. Ver <a class=\"reference internal\" href=\"reference/expressions.html#comprehensions\"><span class=\"std std-ref\">Despliegues para listas, conjuntos y diccionarios</span></a>.</p>\n</dd>\n</main>\n"}, "vista de diccionario": {"title": "vista de diccionario", "body": "<main>\n<dd><p>Los objetos retornados por los m\u00e9todos  <a class=\"reference internal\" href=\"library/stdtypes.html#dict.keys\" title=\"dict.keys\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">dict.keys()</span></code></a>, <a class=\"reference internal\" href=\"library/stdtypes.html#dict.values\" title=\"dict.values\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">dict.values()</span></code></a>, y <a class=\"reference internal\" href=\"library/stdtypes.html#dict.items\" title=\"dict.items\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">dict.items()</span></code></a> son llamados vistas de diccionarios. Proveen una vista din\u00e1mica de las entradas de un diccionario, lo que significa que cuando el diccionario cambia, la vista refleja \u00e9stos cambios. Para forzar a la vista de diccionario a convertirse en una lista completa, use <code class=\"docutils literal notranslate\"><span class=\"pre\">list(dictview)</span></code>.  Vea <a class=\"reference internal\" href=\"library/stdtypes.html#dict-views\"><span class=\"std std-ref\">Objetos tipos vista de diccionario</span></a>.</p>\n</dd>\n</main>\n"}, "docstring": {"title": "docstring", "body": "<main>\n<dd><p>Una cadena de caracteres literal que aparece como la primera expresi\u00f3n en una clase, funci\u00f3n o m\u00f3dulo. Aunque es ignorada cuando se ejecuta, es reconocida por el compilador y puesta en el atributo <code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">__doc__</span></code> de la clase, funci\u00f3n o m\u00f3dulo comprendida.  Como est\u00e1 disponible mediante introspecci\u00f3n, es el lugar can\u00f3nico para ubicar la documentaci\u00f3n del objeto.</p>\n</dd>\n</main>\n"}, "tipado de pato": {"title": "tipado de pato", "body": "<main>\n<dd><p>Un estilo de programaci\u00f3n que no revisa el tipo del objeto para determinar si tiene la interfaz correcta; en vez de ello, el m\u00e9todo o atributo es simplemente llamado o usado (\u00abSi se ve como un pato y grazna como un pato, debe ser un pato\u00bb).  Enfatizando las interfaces en vez de hacerlo con los tipos espec\u00edficos, un c\u00f3digo bien dise\u00f1ado pues tener mayor flexibilidad permitiendo la sustituci\u00f3n polim\u00f3rfica.  El tipado de pato <em>duck-typing</em> evita usar pruebas llamando a <a class=\"reference internal\" href=\"library/functions.html#type\" title=\"type\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">type()</span></code></a> o <a class=\"reference internal\" href=\"library/functions.html#isinstance\" title=\"isinstance\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">isinstance()</span></code></a>.  (Nota: si embargo, el tipado de pato puede ser complementado con <a class=\"reference internal\" href=\"#term-abstract-base-class\"><span class=\"xref std std-term\">abstract base classes</span></a>. En su lugar, generalmente pregunta con <a class=\"reference internal\" href=\"library/functions.html#hasattr\" title=\"hasattr\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">hasattr()</span></code></a> o <a class=\"reference internal\" href=\"#term-EAFP\"><span class=\"xref std std-term\">EAFP</span></a>.</p>\n</dd>\n</main>\n"}, "eafp": {"title": "EAFP", "body": "<main>\n<dd><p>Del ingl\u00e9s <em>Easier to ask for forgiveness than permission</em>, es m\u00e1s f\u00e1cil pedir perd\u00f3n que pedir permiso.  Este estilo de codificaci\u00f3n com\u00fan en Python asume la existencia de claves o atributos v\u00e1lidos y atrapa las excepciones si esta suposici\u00f3n resulta falsa.  Este estilo r\u00e1pido y limpio est\u00e1 caracterizado por muchas sentencias <a class=\"reference internal\" href=\"reference/compound_stmts.html#try\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">try</span></code></a> y <a class=\"reference internal\" href=\"reference/compound_stmts.html#except\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">except</span></code></a>.  Esta t\u00e9cnica contrasta con estilo <a class=\"reference internal\" href=\"#term-LBYL\"><span class=\"xref std std-term\">LBYL</span></a> usual en otros lenguajes como C.</p>\n</dd>\n</main>\n"}, "expresi\u00f3n": {"title": "expresi\u00f3n", "body": "<main>\n<dd><p>Una construcci\u00f3n sint\u00e1ctica que puede ser evaluada, hasta dar un valor.  En otras palabras, una expresi\u00f3n es una acumulaci\u00f3n de elementos de expresi\u00f3n tales como literales, nombres, accesos a atributos, operadores o llamadas a funciones, todos ellos retornando valor.  A diferencia de otros lenguajes, no toda la sintaxis del lenguaje son expresiones. Tambi\u00e9n hay <a class=\"reference internal\" href=\"#term-statement\"><span class=\"xref std std-term\">statement</span></a>s que no pueden ser usadas como expresiones, como la <a class=\"reference internal\" href=\"reference/compound_stmts.html#while\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">while</span></code></a>.  Las asignaciones tambi\u00e9n son sentencias, no expresiones.</p>\n</dd>\n</main>\n"}, "m\u00f3dulo de extensi\u00f3n": {"title": "m\u00f3dulo de extensi\u00f3n", "body": "<main>\n<dd><p>Un m\u00f3dulo escrito en C o C++, usando la API para C de Python para interactuar con el n\u00facleo y el c\u00f3digo del usuario.</p>\n</dd>\n</main>\n"}, "f-string": {"title": "f-string", "body": "<main>\n<dd><p>Son llamadas <em>f-strings</em> las cadenas literales que usan el prefijo <code class=\"docutils literal notranslate\"><span class=\"pre\">'f'</span></code> o <code class=\"docutils literal notranslate\"><span class=\"pre\">'F'</span></code>, que es una abreviatura para  <a class=\"reference internal\" href=\"reference/lexical_analysis.html#f-strings\"><span class=\"std std-ref\">formatted string literals</span></a>.  Vea tambi\u00e9n <span class=\"target\" id=\"index-86\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0498/\"><strong>PEP 498</strong></a>.</p>\n</dd>\n</main>\n"}, "objeto archivo": {"title": "objeto archivo", "body": "<main>\n<dd><p>Un objeto que expone una API orientada a archivos (con m\u00e9todos como <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">read()</span></code> o <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">write()</span></code>) al objeto subyacente.  Dependiendo de la forma en la que fue creado, un objeto archivo, puede mediar el acceso a un archivo real en el disco u otro tipo de dispositivo de almacenamiento o de comunicaci\u00f3n (por ejemplo, entrada/salida est\u00e1ndar, b\u00fafer de memoria, sockets, pipes, etc.).  Los objetos archivo son tambi\u00e9n denominados <em class=\"dfn\">objetos tipo archivo</em> o <em class=\"dfn\">flujos</em>.</p>\n<p>Existen tres categor\u00edas de objetos archivo: crudos <em>raw</em> <a class=\"reference internal\" href=\"#term-binary-file\"><span class=\"xref std std-term\">archivos binarios</span></a>, con b\u00fafer <a class=\"reference internal\" href=\"#term-binary-file\"><span class=\"xref std std-term\">archivos binarios</span></a> y <a class=\"reference internal\" href=\"#term-text-file\"><span class=\"xref std std-term\">archivos de texto</span></a>.  Sus interfaces son definidas en el m\u00f3dulo <a class=\"reference internal\" href=\"library/io.html#module-io\" title=\"io: Core tools for working with streams.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">io</span></code></a>.  La forma can\u00f3nica de crear objetos archivo es usando la funci\u00f3n <a class=\"reference internal\" href=\"library/functions.html#open\" title=\"open\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">open()</span></code></a>.</p>\n</dd>\n</main>\n"}, "objetos tipo archivo": {"title": "objetos tipo archivo", "body": "<main>\n<dd><p>Un sin\u00f3nimo de <a class=\"reference internal\" href=\"#term-file-object\"><span class=\"xref std std-term\">file object</span></a>.</p>\n</dd>\n</main>\n"}, "codificaci\u00f3n del sistema de archivos y manejador de errores": {"title": "codificaci\u00f3n del sistema de archivos y manejador de errores", "body": "<main>\n<dd><p>Controlador de errores y codificaci\u00f3n utilizado por Python para decodificar bytes del sistema operativo y codificar Unicode en el sistema operativo.</p>\n<p>La codificaci\u00f3n del sistema de archivos debe garantizar la decodificaci\u00f3n exitosa de todos los bytes por debajo de 128. Si la codificaci\u00f3n del sistema de archivos no proporciona esta garant\u00eda, las funciones de API pueden lanzar <a class=\"reference internal\" href=\"library/exceptions.html#UnicodeError\" title=\"UnicodeError\"><code class=\"xref py py-exc docutils literal notranslate\"><span class=\"pre\">UnicodeError</span></code></a>.</p>\n<p>Las funciones <a class=\"reference internal\" href=\"library/sys.html#sys.getfilesystemencoding\" title=\"sys.getfilesystemencoding\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sys.getfilesystemencoding()</span></code></a> y <a class=\"reference internal\" href=\"library/sys.html#sys.getfilesystemencodeerrors\" title=\"sys.getfilesystemencodeerrors\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sys.getfilesystemencodeerrors()</span></code></a> se pueden utilizar para obtener la codificaci\u00f3n del sistema de archivos y el controlador de errores.</p>\n<p>La <a class=\"reference internal\" href=\"#term-filesystem-encoding-and-error-handler\"><span class=\"xref std std-term\">codificaci\u00f3n del sistema de archivos y el manejador de errores</span></a> se configuran al inicio de Python mediante la funci\u00f3n <code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">PyConfig_Read()</span></code>: consulte los miembros <a class=\"reference internal\" href=\"c-api/init_config.html#c.PyConfig.filesystem_encoding\" title=\"PyConfig.filesystem_encoding\"><code class=\"xref c c-member docutils literal notranslate\"><span class=\"pre\">filesystem_encoding</span></code></a> y <a class=\"reference internal\" href=\"c-api/init_config.html#c.PyConfig.filesystem_errors\" title=\"PyConfig.filesystem_errors\"><code class=\"xref c c-member docutils literal notranslate\"><span class=\"pre\">filesystem_errors</span></code></a> de <a class=\"reference internal\" href=\"c-api/init_config.html#c.PyConfig\" title=\"PyConfig\"><code class=\"xref c c-type docutils literal notranslate\"><span class=\"pre\">PyConfig</span></code></a>.</p>\n<p>See also the <a class=\"reference internal\" href=\"#term-locale-encoding\"><span class=\"xref std std-term\">locale encoding</span></a>.</p>\n</dd>\n</main>\n"}, "buscador": {"title": "buscador", "body": "<main>\n<dd><p>Un objeto que trata de encontrar el <a class=\"reference internal\" href=\"#term-loader\"><span class=\"xref std std-term\">loader</span></a> para el m\u00f3dulo que est\u00e1 siendo importado.</p>\n<p>Desde la versi\u00f3n 3.3 de Python, existen dos tipos de buscadores: <a class=\"reference internal\" href=\"#term-meta-path-finder\"><span class=\"xref std std-term\">meta buscadores de ruta</span></a> para usar con <a class=\"reference internal\" href=\"library/sys.html#sys.meta_path\" title=\"sys.meta_path\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.meta_path</span></code></a>, y <a class=\"reference internal\" href=\"#term-path-entry-finder\"><span class=\"xref std std-term\">buscadores de entradas de rutas</span></a> para usar con  <a class=\"reference internal\" href=\"library/sys.html#sys.path_hooks\" title=\"sys.path_hooks\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.path_hooks</span></code></a>.</p>\n<p>Vea <span class=\"target\" id=\"index-87\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0302/\"><strong>PEP 302</strong></a>, <span class=\"target\" id=\"index-88\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0420/\"><strong>PEP 420</strong></a> y <span class=\"target\" id=\"index-89\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0451/\"><strong>PEP 451</strong></a> para mayores detalles.</p>\n</dd>\n</main>\n"}, "divisi\u00f3n entera": {"title": "divisi\u00f3n entera", "body": "<main>\n<dd><p>Una divisi\u00f3n matem\u00e1tica que se redondea hacia el entero menor m\u00e1s cercano.  El operador de la divisi\u00f3n entera es <code class=\"docutils literal notranslate\"><span class=\"pre\">//</span></code>.  Por ejemplo, la expresi\u00f3n <code class=\"docutils literal notranslate\"><span class=\"pre\">11</span> <span class=\"pre\">//</span> <span class=\"pre\">4</span></code> eval\u00faa <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span></code> a diferencia del <code class=\"docutils literal notranslate\"><span class=\"pre\">2.75</span></code> retornado por la verdadera divisi\u00f3n de n\u00fameros flotantes.  Note que <code class=\"docutils literal notranslate\"><span class=\"pre\">(-11)</span> <span class=\"pre\">//</span> <span class=\"pre\">4</span></code> es <code class=\"docutils literal notranslate\"><span class=\"pre\">-3</span></code> porque es <code class=\"docutils literal notranslate\"><span class=\"pre\">-2.75</span></code> redondeado <em>para abajo</em>. Ver <span class=\"target\" id=\"index-90\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0238/\"><strong>PEP 238</strong></a>.</p>\n</dd>\n</main>\n"}, "funci\u00f3n": {"title": "funci\u00f3n", "body": "<main>\n<dd><p>Una serie de sentencias que retornan un valor al que las llama.  Tambi\u00e9n se le puede pasar cero o m\u00e1s <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argumentos</span></a> los cuales pueden ser usados en la ejecuci\u00f3n de la misma. Vea tambi\u00e9n <a class=\"reference internal\" href=\"#term-parameter\"><span class=\"xref std std-term\">parameter</span></a>, <a class=\"reference internal\" href=\"#term-method\"><span class=\"xref std std-term\">method</span></a>, y la secci\u00f3n <a class=\"reference internal\" href=\"reference/compound_stmts.html#function\"><span class=\"std std-ref\">Definiciones de funciones</span></a>.</p>\n</dd>\n</main>\n"}, "anotaci\u00f3n de funci\u00f3n": {"title": "anotaci\u00f3n de funci\u00f3n", "body": "<main>\n<dd><p>Una <a class=\"reference internal\" href=\"#term-annotation\"><span class=\"xref std std-term\">annotation</span></a> del par\u00e1metro de una funci\u00f3n o un valor de retorno.</p>\n<p>Las anotaciones de funciones son usadas frecuentemente para <a class=\"reference internal\" href=\"#term-type-hint\"><span class=\"xref std std-term\">indicadores de tipo</span></a>, por ejemplo, se espera que una funci\u00f3n tome dos argumentos de clase <a class=\"reference internal\" href=\"library/functions.html#int\" title=\"int\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">int</span></code></a>  y tambi\u00e9n se espera que retorne dos valores <a class=\"reference internal\" href=\"library/functions.html#int\" title=\"int\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">int</span></code></a>:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">sum_two_numbers</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n   <span class=\"k\">return</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span>\n</pre></div>\n</div>\n<p>La sintaxis de las anotaciones de funciones son explicadas en la secci\u00f3n <a class=\"reference internal\" href=\"reference/compound_stmts.html#function\"><span class=\"std std-ref\">Definiciones de funciones</span></a>.</p>\n<p>Consulte <a class=\"reference internal\" href=\"#term-variable-annotation\"><span class=\"xref std std-term\">variable annotation</span></a> y <span class=\"target\" id=\"index-91\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a>, que describen esta funcionalidad. Consulte tambi\u00e9n <a class=\"reference internal\" href=\"howto/annotations.html#annotations-howto\"><span class=\"std std-ref\">Pr\u00e1cticas recomendadas para las anotaciones</span></a> para conocer las mejores pr\u00e1cticas sobre c\u00f3mo trabajar con anotaciones.</p>\n</dd>\n</main>\n"}, "__future__": {"title": "__future__", "body": "<main>\n<dd><p>Un <a class=\"reference internal\" href=\"reference/simple_stmts.html#future\"><span class=\"std std-ref\">future statement</span></a>, <code class=\"docutils literal notranslate\"><span class=\"pre\">from</span> <span class=\"pre\">__future__</span> <span class=\"pre\">import</span> <span class=\"pre\">&lt;feature&gt;</span></code>, indica al compilador que compile el m\u00f3dulo actual utilizando una sintaxis o sem\u00e1ntica que se convertir\u00e1 en est\u00e1ndar en una versi\u00f3n futura de Python. El m\u00f3dulo <a class=\"reference internal\" href=\"library/__future__.html#module-__future__\" title=\"__future__: Future statement definitions\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">__future__</span></code></a> documenta los posibles valores de <em>feature</em>. Al importar este m\u00f3dulo y evaluar sus variables, puede ver cu\u00e1ndo se agreg\u00f3 por primera vez una nueva caracter\u00edstica al lenguaje y cu\u00e1ndo se convertir\u00e1 (o se convirti\u00f3) en la predeterminada:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">__future__</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">__future__</span><span class=\"o\">.</span><span class=\"n\">division</span>\n<span class=\"go\">_Feature((2, 2, 0, &#39;alpha&#39;, 2), (3, 0, 0, &#39;alpha&#39;, 0), 8192)</span>\n</pre></div>\n</div>\n</dd>\n</main>\n"}, "recolecci\u00f3n de basura": {"title": "recolecci\u00f3n de basura", "body": "<main>\n<dd><p>El proceso de liberar la memoria de lo que ya no est\u00e1 en uso.  Python realiza recolecci\u00f3n de basura (<em>garbage collection</em>) llevando la cuenta de las referencias, y el recogedor de basura c\u00edclico es capaz de detectar y romper las referencias c\u00edclicas.  El recogedor de basura puede ser controlado mediante el m\u00f3dulo <a class=\"reference internal\" href=\"library/gc.html#module-gc\" title=\"gc: Interface to the cycle-detecting garbage collector.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">gc</span></code></a> .</p>\n</dd>\n</main>\n"}, "generador": {"title": "generador", "body": "<main>\n<dd><p>Una funci\u00f3n que retorna un <a class=\"reference internal\" href=\"#term-generator-iterator\"><span class=\"xref std std-term\">generator iterator</span></a>.  Luce como una funci\u00f3n normal excepto que contiene la expresi\u00f3n <a class=\"reference internal\" href=\"reference/simple_stmts.html#yield\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">yield</span></code></a> para producir series de valores utilizables en un bucle <em>for</em> o que pueden ser obtenidas una por una con la funci\u00f3n <a class=\"reference internal\" href=\"library/functions.html#next\" title=\"next\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">next()</span></code></a>.</p>\n<p>Usualmente se refiere a una funci\u00f3n generadora, pero puede referirse a un <em>iterador generador</em> en ciertos contextos.  En aquellos casos en los que el significado no est\u00e1 claro, usar los t\u00e9rminos completos  evita la ambig\u00fcedad.</p>\n</dd>\n</main>\n"}, "iterador generador": {"title": "iterador generador", "body": "<main>\n<dd><p>Un objeto creado por una funci\u00f3n <a class=\"reference internal\" href=\"#term-generator\"><span class=\"xref std std-term\">generator</span></a>.</p>\n<p>Cada <a class=\"reference internal\" href=\"reference/simple_stmts.html#yield\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">yield</span></code></a> suspende temporalmente el procesamiento, recordando el estado de ejecuci\u00f3n local (incluyendo las variables locales y las sentencias <em>try</em> pendientes).  Cuando el \u00abiterador generado\u00bb vuelve, retoma donde ha dejado, a diferencia de lo que ocurre con las funciones que comienzan nuevamente con cada invocaci\u00f3n.</p>\n</dd>\n</main>\n"}, "expresi\u00f3n generadora": {"title": "expresi\u00f3n generadora", "body": "<main>\n<dd><p>Una expresi\u00f3n que retorna un iterador.  Luce como una expresi\u00f3n normal seguida por la cl\u00e1usula <code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">for</span></code> definiendo as\u00ed una variable de bucle, un rango y una cl\u00e1usula opcional <code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">if</span></code>.  La expresi\u00f3n combinada genera valores para la funci\u00f3n contenedora:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">*</span><span class=\"n\">i</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">))</span>         <span class=\"c1\"># sum of squares 0, 1, 4, ... 81</span>\n<span class=\"go\">285</span>\n</pre></div>\n</div>\n</dd>\n</main>\n"}, "funci\u00f3n gen\u00e9rica": {"title": "funci\u00f3n gen\u00e9rica", "body": "<main>\n<dd><p>Una funci\u00f3n compuesta de muchas funciones que implementan la misma operaci\u00f3n para diferentes tipos. Qu\u00e9 implementaci\u00f3n deber\u00e1 ser usada durante la llamada a la misma es determinado por el algoritmo de despacho.</p>\n<p>Vea tambi\u00e9n la entrada de glosario <a class=\"reference internal\" href=\"#term-single-dispatch\"><span class=\"xref std std-term\">single dispatch</span></a>, el decorador <a class=\"reference internal\" href=\"library/functools.html#functools.singledispatch\" title=\"functools.singledispatch\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">functools.singledispatch()</span></code></a>, y <span class=\"target\" id=\"index-92\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0443/\"><strong>PEP 443</strong></a>.</p>\n</dd>\n</main>\n"}, "tipos gen\u00e9ricos": {"title": "tipos gen\u00e9ricos", "body": "<main>\n<dd><p>A <a class=\"reference internal\" href=\"#term-type\"><span class=\"xref std std-term\">type</span></a> that can be parameterized; typically a\n<a class=\"reference internal\" href=\"reference/datamodel.html#sequence-types\"><span class=\"std std-ref\">container class</span></a> such as <a class=\"reference internal\" href=\"library/stdtypes.html#list\" title=\"list\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">list</span></code></a> or\n<a class=\"reference internal\" href=\"library/stdtypes.html#dict\" title=\"dict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dict</span></code></a>. Used for <a class=\"reference internal\" href=\"#term-type-hint\"><span class=\"xref std std-term\">type hints</span></a> and\n<a class=\"reference internal\" href=\"#term-annotation\"><span class=\"xref std std-term\">annotations</span></a>.</p>\n<p>For more details, see <a class=\"reference internal\" href=\"library/stdtypes.html#types-genericalias\"><span class=\"std std-ref\">generic alias types</span></a>,\n<span class=\"target\" id=\"index-22\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0483/\"><strong>PEP 483</strong></a>, <span class=\"target\" id=\"index-23\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a>, <span class=\"target\" id=\"index-24\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0585/\"><strong>PEP 585</strong></a>, and the <a class=\"reference internal\" href=\"library/typing.html#module-typing\" title=\"typing: Support for type hints (see :pep:`484`).\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">typing</span></code></a> module.</p>\n</dd>\n</main>\n"}, "gil": {"title": "GIL", "body": "<main>\n<dd><p>Vea <a class=\"reference internal\" href=\"#term-global-interpreter-lock\"><span class=\"xref std std-term\">global interpreter lock</span></a>.</p>\n</dd>\n</main>\n"}, "bloqueo global del int\u00e9rprete": {"title": "bloqueo global del int\u00e9rprete", "body": "<main>\n<dd><p>Mecanismo empleado por el int\u00e9rprete <a class=\"reference internal\" href=\"#term-CPython\"><span class=\"xref std std-term\">CPython</span></a> para asegurar que s\u00f3lo un hilo ejecute el  <a class=\"reference internal\" href=\"#term-bytecode\"><span class=\"xref std std-term\">bytecode</span></a> Python por vez. Esto simplifica la implementaci\u00f3n de CPython haciendo que el modelo de objetos (incluyendo algunos cr\u00edticos como <a class=\"reference internal\" href=\"library/stdtypes.html#dict\" title=\"dict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dict</span></code></a>) est\u00e1n impl\u00edcitamente a salvo de acceso concurrente.  Bloqueando el int\u00e9rprete completo se simplifica hacerlo multi-hilos, a costa de mucho del paralelismo ofrecido por las m\u00e1quinas con m\u00faltiples procesadores.</p>\n<p>However, some extension modules, either standard or third-party,\nare designed so as to release the GIL when doing computationally intensive\ntasks such as compression or hashing.  Also, the GIL is always released\nwhen doing I/O.</p>\n<p>Esfuerzos previos hechos para crear un int\u00e9rprete \u00absin hilos\u00bb (uno que bloquee los datos compartidos con una granularidad mucho m\u00e1s fina) no han sido exitosos debido a que el rendimiento sufri\u00f3 para el caso m\u00e1s com\u00fan de un solo procesador. Se cree que superar este problema de rendimiento har\u00eda la implementaci\u00f3n mucho m\u00e1s compleja y por tanto, m\u00e1s costosa de mantener.</p>\n</dd>\n</main>\n"}, "hash-based pyc": {"title": "hash-based pyc", "body": "<main>\n<dd><p>Un archivo cache de <em>bytecode</em> que usa el <em>hash</em> en vez de usar el tiempo de la \u00faltima modificaci\u00f3n del archivo fuente correspondiente para determinar su validez. Vea <a class=\"reference internal\" href=\"reference/import.html#pyc-invalidation\"><span class=\"std std-ref\">Invalidaci\u00f3n del c\u00f3digo de bytes en cach\u00e9</span></a>.</p>\n</dd>\n</main>\n"}, "hashable": {"title": "hashable", "body": "<main>\n<dd><p>Un objeto es <em>hashable</em> si tiene un valor de hash que nunca cambiar\u00e1 durante su tiempo de vida (necesita un m\u00e9todo <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__hash__()</span></code> ), y puede ser comparado con otro objeto (necesita el m\u00e9todo <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__eq__()</span></code> ).  Los objetos hashables que se comparan iguales deben tener el mismo n\u00famero hash.</p>\n<p>Ser <em>hashable</em> hace a un objeto utilizable como clave de un diccionario y miembro de un set, porque \u00e9stas estructuras de datos usan los valores de hash internamente.</p>\n<p>La mayor\u00eda de los objetos inmutables incorporados en Python son <em>hashables</em>; los contenedores mutables (como las listas o los diccionarios) no lo son; los contenedores inmutables (como tuplas y conjuntos <em>frozensets</em>) son <em>hashables</em> si sus elementos son <em>hashables</em> .  Los objetos que son instancias de clases definidas por el usuario son <em>hashables</em> por defecto.  Todos se comparan como desiguales (excepto consigo mismos), y su valor de hash est\u00e1 derivado de su funci\u00f3n <a class=\"reference internal\" href=\"library/functions.html#id\" title=\"id\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">id()</span></code></a>.</p>\n</dd>\n</main>\n"}, "idle": {"title": "IDLE", "body": "<main>\n<dd><p>An Integrated Development and Learning Environment for Python.\n<a class=\"reference internal\" href=\"library/idle.html#idle\"><span class=\"std std-ref\">IDLE</span></a> is a basic editor and interpreter environment\nwhich ships with the standard distribution of Python.</p>\n</dd>\n</main>\n"}, "inmutable": {"title": "inmutable", "body": "<main>\n<dd><p>Un objeto con un valor fijo.  Los objetos inmutables son n\u00fameros, cadenas y tuplas.  \u00c9stos objetos no pueden ser alterados.  Un nuevo objeto debe ser creado si un valor diferente ha de ser guardado.  Juegan un rol importante en lugares donde es necesario un valor de hash constante, por ejemplo como claves de un diccionario.</p>\n</dd>\n</main>\n"}, "ruta de importaci\u00f3n": {"title": "ruta de importaci\u00f3n", "body": "<main>\n<dd><p>Una lista de las ubicaciones (o <a class=\"reference internal\" href=\"#term-path-entry\"><span class=\"xref std std-term\">entradas de ruta</span></a>) que son revisadas por <a class=\"reference internal\" href=\"#term-path-based-finder\"><span class=\"xref std std-term\">path based finder</span></a> al importar m\u00f3dulos. Durante la importaci\u00f3n, \u00e9sta lista de localizaciones usualmente viene de <a class=\"reference internal\" href=\"library/sys.html#sys.path\" title=\"sys.path\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.path</span></code></a>, pero para los subpaquetes tambi\u00e9n puede incluir al atributo <code class=\"docutils literal notranslate\"><span class=\"pre\">__path__</span></code> del paquete padre.</p>\n</dd>\n</main>\n"}, "importar": {"title": "importar", "body": "<main>\n<dd><p>El proceso mediante el cual el c\u00f3digo Python dentro de un m\u00f3dulo se hace alcanzable desde otro c\u00f3digo Python en otro m\u00f3dulo.</p>\n</dd>\n</main>\n"}, "importador": {"title": "importador", "body": "<main>\n<dd><p>Un objeto que buscan y lee un m\u00f3dulo; un objeto que es tanto <a class=\"reference internal\" href=\"#term-finder\"><span class=\"xref std std-term\">finder</span></a> como <a class=\"reference internal\" href=\"#term-loader\"><span class=\"xref std std-term\">loader</span></a>.</p>\n</dd>\n</main>\n"}, "interactivo": {"title": "interactivo", "body": "<main>\n<dd><p>Python tiene un int\u00e9rprete interactivo, lo que significa que puede ingresar sentencias y expresiones en el prompt del int\u00e9rprete, ejecutarlos de inmediato y ver sus resultados.  S\u00f3lo ejecute <code class=\"docutils literal notranslate\"><span class=\"pre\">python</span></code> sin argumentos (podr\u00eda seleccionarlo desde el men\u00fa principal de su computadora). Es una forma muy potente de probar nuevas ideas o inspeccionar m\u00f3dulos y paquetes (recuerde  <code class=\"docutils literal notranslate\"><span class=\"pre\">help(x)</span></code>).</p>\n</dd>\n</main>\n"}, "interpretado": {"title": "interpretado", "body": "<main>\n<dd><p>Python es un lenguaje interpretado, a diferencia de uno compilado, a pesar de que la distinci\u00f3n puede ser difusa debido al compilador a <em>bytecode</em>.  Esto significa que los archivos fuente pueden ser corridos directamente, sin crear expl\u00edcitamente un ejecutable que es corrido luego. Los lenguajes interpretados t\u00edpicamente tienen ciclos de desarrollo y depuraci\u00f3n m\u00e1s cortos que los compilados, sin embargo sus programas suelen correr m\u00e1s lentamente.  Vea tambi\u00e9n  <a class=\"reference internal\" href=\"#term-interactive\"><span class=\"xref std std-term\">interactive</span></a>.</p>\n</dd>\n</main>\n"}, "apagado del int\u00e9rprete": {"title": "apagado del int\u00e9rprete", "body": "<main>\n<dd><p>Cuando se le solicita apagarse, el int\u00e9rprete Python ingresa a un fase especial en la cual gradualmente libera todos los recursos reservados, como m\u00f3dulos y varias estructuras internas cr\u00edticas.  Tambi\u00e9n hace varias llamadas al <a class=\"reference internal\" href=\"#term-garbage-collection\"><span class=\"xref std std-term\">recolector de basura</span></a>.  Esto puede disparar la ejecuci\u00f3n de c\u00f3digo de destructores definidos por el usuario o <em>weakref callbacks</em>. El c\u00f3digo ejecutado durante la fase de apagado puede encontrar varias excepciones debido a que los recursos que necesita pueden no funcionar m\u00e1s (ejemplos comunes son los m\u00f3dulos de bibliotecas o los artefactos de advertencias <em>warnings machinery</em>)</p>\n<p>La principal raz\u00f3n para el apagado del int\u00e9rpreter es que el m\u00f3dulo <code class=\"docutils literal notranslate\"><span class=\"pre\">__main__</span></code> o el script que estaba corriendo termine su ejecuci\u00f3n.</p>\n</dd>\n</main>\n"}, "iterable": {"title": "iterable", "body": "<main>\n<dd><p>An object capable of returning its members one at a time. Examples of\niterables include all sequence types (such as <a class=\"reference internal\" href=\"library/stdtypes.html#list\" title=\"list\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">list</span></code></a>, <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a>,\nand <a class=\"reference internal\" href=\"library/stdtypes.html#tuple\" title=\"tuple\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">tuple</span></code></a>) and some non-sequence types like <a class=\"reference internal\" href=\"library/stdtypes.html#dict\" title=\"dict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dict</span></code></a>,\n<a class=\"reference internal\" href=\"#term-file-object\"><span class=\"xref std std-term\">file objects</span></a>, and objects of any classes you define\nwith an <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__iter__()</span></code> method or with a <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__getitem__()</span></code> method\nthat implements <a class=\"reference internal\" href=\"#term-sequence\"><span class=\"xref std std-term\">sequence</span></a> semantics.</p>\n<p>Los iterables pueden ser usados en el bucle <a class=\"reference internal\" href=\"reference/compound_stmts.html#for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">for</span></code></a> y en muchos otros sitios donde una secuencia es necesaria (<a class=\"reference internal\" href=\"library/functions.html#zip\" title=\"zip\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">zip()</span></code></a>, <a class=\"reference internal\" href=\"library/functions.html#map\" title=\"map\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">map()</span></code></a>, \u2026).  Cuando un objeto iterable es pasado como argumento a la funci\u00f3n incorporada <a class=\"reference internal\" href=\"library/functions.html#iter\" title=\"iter\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">iter()</span></code></a>, retorna un iterador para el objeto.  Este iterador pasa as\u00ed el conjunto de valores.  Cuando se usan iterables, normalmente no es necesario llamar a la funci\u00f3n <a class=\"reference internal\" href=\"library/functions.html#iter\" title=\"iter\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">iter()</span></code></a> o tratar con los objetos iteradores usted mismo.  La sentencia <code class=\"docutils literal notranslate\"><span class=\"pre\">for</span></code> lo hace autom\u00e1ticamente por usted, creando un variable temporal sin nombre para mantener el iterador mientras dura el bucle.  Vea tambi\u00e9n <a class=\"reference internal\" href=\"#term-iterator\"><span class=\"xref std std-term\">iterator</span></a>, <a class=\"reference internal\" href=\"#term-sequence\"><span class=\"xref std std-term\">sequence</span></a>, y <a class=\"reference internal\" href=\"#term-generator\"><span class=\"xref std std-term\">generator</span></a>.</p>\n</dd>\n</main>\n"}, "iterador": {"title": "iterador", "body": "<main>\n<dd><p>Un objeto que representa un flujo de datos.  Llamadas repetidas al m\u00e9todo  <a class=\"reference internal\" href=\"library/stdtypes.html#iterator.__next__\" title=\"iterator.__next__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__next__()</span></code></a> del iterador (o al pasar la funci\u00f3n incorporada <a class=\"reference internal\" href=\"library/functions.html#next\" title=\"next\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">next()</span></code></a>) retorna \u00edtems sucesivos del flujo.  Cuando no hay m\u00e1s datos disponibles, una excepci\u00f3n <a class=\"reference internal\" href=\"library/exceptions.html#StopIteration\" title=\"StopIteration\"><code class=\"xref py py-exc docutils literal notranslate\"><span class=\"pre\">StopIteration</span></code></a> es disparada.  En este momento, el objeto iterador est\u00e1 exhausto y cualquier llamada posterior al m\u00e9todo <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__next__()</span></code> s\u00f3lo dispara otra vez <a class=\"reference internal\" href=\"library/exceptions.html#StopIteration\" title=\"StopIteration\"><code class=\"xref py py-exc docutils literal notranslate\"><span class=\"pre\">StopIteration</span></code></a>.  Los iteradores necesitan tener un m\u00e9todo <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__iter__()</span></code> que retorna el objeto iterador mismo as\u00ed cada iterador es tambi\u00e9n un iterable y puede ser usado en casi todos los lugares donde los iterables son aceptados.  Una excepci\u00f3n importante es el c\u00f3digo que intenta m\u00faltiples pases de iteraci\u00f3n.  Un objeto contenedor (como la <a class=\"reference internal\" href=\"library/stdtypes.html#list\" title=\"list\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">list</span></code></a>) produce un nuevo iterador cada vez que pasa a una funci\u00f3n <a class=\"reference internal\" href=\"library/functions.html#iter\" title=\"iter\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">iter()</span></code></a> o se usa en un bucle  <a class=\"reference internal\" href=\"reference/compound_stmts.html#for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">for</span></code></a>.  Intentar \u00e9sto con un iterador simplemente retornar\u00eda el mismo objeto iterador exhausto usado en previas iteraciones, haci\u00e9ndolo aparecer como un contenedor vac\u00edo.</p>\n<p>Puede encontrar m\u00e1s informaci\u00f3n en <a class=\"reference internal\" href=\"library/stdtypes.html#typeiter\"><span class=\"std std-ref\">Tipos de iteradores</span></a>.</p>\n<div class=\"impl-detail compound\">\n<p><strong>Detalles de implementaci\u00f3n de CPython:</strong> CPython does not consistently apply the requirement that an iterator\ndefine <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__iter__()</span></code>.</p>\n</div>\n</dd>\n</main>\n"}, "funci\u00f3n clave": {"title": "funci\u00f3n clave", "body": "<main>\n<dd><p>Una funci\u00f3n clave o una funci\u00f3n de colaci\u00f3n es un invocable que retorna un valor usado para el ordenamiento o clasificaci\u00f3n.  Por ejemplo, <a class=\"reference internal\" href=\"library/locale.html#locale.strxfrm\" title=\"locale.strxfrm\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">locale.strxfrm()</span></code></a> es usada para producir claves de ordenamiento que se adaptan a las convenciones espec\u00edficas de ordenamiento de un <em>locale</em>.</p>\n<p>Cierta cantidad de herramientas de Python aceptan funciones clave para controlar como los elementos son ordenados o agrupados. Incluyendo a  <a class=\"reference internal\" href=\"library/functions.html#min\" title=\"min\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">min()</span></code></a>, <a class=\"reference internal\" href=\"library/functions.html#max\" title=\"max\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">max()</span></code></a>, <a class=\"reference internal\" href=\"library/functions.html#sorted\" title=\"sorted\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sorted()</span></code></a>, <a class=\"reference internal\" href=\"library/stdtypes.html#list.sort\" title=\"list.sort\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">list.sort()</span></code></a>, <a class=\"reference internal\" href=\"library/heapq.html#heapq.merge\" title=\"heapq.merge\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">heapq.merge()</span></code></a>, <a class=\"reference internal\" href=\"library/heapq.html#heapq.nsmallest\" title=\"heapq.nsmallest\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">heapq.nsmallest()</span></code></a>, <a class=\"reference internal\" href=\"library/heapq.html#heapq.nlargest\" title=\"heapq.nlargest\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">heapq.nlargest()</span></code></a>, y <a class=\"reference internal\" href=\"library/itertools.html#itertools.groupby\" title=\"itertools.groupby\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">itertools.groupby()</span></code></a>.</p>\n<p>There are several ways to create a key function.  For example. the\n<a class=\"reference internal\" href=\"library/stdtypes.html#str.lower\" title=\"str.lower\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">str.lower()</span></code></a> method can serve as a key function for case insensitive\nsorts.  Alternatively, a key function can be built from a\n<a class=\"reference internal\" href=\"reference/expressions.html#lambda\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">lambda</span></code></a> expression such as <code class=\"docutils literal notranslate\"><span class=\"pre\">lambda</span> <span class=\"pre\">r:</span> <span class=\"pre\">(r[0],</span> <span class=\"pre\">r[2])</span></code>.  Also,\n<a class=\"reference internal\" href=\"library/operator.html#operator.attrgetter\" title=\"operator.attrgetter\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">operator.attrgetter()</span></code></a>, <a class=\"reference internal\" href=\"library/operator.html#operator.itemgetter\" title=\"operator.itemgetter\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">operator.itemgetter()</span></code></a>, and\n<a class=\"reference internal\" href=\"library/operator.html#operator.methodcaller\" title=\"operator.methodcaller\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">operator.methodcaller()</span></code></a> are three key function constructors.  See the <a class=\"reference internal\" href=\"howto/sorting.html#sortinghowto\"><span class=\"std std-ref\">Sorting HOW TO</span></a> for examples of how to create and use key functions.</p>\n</dd>\n</main>\n"}, "argumento nombrado": {"title": "argumento nombrado", "body": "<main>\n<dd><p>Vea <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a>.</p>\n</dd>\n</main>\n"}, "lambda": {"title": "lambda", "body": "<main>\n<dd><p>Una funci\u00f3n an\u00f3nima de una l\u00ednea consistente en un sola <a class=\"reference internal\" href=\"#term-expression\"><span class=\"xref std std-term\">expression</span></a> que es evaluada cuando la funci\u00f3n es llamada.  La sintaxis para crear una funci\u00f3n lambda es <code class=\"docutils literal notranslate\"><span class=\"pre\">lambda</span> <span class=\"pre\">[parameters]:</span> <span class=\"pre\">expression</span></code></p>\n</dd>\n</main>\n"}, "lbyl": {"title": "LBYL", "body": "<main>\n<dd><p>Del ingl\u00e9s <em>Look before you leap</em>, \u00abmira antes de saltar\u00bb.  Es un estilo de codificaci\u00f3n que prueba expl\u00edcitamente las condiciones previas antes de hacer llamadas o b\u00fasquedas.  Este estilo contrasta con la manera <a class=\"reference internal\" href=\"#term-EAFP\"><span class=\"xref std std-term\">EAFP</span></a> y est\u00e1 caracterizado por la presencia de muchas sentencias <a class=\"reference internal\" href=\"reference/compound_stmts.html#if\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">if</span></code></a>.</p>\n<p>En entornos multi-hilos, el m\u00e9todo LBYL tiene el riesgo de introducir condiciones de carrera entre los hilos que est\u00e1n \u00abmirando\u00bb y los que est\u00e1n \u00absaltando\u00bb.  Por ejemplo, el c\u00f3digo, <code class=\"docutils literal notranslate\"><span class=\"pre\">if</span> <span class=\"pre\">key</span> <span class=\"pre\">in</span> <span class=\"pre\">mapping:</span> <span class=\"pre\">return</span> <span class=\"pre\">mapping[key]</span></code>  puede fallar si otro hilo remueve <em>key</em> de <em>mapping</em> despu\u00e9s del test, pero antes de retornar el valor.  Este problema puede ser resuelto usando bloqueos o empleando el m\u00e9todo EAFP.</p>\n</dd>\n</main>\n"}, "codificaci\u00f3n de la configuraci\u00f3n regional": {"title": "codificaci\u00f3n de la configuraci\u00f3n regional", "body": "<main>\n<dd><p>On Unix, it is the encoding of the LC_CTYPE locale. It can be set with\n<a class=\"reference internal\" href=\"library/locale.html#locale.setlocale\" title=\"locale.setlocale\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">locale.setlocale(locale.LC_CTYPE,</span> <span class=\"pre\">new_locale)</span></code></a>.</p>\n<p>On Windows, it is the ANSI code page (ex: <code class=\"docutils literal notranslate\"><span class=\"pre\">&quot;cp1252&quot;</span></code>).</p>\n<p>On Android and VxWorks, Python uses <code class=\"docutils literal notranslate\"><span class=\"pre\">&quot;utf-8&quot;</span></code> as the locale encoding.</p>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">locale.getencoding()</span></code> can be used to get the locale encoding.</p>\n<p>See also the <a class=\"reference internal\" href=\"#term-filesystem-encoding-and-error-handler\"><span class=\"xref std std-term\">filesystem encoding and error handler</span></a>.</p>\n</dd>\n</main>\n"}, "lista": {"title": "lista", "body": "<main>\n<dd><p>Es una <a class=\"reference internal\" href=\"#term-sequence\"><span class=\"xref std std-term\">sequence</span></a> Python incorporada.  A pesar de su nombre es m\u00e1s similar a un arreglo en otros lenguajes que a una lista enlazada porque el acceso a los elementos es O(1).</p>\n</dd>\n</main>\n"}, "comprensi\u00f3n de listas": {"title": "comprensi\u00f3n de listas", "body": "<main>\n<dd><p>Una forma compacta de procesar todos o parte de los elementos en una secuencia y retornar una lista como resultado.  <code class=\"docutils literal notranslate\"><span class=\"pre\">result</span> <span class=\"pre\">=</span> <span class=\"pre\">['{:#04x}'.format(x)</span> <span class=\"pre\">for</span> <span class=\"pre\">x</span> <span class=\"pre\">in</span> <span class=\"pre\">range(256)</span> <span class=\"pre\">if</span> <span class=\"pre\">x</span> <span class=\"pre\">%</span> <span class=\"pre\">2</span> <span class=\"pre\">==</span> <span class=\"pre\">0]</span></code> genera una lista de cadenas conteniendo n\u00fameros hexadecimales (0x..) entre 0 y 255. La cl\u00e1usula <a class=\"reference internal\" href=\"reference/compound_stmts.html#if\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">if</span></code></a> es opcional.  Si es omitida, todos los elementos en <code class=\"docutils literal notranslate\"><span class=\"pre\">range(256)</span></code> son procesados.</p>\n</dd>\n</main>\n"}, "cargador": {"title": "cargador", "body": "<main>\n<dd><p>Un objeto que carga un m\u00f3dulo. Debe definir el m\u00e9todo llamado <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">load_module()</span></code>.  Un cargador es normalmente retornados por un  <a class=\"reference internal\" href=\"#term-finder\"><span class=\"xref std std-term\">finder</span></a>. Vea <span class=\"target\" id=\"index-93\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0302/\"><strong>PEP 302</strong></a> para detalles y <a class=\"reference internal\" href=\"library/importlib.html#importlib.abc.Loader\" title=\"importlib.abc.Loader\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">importlib.abc.Loader</span></code></a> para una <a class=\"reference internal\" href=\"#term-abstract-base-class\"><span class=\"xref std std-term\">abstract base class</span></a>.</p>\n</dd>\n</main>\n"}, "m\u00e9todo m\u00e1gico": {"title": "m\u00e9todo m\u00e1gico", "body": "<main>\n<dd><p id=\"index-26\">Una manera informal de llamar a un <a class=\"reference internal\" href=\"#term-special-method\"><span class=\"xref std std-term\">special method</span></a>.</p>\n</dd>\n</main>\n"}, "mapeado": {"title": "mapeado", "body": "<main>\n<dd><p>A container object that supports arbitrary key lookups and implements the\nmethods specified in the <a class=\"reference internal\" href=\"library/collections.abc.html#collections.abc.Mapping\" title=\"collections.abc.Mapping\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">collections.abc.Mapping</span></code></a> or\n<a class=\"reference internal\" href=\"library/collections.abc.html#collections.abc.MutableMapping\" title=\"collections.abc.MutableMapping\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">collections.abc.MutableMapping</span></code></a>\n<a class=\"reference internal\" href=\"library/collections.abc.html#collections-abstract-base-classes\"><span class=\"std std-ref\">abstract base classes</span></a>.  Examples\ninclude <a class=\"reference internal\" href=\"library/stdtypes.html#dict\" title=\"dict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dict</span></code></a>, <a class=\"reference internal\" href=\"library/collections.html#collections.defaultdict\" title=\"collections.defaultdict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">collections.defaultdict</span></code></a>,\n<a class=\"reference internal\" href=\"library/collections.html#collections.OrderedDict\" title=\"collections.OrderedDict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">collections.OrderedDict</span></code></a> and <a class=\"reference internal\" href=\"library/collections.html#collections.Counter\" title=\"collections.Counter\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">collections.Counter</span></code></a>.</p>\n</dd>\n</main>\n"}, "meta buscadores de ruta": {"title": "meta buscadores de ruta", "body": "<main>\n<dd><p>Un <a class=\"reference internal\" href=\"#term-finder\"><span class=\"xref std std-term\">finder</span></a> retornado por una b\u00fasqueda de <a class=\"reference internal\" href=\"library/sys.html#sys.meta_path\" title=\"sys.meta_path\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.meta_path</span></code></a>.  Los meta buscadores de ruta est\u00e1n relacionados a <a class=\"reference internal\" href=\"#term-path-entry-finder\"><span class=\"xref std std-term\">buscadores de entradas de rutas</span></a>, pero son algo diferente.</p>\n<p>Vea en <a class=\"reference internal\" href=\"library/importlib.html#importlib.abc.MetaPathFinder\" title=\"importlib.abc.MetaPathFinder\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">importlib.abc.MetaPathFinder</span></code></a> los m\u00e9todos que los meta buscadores de ruta implementan.</p>\n</dd>\n</main>\n"}, "metaclase": {"title": "metaclase", "body": "<main>\n<dd><p>La clase de una clase.  Las definiciones de clases crean nombres de clase, un diccionario de clase, y una lista de clases base.  Las metaclases son responsables de tomar estos tres argumentos y crear la clase.  La mayor\u00eda de los objetos de un lenguaje de programaci\u00f3n orientado a objetos provienen de una implementaci\u00f3n por defecto.  Lo que hace a Python especial que es posible crear metaclases a medida.  La mayor\u00eda de los usuario nunca necesitar\u00e1n esta herramienta, pero cuando la necesidad surge, las metaclases pueden brindar soluciones poderosas y elegantes.  Han sido usadas para <em>loggear</em> acceso de atributos, agregar seguridad a hilos, rastrear la creaci\u00f3n de objetos, implementar <em>singletons</em>, y muchas otras tareas.</p>\n<p>M\u00e1s informaci\u00f3n hallar\u00e1 en <a class=\"reference internal\" href=\"reference/datamodel.html#metaclasses\"><span class=\"std std-ref\">Metaclases</span></a>.</p>\n</dd>\n</main>\n"}, "m\u00e9todo": {"title": "m\u00e9todo", "body": "<main>\n<dd><p>Una funci\u00f3n que es definida dentro del cuerpo de una clase.  Si es llamada como un atributo de una instancia de otra clase, el m\u00e9todo tomar\u00e1 el objeto instanciado como su primer <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a> (el cual es usualmente denominado <cite>self</cite>). Vea <a class=\"reference internal\" href=\"#term-function\"><span class=\"xref std std-term\">function</span></a> y <a class=\"reference internal\" href=\"#term-nested-scope\"><span class=\"xref std std-term\">nested scope</span></a>.</p>\n</dd>\n</main>\n"}, "orden de resoluci\u00f3n de m\u00e9todos": {"title": "orden de resoluci\u00f3n de m\u00e9todos", "body": "<main>\n<dd><p>Orden de resoluci\u00f3n de m\u00e9todos es el orden en el cual una clase base es buscada por un miembro durante la b\u00fasqueda. Mire en <a class=\"reference external\" href=\"https://www.python.org/download/releases/2.3/mro/\">The Python 2.3 Method Resolution Order</a> los detalles del algoritmo usado por el int\u00e9rprete Python desde la versi\u00f3n 2.3.</p>\n</dd>\n</main>\n"}, "m\u00f3dulo": {"title": "m\u00f3dulo", "body": "<main>\n<dd><p>Un objeto que sirve como unidad de organizaci\u00f3n del c\u00f3digo Python.  Los m\u00f3dulos tienen espacios de nombres conteniendo objetos Python arbitrarios.  Los m\u00f3dulos son cargados en Python por el proceso de <a class=\"reference internal\" href=\"#term-importing\"><span class=\"xref std std-term\">importing</span></a>.</p>\n<p>Vea tambi\u00e9n <a class=\"reference internal\" href=\"#term-package\"><span class=\"xref std std-term\">package</span></a>.</p>\n</dd>\n</main>\n"}, "especificador de m\u00f3dulo": {"title": "especificador de m\u00f3dulo", "body": "<main>\n<dd><p>Un espacio de nombres que contiene la informaci\u00f3n relacionada a la importaci\u00f3n usada al leer un m\u00f3dulo.  Una instancia de  <a class=\"reference internal\" href=\"library/importlib.html#importlib.machinery.ModuleSpec\" title=\"importlib.machinery.ModuleSpec\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">importlib.machinery.ModuleSpec</span></code></a>.</p>\n</dd>\n</main>\n"}, "mro": {"title": "MRO", "body": "<main>\n<dd><p>Vea <a class=\"reference internal\" href=\"#term-method-resolution-order\"><span class=\"xref std std-term\">method resolution order</span></a>.</p>\n</dd>\n</main>\n"}, "mutable": {"title": "mutable", "body": "<main>\n<dd><p>Los objetos mutables pueden cambiar su valor pero mantener su <a class=\"reference internal\" href=\"library/functions.html#id\" title=\"id\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">id()</span></code></a>.  Vea tambi\u00e9n <a class=\"reference internal\" href=\"#term-immutable\"><span class=\"xref std std-term\">immutable</span></a>.</p>\n</dd>\n</main>\n"}, "tupla nombrada": {"title": "tupla nombrada", "body": "<main>\n<dd><p>La denominaci\u00f3n \u00abtupla nombrada\u00bb se aplica a cualquier tipo o clase que hereda de una tupla y cuyos elementos indexables son tambi\u00e9n accesibles usando atributos nombrados. Este tipo o clase puede tener adem\u00e1s otras capacidades.</p>\n<p>Varios tipos incorporados son tuplas nombradas, incluyendo los valores retornados por <a class=\"reference internal\" href=\"library/time.html#time.localtime\" title=\"time.localtime\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">time.localtime()</span></code></a> y <a class=\"reference internal\" href=\"library/os.html#os.stat\" title=\"os.stat\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">os.stat()</span></code></a>.  Otro ejemplo es <a class=\"reference internal\" href=\"library/sys.html#sys.float_info\" title=\"sys.float_info\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.float_info</span></code></a>:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">float_info</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>                   <span class=\"c1\"># indexed access</span>\n<span class=\"go\">1024</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">float_info</span><span class=\"o\">.</span><span class=\"n\">max_exp</span>              <span class=\"c1\"># named field access</span>\n<span class=\"go\">1024</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">float_info</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">)</span>   <span class=\"c1\"># kind of tuple</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n<p>Algunas tuplas nombradas con tipos incorporados (como en los ejemplo precedentes). Tambi\u00e9n puede ser creada con una definici\u00f3n regular de clase que hereda de la clase  <a class=\"reference internal\" href=\"library/stdtypes.html#tuple\" title=\"tuple\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">tuple</span></code></a> y que define campos nombrados.  Una clase como esta puede ser hechas personalizadamente o puede ser creada con la funci\u00f3n factor\u00eda <a class=\"reference internal\" href=\"library/collections.html#collections.namedtuple\" title=\"collections.namedtuple\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">collections.namedtuple()</span></code></a>.  Esta \u00faltima t\u00e9cnica autom\u00e1ticamente brinda m\u00e9todos adicionales que pueden no estar presentes en las tuplas nombradas personalizadas o incorporadas.</p>\n</dd>\n</main>\n"}, "espacio de nombres": {"title": "espacio de nombres", "body": "<main>\n<dd><p>El lugar donde la variable es almacenada.  Los espacios de nombres son implementados como diccionarios.  Hay espacio de nombre local, global, e incorporado as\u00ed como espacios de nombres anidados en objetos (en m\u00e9todos).  Los espacios de nombres soportan modularidad previniendo conflictos de nombramiento.  Por ejemplo, las funciones <a class=\"reference internal\" href=\"library/functions.html#open\" title=\"open\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">builtins.open</span></code></a> y <a class=\"reference internal\" href=\"library/os.html#os.open\" title=\"os.open\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">os.open()</span></code></a> se distinguen por su espacio de nombres.  Los espacios de nombres tambi\u00e9n ayuda a la legibilidad y mantenibilidad dejando claro qu\u00e9 m\u00f3dulo implementa una funci\u00f3n.  Por ejemplo, escribiendo <a class=\"reference internal\" href=\"library/random.html#random.seed\" title=\"random.seed\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">random.seed()</span></code></a> o <a class=\"reference internal\" href=\"library/itertools.html#itertools.islice\" title=\"itertools.islice\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">itertools.islice()</span></code></a> queda claro que \u00e9stas funciones est\u00e1n implementadas en los m\u00f3dulos <a class=\"reference internal\" href=\"library/random.html#module-random\" title=\"random: Generate pseudo-random numbers with various common distributions.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">random</span></code></a> y <a class=\"reference internal\" href=\"library/itertools.html#module-itertools\" title=\"itertools: Functions creating iterators for efficient looping.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">itertools</span></code></a>, respectivamente.</p>\n</dd>\n</main>\n"}, "paquete de espacios de nombres": {"title": "paquete de espacios de nombres", "body": "<main>\n<dd><p>Un <span class=\"target\" id=\"index-94\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0420/\"><strong>PEP 420</strong></a> <a class=\"reference internal\" href=\"#term-package\"><span class=\"xref std std-term\">package</span></a> que sirve s\u00f3lo para contener subpaquetes.  Los paquetes de espacios de nombres pueden no tener representaci\u00f3n f\u00edsica, y espec\u00edficamente se diferencian de los <a class=\"reference internal\" href=\"#term-regular-package\"><span class=\"xref std std-term\">regular package</span></a> porque no tienen un archivo <code class=\"docutils literal notranslate\"><span class=\"pre\">__init__.py</span></code>.</p>\n<p>Vea tambi\u00e9n <a class=\"reference internal\" href=\"#term-module\"><span class=\"xref std std-term\">module</span></a>.</p>\n</dd>\n</main>\n"}, "alcances anidados": {"title": "alcances anidados", "body": "<main>\n<dd><p>La habilidad de referirse a una variable dentro de una definici\u00f3n encerrada.  Por ejemplo, una funci\u00f3n definida dentro de otra funci\u00f3n puede referir a variables en la funci\u00f3n externa.  Note que los alcances anidados por defecto s\u00f3lo funcionan para referencia y no para asignaci\u00f3n.  Las variables locales leen y escriben s\u00f3lo en el alcance m\u00e1s interno.  De manera semejante, las variables globales pueden leer y escribir en el espacio de nombres global.  Con <a class=\"reference internal\" href=\"reference/simple_stmts.html#nonlocal\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">nonlocal</span></code></a> se puede escribir en alcances exteriores.</p>\n</dd>\n</main>\n"}, "clase de nuevo estilo": {"title": "clase de nuevo estilo", "body": "<main>\n<dd><p>Vieja denominaci\u00f3n usada para el estilo de clases ahora empleado en todos los objetos de clase.  En versiones m\u00e1s tempranas de Python, s\u00f3lo las nuevas clases pod\u00edan usar capacidades nuevas y vers\u00e1tiles de Python como <a class=\"reference internal\" href=\"reference/datamodel.html#object.__slots__\" title=\"object.__slots__\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">__slots__</span></code></a>, descriptores, propiedades, <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__getattribute__()</span></code>, m\u00e9todos de clase y m\u00e9todos est\u00e1ticos.</p>\n</dd>\n</main>\n"}, "objeto": {"title": "objeto", "body": "<main>\n<dd><p>Cualquier dato con estado (atributo o valor) y comportamiento definido (m\u00e9todos).  Tambi\u00e9n es la m\u00e1s b\u00e1sica clase base para cualquier <a class=\"reference internal\" href=\"#term-new-style-class\"><span class=\"xref std std-term\">new-style class</span></a>.</p>\n</dd>\n</main>\n"}, "paquete": {"title": "paquete", "body": "<main>\n<dd><p>A Python <a class=\"reference internal\" href=\"#term-module\"><span class=\"xref std std-term\">module</span></a> which can contain submodules or recursively,\nsubpackages.  Technically, a package is a Python module with a\n<code class=\"docutils literal notranslate\"><span class=\"pre\">__path__</span></code> attribute.</p>\n<p>Vea tambi\u00e9n <a class=\"reference internal\" href=\"#term-regular-package\"><span class=\"xref std std-term\">regular package</span></a> y <a class=\"reference internal\" href=\"#term-namespace-package\"><span class=\"xref std std-term\">namespace package</span></a>.</p>\n</dd>\n</main>\n"}, "par\u00e1metro": {"title": "par\u00e1metro", "body": "<main>\n<dd><p>Una entidad nombrada en una definici\u00f3n de una <a class=\"reference internal\" href=\"#term-function\"><span class=\"xref std std-term\">function</span></a> (o m\u00e9todo) que especifica un <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a> (o en algunos casos, varios argumentos) que la funci\u00f3n puede aceptar.  Existen cinco tipos de argumentos:</p>\n<ul>\n<li><p><em class=\"dfn\">posicional o nombrado</em>: especifica un argumento que puede ser pasado tanto como <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">posicional</span></a> o como <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">nombrado</span></a>.  Este es el tipo por defecto de par\u00e1metro, como <em>foo</em> y <em>bar</em> en el siguiente ejemplo:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"n\">bar</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n</pre></div>\n</div>\n</li>\n</ul>\n<ul id=\"positional-only-parameter\">\n<li><p><em class=\"dfn\">s\u00f3lo posicional</em>: especifica un argumento que puede ser pasado s\u00f3lo por posici\u00f3n.  Los par\u00e1metros s\u00f3lo posicionales pueden ser definidos incluyendo un car\u00e1cter <code class=\"docutils literal notranslate\"><span class=\"pre\">/</span></code> en la lista de par\u00e1metros de la funci\u00f3n despu\u00e9s de ellos, como <em>posonly1</em> y <em>posonly2</em> en el ejemplo que sigue:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">posonly1</span><span class=\"p\">,</span> <span class=\"n\">posonly2</span><span class=\"p\">,</span> <span class=\"o\">/</span><span class=\"p\">,</span> <span class=\"n\">positional_or_keyword</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n</pre></div>\n</div>\n</li>\n</ul>\n<ul id=\"keyword-only-parameter\">\n<li><p><em class=\"dfn\">s\u00f3lo nombrado</em>: especifica un argumento que s\u00f3lo puede ser pasado por nombre.  Los par\u00e1metros s\u00f3lo por nombre pueden ser definidos incluyendo un par\u00e1metro posicional de una sola variable o un simple <code class=\"docutils literal notranslate\"><span class=\"pre\">*`</span></code> antes de ellos en la lista de par\u00e1metros en la definici\u00f3n de la funci\u00f3n, como <em>kw_only1</em> y <em>kw_only2</em> en el ejemplo siguiente:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"p\">,</span> <span class=\"n\">kw_only1</span><span class=\"p\">,</span> <span class=\"n\">kw_only2</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n</pre></div>\n</div>\n</li>\n<li><p><em class=\"dfn\">variable posicional</em>: especifica una secuencia arbitraria de argumentos posicionales que pueden ser brindados (adem\u00e1s de cualquier argumento posicional aceptado por otros par\u00e1metros).  Este par\u00e1metro puede ser definido anteponiendo al nombre del par\u00e1metro <code class=\"docutils literal notranslate\"><span class=\"pre\">*</span></code>, como a <em>args</em> en el siguiente ejemplo:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n</pre></div>\n</div>\n</li>\n<li><p><em class=\"dfn\">variable nombrado</em>: especifica que arbitrariamente muchos argumentos nombrados pueden ser brindados (adem\u00e1s de cualquier argumento nombrado ya aceptado por cualquier otro par\u00e1metro).  Este par\u00e1metro puede ser definido anteponiendo al nombre del par\u00e1metro con <code class=\"docutils literal notranslate\"><span class=\"pre\">**</span></code>, como <em>kwargs</em> en el ejemplo precedente.</p></li>\n</ul>\n<p>Los par\u00e1metros puede especificar tanto argumentos opcionales como requeridos, as\u00ed como valores por defecto para algunos argumentos opcionales.</p>\n<p>Vea tambi\u00e9n el glosario de <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a>, la pregunta respondida en <a class=\"reference internal\" href=\"faq/programming.html#faq-argument-vs-parameter\"><span class=\"std std-ref\">la diferencia entre argumentos y par\u00e1metros</span></a>, la clase <a class=\"reference internal\" href=\"library/inspect.html#inspect.Parameter\" title=\"inspect.Parameter\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">inspect.Parameter</span></code></a>, la secci\u00f3n <a class=\"reference internal\" href=\"reference/compound_stmts.html#function\"><span class=\"std std-ref\">Definiciones de funciones</span></a> , y <span class=\"target\" id=\"index-95\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0362/\"><strong>PEP 362</strong></a>.</p>\n</dd>\n</main>\n"}, "entrada de ruta": {"title": "entrada de ruta", "body": "<main>\n<dd><p>Una ubicaci\u00f3n \u00fanica en el <a class=\"reference internal\" href=\"#term-import-path\"><span class=\"xref std std-term\">import path</span></a> que el <a class=\"reference internal\" href=\"#term-path-based-finder\"><span class=\"xref std std-term\">path based finder</span></a> consulta para encontrar los m\u00f3dulos a importar.</p>\n</dd>\n</main>\n"}, "buscador de entradas de ruta": {"title": "buscador de entradas de ruta", "body": "<main>\n<dd><p>Un <a class=\"reference internal\" href=\"#term-finder\"><span class=\"xref std std-term\">finder</span></a> retornado por un invocable en <a class=\"reference internal\" href=\"library/sys.html#sys.path_hooks\" title=\"sys.path_hooks\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.path_hooks</span></code></a> (esto es, un <a class=\"reference internal\" href=\"#term-path-entry-hook\"><span class=\"xref std std-term\">path entry hook</span></a>) que sabe c\u00f3mo localizar m\u00f3dulos dada una <a class=\"reference internal\" href=\"#term-path-entry\"><span class=\"xref std std-term\">path entry</span></a>.</p>\n<p>Vea en <a class=\"reference internal\" href=\"library/importlib.html#importlib.abc.PathEntryFinder\" title=\"importlib.abc.PathEntryFinder\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">importlib.abc.PathEntryFinder</span></code></a> los m\u00e9todos que los buscadores de entradas de ruta implementan.</p>\n</dd>\n</main>\n"}, "gancho a entrada de ruta": {"title": "gancho a entrada de ruta", "body": "<main>\n<dd><p>Un invocable en la lista <code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.path_hook</span></code> que retorna un <a class=\"reference internal\" href=\"#term-path-entry-finder\"><span class=\"xref std std-term\">path entry finder</span></a> si \u00e9ste sabe c\u00f3mo encontrar m\u00f3dulos en un <a class=\"reference internal\" href=\"#term-path-entry\"><span class=\"xref std std-term\">path entry</span></a> espec\u00edfico.</p>\n</dd>\n</main>\n"}, "buscador basado en ruta": {"title": "buscador basado en ruta", "body": "<main>\n<dd><p>Uno de los <a class=\"reference internal\" href=\"#term-meta-path-finder\"><span class=\"xref std std-term\">meta buscadores de ruta</span></a> por defecto que busca un <a class=\"reference internal\" href=\"#term-import-path\"><span class=\"xref std std-term\">import path</span></a> para los m\u00f3dulos.</p>\n</dd>\n</main>\n"}, "objeto tipo ruta": {"title": "objeto tipo ruta", "body": "<main>\n<dd><p>Un objeto que representa una ruta del sistema de archivos. Un objeto tipo ruta puede ser tanto una <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a> como un <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a> representando una ruta, o un objeto que implementa el protocolo <a class=\"reference internal\" href=\"library/os.html#os.PathLike\" title=\"os.PathLike\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">os.PathLike</span></code></a>. Un objeto que soporta el protocolo  <a class=\"reference internal\" href=\"library/os.html#os.PathLike\" title=\"os.PathLike\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">os.PathLike</span></code></a> puede ser convertido a ruta del sistema de archivo de clase <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a> o <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a> usando la funci\u00f3n <a class=\"reference internal\" href=\"library/os.html#os.fspath\" title=\"os.fspath\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">os.fspath()</span></code></a>; <a class=\"reference internal\" href=\"library/os.html#os.fsdecode\" title=\"os.fsdecode\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">os.fsdecode()</span></code></a> <a class=\"reference internal\" href=\"library/os.html#os.fsencode\" title=\"os.fsencode\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">os.fsencode()</span></code></a> pueden emplearse para garantizar que retorne respectivamente <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a> o <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a>. Introducido por <span class=\"target\" id=\"index-96\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0519/\"><strong>PEP 519</strong></a>.</p>\n</dd>\n</main>\n"}, "pep": {"title": "PEP", "body": "<main>\n<dd><p>Propuesta de mejora de Python, del ingl\u00e9s <em>Python Enhancement Proposal</em>. Un PEP es un documento de dise\u00f1o que brinda informaci\u00f3n a la comunidad Python, o describe una nueva capacidad para Python, sus procesos o entorno. Los PEPs deber\u00edan dar una especificaci\u00f3n t\u00e9cnica concisa y una fundamentaci\u00f3n para las capacidades propuestas.</p>\n<p>Los PEPs tienen como prop\u00f3sito ser los mecanismos primarios para proponer nuevas y mayores capacidad, para recoger la opini\u00f3n de la comunidad sobre un tema, y para documentar las decisiones de dise\u00f1o que se han hecho en Python. El autor del PEP es el responsable de lograr consenso con la comunidad y documentar las opiniones disidentes.</p>\n<p>Vea <span class=\"target\" id=\"index-97\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0001/\"><strong>PEP 1</strong></a>.</p>\n</dd>\n</main>\n"}, "porci\u00f3n": {"title": "porci\u00f3n", "body": "<main>\n<dd><p>Un conjunto de archivos en un \u00fanico directorio (posiblemente guardo en un archivo comprimido <em>zip</em>) que contribuye a un espacio de nombres de paquete, como est\u00e1 definido en <span class=\"target\" id=\"index-98\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0420/\"><strong>PEP 420</strong></a>.</p>\n</dd>\n</main>\n"}, "argumento posicional": {"title": "argumento posicional", "body": "<main>\n<dd><p>Vea <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a>.</p>\n</dd>\n</main>\n"}, "api provisional": {"title": "API provisional", "body": "<main>\n<dd><p>Una API provisoria es aquella que deliberadamente fue excluida de las garant\u00edas de compatibilidad hacia atr\u00e1s de la biblioteca est\u00e1ndar.  Aunque no se esperan cambios fundamentales en dichas interfaces, como est\u00e1n marcadas como provisionales, los cambios incompatibles hacia atr\u00e1s (incluso remover la misma interfaz) podr\u00edan ocurrir si los desarrolladores principales lo estiman.  Estos cambios no se hacen gratuitamente \u2013 solo ocurrir\u00e1n si fallas fundamentales y serias son descubiertas que no fueron vistas antes de la inclusi\u00f3n de la API.</p>\n<p>Incluso para APIs provisorias, los cambios incompatibles hacia atr\u00e1s son vistos como una \u00absoluci\u00f3n de \u00faltimo recurso\u00bb - se intentar\u00e1 todo para encontrar una soluci\u00f3n compatible hacia atr\u00e1s para los problemas identificados.</p>\n<p>Este proceso permite que la biblioteca est\u00e1ndar contin\u00fae evolucionando con el tiempo, sin bloquearse por errores de dise\u00f1o problem\u00e1ticos por per\u00edodos extensos de tiempo. Vea <span class=\"target\" id=\"index-99\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0411/\"><strong>PEP 411</strong></a> para m\u00e1s detalles.</p>\n</dd>\n</main>\n"}, "paquete provisorio": {"title": "paquete provisorio", "body": "<main>\n<dd><p>Vea <a class=\"reference internal\" href=\"#term-provisional-API\"><span class=\"xref std std-term\">provisional API</span></a>.</p>\n</dd>\n</main>\n"}, "python 3000": {"title": "Python 3000", "body": "<main>\n<dd><p>Apodo para la fecha de lanzamiento de Python 3.x (acu\u00f1ada en un tiempo cuando llegar a la versi\u00f3n 3 era algo distante en el futuro.)  Tambi\u00e9n se lo abrevi\u00f3 como <em>Py3k</em>.</p>\n</dd>\n</main>\n"}, "pyth\u00f3nico": {"title": "Pyth\u00f3nico", "body": "<main>\n<dd><p>Una idea o pieza de c\u00f3digo que sigue ajustadamente la convenciones idiom\u00e1ticas comunes del lenguaje Python, en vez de implementar c\u00f3digo usando conceptos comunes a otros lenguajes.  Por ejemplo, una convenci\u00f3n com\u00fan en Python es hacer bucles sobre todos los elementos de un iterable con la sentencia <a class=\"reference internal\" href=\"reference/compound_stmts.html#for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">for</span></code></a>.  Muchos otros lenguajes no tienen este tipo de construcci\u00f3n, as\u00ed que los que no est\u00e1n familiarizados con Python podr\u00edan usar contadores num\u00e9ricos:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">food</span><span class=\"p\">)):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">food</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span>\n</pre></div>\n</div>\n<p>En contraste, un m\u00e9todo Pyth\u00f3nico m\u00e1s limpio:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">for</span> <span class=\"n\">piece</span> <span class=\"ow\">in</span> <span class=\"n\">food</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">piece</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n</dd>\n</main>\n"}, "nombre calificado": {"title": "nombre calificado", "body": "<main>\n<dd><p>Un nombre con puntos mostrando la ruta desde el alcance global del m\u00f3dulo a la clase, funci\u00f3n o m\u00e9todo definido en dicho m\u00f3dulo, como se define en <span class=\"target\" id=\"index-100\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-3155/\"><strong>PEP 3155</strong></a>.  Para las funciones o clases de m\u00e1s alto nivel, el nombre calificado es el igual al nombre del objeto:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">class</span> <span class=\"nc\">C</span><span class=\"p\">:</span>\n<span class=\"gp\">... </span>    <span class=\"k\">class</span> <span class=\"nc\">D</span><span class=\"p\">:</span>\n<span class=\"gp\">... </span>        <span class=\"k\">def</span> <span class=\"nf\">meth</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>            <span class=\"k\">pass</span>\n<span class=\"gp\">...</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">C</span><span class=\"o\">.</span><span class=\"vm\">__qualname__</span>\n<span class=\"go\">&#39;C&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">D</span><span class=\"o\">.</span><span class=\"vm\">__qualname__</span>\n<span class=\"go\">&#39;C.D&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">D</span><span class=\"o\">.</span><span class=\"n\">meth</span><span class=\"o\">.</span><span class=\"vm\">__qualname__</span>\n<span class=\"go\">&#39;C.D.meth&#39;</span>\n</pre></div>\n</div>\n<p>Cuando es usado para referirse a los m\u00f3dulos, <em>nombre completamente calificado</em> significa la ruta con puntos completo al m\u00f3dulo, incluyendo cualquier paquete padre, por ejemplo, <code class=\"docutils literal notranslate\"><span class=\"pre\">email.mime.text</span></code>:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">email.mime.text</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">email</span><span class=\"o\">.</span><span class=\"n\">mime</span><span class=\"o\">.</span><span class=\"n\">text</span><span class=\"o\">.</span><span class=\"vm\">__name__</span>\n<span class=\"go\">&#39;email.mime.text&#39;</span>\n</pre></div>\n</div>\n</dd>\n</main>\n"}, "contador de referencias": {"title": "contador de referencias", "body": "<main>\n<dd><p>The number of references to an object.  When the reference count of an\nobject drops to zero, it is deallocated.  Reference counting is\ngenerally not visible to Python code, but it is a key element of the\n<a class=\"reference internal\" href=\"#term-CPython\"><span class=\"xref std std-term\">CPython</span></a> implementation.  Programmers can call the\n<a class=\"reference internal\" href=\"library/sys.html#sys.getrefcount\" title=\"sys.getrefcount\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sys.getrefcount()</span></code></a> function to return the\nreference count for a particular object.</p>\n</dd>\n</main>\n"}, "paquete regular": {"title": "paquete regular", "body": "<main>\n<dd><p>Un  <a class=\"reference internal\" href=\"#term-package\"><span class=\"xref std std-term\">package</span></a> tradicional, como aquellos con un directorio conteniendo el archivo <code class=\"docutils literal notranslate\"><span class=\"pre\">__init__.py</span></code>.</p>\n<p>Vea tambi\u00e9n <a class=\"reference internal\" href=\"#term-namespace-package\"><span class=\"xref std std-term\">namespace package</span></a>.</p>\n</dd>\n</main>\n"}, "__slots__": {"title": "__slots__", "body": "<main>\n<dd><p>Es una declaraci\u00f3n dentro de una clase que ahorra memoria predeclarando espacio para las atributos de la instancia y eliminando diccionarios de la instancia.  Aunque es popular, esta t\u00e9cnica es algo dificultosa de lograr correctamente y es mejor reservarla para los casos raros en los que existen grandes cantidades de instancias en aplicaciones con uso cr\u00edtico de memoria.</p>\n</dd>\n</main>\n"}, "secuencia": {"title": "secuencia", "body": "<main>\n<dd><p>Un <a class=\"reference internal\" href=\"#term-iterable\"><span class=\"xref std std-term\">iterable</span></a> que logra un acceso eficiente a los elementos usando \u00edndices enteros a trav\u00e9s del m\u00e9todo especial <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__getitem__()</span></code> y que define un m\u00e9todo <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__len__()</span></code> que retorna la longitud de la secuencia. Algunas de las secuencias incorporadas son <a class=\"reference internal\" href=\"library/stdtypes.html#list\" title=\"list\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">list</span></code></a>, <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a>, <a class=\"reference internal\" href=\"library/stdtypes.html#tuple\" title=\"tuple\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">tuple</span></code></a>, y <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a>. Observe que <a class=\"reference internal\" href=\"library/stdtypes.html#dict\" title=\"dict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dict</span></code></a> tambi\u00e9n soporta <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__getitem__()</span></code> y <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__len__()</span></code>, pero es considerada un mapeo m\u00e1s que una secuencia porque las b\u00fasquedas son por claves arbitraria <a class=\"reference internal\" href=\"#term-immutable\"><span class=\"xref std std-term\">immutable</span></a> y no por enteros.</p>\n<p>La clase abstracta base <a class=\"reference internal\" href=\"library/collections.abc.html#collections.abc.Sequence\" title=\"collections.abc.Sequence\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">collections.abc.Sequence</span></code></a> define una interfaz mucho m\u00e1s rica que va m\u00e1s all\u00e1 de s\u00f3lo <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__getitem__()</span></code> y <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__len__()</span></code>, agregando <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">count()</span></code>, <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">index()</span></code>, <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__contains__()</span></code>, y <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__reversed__()</span></code>. Los tipos que implementan esta interfaz expandida pueden ser registrados expl\u00edcitamente usando <code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">register()</span></code>.</p>\n</dd>\n</main>\n"}, "comprensi\u00f3n de conjuntos": {"title": "comprensi\u00f3n de conjuntos", "body": "<main>\n<dd><p>Una forma compacta de procesar todos o parte de los elementos en un iterable y retornar un conjunto con los resultados. <code class=\"docutils literal notranslate\"><span class=\"pre\">results</span> <span class=\"pre\">=</span> <span class=\"pre\">{c</span> <span class=\"pre\">for</span> <span class=\"pre\">c</span> <span class=\"pre\">in</span> <span class=\"pre\">'abracadabra'</span> <span class=\"pre\">if</span> <span class=\"pre\">c</span> <span class=\"pre\">not</span> <span class=\"pre\">in</span> <span class=\"pre\">'abc'}</span></code> genera el conjunto de cadenas <code class=\"docutils literal notranslate\"><span class=\"pre\">{'r',</span> <span class=\"pre\">'d'}</span></code>. Ver <a class=\"reference internal\" href=\"reference/expressions.html#comprehensions\"><span class=\"std std-ref\">Despliegues para listas, conjuntos y diccionarios</span></a>.</p>\n</dd>\n</main>\n"}, "despacho \u00fanico": {"title": "despacho \u00fanico", "body": "<main>\n<dd><p>Una forma de despacho de una <a class=\"reference internal\" href=\"#term-generic-function\"><span class=\"xref std std-term\">generic function</span></a> donde la implementaci\u00f3n es elegida a partir del tipo de un s\u00f3lo argumento.</p>\n</dd>\n</main>\n"}, "rebanada": {"title": "rebanada", "body": "<main>\n<dd><p>Un objeto que contiene una porci\u00f3n de una <a class=\"reference internal\" href=\"#term-sequence\"><span class=\"xref std std-term\">sequence</span></a>.  Una rebanada es creada usando la notaci\u00f3n de suscripto, <code class=\"docutils literal notranslate\"><span class=\"pre\">[]</span></code> con dos puntos entre los n\u00fameros cuando se ponen varios, como en <code class=\"docutils literal notranslate\"><span class=\"pre\">nombre_variable[1:3:5]</span></code>.  La notaci\u00f3n con corchete (suscrito) usa internamente objetos <a class=\"reference internal\" href=\"library/functions.html#slice\" title=\"slice\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">slice</span></code></a>.</p>\n</dd>\n</main>\n"}, "m\u00e9todo especial": {"title": "m\u00e9todo especial", "body": "<main>\n<dd><p id=\"index-34\">Un m\u00e9todo que es llamado impl\u00edcitamente por Python cuando ejecuta ciertas operaciones en un tipo, como la adici\u00f3n.  Estos m\u00e9todos tienen nombres que comienzan y terminan con doble barra baja.  Los m\u00e9todos especiales est\u00e1n documentados en <a class=\"reference internal\" href=\"reference/datamodel.html#specialnames\"><span class=\"std std-ref\">Nombres especiales de m\u00e9todo</span></a>.</p>\n</dd>\n</main>\n"}, "sentencia": {"title": "sentencia", "body": "<main>\n<dd><p>Una sentencia es parte de un conjunto (un \u00abbloque\u00bb de c\u00f3digo).  Una sentencia tanto es una <a class=\"reference internal\" href=\"#term-expression\"><span class=\"xref std std-term\">expression</span></a>  como alguna de las varias sintaxis usando una palabra clave, como <a class=\"reference internal\" href=\"reference/compound_stmts.html#if\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">if</span></code></a>, <a class=\"reference internal\" href=\"reference/compound_stmts.html#while\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">while</span></code></a> o <a class=\"reference internal\" href=\"reference/compound_stmts.html#for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">for</span></code></a>.</p>\n</dd>\n</main>\n"}, "referencia fuerte": {"title": "referencia fuerte", "body": "<main>\n<dd><p>En la API C de Python, una referencia fuerte es una referencia a un objeto que incrementa el recuento de referencias del objeto cuando se crea y disminuye el recuento de referencias del objeto cuando se elimina.</p>\n<p>La funci\u00f3n <a class=\"reference internal\" href=\"c-api/refcounting.html#c.Py_NewRef\" title=\"Py_NewRef\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">Py_NewRef()</span></code></a> se puede utilizar para crear una referencia fuerte a un objeto. Por lo general, se debe llamar a la funci\u00f3n <a class=\"reference internal\" href=\"c-api/refcounting.html#c.Py_DECREF\" title=\"Py_DECREF\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">Py_DECREF()</span></code></a> en la referencia fuerte antes de salir del alcance de la referencia fuerte, para evitar filtrar una referencia.</p>\n<p>Consulte tambi\u00e9n <a class=\"reference internal\" href=\"#term-borrowed-reference\"><span class=\"xref std std-term\">borrowed reference</span></a>.</p>\n</dd>\n</main>\n"}, "codificaci\u00f3n de texto": {"title": "codificaci\u00f3n de texto", "body": "<main>\n<dd><p>A string in Python is a sequence of Unicode code points (in range\n<code class=\"docutils literal notranslate\"><span class=\"pre\">U+0000</span></code>\u2013<code class=\"docutils literal notranslate\"><span class=\"pre\">U+10FFFF</span></code>). To store or transfer a string, it needs to be\nserialized as a sequence of bytes.</p>\n<p>Serializing a string into a sequence of bytes is known as \u00abencoding\u00bb, and\nrecreating the string from the sequence of bytes is known as \u00abdecoding\u00bb.</p>\n<p>There are a variety of different text serialization\n<a class=\"reference internal\" href=\"library/codecs.html#standard-encodings\"><span class=\"std std-ref\">codecs</span></a>, which are collectively referred to as\n\u00abtext encodings\u00bb.</p>\n</dd>\n</main>\n"}, "archivo de texto": {"title": "archivo de texto", "body": "<main>\n<dd><p>Un <a class=\"reference internal\" href=\"#term-file-object\"><span class=\"xref std std-term\">file object</span></a> capaz de leer y escribir objetos <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a>. Frecuentemente, un archivo de texto tambi\u00e9n accede a un flujo de datos binario y maneja autom\u00e1ticamente el <a class=\"reference internal\" href=\"#term-text-encoding\"><span class=\"xref std std-term\">text encoding</span></a>. Ejemplos de archivos de texto que son abiertos en modo texto (<code class=\"docutils literal notranslate\"><span class=\"pre\">'r'</span></code> o <code class=\"docutils literal notranslate\"><span class=\"pre\">'w'</span></code>), <a class=\"reference internal\" href=\"library/sys.html#sys.stdin\" title=\"sys.stdin\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.stdin</span></code></a>, <a class=\"reference internal\" href=\"library/sys.html#sys.stdout\" title=\"sys.stdout\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.stdout</span></code></a>, y las instancias de <a class=\"reference internal\" href=\"library/io.html#io.StringIO\" title=\"io.StringIO\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">io.StringIO</span></code></a>.</p>\n<p>Vea tambi\u00e9n <a class=\"reference internal\" href=\"#term-binary-file\"><span class=\"xref std std-term\">binary file</span></a> por objeto de archivos capaces de leer y escribir <a class=\"reference internal\" href=\"#term-bytes-like-object\"><span class=\"xref std std-term\">objeto tipo binario</span></a>.</p>\n</dd>\n</main>\n"}, "cadena con triple comilla": {"title": "cadena con triple comilla", "body": "<main>\n<dd><p>Una cadena que est\u00e1 enmarcada por tres instancias de comillas (\u00bb) o apostrofes (\u201c).  Aunque no brindan ninguna funcionalidad que no est\u00e1 disponible usando cadenas con comillas simple, son \u00fatiles por varias razones.  Permiten incluir comillas simples o dobles sin escapar dentro de las cadenas y pueden abarcar m\u00faltiples l\u00edneas sin el uso de caracteres de continuaci\u00f3n, haci\u00e9ndolas particularmente \u00fatiles para escribir docstrings.</p>\n</dd>\n</main>\n"}, "tipo": {"title": "tipo", "body": "<main>\n<dd><p>El tipo de un objeto Python determina qu\u00e9 tipo de objeto es; cada objeto tiene un tipo.  El tipo de un objeto puede ser accedido por su atributo <a class=\"reference internal\" href=\"library/stdtypes.html#instance.__class__\" title=\"instance.__class__\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">__class__</span></code></a> o puede ser conseguido usando <code class=\"docutils literal notranslate\"><span class=\"pre\">type(obj)</span></code>.</p>\n</dd>\n</main>\n"}, "alias de tipos": {"title": "alias de tipos", "body": "<main>\n<dd><p>Un sin\u00f3nimo para un tipo, creado al asignar un tipo a un identificador.</p>\n<p>Los alias de tipos son \u00fatiles para simplificar los <a class=\"reference internal\" href=\"#term-type-hint\"><span class=\"xref std std-term\">indicadores de tipo</span></a>. Por ejemplo:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">remove_gray_shades</span><span class=\"p\">(</span>\n        <span class=\"n\">colors</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]])</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]:</span>\n    <span class=\"k\">pass</span>\n</pre></div>\n</div>\n<p>podr\u00eda ser m\u00e1s legible as\u00ed:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">Color</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">remove_gray_shades</span><span class=\"p\">(</span><span class=\"n\">colors</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">Color</span><span class=\"p\">])</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">Color</span><span class=\"p\">]:</span>\n    <span class=\"k\">pass</span>\n</pre></div>\n</div>\n<p>Vea <a class=\"reference internal\" href=\"library/typing.html#module-typing\" title=\"typing: Support for type hints (see :pep:`484`).\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">typing</span></code></a> y <span class=\"target\" id=\"index-101\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a>, que describen esta funcionalidad.</p>\n</dd>\n</main>\n"}, "indicador de tipo": {"title": "indicador de tipo", "body": "<main>\n<dd><p>Una  <a class=\"reference internal\" href=\"#term-annotation\"><span class=\"xref std std-term\">annotation</span></a> que especifica el tipo esperado para una variable, un atributo de clase, un par\u00e1metro para una funci\u00f3n o un valor de retorno.</p>\n<p>Los indicadores de tipo son opcionales y no son obligados por Python pero son \u00fatiles para las herramientas de an\u00e1lisis de tipos est\u00e1tico, y ayuda a las IDE en el completado del c\u00f3digo y la refactorizaci\u00f3n.</p>\n<p>Los indicadores de tipo de las variables globales, atributos de clase, y funciones, no de variables locales, pueden ser accedidos usando <a class=\"reference internal\" href=\"library/typing.html#typing.get_type_hints\" title=\"typing.get_type_hints\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">typing.get_type_hints()</span></code></a>.</p>\n<p>Vea <a class=\"reference internal\" href=\"library/typing.html#module-typing\" title=\"typing: Support for type hints (see :pep:`484`).\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">typing</span></code></a> y <span class=\"target\" id=\"index-102\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a>, que describen esta funcionalidad.</p>\n</dd>\n</main>\n"}, "saltos de l\u00edneas universales": {"title": "saltos de l\u00edneas universales", "body": "<main>\n<dd><p>Una manera de interpretar flujos de texto en la cual son reconocidos como finales de l\u00ednea todas siguientes formas: la convenci\u00f3n de Unix para fin de l\u00ednea <code class=\"docutils literal notranslate\"><span class=\"pre\">'\\n'</span></code>, la convenci\u00f3n de Windows <code class=\"docutils literal notranslate\"><span class=\"pre\">'\\r\\n'</span></code>, y la vieja convenci\u00f3n de Macintosh <code class=\"docutils literal notranslate\"><span class=\"pre\">'\\r'</span></code>.  Vea <span class=\"target\" id=\"index-103\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0278/\"><strong>PEP 278</strong></a> y <span class=\"target\" id=\"index-104\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-3116/\"><strong>PEP 3116</strong></a>, adem\u00e1s de <a class=\"reference internal\" href=\"library/stdtypes.html#bytes.splitlines\" title=\"bytes.splitlines\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">bytes.splitlines()</span></code></a> para usos adicionales.</p>\n</dd>\n</main>\n"}, "anotaci\u00f3n de variable": {"title": "anotaci\u00f3n de variable", "body": "<main>\n<dd><p>Una <a class=\"reference internal\" href=\"#term-annotation\"><span class=\"xref std std-term\">annotation</span></a> de una variable o un atributo de clase.</p>\n<p>Cuando se anota una variable o un atributo de clase, la asignaci\u00f3n es opcional:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">C</span><span class=\"p\">:</span>\n    <span class=\"n\">field</span><span class=\"p\">:</span> <span class=\"s1\">&#39;annotation&#39;</span>\n</pre></div>\n</div>\n<p>Las anotaciones de variables son frecuentemente usadas para <a class=\"reference internal\" href=\"#term-type-hint\"><span class=\"xref std std-term\">type hints</span></a>: por ejemplo, se espera que esta variable tenga valores de clase <a class=\"reference internal\" href=\"library/functions.html#int\" title=\"int\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">int</span></code></a>:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">count</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n</pre></div>\n</div>\n<p>La sintaxis de la anotaci\u00f3n de variables est\u00e1 explicada en la secci\u00f3n <a class=\"reference internal\" href=\"reference/simple_stmts.html#annassign\"><span class=\"std std-ref\">Declaraciones de asignaci\u00f3n anotadas</span></a>.</p>\n<p>Consulte <a class=\"reference internal\" href=\"#term-function-annotation\"><span class=\"xref std std-term\">function annotation</span></a>, <span class=\"target\" id=\"index-105\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a> y <span class=\"target\" id=\"index-106\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0526/\"><strong>PEP 526</strong></a>, que describen esta funcionalidad. Consulte tambi\u00e9n <a class=\"reference internal\" href=\"howto/annotations.html#annotations-howto\"><span class=\"std std-ref\">Pr\u00e1cticas recomendadas para las anotaciones</span></a> para conocer las mejores pr\u00e1cticas sobre c\u00f3mo trabajar con anotaciones.</p>\n</dd>\n</main>\n"}, "entorno virtual": {"title": "entorno virtual", "body": "<main>\n<dd><p>Un entorno cooperativamente aislado de ejecuci\u00f3n que permite a los usuarios de Python y a las aplicaciones instalar y actualizar paquetes de distribuci\u00f3n de Python sin interferir con el comportamiento de otras aplicaciones de Python en el mismo sistema.</p>\n<p>Vea tambi\u00e9n <a class=\"reference internal\" href=\"library/venv.html#module-venv\" title=\"venv: Creation of virtual environments.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">venv</span></code></a>.</p>\n</dd>\n</main>\n"}, "m\u00e1quina virtual": {"title": "m\u00e1quina virtual", "body": "<main>\n<dd><p>Una computadora definida enteramente por software.  La m\u00e1quina virtual de Python ejecuta el <a class=\"reference internal\" href=\"#term-bytecode\"><span class=\"xref std std-term\">bytecode</span></a> generado por el compilador de <em>bytecode</em>.</p>\n</dd>\n</main>\n"}, "zen de python": {"title": "Zen de Python", "body": "<main>\n<dd><p>Un listado de los principios de dise\u00f1o y la filosof\u00eda de Python que son \u00fatiles para entender y usar el lenguaje.  El listado puede encontrarse ingresando  \u00ab<code class=\"docutils literal notranslate\"><span class=\"pre\">import</span> <span class=\"pre\">this</span></code>\u00bb en la consola interactiva.</p>\n</dd>\n</main>\n"}}