
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>email.message: Representando un mensaje de correo electrónico &#8212; documentación de Python - 3.10.10</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.10.10"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="email.parser: Analizar mensajes de correo electrónico" href="email.parser.html" />
    <link rel="prev" title="email — Un paquete de manejo de correo electrónico y MIME" href="email.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/email.message.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h4>Tema anterior</h4>
  <p class="topless"><a href="email.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> — Un paquete de manejo de correo electrónico y MIME</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="email.parser.html"
                        title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.parser</span></code>: Analizar mensajes de correo electrónico</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/email.message.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="email.parser.html" title="email.parser: Analizar mensajes de correo electrónico"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="email.html" title="email — Un paquete de manejo de correo electrónico y MIME"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La Biblioteca Estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="netdata.html" >Manejo de Datos de Internet</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="email.html" accesskey="U"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> — Un paquete de manejo de correo electrónico y MIME</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.message</span></code>: Representando un mensaje de correo electrónico</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-email.message">
<span id="email-message-representing-an-email-message"></span><h1><a class="reference internal" href="#module-email.message" title="email.message: The base class representing email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.message</span></code></a>: Representando un mensaje de correo electrónico<a class="headerlink" href="#module-email.message" title="Enlazar permanentemente con este título">¶</a></h1>
<p><strong>Código fuente:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/email/message.py">Lib/email/message.py</a></p>
<hr class="docutils" />
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6: </span><a class="footnote-reference brackets" href="#id2" id="id1">1</a></p>
</div>
<p>La clase central en el paquete de <a class="reference internal" href="email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> es la clase <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>, importada desde el módulo <a class="reference internal" href="#module-email.message" title="email.message: The base class representing email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.message</span></code></a>. Esta es la clase base para el modelo de objeto <a class="reference internal" href="email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a>. <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> provee la funcionalidad clave para configurar y consultar las cabeceras, para acceder al cuerpo del mensaje, y para crear o modificar la estructura del mensaje.</p>
<p>Un mensaje de correo electrónico consiste en <em>headers</em> y un <em>payload</em> (al que también nos referimos como <em>content</em>). <em>Headers</em> como <span class="target" id="index-21"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5322.html"><strong>RFC 5322</strong></a> o <span class="target" id="index-22"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6532.html"><strong>RFC 6532</strong></a> son nombres de campos de estilo y valores, donde el nombre y valor están separados por un “:”. Los dos puntos no son parte ni del nombre ni del valor. El <em>payload</em> puede ser un simple mensaje, un objeto binario, o una secuencia estructurada de sub-mensajes, cada uno con su propio conjunto de <em>headers</em> y su propio <em>payload</em>. El último tipo de <em>payload</em> es indicado por el mensaje con un MIME como <em class="mimetype">multipart/*</em> o <em class="mimetype">message/rfc822</em> .</p>
<p>El modelo conceptual provisto por un objeto <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> es el de un diccionario ordenado de cabeceras emparejadas con una carga útil que representa al cuerpo del mensaje <span class="target" id="index-23"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5322.html"><strong>RFC 5322</strong></a>, que podría ser una lista de objetos sub-<code class="docutils literal notranslate"><span class="pre">EmailMessage</span></code>. Además de los métodos normales de diccionario para acceder a las cabeceras y valores, tiene métodos para acceder a información especializada desde las cabeceras (por ejemplo, el tipo de contenido MIME), para operar en la carga útil, generar una versión serializada del mensaje, y recorrer recursivamente el árbol de objetos.</p>
<p>La interfaz tipo diccionario de <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> está indexada por los nombres de las cabeceras, que deberán ser valores ASCII. Los valores del diccionario son cadenas con algunos métodos adicionales. Las cabeceras son almacenadas y retornadas de forma sensible a mayúsculas, pero los nombres de los campos son comparados sin discriminar entre mayúsculas. A diferencia de un dict real, las llaves están ordenadas y pueden estar duplicadas. Se proveen métodos adicionales para trabajar con cabeceras que tienen llaves duplicadas.</p>
<p>La carga útil es un objeto de cadena de caracteres o bytes, en el caso de objetos de mensaje simples, o una lista de objetos <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>, para documentos de contenedor MIME como <em class="mimetype">multipart/*</em> y objetos de mensaje <em class="mimetype">message/rfc822</em>.</p>
<dl class="py class">
<dt id="email.message.EmailMessage">
<em class="property">class </em><code class="sig-prename descclassname">email.message.</code><code class="sig-name descname">EmailMessage</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">policy</span><span class="o">=</span><span class="default_value">default</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si se especifica <em>policy</em>, use las reglas especificadas para actualizar y serializar la representación del mensaje. Si la política no es establecida, use <a class="reference internal" href="email.policy.html#email.policy.default" title="email.policy.default"><code class="xref py py-class docutils literal notranslate"><span class="pre">default</span></code></a>, que sigue las reglas RFC de email excepto para el fin de línea(en lugar del RFC <code class="docutils literal notranslate"><span class="pre">\r\n</span></code>, usa los finales estándar de Python <code class="docutils literal notranslate"><span class="pre">\n</span></code> como final de línea). Para más información ve a la documentación del <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a>.</p>
<dl class="py method">
<dt id="email.message.EmailMessage.as_string">
<code class="sig-name descname">as_string</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">unixfrom</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">maxheaderlen</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">policy</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.as_string" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el mensaje entero como cadena de caracteres. Cuando la opción <em>unixform</em> es verdadera, la cabecera está incluida en la cadena de caracteres retornada. <em>unixform</em> está predeterminado con valor <code class="docutils literal notranslate"><span class="pre">False</span></code>. Por compatibilidad con versiones anteriores, la base <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a>, la case <em>maxheaderlen</em> es aceptada pero con valor <code class="docutils literal notranslate"><span class="pre">None</span></code> como predeterminado, por lo que la longitud de línea se controla mediante <code class="xref py py-attr docutils literal notranslate"><span class="pre">max_line_length</span></code>. El argumento <em>policy</em> puede ser usado para anular el valor predeterminado obtenido de la instancia del mensaje. Esto puede ser usado para controlar parte del formato producido por el método, ya que la política especificada pasará a <a class="reference internal" href="email.generator.html#email.generator.Generator" title="email.generator.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>.</p>
<p>Aplanar el mensaje puede acarrear cambios en <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> si es necesario rellenar los valores predeterminados para completar la transformación a una cadena de caracteres (por ejemplo, se pueden generar o modificar límites MIME).</p>
<p>Tenga en cuenta que este método se proporciona como una comodidad y quizás no sea la forma más eficiente de serializar mensajes en su aplicación, especialmente si estás tratando con múltiples mensajes. Consulte <a class="reference internal" href="email.generator.html#email.generator.Generator" title="email.generator.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> por una API más flexible para serializar mensajes. No olvide también que este método está restringido a producir mensajes serializados como «7 bit clean» cuando <code class="xref py py-attr docutils literal notranslate"><span class="pre">utf8</span></code> es <code class="docutils literal notranslate"><span class="pre">False</span></code>, que es el valor predeterminado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>el comportamiento predeterminado cuando <em>maxheaderlen</em> no está especificado cambió de 0 al valor de <em>max_line_length</em> de la política .</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.__str__">
<code class="sig-name descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.__str__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Equivalente a <code class="docutils literal notranslate"><span class="pre">as_string(policy=self.policy.clone(utf8=True))</span></code>. Permite <code class="docutils literal notranslate"><span class="pre">str(msg)</span></code> para producir una cadena que contenga un mensaje serializado en un formato legible.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>el método se cambió para usar <code class="docutils literal notranslate"><span class="pre">utf8=True</span></code>, produciendo así un <span class="target" id="index-24"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6531.html"><strong>RFC 6531</strong></a> como representación del mensaje, en vez de ser un alias de <a class="reference internal" href="#email.message.EmailMessage.as_string" title="email.message.EmailMessage.as_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_string()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.as_bytes">
<code class="sig-name descname">as_bytes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">unixfrom</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">policy</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.as_bytes" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el mensaje plano como un objeto de bytes. Cuando <em>unixform</em> es verdadero, la cabecera es incluida en la cadena de caracteres retornada. El valor predeterminado de <em>unixform</em> es <code class="docutils literal notranslate"><span class="pre">False</span></code>. El argumento <em>policy</em> puede ser usado para sobreescribir el valor predeterminado obtenido de la instancia del mensaje. Esto puede ser usado para controlar parte del formato producido por el método, ya que la política especificada pasará a <a class="reference internal" href="email.generator.html#email.generator.Generator" title="email.generator.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>.</p>
<p>Aplanar el mensaje puede acarrear cambios en <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> si es necesario rellenar los valores predeterminados para completar la transformación a una cadena de caracteres (por ejemplo, se pueden generar o modificar límites MIME).</p>
<p>Tenga en cuenta que este método se proporciona como una comodidad y quizás no sea la forma más eficiente de serializar mensajes en su aplicación, especialmente si estas tratando con múltiples mensajes. Consulte <a class="reference internal" href="email.generator.html#email.generator.Generator" title="email.generator.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> por una API más flexible para serializar mensajes.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.__bytes__">
<code class="sig-name descname">__bytes__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.__bytes__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Equivalente a <a class="reference internal" href="#email.message.EmailMessage.as_bytes" title="email.message.EmailMessage.as_bytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_bytes()</span></code></a>. Permite <code class="docutils literal notranslate"><span class="pre">bytes(msg)</span></code> para producir un objeto byte que contenga el mensaje serializado.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.is_multipart">
<code class="sig-name descname">is_multipart</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.is_multipart" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si la carga útil del mensaje es una lista de objetos de sub-<a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>, de otra manera retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>. Cuando <a class="reference internal" href="#email.message.EmailMessage.is_multipart" title="email.message.EmailMessage.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>, la carga útil deberá ser un objeto cadena de caracteres (que podría ser una carga útil binaria codificada con CTE). Note que si <a class="reference internal" href="#email.message.EmailMessage.is_multipart" title="email.message.EmailMessage.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> no necesariamente significa que «msg.get_content_maintype() == “multipart”» retornará <code class="docutils literal notranslate"><span class="pre">True</span></code>. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">is_multipart</span></code> retornará <code class="docutils literal notranslate"><span class="pre">True</span></code> cuando la <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> sea del tipo <code class="docutils literal notranslate"><span class="pre">message/rfc822</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.set_unixfrom">
<code class="sig-name descname">set_unixfrom</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">unixfrom</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.set_unixfrom" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Configura la cabecera del mensaje a <em>unixform</em>, que debería ser una cadena de caracteres. (Consulte <a class="reference internal" href="mailbox.html#mailbox.mboxMessage" title="mailbox.mboxMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">mboxMessage</span></code></a> para una descripción de esta cabecera)</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.get_unixfrom">
<code class="sig-name descname">get_unixfrom</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_unixfrom" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la cabecera del mensaje. Predeterminado <code class="docutils literal notranslate"><span class="pre">None</span></code> si la cabecera no ha sido configurada.</p>
</dd></dl>

<p>Los siguientes métodos implementan el mapeo como una interfaz para acceder a la cabecera del mensaje. Tenga en cuenta que hay algunas diferencias semánticas entre esos métodos y una interfaz de mapeo normal(es decir, diccionario). Por ejemplo, en un diccionario no hay claves duplicadas, pero pueden haber cabeceras duplicadas. Además, en los diccionarios no hay un orden garantizado para las claves retornadas por <a class="reference internal" href="#email.message.EmailMessage.keys" title="email.message.EmailMessage.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code></a>, pero en un objeto <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>, las cabeceras siempre regresan en orden de aparición en el mensaje original, o en el que fueron agregadas luego. Cualquier cabecera borrada y vuelta a añadir siempre se agrega al final de la lista.</p>
<p>Estas diferencias semánticas son intencionales y están sesgadas hacia la conveniencia en los casos de uso más comunes.</p>
<p>Note que en todos los casos, cualquier cabecera presente en el mensaje no se incluye en la interfaz de mapeo.</p>
<dl class="py method">
<dt id="email.message.EmailMessage.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.__len__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el número total de cabeceras, incluidas las duplicadas.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.__contains__">
<code class="sig-name descname">__contains__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.__contains__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si el objeto del mensaje tiene un campo llamado “nombre”. La comparación se realiza sin tener en cuenta mayúsculas o minúsculas y “nombre” no incluye “:”.  Se utiliza para el operador <code class="docutils literal notranslate"><span class="pre">in</span></code> Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="s1">&#39;message-id&#39;</span> <span class="ow">in</span> <span class="n">myMessage</span><span class="p">:</span>
   <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Message-ID:&#39;</span><span class="p">,</span> <span class="n">myMessage</span><span class="p">[</span><span class="s1">&#39;message-id&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.__getitem__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el valor de la cabecera nombrada. <em>name</em> no incluye el separador de dos puntos, “:”. Si la cabecera se pierde, regresa <code class="docutils literal notranslate"><span class="pre">None</span></code>, un <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> no se genera nunca.</p>
<p>Tenga en cuenta que si el campo nombrado aparece más de una vez en la cabecera del mensaje, esa cantidad de veces el valor regresado será indefinido. Use el método <a class="reference internal" href="#email.message.EmailMessage.get_all" title="email.message.EmailMessage.get_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_all()</span></code></a> para obtener los valores de todas las cabeceras existentes llamadas <em>name</em>.</p>
<p>Usando el <em>standard non-“compat32”</em>, el valor regresado es una instancia de una subclase de <a class="reference internal" href="email.headerregistry.html#email.headerregistry.BaseHeader" title="email.headerregistry.BaseHeader"><code class="xref py py-class docutils literal notranslate"><span class="pre">email.headerregistry.BaseHeader</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.__setitem__">
<code class="sig-name descname">__setitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">val</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.__setitem__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Agrega una cabecera al mensaje con un campo “nombre” y un valor “val”. El campo se agrega al final de las cabeceras existentes en el mensaje.</p>
<p>Tenga en cuenta que esto no sobrescribe ni borra ninguna cabecera con el mismo nombre. Si quiere asegurarse de que la nueva cabecera es la única en el mensaje con el campo “nombre”, borre el campo primero, por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">del</span> <span class="n">msg</span><span class="p">[</span><span class="s1">&#39;subject&#39;</span><span class="p">]</span>
<span class="n">msg</span><span class="p">[</span><span class="s1">&#39;subject&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Python roolz!&#39;</span>
</pre></div>
</div>
<p>Si el <code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code> define ciertas cabeceras para ser únicos(como lo hace el <em>standard</em>), este método puede generar un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> cuando se intenta asignar un valor a una cabecera preexistente. Este comportamiento es intencional por consistencia, pero no dependa de ello, ya que podemos optar por hacer que tales asignaciones eliminen la cabecera en el futuro.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.__delitem__">
<code class="sig-name descname">__delitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.__delitem__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Elimine todas las apariciones del campo “nombre” de las cabeceras del mensaje. No se genera ninguna excepción si el campo nombrado no está presente en las cabeceras.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.keys">
<code class="sig-name descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.keys" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una lista de los nombres de todos los campos de la cabecera del mensaje.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.values">
<code class="sig-name descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.values" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una lista de todos los valores de los campos del mensaje.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.items">
<code class="sig-name descname">items</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.items" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una lista de tuplas de dos elementos que contienen todos los campos cabeceras y valores del mensaje.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.get">
<code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">failobj</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el valor de la cabecera nombrada. Esto es idéntico a <a class="reference internal" href="#email.message.EmailMessage.__getitem__" title="email.message.EmailMessage.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> excepto que el opcional <em>failobj</em> es retornado si no se encuentra la cabecera nombrada (<em>failobj</em> es por defecto <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<p>Aquí hay algunos métodos adicionales útiles relacionados con la cabecera:</p>
<dl class="py method">
<dt id="email.message.EmailMessage.get_all">
<code class="sig-name descname">get_all</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">failobj</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_all" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una lista de todos los valores para el campo <em>nombre</em>. Si no se nombran tales cabeceras en el mensaje, regresa <em>failobj</em> (por defecto <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.add_header">
<code class="sig-name descname">add_header</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">_name</span></em>, <em class="sig-param"><span class="n">_value</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">_params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.add_header" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Configuración extendida de cabeceras. Este método es similar a <a class="reference internal" href="#email.message.EmailMessage.__setitem__" title="email.message.EmailMessage.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a>, excepto que se pueden proporcionar parámetros de cabecera adicionales como argumentos de palabras clave.</p>
<p>Por cada ítem en los parámetros del diccionario <em>_params</em>, la clave se toma como el nombre del parámetro, con barra baja (“_”) convertidos a guiones (“-”) (ya que en Python no se permiten “-” como identificadores). Normalmente, el parámetro debe ser añadido como <code class="docutils literal notranslate"><span class="pre">key='value'</span></code> a menos que el valor sea <code class="docutils literal notranslate"><span class="pre">None</span></code>, en ese caso solo la clave debe ser añadida.</p>
<p>Si el valor contiene caracteres no-ASCII, el <em>charset</em> y el lenguaje deben ser controlados especificando el valor como una triple tupla en formato <code class="docutils literal notranslate"><span class="pre">(CHARSET,</span> <span class="pre">LANGUAJE,</span> <span class="pre">VALUE)</span></code>, donde <code class="docutils literal notranslate"><span class="pre">CHARSET</span></code> es una <em>string</em> llamando al <em>charset</em> usado para codificar el valor, <code class="docutils literal notranslate"><span class="pre">LANGUAJE</span></code> generalmente se establece en <code class="docutils literal notranslate"><span class="pre">None</span></code> o en una cadena de caracteres vacía (consulte <span class="target" id="index-25"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2231.html"><strong>RFC 2231</strong></a> para más opciones), y <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> es el valor de la cadena de caracteres que contiene puntos de código no-ASCII. Si la triple tupla no pasa y el valor contiene caracteres no-ASCII, es automáticamente codificada en formato <span class="target" id="index-26"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2231.html"><strong>RFC 2231</strong></a>, usando <code class="docutils literal notranslate"><span class="pre">CHARSET</span></code> de <code class="docutils literal notranslate"><span class="pre">utf-8</span></code> y <code class="docutils literal notranslate"><span class="pre">LANGUAJE</span></code> <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Aquí hay un ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">msg</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;Content-Disposition&#39;</span><span class="p">,</span> <span class="s1">&#39;attachment&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;bud.gif&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Esto agregará una cabecera que se ve como:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Content</span><span class="o">-</span><span class="n">Disposition</span><span class="p">:</span> <span class="n">attachment</span><span class="p">;</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;bud.gif&quot;</span>
</pre></div>
</div>
<p>Un ejemplo de la interfaz extendida con caracteres no-ASCII:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">msg</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;Content-Disposition&#39;</span><span class="p">,</span> <span class="s1">&#39;attachment&#39;</span><span class="p">,</span>
               <span class="n">filename</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;iso-8859-1&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;Fußballer.ppt&#39;</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.replace_header">
<code class="sig-name descname">replace_header</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">_name</span></em>, <em class="sig-param"><span class="n">_value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.replace_header" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Reemplaza una cabecera. Reemplaza la primer cabecera encontrada en el mensaje que coincida con <em>_name</em>, conservando el orden de cabeceras y uso de minúsculas (y mayúsculas) del nombre de campo de la cabecera original. Si no hay coincidencia, se lanzará un <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.get_content_type">
<code class="sig-name descname">get_content_type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_content_type" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el tipo de contenido del mensaje, pasado a minúsculas de la forma <em class="mimetype">maintype/subtype</em>. Si no hay cabecera llamada <em class="mailheader">Content-Type</em> en el mensaje, regresa el valor de <a class="reference internal" href="#email.message.EmailMessage.get_default_type" title="email.message.EmailMessage.get_default_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_default_type()</span></code></a>. Si <em class="mailheader">Content-Type</em> no es válido, retorna <code class="docutils literal notranslate"><span class="pre">text/plain</span></code>.</p>
<p>(De acuerdo con <span class="target" id="index-27"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2045.html"><strong>RFC 2045</strong></a>, los mensajes siempre tienen un tipo predeterminado, <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content_type`siempre</span> <span class="pre">retornará</span> <span class="pre">un</span> <span class="pre">valor.</span> <span class="pre">:rfc:`2045`define</span> <span class="pre">el</span> <span class="pre">tipo</span> <span class="pre">predeterminado</span> <span class="pre">de</span> <span class="pre">un</span> <span class="pre">mensaje</span> <span class="pre">como</span> <span class="pre">:mimetype:`text/plain()</span></code> a menos que aparezca dentro de un contenedor <em class="mimetype">multipart/digest</em>, en cuyo caso sería <em class="mimetype">message/rfc822</em>. Si la cabecera <em class="mailheader">Content-Type</em> tiene una especificación de tipo que sea inválida, <span class="target" id="index-28"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2045.html"><strong>RFC 2045</strong></a> exige que el tipo predeterminado sea <em class="mimetype">text/plain</em>.)</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.get_content_maintype">
<code class="sig-name descname">get_content_maintype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_content_maintype" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el tipo de contenido principal del mensaje. Esta es la parte  <em class="mimetype">maintype</em> de la cadena retornada por <a class="reference internal" href="#email.message.EmailMessage.get_content_type" title="email.message.EmailMessage.get_content_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content_type()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.get_content_subtype">
<code class="sig-name descname">get_content_subtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_content_subtype" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el tipo del sub-contenido del mensaje. Esta es la parte <em class="mimetype">subtype</em> de la cadena retornada por <a class="reference internal" href="#email.message.EmailMessage.get_content_type" title="email.message.EmailMessage.get_content_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content_type()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.get_default_type">
<code class="sig-name descname">get_default_type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_default_type" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el tipo de contenido predeterminado. La mayoría de los mensajes tienen como tipo de contenido predeterminado a <em class="mimetype">text/plain</em>, a excepción de los mensajes que son sub-partes de contenedores <em class="mimetype">multipart/digest</em>. Estas sub-partes tienen como tipo de contenido predeterminado a <em class="mimetype">message/rfc822</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.set_default_type">
<code class="sig-name descname">set_default_type</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ctype</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.set_default_type" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece el tipo de contenido predeterminado. <em>ctype</em> debería ser <em class="mimetype">text/plain</em> o <em class="mimetype">message/rfc822</em>, aunque esto no está impuesto. El tipo de contenido predeterminado no se almacena en la cabecera <em class="mailheader">Content-Type</em>, así que sólo afecta al valor de retorno de los métodos <code class="docutils literal notranslate"><span class="pre">get_content_type</span></code> cuando ninguna cabecera <em class="mailheader">Content-Type</em> está presente en el mensaje.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.set_param">
<code class="sig-name descname">set_param</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">param</span></em>, <em class="sig-param"><span class="n">value</span></em>, <em class="sig-param"><span class="n">header</span><span class="o">=</span><span class="default_value">'Content-Type'</span></em>, <em class="sig-param"><span class="n">requote</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">charset</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">language</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">replace</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.set_param" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece un parámetro en el encabezado <em class="mailheader">Content-Type</em>. Si el parámetro ya existe en el encabezado, reemplace su valor con <em>value</em>. Cuando <em>header</em> es <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> (el predeterminado) y el encabezado aún no existe en el mensaje, agréguelo, establece su valor en <em class="mimetype">text/plain</em> y agregue el nuevo valor del parámetro. <em>header</em> opcional especifica un encabezado alternativo a <em class="mailheader">Content-Type</em>.</p>
<p>Si el valor contiene caracteres <em>non-ASCII</em>, el <em>charset</em> y el lenguaje pueden ser especificados explícitamente con los parámetros <em>charset</em> y <em>language</em>. Opcionalmente <em>language</em> especifica el lenguaje <span class="target" id="index-29"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2231.html"><strong>RFC 2231</strong></a>, por defecto una cadena vacía. Ambos <em>charset</em> y <em>language</em> deberán ser cadenas. los valores predeterminados son <code class="docutils literal notranslate"><span class="pre">utf8</span></code> para <em>charset</em> y <code class="docutils literal notranslate"><span class="pre">None</span></code> para <em>language</em>.</p>
<p>Si <em>replace</em> es <code class="docutils literal notranslate"><span class="pre">False</span></code> (predeterminado) la cabecera se mueve al final de la lista de cabeceras. Si <em>replace</em> es <code class="docutils literal notranslate"><span class="pre">True</span></code>, la cabecera se actualizará en su lugar.</p>
<p>El uso del parámetro <em>requote</em> con objetos <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> está obsoleto.</p>
<p>Tenga en cuenta que se puede acceder a los parámetros existentes de las cabeceras a través del atributo  <code class="xref py py-attr docutils literal notranslate"><span class="pre">params</span></code> de la cabecera (por ejemplo, <code class="docutils literal notranslate"><span class="pre">msg['Content-Type'].params['charset']</span></code>).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Se agregó la palabra clave <code class="docutils literal notranslate"><span class="pre">replace</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.del_param">
<code class="sig-name descname">del_param</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">param</span></em>, <em class="sig-param"><span class="n">header</span><span class="o">=</span><span class="default_value">'content-type'</span></em>, <em class="sig-param"><span class="n">requote</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.del_param" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Elimina completamente el parámetro dado de la cabecera <em class="mailheader">Content-Type</em>. La cabecera será reescrita en su lugar, sin el parámetro o su valor. Opcionalmente <em>header</em> especifica una alternativa a <em class="mailheader">Content-Type</em>.</p>
<p>El uso del parámetro <em>requote</em> con objetos <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> está obsoleto.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.get_filename">
<code class="sig-name descname">get_filename</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">failobj</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_filename" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el valor del parámetro <code class="docutils literal notranslate"><span class="pre">filename</span></code> de la cabecera <em class="mailheader">Content-Disposition</em> del mensaje. Si la cabecera no tiene un parámetro <code class="docutils literal notranslate"><span class="pre">filename</span></code>, este método recae a buscar el parámetro <code class="docutils literal notranslate"><span class="pre">name</span></code> en la cabecera <em class="mailheader">Content-Type</em>. Si ninguno se encuentra o falta la cabecera, se retorna <em>failobj</em>. La cadena retornada siempre estará sin comillas según <a class="reference internal" href="email.utils.html#email.utils.unquote" title="email.utils.unquote"><code class="xref py py-func docutils literal notranslate"><span class="pre">email.utils.unquote()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.get_boundary">
<code class="sig-name descname">get_boundary</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">failobj</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_boundary" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el parámetro <code class="docutils literal notranslate"><span class="pre">boundary</span></code> de la cabecera <em class="mailheader">Content-Type</em> del mensaje, o <em>failobj</em> si la cabecera no se encuentra o si no tiene un parámetro <code class="docutils literal notranslate"><span class="pre">boundary</span></code>. La cadena retornada siempre estará sin comillas según <a class="reference internal" href="email.utils.html#email.utils.unquote" title="email.utils.unquote"><code class="xref py py-func docutils literal notranslate"><span class="pre">email.utils.unquote()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.set_boundary">
<code class="sig-name descname">set_boundary</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">boundary</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.set_boundary" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece el parámetro <code class="docutils literal notranslate"><span class="pre">boundary</span></code> de la cabecera <em class="mailheader">Content-Type</em> como <em>boundary</em>.  <a class="reference internal" href="#email.message.EmailMessage.set_boundary" title="email.message.EmailMessage.set_boundary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_boundary()</span></code></a> siempre que sea necesario pondrá comillas a <em>boundary</em>. Si el objeto mensaje no tiene cabecera <em class="mailheader">Content-Type</em> se lanza <a class="reference internal" href="email.errors.html#email.errors.HeaderParseError" title="email.errors.HeaderParseError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HeaderParseError</span></code></a>.</p>
<p>Note que usar este método es sutilmente diferente a borrar la cabecera <em class="mailheader">Content-Type</em> antigua y agregar una nueva con el nuevo límite utilizando <a class="reference internal" href="#email.message.EmailMessage.add_header" title="email.message.EmailMessage.add_header"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_header()</span></code></a>, porque <a class="reference internal" href="#email.message.EmailMessage.set_boundary" title="email.message.EmailMessage.set_boundary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_boundary()</span></code></a> preserva el orden de la cabecera <em class="mailheader">Content-Type</em> en la lista de cabeceras.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.get_content_charset">
<code class="sig-name descname">get_content_charset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">failobj</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_content_charset" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el parámetro <code class="docutils literal notranslate"><span class="pre">charset</span></code> de la cabecera <em class="mailheader">Content-Type`forzado a minúsculas. Si no hay una cabecera :mailheader:`Content-Type</em>, o si esa cabecera no tiene el parámetro <code class="docutils literal notranslate"><span class="pre">charset</span></code>, se retorna <em>failobj</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.get_charsets">
<code class="sig-name descname">get_charsets</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">failobj</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_charsets" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una lista que contiene los nombres de los <em>charset</em> en el mensaje. Si el mensaje es <em class="mimetype">multipart</em>, la lista contendrá un elemento por cada subparte en la carga útil, de lo contrario será una lista de longitud 1.</p>
<p>Cada elemento de la lista será una cadena que tendrá el valor del parámetro <code class="docutils literal notranslate"><span class="pre">charset</span></code> en la cabecera <em class="mailheader">Content-Type</em> para la subparte representada. Si la subparte no tiene cabecera <em class="mailheader">Content-Type</em>, no tiene parámetro <code class="docutils literal notranslate"><span class="pre">charset</span></code>, o no es del tipo MIME principal <em class="mimetype">text</em>, entonces ese elemento en la lista retornada será <em>failobj</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.is_attachment">
<code class="sig-name descname">is_attachment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.is_attachment" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si hay una cabecera <em class="mailheader">Content-Disposition</em> y su valor (sensible a mayúsculas) es <code class="docutils literal notranslate"><span class="pre">attachment</span></code>, de lo contrario retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4.2: </span><em>is_attachment</em> ahora es un método en lugar de una propiedad, por consistencia con <a class="reference internal" href="email.compat32-message.html#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.get_content_disposition">
<code class="sig-name descname">get_content_disposition</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_content_disposition" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el valor en minúsculas (sin parámetros) de la cabecera <em class="mailheader">Content-Disposition</em> si el mensaje la tiene, de lo contrario retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>. Los valores posibles para este método son <em>inline</em>, <em>attachment</em> o <code class="docutils literal notranslate"><span class="pre">None</span></code> si el mensaje sigue <span class="target" id="index-30"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2183.html"><strong>RFC 2183</strong></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
</dd></dl>

<p>Los siguientes métodos se refieren a interrogar y manipular el contenido (<em>payload</em>) del mensaje.</p>
<dl class="py method">
<dt id="email.message.EmailMessage.walk">
<code class="sig-name descname">walk</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.walk" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El método <a class="reference internal" href="#email.message.EmailMessage.walk" title="email.message.EmailMessage.walk"><code class="xref py py-meth docutils literal notranslate"><span class="pre">walk()</span></code></a> es un generador multipropósito que puede usarse para iterar sobre todas las partes y subpartes del árbol de un objeto mensaje, ordenando el recorrido en profundidad primero. Típicamente se usaría <a class="reference internal" href="#email.message.EmailMessage.walk" title="email.message.EmailMessage.walk"><code class="xref py py-meth docutils literal notranslate"><span class="pre">walk()</span></code></a> como el iterador en un ciclo <code class="docutils literal notranslate"><span class="pre">for</span></code>; cada iteración retornará la siguiente subparte.</p>
<p>Aquí hay un ejemplo que imprime el tipo MIME de cada parte de una estructura de mensaje de varias partes:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">msg</span><span class="o">.</span><span class="n">walk</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">get_content_type</span><span class="p">())</span>
<span class="go">multipart/report</span>
<span class="go">text/plain</span>
<span class="go">message/delivery-status</span>
<span class="go">text/plain</span>
<span class="go">text/plain</span>
<span class="go">message/rfc822</span>
<span class="go">text/plain</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">walk</span></code> itera sobre las subpartes de cualquier parte donde <a class="reference internal" href="#email.message.EmailMessage.is_multipart" title="email.message.EmailMessage.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> retorna <code class="docutils literal notranslate"><span class="pre">True</span></code>, aun si <code class="docutils literal notranslate"><span class="pre">msg.get_content_maintype()</span> <span class="pre">==</span> <span class="pre">'multipart'</span></code> pueda retornar <code class="docutils literal notranslate"><span class="pre">False</span></code>. Podemos ver esto en nuestro ejemplo al hacer uso de la función auxiliar de depuración <code class="docutils literal notranslate"><span class="pre">_structure</span></code>:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">email.iterators</span> <span class="kn">import</span> <span class="n">_structure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">msg</span><span class="o">.</span><span class="n">walk</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">get_content_maintype</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;multipart&#39;</span><span class="p">,</span>
<span class="gp">... </span>          <span class="n">part</span><span class="o">.</span><span class="n">is_multipart</span><span class="p">())</span>
<span class="go">True True</span>
<span class="go">False False</span>
<span class="go">False True</span>
<span class="go">False False</span>
<span class="go">False False</span>
<span class="go">False True</span>
<span class="go">False False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_structure</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="go">multipart/report</span>
<span class="go">    text/plain</span>
<span class="go">    message/delivery-status</span>
<span class="go">        text/plain</span>
<span class="go">        text/plain</span>
<span class="go">    message/rfc822</span>
<span class="go">        text/plain</span>
</pre></div>
</div>
<p>Aquí las partes <code class="docutils literal notranslate"><span class="pre">message</span></code> no son <code class="docutils literal notranslate"><span class="pre">multiparts</span></code>, pero sí contienen subpartes. <code class="docutils literal notranslate"><span class="pre">is_multipart()``retorna</span> <span class="pre">``True</span></code> y <code class="docutils literal notranslate"><span class="pre">walk</span></code> desciende a las subpartes.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.get_body">
<code class="sig-name descname">get_body</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">preferencelist</span><span class="o">=</span><span class="default_value">('related', 'html', 'plain')</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_body" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la parte MIME que es la mejor candidata para ser el «cuerpo» del mensaje.</p>
<p><em>preferencelist</em> debe ser una secuencia de cadenas del conjunto <code class="docutils literal notranslate"><span class="pre">related</span></code>, <code class="docutils literal notranslate"><span class="pre">html</span></code>, y <code class="docutils literal notranslate"><span class="pre">plain</span></code>, e Indica el orden de preferencia para el tipo de contenido de la parte retornada.</p>
<p>Empieza a buscar coincidencias candidatas con el objeto en el que se llama al método <code class="docutils literal notranslate"><span class="pre">get_body</span></code>”.</p>
<p>Si <code class="docutils literal notranslate"><span class="pre">related</span></code> no está incluido en la <em>preferencelist</em>, considere la parte raíz (o subparte de la parte raíz) de cualquier relacionado encontrado como candidato si la (sub-)parte coincide con una preferencia.</p>
<p>Cuando se encuentra una <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code>, verifica el parámetro <code class="docutils literal notranslate"><span class="pre">start</span></code> y si se encuentra una parte con un <em class="mailheader">Content-ID</em> que coincida, considera solamente a ésta cuando se busca coincidencias candidatas. De otra forma considera sólo la primera parte (predeterminado <em>root</em>) de la <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code>.</p>
<p>Si una parte tiene una cabecera <em class="mailheader">Content-Disposition</em> , sólo se considera a ésta parte como coincidencia candidata si el valor de la cabecera es <code class="docutils literal notranslate"><span class="pre">inline</span></code>.</p>
<p>Si ninguno de los candidatos coincide con ninguna de las preferencias en <em>preferencelist</em>, retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Notas: (1) Para la mayoría de las aplicaciones las únicas combinaciones de <em>preferencelist</em> que realmente tienen sentido son <code class="docutils literal notranslate"><span class="pre">('plain',)</span></code>, <code class="docutils literal notranslate"><span class="pre">('html',</span> <span class="pre">'plain')</span></code>, y la predeterminada <code class="docutils literal notranslate"><span class="pre">('related',</span> <span class="pre">'html',</span> <span class="pre">'plain')</span></code>. (2) Debido a que la coincidencia comienza con el objeto en el que se llama a <code class="docutils literal notranslate"><span class="pre">get_body</span></code>, llamar a <code class="docutils literal notranslate"><span class="pre">get_body</span></code> en un <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code> devolverá el objeto en sí a menos que la <em>preferencelist</em> tenga un valor no predeterminado. (3) Los mensajes (o partes de mensajes) que no especifican un <em class="mailheader">Content-Type</em> o cuya cabecera <em class="mailheader">Content-Type</em> sea inválida se tratarán como si fueran del tipo <code class="docutils literal notranslate"><span class="pre">text/plain</span></code>, que ocasionalmente puede ocasionar que <code class="docutils literal notranslate"><span class="pre">get_body</span></code> retorne resultados inesperados.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.iter_attachments">
<code class="sig-name descname">iter_attachments</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.iter_attachments" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Devuelve un iterador sobre todas las subpartes inmediatas del mensaje que no son partes candidatas del «body». Es decir, omitir la primer ocurrencia de cada <code class="docutils literal notranslate"><span class="pre">text/plain</span></code>, <code class="docutils literal notranslate"><span class="pre">text/html</span></code>, <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code>, o <code class="docutils literal notranslate"><span class="pre">multipart/alternative``(a</span> <span class="pre">menos</span> <span class="pre">que</span> <span class="pre">estén</span> <span class="pre">marcados</span> <span class="pre">explícitamente</span> <span class="pre">como</span> <span class="pre">adjuntos</span> <span class="pre">a</span> <span class="pre">través</span> <span class="pre">de</span> <span class="pre">:mailheader:`Content-Disposition:</span> <span class="pre">attachment`)</span> <span class="pre">y</span> <span class="pre">retornar</span> <span class="pre">todas</span> <span class="pre">las</span> <span class="pre">partes</span> <span class="pre">restantes.</span> <span class="pre">Cuando</span> <span class="pre">se</span> <span class="pre">aplica</span> <span class="pre">directamente</span> <span class="pre">a</span> <span class="pre">un</span> <span class="pre">``multipart/related</span></code>, retorna un iterador sobre todas las partes relacionadas excepto la parte raíz (es decir, la parte apuntada por el parámetro <code class="docutils literal notranslate"><span class="pre">start</span></code> , o la primera parte si no hay un parámetro <code class="docutils literal notranslate"><span class="pre">start</span></code> o el parámetro <code class="docutils literal notranslate"><span class="pre">start</span></code> no coincide con el <em class="mailheader">Content-ID</em> de ninguna de las partes). Cuando se aplica directamente a un <code class="docutils literal notranslate"><span class="pre">multipart/alternative</span></code> o a un no-<code class="docutils literal notranslate"><span class="pre">multipart</span></code>, retorna un iterador vacío.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.iter_parts">
<code class="sig-name descname">iter_parts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.iter_parts" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un iterador sobre todas las partes inmediatas del mensaje, que estará vacío para una no-<code class="docutils literal notranslate"><span class="pre">multipart</span></code>. (vea también <a class="reference internal" href="#email.message.EmailMessage.walk" title="email.message.EmailMessage.walk"><code class="xref py py-meth docutils literal notranslate"><span class="pre">walk()</span></code></a>.)</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.get_content">
<code class="sig-name descname">get_content</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">content_manager</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kw</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.get_content" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llama al método <a class="reference internal" href="email.contentmanager.html#email.contentmanager.ContentManager.get_content" title="email.contentmanager.ContentManager.get_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content()</span></code></a> del <em>content_manager</em>, pasando <em>self</em> como el objeto del mensaje y pasando cualquier otro argumento o palabra clave como argumentos adicionales. Si no se especifica <em>content_manager</em> se usa el <code class="docutils literal notranslate"><span class="pre">content_manager</span></code> especificado por la <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a> actual.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.set_content">
<code class="sig-name descname">set_content</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">content_manager</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kw</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.set_content" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llama al método <a class="reference internal" href="email.contentmanager.html#email.contentmanager.ContentManager.set_content" title="email.contentmanager.ContentManager.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a> del <em>content_manager</em>, pasando <em>self</em> como el objeto <em>message</em> y pasando cualquier otro argumento o palabra clave como argumentos adicionales. Si no se especifica <em>content_manager</em> se usa el <code class="docutils literal notranslate"><span class="pre">content_manager</span></code> especificado por la <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a> actual.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.make_related">
<code class="sig-name descname">make_related</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">boundary</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.make_related" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierte un mensaje no-<code class="docutils literal notranslate"><span class="pre">multipart</span></code> a un mensaje <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code>, moviendo cualquier cabecera <em class="mailheader">Content-</em> y la carga útil a una (nueva) primera parte del <code class="docutils literal notranslate"><span class="pre">multipart</span></code>. Si <em>boundary</em> se especifica, se utiliza como la cadena límite en el <em>multipart</em>, de otra forma deja que el límite se cree automáticamente cuando se necesite (por ejemplo, cuando se serializa el mensaje).</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.make_alternative">
<code class="sig-name descname">make_alternative</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">boundary</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.make_alternative" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierte un mensaje no-<code class="docutils literal notranslate"><span class="pre">multipart</span></code> o un mensaje <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code> a uno <code class="docutils literal notranslate"><span class="pre">multipart/alternative``moviendo</span> <span class="pre">cualquier</span> <span class="pre">cabecera</span> <span class="pre">:mailheader:`Content-`</span> <span class="pre">y</span> <span class="pre">la</span> <span class="pre">carga</span> <span class="pre">útil</span> <span class="pre">existentes</span> <span class="pre">a</span> <span class="pre">una</span> <span class="pre">(nueva)</span> <span class="pre">primera</span> <span class="pre">parte</span> <span class="pre">del</span> <span class="pre">``multipart</span></code>. Si <em>boundary</em> se especifica, se utiliza como la cadena límite en el <em>multipart</em>, de otra forma deja que el límite se cree automáticamente cuando se necesite (por ejemplo, cuando se serializa el mensaje).</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.make_mixed">
<code class="sig-name descname">make_mixed</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">boundary</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.make_mixed" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierte un mensaje no-<code class="docutils literal notranslate"><span class="pre">multipart</span></code>, <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code> o <code class="docutils literal notranslate"><span class="pre">multipart-alternative</span></code> a uno <code class="docutils literal notranslate"><span class="pre">multipart/mixed</span></code> moviendo cualquier cabecera <em class="mailheader">Content-</em> y la carga útil existentes a una (nueva) primera parte del <code class="docutils literal notranslate"><span class="pre">multipart</span></code>. Si <em>boundary</em> se especifica, se utiliza como la cadena límite en el <em>multipart</em>, de otra forma deja que el límite se cree automáticamente cuando se necesite (por ejemplo, cuando se serializa el mensaje).</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.add_related">
<code class="sig-name descname">add_related</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">content_manager</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kw</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.add_related" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si el mensaje es un <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code>, crea un nuevo objeto mensaje, pasa todos los argumentos a su método <a class="reference internal" href="#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a> y lo une al <code class="docutils literal notranslate"><span class="pre">multipart</span></code> con <a class="reference internal" href="email.compat32-message.html#email.message.Message.attach" title="email.message.Message.attach"><code class="xref py py-meth docutils literal notranslate"><span class="pre">attach()</span></code></a>. Si el mensaje es un no-<code class="docutils literal notranslate"><span class="pre">multipart</span></code>, llama a <a class="reference internal" href="#email.message.EmailMessage.make_related" title="email.message.EmailMessage.make_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_related()</span></code></a> y procede como arriba. Si el mensaje es cualquier otro tipo de <code class="docutils literal notranslate"><span class="pre">multipart</span></code>, lanza <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>. Si <em>content_manager</em> no es especificado, usa el <code class="docutils literal notranslate"><span class="pre">content_manager</span></code> especificado por la <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a> actual. Si la parte agregada no tiene un encabezado <em class="mailheader">Content-Disposition</em>, se agrega uno con el valor <code class="docutils literal notranslate"><span class="pre">inline</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.add_alternative">
<code class="sig-name descname">add_alternative</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">content_manager</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kw</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.add_alternative" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si el mensaje es un <code class="docutils literal notranslate"><span class="pre">multipart/alternative</span></code>, crea un nuevo objeto mensaje, pasa todos los argumentos a su método <a class="reference internal" href="#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a> y lo une al <code class="docutils literal notranslate"><span class="pre">multipart</span></code> con <a class="reference internal" href="email.compat32-message.html#email.message.Message.attach" title="email.message.Message.attach"><code class="xref py py-meth docutils literal notranslate"><span class="pre">attach()</span></code></a>. Si el mensaje es un no-<code class="docutils literal notranslate"><span class="pre">multipart</span></code> o <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code>, llama a <a class="reference internal" href="#email.message.EmailMessage.make_alternative" title="email.message.EmailMessage.make_alternative"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_alternative()</span></code></a> y procede como arriba. Si el mensaje es cualquier otro tipo de <code class="docutils literal notranslate"><span class="pre">multipart</span></code>, lanza <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>. Si <em>content_manager</em> no es especificado, usa el <code class="docutils literal notranslate"><span class="pre">content_manager</span></code> especificado por la <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a> actual.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.add_attachment">
<code class="sig-name descname">add_attachment</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">content_manager</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kw</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.add_attachment" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si el mensaje es un <code class="docutils literal notranslate"><span class="pre">multipart/mixed</span></code>, cree un nuevo objeto de mensaje, pase todos los argumentos a su método <a class="reference internal" href="#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a> y <a class="reference internal" href="email.compat32-message.html#email.message.Message.attach" title="email.message.Message.attach"><code class="xref py py-meth docutils literal notranslate"><span class="pre">attach()</span></code></a> al <code class="docutils literal notranslate"><span class="pre">multipart</span></code>. Si el mensaje no es <code class="docutils literal notranslate"><span class="pre">multipart</span></code>, <code class="docutils literal notranslate"><span class="pre">multipart/related</span></code> o <code class="docutils literal notranslate"><span class="pre">multipart/alternative</span></code>, llame <a class="reference internal" href="#email.message.EmailMessage.make_mixed" title="email.message.EmailMessage.make_mixed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_mixed()</span></code></a> y luego proceda como se indicó anteriormente. Si no se especifica <em>content_manager</em>, use el <code class="docutils literal notranslate"><span class="pre">content_manager</span></code> especificado por el actual <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a>. Si la parte agregada no tiene encabezado <em class="mailheader">Content-Disposition</em>, agregue uno con el valor <code class="docutils literal notranslate"><span class="pre">attachment</span></code>. Este método se puede utilizar tanto para adjuntos explícitos (<em class="mailheader">Content-Disposition: attachment</em>) como para adjuntos <code class="docutils literal notranslate"><span class="pre">inline</span></code> (<em class="mailheader">Content-Disposition: inline</em>), pasando las opciones apropiadas al <code class="docutils literal notranslate"><span class="pre">content_manager</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.clear" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Elimina la carga útil y todas las cabeceras.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.EmailMessage.clear_content">
<code class="sig-name descname">clear_content</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.EmailMessage.clear_content" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Elimina la carga útil y todos los <code class="xref py py-exc docutils literal notranslate"><span class="pre">Content-</span></code> <em>headers</em>, dejando a las demás cabeceras intactas y en su orden original.</p>
</dd></dl>

<p>Los objetos <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> tienen los siguientes atributos de instancia:</p>
<dl class="py attribute">
<dt id="email.message.EmailMessage.preamble">
<code class="sig-name descname">preamble</code><a class="headerlink" href="#email.message.EmailMessage.preamble" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El formato de un documento MIME permite algo de texto entre la linea en blanco después de las cabeceras y la primera cadena límite de multiparte. Normalmente, este texto nunca es visible en un lector de correo compatible con MIME porque queda fuera de la armadura MIME estándar. Sin embargo, al ver el texto sin formato del mensaje, o al ver el mensaje en un lector no compatible con MIME, este texto puede volverse visible.</p>
<p>El atributo <em>preamble</em> contiene este texto extra para documentos MIME. Cuando el <a class="reference internal" href="email.parser.html#email.parser.Parser" title="email.parser.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parser</span></code></a> descubre texto después de las cabeceras pero antes de la primer cadena límite, asigna este texto al atributo <em>preamble</em> del mensaje. Cuando el <a class="reference internal" href="email.generator.html#email.generator.Generator" title="email.generator.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> escribe la representación de texto sin formato de un mensaje MIME y encuentra que el mensaje tiene un atributo <em>preamble</em> escribirá este texto en el área entre las cabeceras y el primer límite. Véase <a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.parser</span></code></a> y <a class="reference internal" href="email.generator.html#module-email.generator" title="email.generator: Generate flat text email messages from a message structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.generator</span></code></a> para conocer detalles.</p>
<p>Cabe señalar que si el objeto <em>message</em> no tiene preámbulo, el atributo <em>preamble</em> será igual a <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="email.message.EmailMessage.epilogue">
<code class="sig-name descname">epilogue</code><a class="headerlink" href="#email.message.EmailMessage.epilogue" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El atributo <em>epilogue</em> actúa de igual forma al atributo <em>preamble</em> con la excepción de que contiene texto que aparece entre el último límite y el fin del mensaje. Como con el <a class="reference internal" href="#email.message.EmailMessage.preamble" title="email.message.EmailMessage.preamble"><code class="xref py py-attr docutils literal notranslate"><span class="pre">preamble</span></code></a>, si no hay texto de epílogo este atributo será <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="email.message.EmailMessage.defects">
<code class="sig-name descname">defects</code><a class="headerlink" href="#email.message.EmailMessage.defects" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El atributo <em>defects</em> contiene una lista de todos los errores encontrados al hacer el análisis sintáctico del mensaje. Vea <a class="reference internal" href="email.errors.html#module-email.errors" title="email.errors: The exception classes used by the email package."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.errors</span></code></a> para una descripción detallada de los posibles efectos del análisis sintáctico.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="email.message.MIMEPart">
<em class="property">class </em><code class="sig-prename descclassname">email.message.</code><code class="sig-name descname">MIMEPart</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">policy</span><span class="o">=</span><span class="default_value">default</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.MIMEPart" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta clase representa una subparte de un mensaje MIME. Es idéntica a <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>, excepto que las cabeceras <em class="mailheader">MIME-Version</em> son añadidas cuando se llama a <a class="reference internal" href="#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a>, ya que las subpartes no necesitan su propia cabecera <em class="mailheader">MIME-Version</em>.</p>
</dd></dl>

<p class="rubric">Notas al pie</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Añadido originalmente en la versión 3.4 como un <a class="reference internal" href="../glossary.html#term-provisional-package"><span class="xref std std-term">módulo provisional</span></a>. La documentación para la clase heredada <em>message</em> se movió a  <a class="reference internal" href="email.compat32-message.html#compat32-message"><span class="std std-ref">email.message.Message: Representar un mensaje de correo electrónico usando la API compat32</span></a>.</p>
</dd>
</dl>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Tema anterior</h4>
  <p class="topless"><a href="email.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> — Un paquete de manejo de correo electrónico y MIME</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="email.parser.html"
                        title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.parser</span></code>: Analizar mensajes de correo electrónico</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/email.message.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="email.parser.html" title="email.parser: Analizar mensajes de correo electrónico"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="email.html" title="email — Un paquete de manejo de correo electrónico y MIME"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La Biblioteca Estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="netdata.html" >Manejo de Datos de Internet</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="email.html" ><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> — Un paquete de manejo de correo electrónico y MIME</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.message</span></code>: Representando un mensaje de correo electrónico</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 27, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>