
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="decimal — Aritmética decimal de coma fija y coma flotante" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/decimal.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Código fuente: Lib/decimal.py El módulo decimal proporciona soporte para aritmética de coma flotante decimal rápida y redondeada correctamente. Ofrece varias ventajas en comparación con el tipo de ..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Código fuente: Lib/decimal.py El módulo decimal proporciona soporte para aritmética de coma flotante decimal rápida y redondeada correctamente. Ofrece varias ventajas en comparación con el tipo de ..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>decimal — Aritmética decimal de coma fija y coma flotante &#8212; documentación de Python - 3.11.2</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=2d3badd06fe70b34b68db01f99471ce1624ffe4a" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.11.2"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="fractions — Números racionales" href="fractions.html" />
    <link rel="prev" title="cmath – Función matemática para números complejos" href="cmath.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/decimal.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code> — Aritmética decimal de coma fija y coma flotante</a><ul>
<li><a class="reference internal" href="#quick-start-tutorial">Tutorial de inicio rápido</a></li>
<li><a class="reference internal" href="#decimal-objects">Objetos Decimal</a><ul>
<li><a class="reference internal" href="#logical-operands">Operandos lógicos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#context-objects">Objetos context</a></li>
<li><a class="reference internal" href="#constants">Constantes</a></li>
<li><a class="reference internal" href="#rounding-modes">Modos de redondeo</a></li>
<li><a class="reference internal" href="#signals">Señales</a></li>
<li><a class="reference internal" href="#floating-point-notes">Notas sobre la representación en coma flotante</a><ul>
<li><a class="reference internal" href="#mitigating-round-off-error-with-increased-precision">Mitigación del error de redondeo usando mayor precisión</a></li>
<li><a class="reference internal" href="#special-values">Valores especiales</a></li>
</ul>
</li>
<li><a class="reference internal" href="#working-with-threads">Trabajando con hilos</a></li>
<li><a class="reference internal" href="#recipes">Casos prácticos</a></li>
<li><a class="reference internal" href="#decimal-faq">Preguntas frecuentes sobre decimal</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="cmath.html"
                          title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code> – Función matemática para números complejos</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="fractions.html"
                          title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fractions</span></code> — Números racionales</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/library/decimal.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="fractions.html" title="fractions — Números racionales"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="cmath.html" title="cmath – Función matemática para números complejos"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="numeric.html" accesskey="U">Módulos numéricos y matemáticos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code> — Aritmética decimal de coma fija y coma flotante</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-decimal">
<span id="decimal-decimal-fixed-point-and-floating-point-arithmetic"></span><h1><a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> — Aritmética decimal de coma fija y coma flotante<a class="headerlink" href="#module-decimal" title="Enlazar permanentemente con este título">¶</a></h1>
<p><strong>Código fuente:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.11/Lib/decimal.py">Lib/decimal.py</a></p>
<hr class="docutils" />
<p>El módulo <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> proporciona soporte para aritmética de coma flotante decimal rápida y redondeada correctamente. Ofrece varias ventajas en comparación con el tipo de dato <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>:</p>
<ul>
<li><p>Decimal «se basa en un modelo de coma flotante que se diseñó pensando en las personas, y necesariamente tiene un principio rector supremo: las computadoras deben proporcionar una aritmética que funcione de la misma manera que la aritmética que las personas aprenden en la escuela.» – extracto (traducido) de la especificación de la aritmética decimal.</p></li>
<li><p>Decimal numbers can be represented exactly.  In contrast, numbers like
<code class="docutils literal notranslate"><span class="pre">1.1</span></code> and <code class="docutils literal notranslate"><span class="pre">2.2</span></code> do not have exact representations in binary
floating point. End users typically would not expect <code class="docutils literal notranslate"><span class="pre">1.1</span> <span class="pre">+</span> <span class="pre">2.2</span></code> to display
as <code class="docutils literal notranslate"><span class="pre">3.3000000000000003</span></code> as it does with binary floating point.</p></li>
<li><p>The exactness carries over into arithmetic.  In decimal floating point, <code class="docutils literal notranslate"><span class="pre">0.1</span>
<span class="pre">+</span> <span class="pre">0.1</span> <span class="pre">+</span> <span class="pre">0.1</span> <span class="pre">-</span> <span class="pre">0.3</span></code> is exactly equal to zero.  In binary floating point, the result
is <code class="docutils literal notranslate"><span class="pre">5.5511151231257827e-017</span></code>.  While near to zero, the differences
prevent reliable equality testing and differences can accumulate. For this
reason, decimal is preferred in accounting applications which have strict
equality invariants.</p></li>
<li><p>The decimal module incorporates a notion of significant places so that <code class="docutils literal notranslate"><span class="pre">1.30</span>
<span class="pre">+</span> <span class="pre">1.20</span></code> is <code class="docutils literal notranslate"><span class="pre">2.50</span></code>.  The trailing zero is kept to indicate significance.
This is the customary presentation for monetary applications. For
multiplication, the «schoolbook» approach uses all the figures in the
multiplicands.  For instance, <code class="docutils literal notranslate"><span class="pre">1.3</span> <span class="pre">*</span> <span class="pre">1.2</span></code> gives <code class="docutils literal notranslate"><span class="pre">1.56</span></code> while <code class="docutils literal notranslate"><span class="pre">1.30</span> <span class="pre">*</span>
<span class="pre">1.20</span></code> gives <code class="docutils literal notranslate"><span class="pre">1.5600</span></code>.</p></li>
<li><p>A diferencia del punto flotante binario basado en hardware, el módulo decimal tiene una precisión modificable por el usuario (por defecto es de 28 dígitos decimales) que puede ser tan grande como sea necesario para un problema dado:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.142857&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.1428571428571428571428571429&#39;)</span>
</pre></div>
</div>
</li>
<li><p>Tanto la representación en coma flotante binaria como la decimal se implementan de acuerdo a estándares publicados. Mientras que el tipo float expone solo una pequeña parte de sus capacidades, el módulo decimal expone todos los componentes requeridos del estándar. Cuando es necesario, el desarrollador tiene control total sobre el redondeo y la gestión de las señales. Esto incluye la capacidad de forzar la aritmética exacta, utilizando excepciones para bloquear cualquier operación inexacta.</p></li>
<li><p>El módulo decimal fue diseñado para admitir «indiscriminadamente, tanto aritmética decimal exacta sin redondeo (a veces llamada aritmética de coma fija) como la aritmética de coma flotante con redondeo.» – extracto (traducido) de la especificación de la aritmética decimal.</p></li>
</ul>
<p>El módulo está diseñado en torno a tres conceptos: el número decimal, el contexto aritmético y las señales.</p>
<p>A decimal number is immutable.  It has a sign, coefficient digits, and an
exponent.  To preserve significance, the coefficient digits do not truncate
trailing zeros.  Decimals also include special values such as
<code class="docutils literal notranslate"><span class="pre">Infinity</span></code>, <code class="docutils literal notranslate"><span class="pre">-Infinity</span></code>, and <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.  The standard also
differentiates <code class="docutils literal notranslate"><span class="pre">-0</span></code> from <code class="docutils literal notranslate"><span class="pre">+0</span></code>.</p>
<p>El contexto aritmético es un entorno que permite especificar una precisión, reglas de redondeo, límites en los exponentes, flags que indican el resultado de las operaciones y habilitadores de trampas que especifican si las señales (reportadas durante operaciones ilegales) son tratadas o no como excepciones de Python. Las opciones de redondeo incluyen <a class="reference internal" href="#decimal.ROUND_CEILING" title="decimal.ROUND_CEILING"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_CEILING</span></code></a>, <a class="reference internal" href="#decimal.ROUND_DOWN" title="decimal.ROUND_DOWN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_DOWN</span></code></a>, <a class="reference internal" href="#decimal.ROUND_FLOOR" title="decimal.ROUND_FLOOR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_FLOOR</span></code></a>, <a class="reference internal" href="#decimal.ROUND_HALF_DOWN" title="decimal.ROUND_HALF_DOWN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_DOWN</span></code></a>, <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a>, <a class="reference internal" href="#decimal.ROUND_HALF_UP" title="decimal.ROUND_HALF_UP"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_UP</span></code></a>, <a class="reference internal" href="#decimal.ROUND_UP" title="decimal.ROUND_UP"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_UP</span></code></a> y <a class="reference internal" href="#decimal.ROUND_05UP" title="decimal.ROUND_05UP"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_05UP</span></code></a>.</p>
<p>Las señales son grupos de condiciones excepcionales que ocurren durante el cálculo. Dependiendo de las necesidades de la aplicación, las señales pueden ignorarse, tratarse como información o tratarse como excepciones. Las señales existentes en el módulo decimal son <a class="reference internal" href="#decimal.Clamped" title="decimal.Clamped"><code class="xref py py-const docutils literal notranslate"><span class="pre">Clamped</span></code></a>, <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a>, <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-const docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a>, <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a>, <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal notranslate"><span class="pre">Rounded</span></code></a>, <a class="reference internal" href="#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-const docutils literal notranslate"><span class="pre">Subnormal</span></code></a>, <a class="reference internal" href="#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-const docutils literal notranslate"><span class="pre">Overflow</span></code></a>, <a class="reference internal" href="#decimal.Underflow" title="decimal.Underflow"><code class="xref py py-const docutils literal notranslate"><span class="pre">Underflow</span></code></a> y <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-const docutils literal notranslate"><span class="pre">FloatOperation</span></code></a>.</p>
<p>Por cada señal hay un flag y un habilitador de trampa. Cuando ocurre una operación ilegal, su flag se establece en uno, luego, si su habilitador de trampa está establecido en uno, se lanza una excepción. La configuración de los flags es persistente, por lo que el usuario debe restablecerlos antes de comenzar un cálculo que desee monitorear.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<ul class="simple">
<li><p>IBM’s General Decimal Arithmetic Specification, <a class="reference external" href="https://speleotrove.com/decimal/decarith.html">The General Decimal Arithmetic
Specification</a>.</p></li>
</ul>
</div>
<section id="quick-start-tutorial">
<span id="decimal-tutorial"></span><h2>Tutorial de inicio rápido<a class="headerlink" href="#quick-start-tutorial" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El punto de partida habitual para usar decimales es importar el módulo, ver el contexto actual con <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> y, si es necesario, establecer nuevos valores para la precisión, el redondeo o trampas de señales habilitadas:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span>
<span class="go">Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[], traps=[Overflow, DivisionByZero,</span>
<span class="go">        InvalidOperation])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">7</span>       <span class="c1"># Set a new precision</span>
</pre></div>
</div>
<p>Decimal instances can be constructed from integers, strings, floats, or tuples.
Construction from an integer or a float performs an exact conversion of the
value of that integer or float.  Decimal numbers include special values such as
<code class="docutils literal notranslate"><span class="pre">NaN</span></code> which stands for «Not a number», positive and negative
<code class="docutils literal notranslate"><span class="pre">Infinity</span></code>, and <code class="docutils literal notranslate"><span class="pre">-0</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">Decimal(&#39;10&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.14&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.14&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.140000000000000124344978758017532527446746826171875&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
<span class="go">Decimal(&#39;3.14&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">))</span>
<span class="go">Decimal(&#39;1.4142135623730951&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.5&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.414213562373095048801688724&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;NaN&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;NaN&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-Infinity&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;-Infinity&#39;)</span>
</pre></div>
</div>
<p>Si la señal <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FloatOperation</span></code></a> es atrapada, la mezcla accidental de decimales y flotantes en constructores o comparaciones de orden lanzará una excepción:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">getcontext</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">FloatOperation</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.FloatOperation</span>: <span class="n">[&lt;class &#39;decimal.FloatOperation&#39;&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.5&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">3.7</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.FloatOperation</span>: <span class="n">[&lt;class &#39;decimal.FloatOperation&#39;&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.5&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mf">3.5</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<p>La significación de un nuevo objeto Decimal es determinada únicamente por el número de dígitos ingresados. La precisión y el redondeo establecidos en el contexto solo entran en juego durante las operaciones aritméticas.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.0&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.0&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.1415926535&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.1415926535&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.1415926535&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.7182818285&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.85987&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">rounding</span> <span class="o">=</span> <span class="n">ROUND_UP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.1415926535&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.7182818285&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.85988&#39;)</span>
</pre></div>
</div>
<p>Se lanza una excepción <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> si durante la construcción de un objeto Decimal se exceden los límites internos de la versión de C:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;1e9999999999999999999&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">decimal.InvalidOperation</span>: <span class="n">[&lt;class &#39;decimal.InvalidOperation&#39;&gt;]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3.</span></p>
</div>
<p>Los objetos Decimal interactúan bien con gran parte del resto de Python. Aquí hay un pequeño circo volador de punto flotante decimal:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="s1">&#39;1.34 1.87 3.45 2.35 1.00 0.03 9.25&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal(&#39;9.25&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.03&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">[Decimal(&#39;0.03&#39;), Decimal(&#39;1.00&#39;), Decimal(&#39;1.34&#39;), Decimal(&#39;1.87&#39;),</span>
<span class="go"> Decimal(&#39;2.35&#39;), Decimal(&#39;3.45&#39;), Decimal(&#39;9.25&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">Decimal(&#39;19.29&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&#39;1.34&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.34</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.3&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="mi">5</span>
<span class="go">Decimal(&#39;6.70&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="go">Decimal(&#39;2.5058&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">%</span> <span class="n">a</span>
<span class="go">Decimal(&#39;0.77&#39;)</span>
</pre></div>
</div>
<p>Y algunas funciones matemáticas también están disponibles para Decimal:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
<span class="go">Decimal(&#39;1.414213562373095048801688724&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.718281828459045235360287471&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;10&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ln</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.302585092994045684017991455&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;10&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">log10</span><span class="p">()</span>
<span class="go">Decimal(&#39;1&#39;)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#decimal.Decimal.quantize" title="decimal.Decimal.quantize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quantize()</span></code></a> method rounds a number to a fixed exponent.  This method is
useful for monetary applications that often round results to a fixed number of
places:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.325&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;.01&#39;</span><span class="p">),</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span>
<span class="go">Decimal(&#39;7.32&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.325&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.&#39;</span><span class="p">),</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_UP</span><span class="p">)</span>
<span class="go">Decimal(&#39;8&#39;)</span>
</pre></div>
</div>
<p>Como se muestra arriba, la función <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> accede al contexto actual y permite cambiar la configuración. Este enfoque satisface las necesidades de la mayoría de las aplicaciones.</p>
<p>Para trabajos más avanzados, puede resultar útil crear contextos alternativos utilizando el constructor Context(). Para activar un contexto alternativo, usa la función <a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">setcontext()</span></code></a>.</p>
<p>De acuerdo con el estándar, el módulo <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> proporciona dos contextos estándar listos para usar, <a class="reference internal" href="#decimal.BasicContext" title="decimal.BasicContext"><code class="xref py py-const docutils literal notranslate"><span class="pre">BasicContext</span></code></a> y <a class="reference internal" href="#decimal.ExtendedContext" title="decimal.ExtendedContext"><code class="xref py py-const docutils literal notranslate"><span class="pre">ExtendedContext</span></code></a>. El primero es particularmente útil para la depuración, ya que muchas de las trampas de señales están habilitadas por defecto:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">myothercontext</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_HALF_DOWN</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">myothercontext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.142857142857142857142857142857142857142857142857142857142857&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">ExtendedContext</span>
<span class="go">Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[], traps=[])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.142857143&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Decimal(&#39;Infinity&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">BasicContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;pyshell#143&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">-toplevel-</span>
    <span class="n">Decimal</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gr">DivisionByZero</span>: <span class="n">x / 0</span>
</pre></div>
</div>
<p>Contexts also have signal flags for monitoring exceptional conditions
encountered during computations.  The flags remain set until explicitly cleared,
so it is best to clear the flags before each set of monitored computations by
using the <a class="reference internal" href="#decimal.Context.clear_flags" title="decimal.Context.clear_flags"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clear_flags()</span></code></a> method.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">clear_flags</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">355</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">113</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.14159292&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span>
<span class="go">Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span>
<span class="go">        capitals=1, clamp=0, flags=[Inexact, Rounded], traps=[])</span>
</pre></div>
</div>
<p>The <em>flags</em> entry shows that the rational approximation to pi was
rounded (digits beyond the context precision were thrown away) and that the
result is inexact (some of the discarded digits were non-zero).</p>
<p>Individual traps are set using the dictionary in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">traps</span></code>
attribute of a context:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">ExtendedContext</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Decimal(&#39;Infinity&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">DivisionByZero</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;pyshell#112&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">-toplevel-</span>
    <span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gr">DivisionByZero</span>: <span class="n">x / 0</span>
</pre></div>
</div>
<p>La mayoría de los programas ajustan el contexto actual una sola vez, al comienzo del programa. Y, en muchas aplicaciones, los datos se convierten a <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> mediante una única conversión dentro de un bucle. Con el contexto establecido y los decimales creados, la mayor parte del programa manipula los datos de la misma forma que con otros tipos numéricos de Python.</p>
</section>
<section id="decimal-objects">
<span id="decimal-decimal"></span><h2>Objetos Decimal<a class="headerlink" href="#decimal-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="decimal.Decimal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Decimal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'0'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Construye un nuevo objeto <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> basado en <em>value</em>.</p>
<p><em>value</em> puede ser un entero, una cadena de caracteres, una tupla, un <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> u otro objeto <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>. Si no se proporciona <em>value</em>, retorna <code class="docutils literal notranslate"><span class="pre">Decimal('0')</span></code>. Si <em>value</em> es una cadena, debe ajustarse a la sintaxis de cadena numérica decimal después de que los espacios en blanco iniciales y finales, así como los guiones bajos, sean eliminados:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sign</span>           <span class="p">:</span><span class="o">:=</span>  <span class="s1">&#39;+&#39;</span> <span class="o">|</span> <span class="s1">&#39;-&#39;</span>
<span class="n">digit</span>          <span class="p">:</span><span class="o">:=</span>  <span class="s1">&#39;0&#39;</span> <span class="o">|</span> <span class="s1">&#39;1&#39;</span> <span class="o">|</span> <span class="s1">&#39;2&#39;</span> <span class="o">|</span> <span class="s1">&#39;3&#39;</span> <span class="o">|</span> <span class="s1">&#39;4&#39;</span> <span class="o">|</span> <span class="s1">&#39;5&#39;</span> <span class="o">|</span> <span class="s1">&#39;6&#39;</span> <span class="o">|</span> <span class="s1">&#39;7&#39;</span> <span class="o">|</span> <span class="s1">&#39;8&#39;</span> <span class="o">|</span> <span class="s1">&#39;9&#39;</span>
<span class="n">indicator</span>      <span class="p">:</span><span class="o">:=</span>  <span class="s1">&#39;e&#39;</span> <span class="o">|</span> <span class="s1">&#39;E&#39;</span>
<span class="n">digits</span>         <span class="p">:</span><span class="o">:=</span>  <span class="n">digit</span> <span class="p">[</span><span class="n">digit</span><span class="p">]</span><span class="o">...</span>
<span class="n">decimal</span><span class="o">-</span><span class="n">part</span>   <span class="p">:</span><span class="o">:=</span>  <span class="n">digits</span> <span class="s1">&#39;.&#39;</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span> <span class="o">|</span> <span class="p">[</span><span class="s1">&#39;.&#39;</span><span class="p">]</span> <span class="n">digits</span>
<span class="n">exponent</span><span class="o">-</span><span class="n">part</span>  <span class="p">:</span><span class="o">:=</span>  <span class="n">indicator</span> <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">digits</span>
<span class="n">infinity</span>       <span class="p">:</span><span class="o">:=</span>  <span class="s1">&#39;Infinity&#39;</span> <span class="o">|</span> <span class="s1">&#39;Inf&#39;</span>
<span class="n">nan</span>            <span class="p">:</span><span class="o">:=</span>  <span class="s1">&#39;NaN&#39;</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span> <span class="o">|</span> <span class="s1">&#39;sNaN&#39;</span> <span class="p">[</span><span class="n">digits</span><span class="p">]</span>
<span class="n">numeric</span><span class="o">-</span><span class="n">value</span>  <span class="p">:</span><span class="o">:=</span>  <span class="n">decimal</span><span class="o">-</span><span class="n">part</span> <span class="p">[</span><span class="n">exponent</span><span class="o">-</span><span class="n">part</span><span class="p">]</span> <span class="o">|</span> <span class="n">infinity</span>
<span class="n">numeric</span><span class="o">-</span><span class="n">string</span> <span class="p">:</span><span class="o">:=</span>  <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">numeric</span><span class="o">-</span><span class="n">value</span> <span class="o">|</span> <span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="n">nan</span>
</pre></div>
</div>
<p>También se permiten otros dígitos decimales Unicode en aquellos lugares en los que arriba aparece <code class="docutils literal notranslate"><span class="pre">digit</span></code>. Estos incluyen dígitos decimales de otros alfabetos (por ejemplo, dígitos del alfabeto árabe-índico y devanāgarī) junto con los dígitos de ancho completo desde <code class="docutils literal notranslate"><span class="pre">'\uff10'</span></code> a <code class="docutils literal notranslate"><span class="pre">'\uff19'</span></code>.</p>
<p>If <em>value</em> is a <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, it should have three components, a sign
(<code class="docutils literal notranslate"><span class="pre">0</span></code> for positive or <code class="docutils literal notranslate"><span class="pre">1</span></code> for negative), a <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> of
digits, and an integer exponent. For example, <code class="docutils literal notranslate"><span class="pre">Decimal((0,</span> <span class="pre">(1,</span> <span class="pre">4,</span> <span class="pre">1,</span> <span class="pre">4),</span> <span class="pre">-3))</span></code>
returns <code class="docutils literal notranslate"><span class="pre">Decimal('1.414')</span></code>.</p>
<p>Si <em>value</em> es un <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, el valor binario de coma flotante se convierte sin pérdidas a su equivalente decimal exacto. Esta conversión a menudo puede requerir 53 o más dígitos de precisión. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">Decimal(float('1.1'))</span></code> se convierte en <code class="docutils literal notranslate"><span class="pre">Decimal('1.100000000000000088817841970012523233890533447265625')</span></code>.</p>
<p>La precisión de <em>context</em> no afecta a la cantidad de dígitos almacenados. Eso está determinado exclusivamente por el número de dígitos en <em>value</em>. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">Decimal('3.00000')</span></code> registra los cinco ceros incluso si la precisión del contexto es solo tres.</p>
<p>The purpose of the <em>context</em> argument is determining what to do if <em>value</em> is a
malformed string.  If the context traps <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a>, an exception
is raised; otherwise, the constructor returns a new Decimal with the value of
<code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p>
<p>Una vez construidos, los objetos <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> son inmutables.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Ahora se permite que el argumento del constructor sea una instancia <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Los argumentos <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> ahora generan una excepción si se establece la trampa <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FloatOperation</span></code></a>. Por defecto, la trampa está desactivada.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Se permiten guiones bajos para la agrupación, como ocurre en el código con los literales enteros y de punto flotante.</p>
</div>
<p>Los objetos de coma flotante decimal comparten muchas propiedades con los otros tipos numéricos integrados, como <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> e <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>. Se aplican todas las operaciones matemáticas habituales y los métodos especiales. Asimismo, los objetos decimales se pueden copiar, serializar con pickle, imprimir, usar como claves de un diccionario o como elementos de un conjunto, comparar, ordenar y convertir a otros tipos (como <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> o <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>).</p>
<p>Hay algunas pequeñas diferencias entre la aritmética en objetos decimales y la aritmética en enteros y flotantes. Cuando el operador de resto <code class="docutils literal notranslate"><span class="pre">%</span></code> se aplica a objetos Decimal, el signo del resultado es el signo del <em>dividendo</em> en lugar del signo del divisor:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">%</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Decimal(&#39;-3&#39;)</span>
</pre></div>
</div>
<p>El operador de división entera <code class="docutils literal notranslate"><span class="pre">//</span></code> se comporta de manera análoga, retornando la parte entera del cociente verdadero (truncando hacia cero) en lugar del resultado de aplicarle la función suelo. Esto se hace con la finalidad de preservar la identidad habitual <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">(x</span> <span class="pre">//</span> <span class="pre">y)</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="mi">7</span> <span class="o">//</span> <span class="mi">4</span>
<span class="go">-2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="o">//</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Decimal(&#39;-1&#39;)</span>
</pre></div>
</div>
<p>Los operadores <code class="docutils literal notranslate"><span class="pre">%</span></code> y <code class="docutils literal notranslate"><span class="pre">//</span></code> implementan las operaciones <code class="docutils literal notranslate"><span class="pre">remainder</span></code> y <code class="docutils literal notranslate"><span class="pre">divide-integer</span></code> (respectivamente) como se describe en la especificación.</p>
<p>Los objetos de la clase Decimal generalmente no se pueden combinar con flotantes o instancias de <a class="reference internal" href="fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">fractions.Fraction</span></code></a> en operaciones aritméticas: un intento de agregar un objeto <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> a un <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, por ejemplo, lanzará una excepción <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>. Sin embargo, es posible usar los operadores de comparación de Python para comparar una instancia de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> <code class="docutils literal notranslate"><span class="pre">x</span></code> con otro número <code class="docutils literal notranslate"><span class="pre">y</span></code>. Esto evita resultados confusos al hacer comparaciones de igualdad entre números de diferentes tipos.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Las comparaciones de tipo mixto entre instancias de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> y otros tipos numéricos ahora son totalmente compatibles.</p>
</div>
<p>Además de las propiedades numéricas estándar, los objetos de coma flotante decimal también tienen varios métodos especializados:</p>
<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.adjusted">
<span class="sig-name descname"><span class="pre">adjusted</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.adjusted" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el exponente ajustado después de desplazar los dígitos del extremo derecho del coeficiente hasta que solo quede el dígito principal: <code class="docutils literal notranslate"><span class="pre">Decimal('321e+5').adjusted()</span></code> retorna siete. Se utiliza para determinar la posición del dígito más significativo con respecto al punto decimal.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.as_integer_ratio">
<span class="sig-name descname"><span class="pre">as_integer_ratio</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.as_integer_ratio" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un par de enteros <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code> que representan la instancia de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> proporcionada como una fracción irreducible y con un denominador positivo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-3.14&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(-157, 50)</span>
</pre></div>
</div>
<p>La conversión es exacta. Lanza una excepción OverflowError si se proporcionan valores infinitos y ValueError con valores NaN.</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.</span></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.as_tuple">
<span class="sig-name descname"><span class="pre">as_tuple</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.as_tuple" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una representación en forma de <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a> del número: <code class="docutils literal notranslate"><span class="pre">DecimalTuple(sign,</span> <span class="pre">digits,</span> <span class="pre">exponent)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.canonical">
<span class="sig-name descname"><span class="pre">canonical</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.canonical" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la codificación canónica del argumento. Actualmente, la codificación de una instancia de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> es siempre canónica, por lo que esta operación retorna su argumento sin cambios.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.compare">
<span class="sig-name descname"><span class="pre">compare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Compara los valores de dos instancias de Decimal. El método <a class="reference internal" href="#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare()</span></code></a> retorna una instancia de Decimal, y si alguno de los operandos es un NaN, el resultado es un NaN:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="ow">or</span> <span class="n">b</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">NaN</span>  <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;NaN&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span>            <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-1&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">==</span> <span class="n">b</span>           <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span>            <span class="o">==&gt;</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.compare_signal">
<span class="sig-name descname"><span class="pre">compare_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare_signal" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta operación es idéntica al método <a class="reference internal" href="#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare()</span></code></a>, excepto que todos los valores NaN generan una señal. Es decir, si ninguno de los operandos es un NaN señalizador, cualquier operando de NaN silencioso se trata como si fuera un NaN señalizador.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.compare_total">
<span class="sig-name descname"><span class="pre">compare_total</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare_total" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Compara dos operandos utilizando su representación abstracta en lugar de su valor numérico. Similar al método <a class="reference internal" href="#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare()</span></code></a>, pero el resultado proporciona un ordenamiento total en las instancias de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>. Dos instancias de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> con el mismo valor numérico, pero diferentes representaciones, se comparan como desiguales usando este orden:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;12.0&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">compare_total</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;12&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;-1&#39;)</span>
</pre></div>
</div>
<p>Los NaN silenciosos y señalizadores también se incluyen en el ordenamiento total. El resultado de esta función es <code class="docutils literal notranslate"><span class="pre">Decimal('0')</span></code> si ambos operandos tienen la misma representación, <code class="docutils literal notranslate"><span class="pre">Decimal('-1')</span></code> si el primer operando es menor en el orden total que el segundo y <code class="docutils literal notranslate"><span class="pre">Decimal('1')</span></code> si el primer operando es mayor en el orden total que el segundo operando. Consulta las especificaciones para obtener detalles sobre el ordenamiento total.</p>
<p>Esta operación no se ve afectada por el contexto y es silenciosa: no se cambian los flags y no se realiza ningún redondeo. Como excepción, la versión de C puede lanzar InvalidOperation si el segundo operando no se puede convertir exactamente.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.compare_total_mag">
<span class="sig-name descname"><span class="pre">compare_total_mag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.compare_total_mag" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Compara dos operandos usando su representación abstracta en lugar de su valor, como en <a class="reference internal" href="#decimal.Decimal.compare_total" title="decimal.Decimal.compare_total"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare_total()</span></code></a>, pero ignorando el signo de cada operando. <code class="docutils literal notranslate"><span class="pre">x.compare_total_mag(y)</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">x.copy_abs().compare_total(y.copy_abs())</span></code>.</p>
<p>Esta operación no se ve afectada por el contexto y es silenciosa: no se cambian los flags y no se realiza ningún redondeo. Como excepción, la versión de C puede lanzar InvalidOperation si el segundo operando no se puede convertir exactamente.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.conjugate">
<span class="sig-name descname"><span class="pre">conjugate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.conjugate" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Simplemente retorna self (el propio objeto al que pertenece el método invocado). Este método existe solo para cumplir con la Especificación decimal.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.copy_abs">
<span class="sig-name descname"><span class="pre">copy_abs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.copy_abs" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el valor absoluto del argumento. Esta operación no se ve afectada por el contexto y es silenciosa: no se modifican los flags y no se realiza ningún redondeo.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.copy_negate">
<span class="sig-name descname"><span class="pre">copy_negate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.copy_negate" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la negación del argumento. Esta operación no se ve afectada por el contexto y es silenciosa: no se cambian los flags y no se realiza ningún redondeo.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.copy_sign">
<span class="sig-name descname"><span class="pre">copy_sign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.copy_sign" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia del primer operando pero con el signo establecido para que sea el mismo que el del segundo operando. Por ejemplo:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.3&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">copy_sign</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;-1.5&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;-2.3&#39;)</span>
</pre></div>
</div>
<p>Esta operación no se ve afectada por el contexto y es silenciosa: no se cambian los flags y no se realiza ningún redondeo. Como excepción, la versión de C puede lanzar InvalidOperation si el segundo operando no se puede convertir exactamente.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.exp" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el valor de la función exponencial (natural) <code class="docutils literal notranslate"><span class="pre">e**x</span></code> en el número dado. El resultado es correctamente redondeado utilizando el modo de redondeo <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.718281828459045235360287471&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">321</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&#39;2.561702493119680037517373933E+139&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.from_float">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_float</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.from_float" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Alternative constructor that only accepts instances of <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> or
<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>.</p>
<p>Note <code class="docutils literal notranslate"><span class="pre">Decimal.from_float(0.1)</span></code> is not the same as <code class="docutils literal notranslate"><span class="pre">Decimal('0.1')</span></code>.
Since 0.1 is not exactly representable in binary floating point, the
value is stored as the nearest representable value which is
<code class="docutils literal notranslate"><span class="pre">0x1.999999999999ap-4</span></code>.  That equivalent value in decimal is
<code class="docutils literal notranslate"><span class="pre">0.1000000000000000055511151231257827021181583404541015625</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Desde Python 3.2 en adelante, una instancia de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> también se puede construir directamente desde una instancia de <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>.</p>
</div>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.1000000000000000055511151231257827021181583404541015625&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;nan&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;NaN&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;Infinity&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;-Infinity&#39;)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.fma">
<span class="sig-name descname"><span class="pre">fma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">third</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.fma" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Fusión de la multiplicación y la suma. Retorna self*other+third sin redondeo del producto intermedio self*other.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">fma</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">Decimal(&#39;11&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_canonical">
<span class="sig-name descname"><span class="pre">is_canonical</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_canonical" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> si el argumento es canónico y <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> en caso contrario. Actualmente, una instancia de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> es siempre canónica, por lo que esta operación siempre retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_finite">
<span class="sig-name descname"><span class="pre">is_finite</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_finite" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> si el argumento es un número finito y <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> si el argumento es un valor infinito o un NaN.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_infinite">
<span class="sig-name descname"><span class="pre">is_infinite</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_infinite" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> si el argumento es un valor infinito positivo o negativo y <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> en caso contrario.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_nan">
<span class="sig-name descname"><span class="pre">is_nan</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_nan" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> si el argumento es un NaN (silencioso o señalizador) y <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> en caso contrario.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_normal">
<span class="sig-name descname"><span class="pre">is_normal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_normal" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> si el argumento es un número finito <em>normal</em>. Retorna <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> si el argumento es cero, subnormal, infinito o un NaN.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_qnan">
<span class="sig-name descname"><span class="pre">is_qnan</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_qnan" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> si el argumento es un NaN silencioso y <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> en caso contrario.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_signed">
<span class="sig-name descname"><span class="pre">is_signed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_signed" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> si el argumento tiene signo negativo y <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> en caso contrario. Ten en cuenta que tanto los ceros como los NaN pueden tener signo.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_snan">
<span class="sig-name descname"><span class="pre">is_snan</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_snan" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> si el argumento es un NaN señalizador y <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> en caso contrario.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_subnormal">
<span class="sig-name descname"><span class="pre">is_subnormal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_subnormal" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> si el argumento es subnormal y <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> en caso contrario.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.is_zero">
<span class="sig-name descname"><span class="pre">is_zero</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.is_zero" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> si el argumento es un cero (positivo o negativo) y <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> en caso contrario.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.ln">
<span class="sig-name descname"><span class="pre">ln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.ln" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el logaritmo natural (base e) del operando. El resultado es correctamente redondeado utilizando el modo de redondeo <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.log10">
<span class="sig-name descname"><span class="pre">log10</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.log10" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el logaritmo en base diez del operando. El resultado es correctamente redondeado utilizando el modo de redondeo <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.logb">
<span class="sig-name descname"><span class="pre">logb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logb" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Para un número distinto de cero, retorna el exponente ajustado de su operando como una instancia de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>. Si el operando es cero, se retorna <code class="docutils literal notranslate"><span class="pre">Decimal('-Infinity')</span></code> y se activa el flag <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-const docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a>. Si el operando es infinito, se retorna <code class="docutils literal notranslate"><span class="pre">Decimal('Infinity')</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.logical_and">
<span class="sig-name descname"><span class="pre">logical_and</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_and" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">logic_and()</span></code> es una operación lógica que toma dos <em>operandos lógicos</em> (consultar <a class="reference internal" href="#logical-operands-label"><span class="std std-ref">Operandos lógicos</span></a>). El resultado es el <code class="docutils literal notranslate"><span class="pre">and</span></code> dígito por dígito de los dos operandos.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.logical_invert">
<span class="sig-name descname"><span class="pre">logical_invert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_invert" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">logic_invert()</span></code> es una operación lógica. El resultado es la inversión dígito a dígito del operando.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.logical_or">
<span class="sig-name descname"><span class="pre">logical_or</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_or" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p><a class="reference internal" href="#decimal.Decimal.logical_or" title="decimal.Decimal.logical_or"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_or()</span></code></a> es una operación lógica que toma dos <em>operandos lógicos</em> (consultar <a class="reference internal" href="#logical-operands-label"><span class="std std-ref">Operandos lógicos</span></a>). El resultado es un <code class="docutils literal notranslate"><span class="pre">or</span></code> dígito a dígito de los dos operandos.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.logical_xor">
<span class="sig-name descname"><span class="pre">logical_xor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.logical_xor" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">logic_xor()</span></code> es una operación lógica que toma dos <em>operandos lógicos</em> (consultar <a class="reference internal" href="#logical-operands-label"><span class="std std-ref">Operandos lógicos</span></a>). El resultado es la disyunción exclusiva («exclusive or») dígito a dígito de ambos operandos.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.max">
<span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.max" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Like <code class="docutils literal notranslate"><span class="pre">max(self,</span> <span class="pre">other)</span></code> except that the context rounding rule is applied
before returning and that <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values are either signaled or
ignored (depending on the context and whether they are signaling or
quiet).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.max_mag">
<span class="sig-name descname"><span class="pre">max_mag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.max_mag" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Similar al método <a class="reference internal" href="#decimal.Decimal.max" title="decimal.Decimal.max"><code class="xref py py-meth docutils literal notranslate"><span class="pre">max()</span></code></a>, pero la comparación se realiza utilizando los valores absolutos de los operandos.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.min">
<span class="sig-name descname"><span class="pre">min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.min" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Like <code class="docutils literal notranslate"><span class="pre">min(self,</span> <span class="pre">other)</span></code> except that the context rounding rule is applied
before returning and that <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values are either signaled or
ignored (depending on the context and whether they are signaling or
quiet).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.min_mag">
<span class="sig-name descname"><span class="pre">min_mag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.min_mag" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Similar al método <a class="reference internal" href="#decimal.Decimal.min" title="decimal.Decimal.min"><code class="xref py py-meth docutils literal notranslate"><span class="pre">min()</span></code></a>, pero la comparación se realiza utilizando los valores absolutos de los operandos.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.next_minus">
<span class="sig-name descname"><span class="pre">next_minus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.next_minus" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el número más grande representable en el contexto proporcionado (o en el contexto del hilo actual si no se proporciona un contexto) que sea más pequeño que el operando proporcionado.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.next_plus">
<span class="sig-name descname"><span class="pre">next_plus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.next_plus" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el número más pequeño representable en el contexto proporcionado (o en el contexto del hilo actual si no se proporciona ningún contexto) que sea más grande que el operando proporcionado.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.next_toward">
<span class="sig-name descname"><span class="pre">next_toward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.next_toward" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si los dos operandos no son iguales, retorna el número más cercano al primer operando en la dirección del segundo operando. Si ambos operandos son numéricamente iguales, retorna una copia del primer operando con el signo establecido para que sea el mismo que el signo del segundo operando.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.normalize">
<span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.normalize" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Normalize the number by stripping the rightmost trailing zeros and
converting any result equal to <code class="docutils literal notranslate"><span class="pre">Decimal('0')</span></code> to
<code class="docutils literal notranslate"><span class="pre">Decimal('0e0')</span></code>. Used for producing canonical values for attributes
of an equivalence class. For example, <code class="docutils literal notranslate"><span class="pre">Decimal('32.100')</span></code> and
<code class="docutils literal notranslate"><span class="pre">Decimal('0.321000e+2')</span></code> both normalize to the equivalent value
<code class="docutils literal notranslate"><span class="pre">Decimal('32.1')</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.number_class">
<span class="sig-name descname"><span class="pre">number_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.number_class" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una cadena de caracteres que describe la <em>class</em> del operando. El valor retornado es una de las siguientes diez cadenas de caracteres.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;-Infinity&quot;</span></code>, que indica que el operando es un infinito negativo.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;-Normal&quot;</span></code>, que indica que el operando es un número normal negativo.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;-Subnormal&quot;</span></code>, que indica que el operando es negativo y subnormal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;-Zero&quot;</span></code>, que indica que el operando es un cero negativo.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;+Zero&quot;</span></code>, que indica que el operando es un cero positivo.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;+Subnormal&quot;</span></code>,que indica que el operando es positivo y subnormal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;+Normal&quot;</span></code>, que indica que el operando es un número normal positivo.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;+Infinity&quot;</span></code>, que indica que el operando es un infinito positivo.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;NaN&quot;</span></code>, que indica que el operando es un NaN (no es un número) silencioso.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;sNaN&quot;</span></code>, que indica que el operando es un NaN (no es un número) señalizador.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.quantize">
<span class="sig-name descname"><span class="pre">quantize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rounding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.quantize" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un valor igual al primer operando después de ser redondeado y de asignarle el exponente del segundo operando.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.41421356&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.000&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;1.414&#39;)</span>
</pre></div>
</div>
<p>A diferencia de otras operaciones, se genera una señal <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> si la longitud del coeficiente después de la operación quantize es mayor que la precisión. Esto garantiza que, a menos que exista una condición de error, el exponente cuantificado sea siempre igual al del operando de la derecha.</p>
<p>Además, a diferencia de otras operaciones, quantize nunca genera una señal Underflow, incluso si el resultado es subnormal e inexacto.</p>
<p>Si el exponente del segundo operando es mayor que el del primero, puede ser necesario redondear. En este caso, el modo de redondeo está determinado por el argumento <code class="docutils literal notranslate"><span class="pre">rounding</span></code>, si se proporciona, o por el argumento <code class="docutils literal notranslate"><span class="pre">context</span></code> en caso contrario. Si no se proporciona ninguno de estos dos argumentos, se utiliza el modo de redondeo establecido en el contexto del hilo actual.</p>
<p>An error is returned whenever the resulting exponent is greater than
<code class="xref py py-attr docutils literal notranslate"><span class="pre">Emax</span></code> or less than <a class="reference internal" href="#decimal.Context.Etiny" title="decimal.Context.Etiny"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Etiny()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.radix">
<span class="sig-name descname"><span class="pre">radix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.radix" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">Decimal(10)</span></code>, que es la raíz (base) en la que la clase <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> hace toda su aritmética. Este método está incluido solo por compatibilidad con la especificación.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.remainder_near">
<span class="sig-name descname"><span class="pre">remainder_near</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.remainder_near" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el resto de dividir <em>self</em> entre <em>other</em>. Esto difiere de la operación <code class="docutils literal notranslate"><span class="pre">self%other</span></code>, en la que el signo del resto se elige para minimizar su valor absoluto. Más precisamente, el valor de retorno es <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">-</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">other</span></code>, donde <code class="docutils literal notranslate"><span class="pre">n</span></code> es el número entero más cercano al valor exacto de <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">/</span> <span class="pre">other</span></code>. Si dos enteros están igualmente cerca, entonces el valor par es el elegido.</p>
<p>Si el resultado es cero, entonces su signo será el signo de <em>self</em>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal(&#39;-2&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal(&#39;5&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">35</span><span class="p">)</span><span class="o">.</span><span class="n">remainder_near</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Decimal(&#39;-5&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.rotate">
<span class="sig-name descname"><span class="pre">rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.rotate" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el resultado de rotar los dígitos del primer operando en una cantidad especificada por el segundo operando. El segundo operando debe ser un número entero en el rango comprendido desde -precisión hasta precisión. El valor absoluto del segundo operando da el número de lugares a rotar. Si el segundo operando es positivo, la rotación es hacia la izquierda; de lo contrario, la rotación es hacia la derecha. El coeficiente del primer operando se rellena con ceros a la izquierda para satisfacer la precisión de longitud si es necesario. El signo y el exponente del primer operando no se modifican.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.same_quantum">
<span class="sig-name descname"><span class="pre">same_quantum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.same_quantum" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Test whether self and other have the same exponent or whether both are
<code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p>
<p>Esta operación no se ve afectada por el contexto y es silenciosa: no se cambian los flags y no se realiza ningún redondeo. Como excepción, la versión de C puede lanzar InvalidOperation si el segundo operando no se puede convertir exactamente.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.scaleb">
<span class="sig-name descname"><span class="pre">scaleb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.scaleb" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el primer operando con su exponente ajustado por el segundo. De manera equivalente, retorna el primer operando multiplicado por <code class="docutils literal notranslate"><span class="pre">10**other</span></code>. El segundo operando debe ser un número entero.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.shift">
<span class="sig-name descname"><span class="pre">shift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.shift" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el resultado de cambiar los dígitos del primer operando en una cantidad especificada por el segundo operando. El segundo operando debe ser un número entero en el rango comprendido desde -precisión hasta precisión. El valor absoluto del segundo operando da el número de lugares a desplazar. Si el segundo operando es positivo, el desplazamiento es hacia la izquierda; de lo contrario, el desplazamiento es hacia la derecha. Los dígitos desplazados en el coeficiente son ceros. El signo y el exponente del primer operando no se modifican.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.sqrt">
<span class="sig-name descname"><span class="pre">sqrt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.sqrt" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la raíz cuadrada del argumento con precisión total.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.to_eng_string">
<span class="sig-name descname"><span class="pre">to_eng_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_eng_string" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierte a una cadena de caracteres, usando notación de ingeniería si se necesita un exponente.</p>
<p>La notación de ingeniería tiene como exponente un múltiplo de 3. Esto puede dejar hasta 3 dígitos a la izquierda del punto decimal y puede requerir la adición de uno o dos ceros finales.</p>
<p>Por ejemplo, este método convierte <code class="docutils literal notranslate"><span class="pre">Decimal('123E+1')</span></code> en <code class="docutils literal notranslate"><span class="pre">Decimal('1.23E+3')</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.to_integral">
<span class="sig-name descname"><span class="pre">to_integral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rounding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_integral" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Idéntico al método <a class="reference internal" href="#decimal.Decimal.to_integral_value" title="decimal.Decimal.to_integral_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_integral_value()</span></code></a>. El nombre <code class="docutils literal notranslate"><span class="pre">to_integral</span></code> se ha mantenido por compatibilidad con versiones anteriores.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.to_integral_exact">
<span class="sig-name descname"><span class="pre">to_integral_exact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rounding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_integral_exact" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Redondea al entero más cercano, generando la señal <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a> o <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal notranslate"><span class="pre">Rounded</span></code></a>, según corresponda, si se produce un redondeo. El modo de redondeo está determinado por el parámetro <code class="docutils literal notranslate"><span class="pre">rounding</span></code> si es proporcionado, o por el establecido en el <code class="docutils literal notranslate"><span class="pre">context</span></code> proporcionado en caso contrario. Si no se proporciona ninguno de estos dos parámetros, se utiliza el modo de redondeo establecido en el contexto actual.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Decimal.to_integral_value">
<span class="sig-name descname"><span class="pre">to_integral_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rounding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Decimal.to_integral_value" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Redondea al entero más cercano sin generar la señal <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a> o <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal notranslate"><span class="pre">Rounded</span></code></a>. Si se proporciona, se aplica el método de redondeo especificado por <em>rounding</em>; en caso contrario, se utiliza el método de redondeo del <em>context</em> proporcionado o el del contexto actual.</p>
</dd></dl>

</dd></dl>

<section id="logical-operands">
<span id="logical-operands-label"></span><h3>Operandos lógicos<a class="headerlink" href="#logical-operands" title="Enlazar permanentemente con este título">¶</a></h3>
<p>The <a class="reference internal" href="#decimal.Decimal.logical_and" title="decimal.Decimal.logical_and"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_and()</span></code></a>, <a class="reference internal" href="#decimal.Decimal.logical_invert" title="decimal.Decimal.logical_invert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_invert()</span></code></a>, <a class="reference internal" href="#decimal.Decimal.logical_or" title="decimal.Decimal.logical_or"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_or()</span></code></a>,
and <a class="reference internal" href="#decimal.Decimal.logical_xor" title="decimal.Decimal.logical_xor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logical_xor()</span></code></a> methods expect their arguments to be <em>logical
operands</em>.  A <em>logical operand</em> is a <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> instance whose
exponent and sign are both zero, and whose digits are all either
<code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</section>
</section>
<section id="context-objects">
<span id="decimal-context"></span><h2>Objetos context<a class="headerlink" href="#context-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los contextos son entornos para operaciones aritméticas. Gobiernan la precisión, establecen reglas para el redondeo, determinan qué señales se tratan como excepciones y limitan el rango para los exponentes.</p>
<p>Cada hilo tiene su propio contexto actual, al que se accede o se reemplaza usando las funciones <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> y <a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">setcontext()</span></code></a> respectivamente:</p>
<dl class="py function">
<dt class="sig sig-object py" id="decimal.getcontext">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">getcontext</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.getcontext" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el contexto actual del hilo activo.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="decimal.setcontext">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">setcontext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.setcontext" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece <em>c</em> como contexto actual para el hilo activo.</p>
</dd></dl>

<p>También puedes usar la declaración <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> y la función <a class="reference internal" href="#decimal.localcontext" title="decimal.localcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">localcontext()</span></code></a> para cambiar temporalmente el contexto activo.</p>
<dl class="py function">
<dt class="sig sig-object py" id="decimal.localcontext">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">localcontext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">\*\*kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.localcontext" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Return a context manager that will set the current context for the active thread
to a copy of <em>ctx</em> on entry to the with-statement and restore the previous context
when exiting the with-statement. If no context is specified, a copy of the
current context is used.  The <em>kwargs</em> argument is used to set the attributes
of the new context.</p>
<p>Por ejemplo, el siguiente código establece la precisión decimal actual en 42 lugares, realiza un cálculo y luego restaura automáticamente el contexto anterior:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">localcontext</span>

<span class="k">with</span> <span class="n">localcontext</span><span class="p">()</span> <span class="k">as</span> <span class="n">ctx</span><span class="p">:</span>
    <span class="n">ctx</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">42</span>   <span class="c1"># Perform a high precision calculation</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">calculate_something</span><span class="p">()</span>
<span class="n">s</span> <span class="o">=</span> <span class="o">+</span><span class="n">s</span>  <span class="c1"># Round the final result back to the default precision</span>
</pre></div>
</div>
<p>Usando argumentos de palabra clave, el código sería el siguiente:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">localcontext</span>

<span class="k">with</span> <span class="n">localcontext</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span> <span class="k">as</span> <span class="n">ctx</span><span class="p">:</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">calculate_something</span><span class="p">()</span>
<span class="n">s</span> <span class="o">=</span> <span class="o">+</span><span class="n">s</span>
</pre></div>
</div>
<p>Lanza <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> si <em>kwargs</em> proporciona un atributo que <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> no soporta. Lanza también <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> o <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> si <em>kwargs</em> proporciona un valor no válido para un atributo.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span><a class="reference internal" href="#decimal.localcontext" title="decimal.localcontext"><code class="xref py py-meth docutils literal notranslate"><span class="pre">localcontext()</span></code></a> ahora admite la configuración de atributos de contexto mediante el uso de argumentos de palabra clave.</p>
</div>
</dd></dl>

<p>También se pueden crear nuevos contextos utilizando el constructor de la clase <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> que se describe a continuación. Además, el módulo proporciona tres contextos prediseñados:</p>
<dl class="py class">
<dt class="sig sig-object py" id="decimal.BasicContext">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">BasicContext</span></span><a class="headerlink" href="#decimal.BasicContext" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este es un contexto estándar definido por la Especificación general de la aritmética decimal. La precisión se establece en nueve. El redondeo se establece en <a class="reference internal" href="#decimal.ROUND_HALF_UP" title="decimal.ROUND_HALF_UP"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_UP</span></code></a>. Se restablecen todos los flags. Todas las trampas están habilitadas (las señales son tratadas como excepciones) excepto <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a>, <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-const docutils literal notranslate"><span class="pre">Rounded</span></code></a> y <a class="reference internal" href="#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-const docutils literal notranslate"><span class="pre">Subnormal</span></code></a>.</p>
<p>Debido a que la mayoría de las trampas están habilitadas, este contexto es especialmente útil para la depuración.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.ExtendedContext">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ExtendedContext</span></span><a class="headerlink" href="#decimal.ExtendedContext" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este es un contexto estándar definido por la Especificación general de la aritmética decimal. La precisión se establece en nueve. El redondeo se establece en <a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a>. Se restablecen todos los flags. No se habilitan trampas (para que no se generen excepciones durante los cálculos).</p>
<p>Because the traps are disabled, this context is useful for applications that
prefer to have result value of <code class="docutils literal notranslate"><span class="pre">NaN</span></code> or <code class="docutils literal notranslate"><span class="pre">Infinity</span></code> instead of
raising exceptions.  This allows an application to complete a run in the
presence of conditions that would otherwise halt the program.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.DefaultContext">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">DefaultContext</span></span><a class="headerlink" href="#decimal.DefaultContext" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este contexto es utilizado por el constructor de la clase <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> como un prototipo para nuevos contextos. Cambiar un campo (como la precisión) tiene el efecto de cambiar el valor predeterminado para los nuevos contextos creados por el constructor de <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a>.</p>
<p>Este contexto es más útil en entornos con múltiples hilos. Cambiar uno de los campos antes de que se inicien los hilos tiene el efecto de establecer valores predeterminados en todo el sistema. No se recomienda cambiar los campos después de que se hayan iniciado los hilos, ya que requeriría el uso de mecanismos de sincronización para evitar condiciones de carrera entre los hilos.</p>
<p>En entornos de un solo hilo, es preferible no utilizar este contexto en absoluto. En su lugar, simplemente crea contextos explícitamente como se describe a continuación.</p>
<p>The default values are <code class="xref py py-attr docutils literal notranslate"><span class="pre">Context.prec</span></code>=<code class="docutils literal notranslate"><span class="pre">28</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">Context.rounding</span></code>=<a class="reference internal" href="#decimal.ROUND_HALF_EVEN" title="decimal.ROUND_HALF_EVEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code></a>,
and enabled traps for <a class="reference internal" href="#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-class docutils literal notranslate"><span class="pre">Overflow</span></code></a>, <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a>, and
<a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-class docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a>.</p>
</dd></dl>

<p>Además de los tres contextos proporcionados, se pueden crear nuevos contextos mediante el constructor de la clase <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="decimal.Context">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rounding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Emin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Emax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">capitals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un nuevo contexto. Si no se especifica un campo, o es <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>, los valores predeterminados se copian de <a class="reference internal" href="#decimal.DefaultContext" title="decimal.DefaultContext"><code class="xref py py-const docutils literal notranslate"><span class="pre">DefaultContext</span></code></a>. Si el campo <em>flags</em> no está especificado, o es <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>, se restablecen todas los flags.</p>
<p><em>prec</em> is an integer in the range [<code class="docutils literal notranslate"><span class="pre">1</span></code>, <a class="reference internal" href="#decimal.MAX_PREC" title="decimal.MAX_PREC"><code class="xref py py-const docutils literal notranslate"><span class="pre">MAX_PREC</span></code></a>] that sets
the precision for arithmetic operations in the context.</p>
<p>La opción <em>rounding</em> es una de las constantes enumeradas en la sección <a class="reference internal" href="#rounding-modes">Rounding Modes</a>.</p>
<p>Los campos <em>traps</em> y <em>flags</em> enumeran las señales que se deben establecer. Generalmente, los nuevos contextos solo deben establecer trampas y dejar los flags sin establecer.</p>
<p>The <em>Emin</em> and <em>Emax</em> fields are integers specifying the outer limits allowable
for exponents. <em>Emin</em> must be in the range [<a class="reference internal" href="#decimal.MIN_EMIN" title="decimal.MIN_EMIN"><code class="xref py py-const docutils literal notranslate"><span class="pre">MIN_EMIN</span></code></a>, <code class="docutils literal notranslate"><span class="pre">0</span></code>],
<em>Emax</em> in the range [<code class="docutils literal notranslate"><span class="pre">0</span></code>, <a class="reference internal" href="#decimal.MAX_EMAX" title="decimal.MAX_EMAX"><code class="xref py py-const docutils literal notranslate"><span class="pre">MAX_EMAX</span></code></a>].</p>
<p>The <em>capitals</em> field is either <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">1</span></code> (the default). If set to
<code class="docutils literal notranslate"><span class="pre">1</span></code>, exponents are printed with a capital <code class="docutils literal notranslate"><span class="pre">E</span></code>; otherwise, a
lowercase <code class="docutils literal notranslate"><span class="pre">e</span></code> is used: <code class="docutils literal notranslate"><span class="pre">Decimal('6.02e+23')</span></code>.</p>
<p>The <em>clamp</em> field is either <code class="docutils literal notranslate"><span class="pre">0</span></code> (the default) or <code class="docutils literal notranslate"><span class="pre">1</span></code>.
If set to <code class="docutils literal notranslate"><span class="pre">1</span></code>, the exponent <code class="docutils literal notranslate"><span class="pre">e</span></code> of a <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>
instance representable in this context is strictly limited to the
range <code class="docutils literal notranslate"><span class="pre">Emin</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">e</span> <span class="pre">&lt;=</span> <span class="pre">Emax</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code>.  If <em>clamp</em> is
<code class="docutils literal notranslate"><span class="pre">0</span></code> then a weaker condition holds: the adjusted exponent of
the <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> instance is at most <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emax</span></code>.  When <em>clamp</em> is
<code class="docutils literal notranslate"><span class="pre">1</span></code>, a large normal number will, where possible, have its
exponent reduced and a corresponding number of zeros added to its
coefficient, in order to fit the exponent constraints; this
preserves the value of the number but loses information about
significant trailing zeros.  For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span> <span class="n">clamp</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">create_decimal</span><span class="p">(</span><span class="s1">&#39;1.23e999&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.23000E+999&#39;)</span>
</pre></div>
</div>
<p>A <em>clamp</em> value of <code class="docutils literal notranslate"><span class="pre">1</span></code> allows compatibility with the
fixed-width decimal interchange formats specified in IEEE 754.</p>
<p>The <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> class defines several general purpose methods as well as
a large number of methods for doing arithmetic directly in a given context.
In addition, for each of the <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> methods described above (with
the exception of the <a class="reference internal" href="#decimal.Decimal.adjusted" title="decimal.Decimal.adjusted"><code class="xref py py-meth docutils literal notranslate"><span class="pre">adjusted()</span></code></a> and <a class="reference internal" href="#decimal.Decimal.as_tuple" title="decimal.Decimal.as_tuple"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_tuple()</span></code></a> methods) there is
a corresponding <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> method.  For example, for a <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a>
instance <code class="docutils literal notranslate"><span class="pre">C</span></code> and <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> instance <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">C.exp(x)</span></code> is
equivalent to <code class="docutils literal notranslate"><span class="pre">x.exp(context=C)</span></code>.  Each <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> method accepts a
Python integer (an instance of <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) anywhere that a
Decimal instance is accepted.</p>
<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.clear_flags">
<span class="sig-name descname"><span class="pre">clear_flags</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.clear_flags" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Resets all of the flags to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.clear_traps">
<span class="sig-name descname"><span class="pre">clear_traps</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.clear_traps" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Resets all of the traps to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un duplicado del contexto.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.copy_decimal">
<span class="sig-name descname"><span class="pre">copy_decimal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_decimal" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de la instancia de Decimal num.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.create_decimal">
<span class="sig-name descname"><span class="pre">create_decimal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.create_decimal" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea una nueva instancia de Decimal a partir de <em>num</em> pero usando <em>self</em> como contexto. A diferencia del constructor de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>, la precisión del contexto, el método de redondeo, los flags y las trampas se aplican a la conversión.</p>
<p>Esto es útil porque las constantes a menudo se proporcionan con una precisión mayor que la que necesita la aplicación. Otro beneficio es que el redondeo elimina inmediatamente los efectos no deseados de los dígitos más allá de la precisión actual. En el siguiente ejemplo, usar entradas no redondeadas significa que agregar cero a una suma puede cambiar el resultado:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.4445&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.0023&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;4.45&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.4445&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.0023&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;4.44&#39;)</span>
</pre></div>
</div>
<p>Este método implementa la operación to-number de la especificación de IBM. Si el argumento es una cadena de caracteres, no se permiten espacios en blanco ni guiones bajos, ni al principio ni al final.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.create_decimal_from_float">
<span class="sig-name descname"><span class="pre">create_decimal_from_float</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.create_decimal_from_float" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea una nueva instancia de Decimal a partir de un flotante <em>f</em>, pero redondeando usando <em>self</em> como contexto. A diferencia del método de clase <a class="reference internal" href="#decimal.Decimal.from_float" title="decimal.Decimal.from_float"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Decimal.from_float()</span></code></a>, la precisión del contexto, el método de redondeo, los flags y las trampas se aplican a la conversión.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">create_decimal_from_float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.1415&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">create_decimal_from_float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">decimal.Inexact</span>: <span class="n">None</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.Etiny">
<span class="sig-name descname"><span class="pre">Etiny</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.Etiny" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un valor igual a <code class="docutils literal notranslate"><span class="pre">Emin</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code> que es el valor mínimo del exponente para resultados subnormales. Cuando ocurre un desbordamiento numérico negativo («underflow»), el exponente se establece en <a class="reference internal" href="#decimal.Context.Etiny" title="decimal.Context.Etiny"><code class="xref py py-const docutils literal notranslate"><span class="pre">Etiny</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.Etop">
<span class="sig-name descname"><span class="pre">Etop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.Etop" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un valor igual a <code class="docutils literal notranslate"><span class="pre">Emax</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
</dd></dl>

<p>El enfoque habitual para trabajar con decimales es crear instancias de la clase <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> y luego aplicar operaciones aritméticas que tienen lugar dentro del contexto actual para el hilo activo. Un enfoque alternativo es utilizar métodos de contexto para calcular dentro de un contexto específico. Los métodos son similares a los de la clase <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> y aquí solo se relatan brevemente.</p>
<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.abs">
<span class="sig-name descname"><span class="pre">abs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.abs" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el valor absoluto de <em>x</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.add" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la suma de <em>x</em> e <em>y</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.canonical">
<span class="sig-name descname"><span class="pre">canonical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.canonical" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el mismo objeto Decimal <em>x</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.compare">
<span class="sig-name descname"><span class="pre">compare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Compara <em>x</em> e <em>y</em> numéricamente.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.compare_signal">
<span class="sig-name descname"><span class="pre">compare_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare_signal" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Compara los valores de los dos operandos numéricamente.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.compare_total">
<span class="sig-name descname"><span class="pre">compare_total</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare_total" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Compara los dos operandos utilizando su representación abstracta.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.compare_total_mag">
<span class="sig-name descname"><span class="pre">compare_total_mag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare_total_mag" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Compara los dos operandos utilizando su representación abstracta, ignorando el signo.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.copy_abs">
<span class="sig-name descname"><span class="pre">copy_abs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_abs" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de <em>x</em> con el signo establecido en 0.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.copy_negate">
<span class="sig-name descname"><span class="pre">copy_negate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_negate" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de <em>x</em> con el signo invertido.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.copy_sign">
<span class="sig-name descname"><span class="pre">copy_sign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_sign" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Copia el signo de <em>y</em> en <em>x</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.divide">
<span class="sig-name descname"><span class="pre">divide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.divide" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <em>x</em> dividido entre <em>y</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.divide_int">
<span class="sig-name descname"><span class="pre">divide_int</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.divide_int" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <em>x</em> dividido entre <em>y</em>, truncando el resultado a un número entero.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.divmod">
<span class="sig-name descname"><span class="pre">divmod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.divmod" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Divide dos números y retorna la parte entera del resultado.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.exp" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">**</span> <span class="pre">x</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.fma">
<span class="sig-name descname"><span class="pre">fma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.fma" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <em>x</em> multiplicado por <em>y</em>, más <em>z</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_canonical">
<span class="sig-name descname"><span class="pre">is_canonical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_canonical" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si <em>x</em> está en forma canónica, en caso contrario retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_finite">
<span class="sig-name descname"><span class="pre">is_finite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_finite" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si <em>x</em> es un valor finito, en caso contrario retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_infinite">
<span class="sig-name descname"><span class="pre">is_infinite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_infinite" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si <em>x</em> es un valor infinito, en caso contrario retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_nan">
<span class="sig-name descname"><span class="pre">is_nan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_nan" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si <em>x</em> es un valor qNaN o sNaN , en caso contrario retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_normal">
<span class="sig-name descname"><span class="pre">is_normal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_normal" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si <em>x</em> es un número normal, en caso contrario retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_qnan">
<span class="sig-name descname"><span class="pre">is_qnan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_qnan" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si <em>x</em> es un NaN silencioso, en caso contrario retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_signed">
<span class="sig-name descname"><span class="pre">is_signed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_signed" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si <em>x</em> es un valor negativo, en caso contrario retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_snan">
<span class="sig-name descname"><span class="pre">is_snan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_snan" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si <em>x</em> es un NaN señalizador, en caso contrario retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_subnormal">
<span class="sig-name descname"><span class="pre">is_subnormal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_subnormal" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si <em>x</em> es un número subnormal, en caso contrario retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.is_zero">
<span class="sig-name descname"><span class="pre">is_zero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_zero" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si <em>x</em> es un cero, en caso contrario retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.ln">
<span class="sig-name descname"><span class="pre">ln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.ln" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el logaritmo natural (base e) de <em>x</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.log10">
<span class="sig-name descname"><span class="pre">log10</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.log10" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el logaritmo en base 10 de <em>x</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.logb">
<span class="sig-name descname"><span class="pre">logb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logb" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el exponente de la magnitud del MSD («dígito más significativo») del operando.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.logical_and">
<span class="sig-name descname"><span class="pre">logical_and</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_and" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Aplica la operación lógica <em>and</em> entre los dígitos de cada operando.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.logical_invert">
<span class="sig-name descname"><span class="pre">logical_invert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_invert" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Invierte todos los dígitos en <em>x</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.logical_or">
<span class="sig-name descname"><span class="pre">logical_or</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_or" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Aplica la operación lógica <em>or</em> entre los dígitos de cada operando.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.logical_xor">
<span class="sig-name descname"><span class="pre">logical_xor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_xor" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Aplica la operación lógica <em>xor</em> entre los dígitos de cada operando.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.max">
<span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.max" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Compara dos valores numéricamente y retorna el mayor de ellos.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.max_mag">
<span class="sig-name descname"><span class="pre">max_mag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.max_mag" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Compara los valores numéricamente ignorando sus signos.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.min">
<span class="sig-name descname"><span class="pre">min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.min" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Compara dos valores numéricamente y retorna el menor de ellos.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.min_mag">
<span class="sig-name descname"><span class="pre">min_mag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.min_mag" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Compara los valores numéricamente ignorando sus signos.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.minus">
<span class="sig-name descname"><span class="pre">minus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.minus" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Se corresponde con el operador unario de resta (prefijo) de Python.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.multiply">
<span class="sig-name descname"><span class="pre">multiply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.multiply" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el producto de <em>x</em> por <em>y</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.next_minus">
<span class="sig-name descname"><span class="pre">next_minus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.next_minus" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el número más grande representable menor que <em>x</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.next_plus">
<span class="sig-name descname"><span class="pre">next_plus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.next_plus" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el número más pequeño representable mayor que <em>x</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.next_toward">
<span class="sig-name descname"><span class="pre">next_toward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.next_toward" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el número más cercano a <em>x</em>, en la dirección de <em>y</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.normalize">
<span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.normalize" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Reduce <em>x</em> a su forma más simple.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.number_class">
<span class="sig-name descname"><span class="pre">number_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.number_class" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una cadena de caracteres indicando la clase de <em>x</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.plus">
<span class="sig-name descname"><span class="pre">plus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.plus" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Se corresponde con el operador unario de suma (prefijo) de Python. Esta operación aplica la precisión y el redondeo establecidos en el contexto, por lo que <em>no</em> es una operación de identidad.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.power">
<span class="sig-name descname"><span class="pre">power</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modulo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.power" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">x</span></code> elevado a la potencia <code class="docutils literal notranslate"><span class="pre">y</span></code>, reconduciendo al módulo <code class="docutils literal notranslate"><span class="pre">modulo</span></code> si se proporciona.</p>
<p>With two arguments, compute <code class="docutils literal notranslate"><span class="pre">x**y</span></code>.  If <code class="docutils literal notranslate"><span class="pre">x</span></code> is negative then <code class="docutils literal notranslate"><span class="pre">y</span></code>
must be integral.  The result will be inexact unless <code class="docutils literal notranslate"><span class="pre">y</span></code> is integral and
the result is finite and can be expressed exactly in “precision” digits.
The rounding mode of the context is used. Results are always correctly rounded
in the Python version.</p>
<p><code class="docutils literal notranslate"><span class="pre">Decimal(0)</span> <span class="pre">**</span> <span class="pre">Decimal(0)</span></code> da como resultado <code class="docutils literal notranslate"><span class="pre">InvalidOperation</span></code>, y si <code class="docutils literal notranslate"><span class="pre">InvalidOperation</span></code> no es atrapada, entonces da como resultado <code class="docutils literal notranslate"><span class="pre">Decimal('NaN')</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>The C module computes <a class="reference internal" href="#decimal.Context.power" title="decimal.Context.power"><code class="xref py py-meth docutils literal notranslate"><span class="pre">power()</span></code></a> in terms of the correctly rounded
<a class="reference internal" href="#decimal.Context.exp" title="decimal.Context.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a> and <a class="reference internal" href="#decimal.Context.ln" title="decimal.Context.ln"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ln()</span></code></a> functions. The result is well-defined but
only «almost always correctly rounded».</p>
</div>
<p>Con tres argumentos, calcula <code class="docutils literal notranslate"><span class="pre">(x**y)</span> <span class="pre">%</span> <span class="pre">modulo</span></code>. Para la forma de tres argumentos, se mantienen las siguientes restricciones sobre los argumentos:</p>
<blockquote>
<div><ul class="simple">
<li><p>los tres argumentos deben ser enteros</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code> debe ser un valor no negativo</p></li>
<li><p>al menos uno, <code class="docutils literal notranslate"><span class="pre">x</span></code> o <code class="docutils literal notranslate"><span class="pre">y</span></code> , no debe ser cero</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">modulo</span></code> no debe ser cero y tener como mínimo los dígitos de la “precisión”</p></li>
</ul>
</div></blockquote>
<p>El valor resultante de <code class="docutils literal notranslate"><span class="pre">Context.power(x,</span> <span class="pre">y,</span> <span class="pre">modulo)</span></code> es igual al valor que se obtendría calculando <code class="docutils literal notranslate"><span class="pre">(x**y)</span> <span class="pre">%</span> <span class="pre">modulo</span></code> con precisión ilimitada, la diferencia es que se calcula de manera más eficiente . El exponente del resultado es cero, independientemente de los exponentes de <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> y  <code class="docutils literal notranslate"><span class="pre">modulo</span></code>. El resultado siempre es exacto.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.quantize">
<span class="sig-name descname"><span class="pre">quantize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.quantize" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un valor igual a <em>x</em> (redondeado), pero que tiene el exponente de <em>y</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.radix">
<span class="sig-name descname"><span class="pre">radix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.radix" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Simplemente retorna 10, ya que es Decimal, :)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.remainder">
<span class="sig-name descname"><span class="pre">remainder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.remainder" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el resto de la división entera.</p>
<p>El signo del resultado, si no es cero, es el mismo que el del dividendo original.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.remainder_near">
<span class="sig-name descname"><span class="pre">remainder_near</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.remainder_near" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span> <span class="pre">*</span> <span class="pre">n</span></code>, donde <em>n</em> es el número entero más cercano al valor exacto de <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code> (si el resultado es 0, entonces su signo será el signo de <em>x</em>).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.rotate">
<span class="sig-name descname"><span class="pre">rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.rotate" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de <em>x</em> rotada <em>y</em> veces.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.same_quantum">
<span class="sig-name descname"><span class="pre">same_quantum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.same_quantum" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si los dos operandos tienen el mismo exponente.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.scaleb">
<span class="sig-name descname"><span class="pre">scaleb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.scaleb" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el primer operando después de agregar el segundo valor a su exponente.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.shift">
<span class="sig-name descname"><span class="pre">shift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.shift" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de <em>x</em> desplazada <em>y</em> veces.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.sqrt">
<span class="sig-name descname"><span class="pre">sqrt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.sqrt" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la raíz cuadrada de un número no negativo para la precisión del contexto.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.subtract">
<span class="sig-name descname"><span class="pre">subtract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.subtract" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la diferencia entre <em>x</em> e <em>y</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.to_eng_string">
<span class="sig-name descname"><span class="pre">to_eng_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.to_eng_string" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierte a una cadena de caracteres, usando notación de ingeniería si se necesita un exponente.</p>
<p>La notación de ingeniería tiene como exponente un múltiplo de 3. Esto puede dejar hasta 3 dígitos a la izquierda del punto decimal y puede requerir la adición de uno o dos ceros finales.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.to_integral_exact">
<span class="sig-name descname"><span class="pre">to_integral_exact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.to_integral_exact" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Redondea a un entero.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="decimal.Context.to_sci_string">
<span class="sig-name descname"><span class="pre">to_sci_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.to_sci_string" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierte un número en una cadena de caracteres usando notación científica.</p>
</dd></dl>

</dd></dl>

</section>
<section id="constants">
<span id="decimal-rounding-modes"></span><h2>Constantes<a class="headerlink" href="#constants" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las constantes detalladas en esta sección solo son relevantes para el módulo de C. Se incluyen también en la versión pura de Python por compatibilidad.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%" />
<col style="width: 29%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>32-bit</p></th>
<th class="head"><p>64-bit</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="py data">
<dt class="sig sig-object py" id="decimal.MAX_PREC">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">MAX_PREC</span></span><a class="headerlink" href="#decimal.MAX_PREC" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

</td>
<td><p><code class="docutils literal notranslate"><span class="pre">425000000</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">999999999999999999</span></code></p></td>
</tr>
<tr class="row-odd"><td><dl class="py data">
<dt class="sig sig-object py" id="decimal.MAX_EMAX">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">MAX_EMAX</span></span><a class="headerlink" href="#decimal.MAX_EMAX" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

</td>
<td><p><code class="docutils literal notranslate"><span class="pre">425000000</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">999999999999999999</span></code></p></td>
</tr>
<tr class="row-even"><td><dl class="py data">
<dt class="sig sig-object py" id="decimal.MIN_EMIN">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">MIN_EMIN</span></span><a class="headerlink" href="#decimal.MIN_EMIN" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

</td>
<td><p><code class="docutils literal notranslate"><span class="pre">-425000000</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-999999999999999999</span></code></p></td>
</tr>
<tr class="row-odd"><td><dl class="py data">
<dt class="sig sig-object py" id="decimal.MIN_ETINY">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">MIN_ETINY</span></span><a class="headerlink" href="#decimal.MIN_ETINY" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

</td>
<td><p><code class="docutils literal notranslate"><span class="pre">-849999999</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-1999999999999999997</span></code></p></td>
</tr>
</tbody>
</table>
<dl class="py data">
<dt class="sig sig-object py" id="decimal.HAVE_THREADS">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">HAVE_THREADS</span></span><a class="headerlink" href="#decimal.HAVE_THREADS" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El valor es <code class="docutils literal notranslate"><span class="pre">True</span></code>. Está obsoleta, debido ha que Python ahora siempre tiene soporte para hilos.</p>
</dd></dl>

<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9.</span></p>
</div>
<dl class="py data">
<dt class="sig sig-object py" id="decimal.HAVE_CONTEXTVAR">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">HAVE_CONTEXTVAR</span></span><a class="headerlink" href="#decimal.HAVE_CONTEXTVAR" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El valor predeterminado es <code class="docutils literal notranslate"><span class="pre">True</span></code>. Si Python se <a class="reference internal" href="../using/configure.html#cmdoption-without-decimal-contextvar"><code class="xref std std-option docutils literal notranslate"><span class="pre">configura</span> <span class="pre">usando</span> <span class="pre">--without-decimal-contextvar</span></code></a>, la versión de C usa un contexto de hilos-locales en lugar de un contexto de corrutinas-locales y el valor de la constante es <code class="docutils literal notranslate"><span class="pre">False</span></code>. Esto es algo más rápido en algunos escenarios de contexto anidado.</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9: </span>retro-portado a las versiones 3.7 y 3.8.</p>
</div>
</section>
<section id="rounding-modes">
<h2>Modos de redondeo<a class="headerlink" href="#rounding-modes" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_CEILING">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_CEILING</span></span><a class="headerlink" href="#decimal.ROUND_CEILING" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Round towards <code class="docutils literal notranslate"><span class="pre">Infinity</span></code>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_DOWN">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_DOWN</span></span><a class="headerlink" href="#decimal.ROUND_DOWN" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Redondear hacia cero.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_FLOOR">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_FLOOR</span></span><a class="headerlink" href="#decimal.ROUND_FLOOR" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Round towards <code class="docutils literal notranslate"><span class="pre">-Infinity</span></code>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_HALF_DOWN">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_HALF_DOWN</span></span><a class="headerlink" href="#decimal.ROUND_HALF_DOWN" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Redondear al valor contiguo más cercano, con empates hacia cero.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_HALF_EVEN">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_HALF_EVEN</span></span><a class="headerlink" href="#decimal.ROUND_HALF_EVEN" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Redondear al valor contiguo más cercano, con empates al entero par contiguo.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_HALF_UP">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_HALF_UP</span></span><a class="headerlink" href="#decimal.ROUND_HALF_UP" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Redondear al valor contiguo más cercano, con empates alejándose de cero.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_UP">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_UP</span></span><a class="headerlink" href="#decimal.ROUND_UP" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Redondear alejándose de cero.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="decimal.ROUND_05UP">
<span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">ROUND_05UP</span></span><a class="headerlink" href="#decimal.ROUND_05UP" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si el último dígito después de redondear hacia cero es 0 ó 5, redondear alejándose de cero, en caso contrario, redondear hacia cero.</p>
</dd></dl>

</section>
<section id="signals">
<span id="decimal-signals"></span><h2>Señales<a class="headerlink" href="#signals" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las señales representan condiciones que surgen durante el cálculo. Cada una se corresponde con un solo flag de contexto y un habilitador de trampas de contexto.</p>
<p>El flag de contexto se establece siempre que se encuentra la condición. Después del cálculo, los flags pueden comprobarse con fines informativos (por ejemplo, para determinar si un cálculo fue exacto). Después de verificar los flags, asegúrate de borrarlos antes de comenzar con el siguiente cálculo.</p>
<p>Si el habilitador de trampas del contexto está configurado para la señal, entonces la condición hace que se lance una excepción de Python. Por ejemplo, si se establece la trampa <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-class docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a>, se genera una excepción <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a> al encontrar la condición.</p>
<dl class="py class">
<dt class="sig sig-object py" id="decimal.Clamped">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Clamped</span></span><a class="headerlink" href="#decimal.Clamped" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Cambia un exponente para ajustar las restricciones de representación.</p>
<p>Typically, clamping occurs when an exponent falls outside the context’s
<code class="xref py py-attr docutils literal notranslate"><span class="pre">Emin</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emax</span></code> limits.  If possible, the exponent is reduced to
fit by adding zeros to the coefficient.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.DecimalException">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">DecimalException</span></span><a class="headerlink" href="#decimal.DecimalException" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Clase base para otras señales. Es una subclase de <a class="reference internal" href="exceptions.html#ArithmeticError" title="ArithmeticError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.DivisionByZero">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">DivisionByZero</span></span><a class="headerlink" href="#decimal.DivisionByZero" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Señala la división de un número no infinito entre cero.</p>
<p>Can occur with division, modulo division, or when raising a number to a negative
power.  If this signal is not trapped, returns <code class="docutils literal notranslate"><span class="pre">Infinity</span></code> or
<code class="docutils literal notranslate"><span class="pre">-Infinity</span></code> with the sign determined by the inputs to the calculation.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.Inexact">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Inexact</span></span><a class="headerlink" href="#decimal.Inexact" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Indica que se produjo un redondeo y el resultado no es exacto.</p>
<p>Señala que se descartaron dígitos distintos de cero durante el redondeo. Se retorna el resultado redondeado. El flag o la trampa de señal se utiliza para detectar cuando los resultados son inexactos.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.InvalidOperation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">InvalidOperation</span></span><a class="headerlink" href="#decimal.InvalidOperation" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Señala que se realizó una operación no válida.</p>
<p>Indicates that an operation was requested that does not make sense. If not
trapped, returns <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.  Possible causes include:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Infinity</span> <span class="o">-</span> <span class="n">Infinity</span>
<span class="mi">0</span> <span class="o">*</span> <span class="n">Infinity</span>
<span class="n">Infinity</span> <span class="o">/</span> <span class="n">Infinity</span>
<span class="n">x</span> <span class="o">%</span> <span class="mi">0</span>
<span class="n">Infinity</span> <span class="o">%</span> <span class="n">x</span>
<span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="mi">0</span> <span class="o">**</span> <span class="mi">0</span>
<span class="n">x</span> <span class="o">**</span> <span class="p">(</span><span class="n">non</span><span class="o">-</span><span class="n">integer</span><span class="p">)</span>
<span class="n">x</span> <span class="o">**</span> <span class="n">Infinity</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.Overflow">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Overflow</span></span><a class="headerlink" href="#decimal.Overflow" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Desbordamiento numérico.</p>
<p>Indicates the exponent is larger than <code class="xref py py-attr docutils literal notranslate"><span class="pre">Context.Emax</span></code> after rounding has
occurred.  If not trapped, the result depends on the rounding mode, either
pulling inward to the largest representable finite number or rounding outward
to <code class="docutils literal notranslate"><span class="pre">Infinity</span></code>.  In either case, <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-class docutils literal notranslate"><span class="pre">Inexact</span></code></a> and <a class="reference internal" href="#decimal.Rounded" title="decimal.Rounded"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rounded</span></code></a>
are also signaled.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.Rounded">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Rounded</span></span><a class="headerlink" href="#decimal.Rounded" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Se produjo un redondeo, aunque posiblemente no hubo pérdida de información.</p>
<p>Signaled whenever rounding discards digits; even if those digits are zero
(such as rounding <code class="docutils literal notranslate"><span class="pre">5.00</span></code> to <code class="docutils literal notranslate"><span class="pre">5.0</span></code>).  If not trapped, returns
the result unchanged.  This signal is used to detect loss of significant
digits.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.Subnormal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Subnormal</span></span><a class="headerlink" href="#decimal.Subnormal" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Exponent was lower than <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emin</span></code> prior to rounding.</p>
<p>Ocurre cuando el resultado de una operación es subnormal (el exponente es demasiado pequeño). Si no está atrapada, se retorna el resultado sin cambios.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.Underflow">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">Underflow</span></span><a class="headerlink" href="#decimal.Underflow" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Desbordamiento numérico negativo con resultado redondeado a cero.</p>
<p>Ocurre cuando un resultado subnormal se lleva a cero mediante redondeo. <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-class docutils literal notranslate"><span class="pre">Inexact</span></code></a> y <a class="reference internal" href="#decimal.Subnormal" title="decimal.Subnormal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subnormal</span></code></a> también se señalan.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="decimal.FloatOperation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">decimal.</span></span><span class="sig-name descname"><span class="pre">FloatOperation</span></span><a class="headerlink" href="#decimal.FloatOperation" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Habilita una semántica más estricta para mezclar flotantes y objetos Decimal.</p>
<p>Si la señal no está atrapada (predeterminado), se permite mezclar flotantes y objetos Decimal en el constructor de <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>, en el método <a class="reference internal" href="#decimal.Context.create_decimal" title="decimal.Context.create_decimal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_decimal()</span></code></a> y en todos los operadores de comparación. Tanto la conversión como las comparaciones son exactas. Cualquier ocurrencia de una operación mixta se registra silenciosamente estableciendo <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FloatOperation</span></code></a> a los flags del contexto. Las conversiones explícitas usando <a class="reference internal" href="#decimal.Decimal.from_float" title="decimal.Decimal.from_float"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_float()</span></code></a> o <a class="reference internal" href="#decimal.Context.create_decimal_from_float" title="decimal.Context.create_decimal_from_float"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_decimal_from_float()</span></code></a> no establecen el flag.</p>
<p>En caso contrario (la señal está atrapada), solo las comparaciones de igualdad y las conversiones explícitas permanecen silenciadas. Todas las demás operaciones mixtas lanzan una excepción <a class="reference internal" href="#decimal.FloatOperation" title="decimal.FloatOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FloatOperation</span></code></a>.</p>
</dd></dl>

<p>La siguiente tabla resume la jerarquía de señales:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">exceptions</span><span class="o">.</span><span class="n">ArithmeticError</span><span class="p">(</span><span class="n">exceptions</span><span class="o">.</span><span class="n">Exception</span><span class="p">)</span>
    <span class="n">DecimalException</span>
        <span class="n">Clamped</span>
        <span class="n">DivisionByZero</span><span class="p">(</span><span class="n">DecimalException</span><span class="p">,</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ZeroDivisionError</span><span class="p">)</span>
        <span class="n">Inexact</span>
            <span class="n">Overflow</span><span class="p">(</span><span class="n">Inexact</span><span class="p">,</span> <span class="n">Rounded</span><span class="p">)</span>
            <span class="n">Underflow</span><span class="p">(</span><span class="n">Inexact</span><span class="p">,</span> <span class="n">Rounded</span><span class="p">,</span> <span class="n">Subnormal</span><span class="p">)</span>
        <span class="n">InvalidOperation</span>
        <span class="n">Rounded</span>
        <span class="n">Subnormal</span>
        <span class="n">FloatOperation</span><span class="p">(</span><span class="n">DecimalException</span><span class="p">,</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">TypeError</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="floating-point-notes">
<span id="decimal-notes"></span><h2>Notas sobre la representación en coma flotante<a class="headerlink" href="#floating-point-notes" title="Enlazar permanentemente con este título">¶</a></h2>
<section id="mitigating-round-off-error-with-increased-precision">
<h3>Mitigación del error de redondeo usando mayor precisión<a class="headerlink" href="#mitigating-round-off-error-with-increased-precision" title="Enlazar permanentemente con este título">¶</a></h3>
<p>The use of decimal floating point eliminates decimal representation error
(making it possible to represent <code class="docutils literal notranslate"><span class="pre">0.1</span></code> exactly); however, some operations
can still incur round-off error when non-zero digits exceed the fixed precision.</p>
<p>Los efectos del error de redondeo pueden amplificarse mediante la suma o resta de cantidades casi compensadas, lo que da como resultado una pérdida de significación. Knuth proporciona dos ejemplos instructivos en los que la aritmética de coma flotante redondeada con precisión insuficiente provoca la ruptura de las propiedades asociativas y distributivas de la suma:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="go"># Examples from Seminumerical Algorithms, Section 4.2.2.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">getcontext</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">8</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">11111113</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">11111111</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.51111111&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span>
<span class="go">Decimal(&#39;9.5111111&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;10&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">20000</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;6.0000003&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.01&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.0060000&#39;)</span>
</pre></div>
</div>
<p>El módulo <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> permite restaurar las identidades ampliando la precisión lo suficiente para evitar la pérdida de significación:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">11111113</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">11111111</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;7.51111111&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span>
<span class="go">Decimal(&#39;9.51111111&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;9.51111111&#39;)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">20000</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;6.0000003&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.0060000&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="o">+</span><span class="n">w</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.0060000&#39;)</span>
</pre></div>
</div>
</section>
<section id="special-values">
<h3>Valores especiales<a class="headerlink" href="#special-values" title="Enlazar permanentemente con este título">¶</a></h3>
<p>The number system for the <a class="reference internal" href="#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> module provides special values
including <code class="docutils literal notranslate"><span class="pre">NaN</span></code>, <code class="docutils literal notranslate"><span class="pre">sNaN</span></code>, <code class="docutils literal notranslate"><span class="pre">-Infinity</span></code>, <code class="docutils literal notranslate"><span class="pre">Infinity</span></code>,
and two zeros, <code class="docutils literal notranslate"><span class="pre">+0</span></code> and <code class="docutils literal notranslate"><span class="pre">-0</span></code>.</p>
<p>Los infinitos se pueden construir directamente con <code class="docutils literal notranslate"><span class="pre">Decimal('Infinity')</span></code>. Además, pueden surgir al dividir entre cero cuando la señal <a class="reference internal" href="#decimal.DivisionByZero" title="decimal.DivisionByZero"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DivisionByZero</span></code></a> no es interceptada. Asimismo, cuando la señal <a class="reference internal" href="#decimal.Overflow" title="decimal.Overflow"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Overflow</span></code></a> no es interceptada, un infinito puede resultar del redondeo más allá de los límites del mayor número representable.</p>
<p>Los infinitos tienen signo (afín) y se pueden usar en operaciones aritméticas donde se tratan como números muy grandes e indeterminados. Por ejemplo, adicionar una constante a infinito resulta en otro infinito.</p>
<p>Some operations are indeterminate and return <code class="docutils literal notranslate"><span class="pre">NaN</span></code>, or if the
<a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> signal is trapped, raise an exception.  For example,
<code class="docutils literal notranslate"><span class="pre">0/0</span></code> returns <code class="docutils literal notranslate"><span class="pre">NaN</span></code> which means «not a number».  This variety of
<code class="docutils literal notranslate"><span class="pre">NaN</span></code> is quiet and, once created, will flow through other computations
always resulting in another <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.  This behavior can be useful for a
series of computations that occasionally have missing inputs — it allows the
calculation to proceed while flagging specific results as invalid.</p>
<p>A variant is <code class="docutils literal notranslate"><span class="pre">sNaN</span></code> which signals rather than remaining quiet after every
operation.  This is a useful return value when an invalid result needs to
interrupt a calculation for special handling.</p>
<p>The behavior of Python’s comparison operators can be a little surprising where a
<code class="docutils literal notranslate"><span class="pre">NaN</span></code> is involved.  A test for equality where one of the operands is a
quiet or signaling <code class="docutils literal notranslate"><span class="pre">NaN</span></code> always returns <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> (even when doing
<code class="docutils literal notranslate"><span class="pre">Decimal('NaN')==Decimal('NaN')</span></code>), while a test for inequality always returns
<a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>.  An attempt to compare two Decimals using any of the <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> or <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> operators will raise the <a class="reference internal" href="#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a> signal
if either operand is a <code class="docutils literal notranslate"><span class="pre">NaN</span></code>, and return <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> if this signal is
not trapped.  Note that the General Decimal Arithmetic specification does not
specify the behavior of direct comparisons; these rules for comparisons
involving a <code class="docutils literal notranslate"><span class="pre">NaN</span></code> were taken from the IEEE 854 standard (see Table 3 in
section 5.7).  To ensure strict standards-compliance, use the <a class="reference internal" href="#decimal.Decimal.compare" title="decimal.Decimal.compare"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare()</span></code></a>
and <a class="reference internal" href="#decimal.Decimal.compare_signal" title="decimal.Decimal.compare_signal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compare_signal()</span></code></a> methods instead.</p>
<p>Los ceros con signo pueden resultar de cálculos que desbordan la precisión establecida. Mantienen el signo que habría resultado si el cálculo se hubiera realizado con mayor precisión. Dado que su magnitud es cero, los ceros positivos y negativos se tratan como iguales y su signo es solo informativo.</p>
<p>Además de los dos ceros con signo, que son distintos pero iguales, hay varias representaciones del cero con diferente precisión pero equivalentes en valor. Esto requiere de algo de tiempo para acostumbrarse. Para un ojo habituado a las representaciones normalizadas de coma flotante, no es inmediatamente obvio que el siguiente cálculo retorne un valor igual a cero:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;Infinity&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;0E-1000026&#39;)</span>
</pre></div>
</div>
</section>
</section>
<section id="working-with-threads">
<span id="decimal-threads"></span><h2>Trabajando con hilos<a class="headerlink" href="#working-with-threads" title="Enlazar permanentemente con este título">¶</a></h2>
<p>La función <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> accede a un objeto <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> diferente para cada hilo. Tener contextos de hilo separados significa que los hilos pueden realizar cambios (como <code class="docutils literal notranslate"><span class="pre">getcontext().prec=10</span></code>) sin interferir con otros hilos.</p>
<p>Asimismo, la función <a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">setcontext()</span></code></a> asigna automáticamente su objetivo al hilo actual.</p>
<p>Si <a class="reference internal" href="#decimal.setcontext" title="decimal.setcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">setcontext()</span></code></a> no ha sido invocada antes de <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a>, entonces <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a> creará automáticamente un nuevo contexto para usar en el hilo actual.</p>
<p>El nuevo contexto es copiado a partir de un contexto prototipo llamado <em>DefaultContext</em>. Modifica directamente el objeto <em>DefaultContext</em> para controlar los valores predeterminados, de modo que cada hilo utilice los mismos valores en toda la aplicación. Esto debe hacerse <em>antes</em> de que se inicien los hilos, para evitar que tenga lugar una condición de carrera entre los mismos al invocar a <a class="reference internal" href="#decimal.getcontext" title="decimal.getcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code></a>. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set applicationwide defaults for all threads about to be launched</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">rounding</span> <span class="o">=</span> <span class="n">ROUND_DOWN</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">traps</span> <span class="o">=</span> <span class="n">ExtendedContext</span><span class="o">.</span><span class="n">traps</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">DefaultContext</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">InvalidOperation</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">setcontext</span><span class="p">(</span><span class="n">DefaultContext</span><span class="p">)</span>

<span class="c1"># Afterwards, the threads can be started</span>
<span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t3</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
 <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
</pre></div>
</div>
</section>
<section id="recipes">
<span id="decimal-recipes"></span><h2>Casos prácticos<a class="headerlink" href="#recipes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>A continuación hay algunos casos prácticos que sirven como funciones de utilidad y que muestran formas de trabajar con la clase <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">moneyfmt</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">places</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">curr</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">dp</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span>
             <span class="n">pos</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">trailneg</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert Decimal to a money formatted string.</span>

<span class="sd">    places:  required number of places after the decimal point</span>
<span class="sd">    curr:    optional currency symbol before the sign (may be blank)</span>
<span class="sd">    sep:     optional grouping separator (comma, period, space, or blank)</span>
<span class="sd">    dp:      decimal point indicator (comma or period)</span>
<span class="sd">             only specify as blank when places is zero</span>
<span class="sd">    pos:     optional sign for positive numbers: &#39;+&#39;, space or blank</span>
<span class="sd">    neg:     optional sign for negative numbers: &#39;-&#39;, &#39;(&#39;, space or blank</span>
<span class="sd">    trailneg:optional trailing minus indicator:  &#39;-&#39;, &#39;)&#39;, space or blank</span>

<span class="sd">    &gt;&gt;&gt; d = Decimal(&#39;-1234567.8901&#39;)</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, curr=&#39;$&#39;)</span>
<span class="sd">    &#39;-$1,234,567.89&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, places=0, sep=&#39;.&#39;, dp=&#39;&#39;, neg=&#39;&#39;, trailneg=&#39;-&#39;)</span>
<span class="sd">    &#39;1.234.568-&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(d, curr=&#39;$&#39;, neg=&#39;(&#39;, trailneg=&#39;)&#39;)</span>
<span class="sd">    &#39;($1,234,567.89)&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(Decimal(123456789), sep=&#39; &#39;)</span>
<span class="sd">    &#39;123 456 789.00&#39;</span>
<span class="sd">    &gt;&gt;&gt; moneyfmt(Decimal(&#39;-0.02&#39;), neg=&#39;&lt;&#39;, trailneg=&#39;&gt;&#39;)</span>
<span class="sd">    &#39;&lt;0.02&gt;&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="n">places</span>      <span class="c1"># 2 places --&gt; &#39;0.01&#39;</span>
    <span class="n">sign</span><span class="p">,</span> <span class="n">digits</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">as_tuple</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">digits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">digits</span><span class="p">))</span>
    <span class="n">build</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">,</span> <span class="n">digits</span><span class="o">.</span><span class="n">pop</span>
    <span class="k">if</span> <span class="n">sign</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="n">trailneg</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">places</span><span class="p">):</span>
        <span class="n">build</span><span class="p">(</span><span class="nb">next</span><span class="p">()</span> <span class="k">if</span> <span class="n">digits</span> <span class="k">else</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">places</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">digits</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">digits</span><span class="p">:</span>
        <span class="n">build</span><span class="p">(</span><span class="nb">next</span><span class="p">())</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">digits</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">build</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">build</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
    <span class="n">build</span><span class="p">(</span><span class="n">neg</span> <span class="k">if</span> <span class="n">sign</span> <span class="k">else</span> <span class="n">pos</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">pi</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Compute Pi to the current precision.</span>

<span class="sd">    &gt;&gt;&gt; print(pi())</span>
<span class="sd">    3.141592653589793238462643383</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>  <span class="c1"># extra digits for intermediate steps</span>
    <span class="n">three</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>      <span class="c1"># substitute &quot;three=3.0&quot; for regular floats</span>
    <span class="n">lasts</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">da</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">three</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">24</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">na</span> <span class="o">=</span> <span class="n">n</span><span class="o">+</span><span class="n">na</span><span class="p">,</span> <span class="n">na</span><span class="o">+</span><span class="mi">8</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">da</span> <span class="o">=</span> <span class="n">d</span><span class="o">+</span><span class="n">da</span><span class="p">,</span> <span class="n">da</span><span class="o">+</span><span class="mi">32</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">t</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>               <span class="c1"># unary plus applies the new precision</span>

<span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return e raised to the power of x.  Result type matches input type.</span>

<span class="sd">    &gt;&gt;&gt; print(exp(Decimal(1)))</span>
<span class="sd">    2.718281828459045235360287471</span>
<span class="sd">    &gt;&gt;&gt; print(exp(Decimal(2)))</span>
<span class="sd">    7.389056098930650227230427461</span>
<span class="sd">    &gt;&gt;&gt; print(exp(2.0))</span>
<span class="sd">    7.38905609893</span>
<span class="sd">    &gt;&gt;&gt; print(exp(2+0j))</span>
<span class="sd">    (7.38905609893+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>

<span class="k">def</span> <span class="nf">cos</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the cosine of x as measured in radians.</span>

<span class="sd">    The Taylor series approximation works best for a small value of x.</span>
<span class="sd">    For larger values, first compute x = x % (2 * pi).</span>

<span class="sd">    &gt;&gt;&gt; print(cos(Decimal(&#39;0.5&#39;)))</span>
<span class="sd">    0.8775825618903727161162815826</span>
<span class="sd">    &gt;&gt;&gt; print(cos(0.5))</span>
<span class="sd">    0.87758256189</span>
<span class="sd">    &gt;&gt;&gt; print(cos(0.5+0j))</span>
<span class="sd">    (0.87758256189+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
        <span class="n">sign</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span> <span class="o">*</span> <span class="n">sign</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>

<span class="k">def</span> <span class="nf">sin</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the sine of x as measured in radians.</span>

<span class="sd">    The Taylor series approximation works best for a small value of x.</span>
<span class="sd">    For larger values, first compute x = x % (2 * pi).</span>

<span class="sd">    &gt;&gt;&gt; print(sin(Decimal(&#39;0.5&#39;)))</span>
<span class="sd">    0.4794255386042030002732879352</span>
<span class="sd">    &gt;&gt;&gt; print(sin(0.5))</span>
<span class="sd">    0.479425538604</span>
<span class="sd">    &gt;&gt;&gt; print(sin(0.5+0j))</span>
<span class="sd">    (0.479425538604+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">lasts</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">lasts</span><span class="p">:</span>
        <span class="n">lasts</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="n">fact</span> <span class="o">*=</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
        <span class="n">sign</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">fact</span> <span class="o">*</span> <span class="n">sign</span>
    <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="o">+</span><span class="n">s</span>
</pre></div>
</div>
</section>
<section id="decimal-faq">
<span id="id1"></span><h2>Preguntas frecuentes sobre decimal<a class="headerlink" href="#decimal-faq" title="Enlazar permanentemente con este título">¶</a></h2>
<p>P. Es engorroso escribir <code class="docutils literal notranslate"><span class="pre">decimal.Decimal('1234.5')</span></code>. ¿Hay alguna forma de minimizar la escritura cuando se usa el intérprete interactivo?</p>
<p>R. Algunos usuarios abrevian el constructor a una sola letra:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="p">(</span><span class="s1">&#39;1.23&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">D</span><span class="p">(</span><span class="s1">&#39;3.45&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;4.68&#39;)</span>
</pre></div>
</div>
<p>P. En una aplicación de coma fija con dos decimales, algunas entradas tienen muchos dígitos decimales y deben redondearse. En cambio, otras no tienen dígitos en exceso y deben ser validadas. ¿Qué métodos deben utilizarse?</p>
<p>A. The <a class="reference internal" href="#decimal.Decimal.quantize" title="decimal.Decimal.quantize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quantize()</span></code></a> method rounds to a fixed number of decimal places. If
the <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-const docutils literal notranslate"><span class="pre">Inexact</span></code></a> trap is set, it is also useful for validation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">TWOPLACES</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="o">-</span><span class="mi">2</span>       <span class="c1"># same as Decimal(&#39;0.01&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Round to two places</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.214&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.21&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Validate that a number does not exceed two places</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.21&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">Context</span><span class="p">(</span><span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">]))</span>
<span class="go">Decimal(&#39;3.21&#39;)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.214&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">Context</span><span class="p">(</span><span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">]))</span>
<span class="gt">Traceback (most recent call last):</span>
   <span class="c">...</span>
<span class="gr">Inexact</span>: <span class="n">None</span>
</pre></div>
</div>
<p>P. Si tengo entradas validadas con dos dígitos decimales, ¿cómo mantengo eso invariante en una aplicación?</p>
<p>A. Some operations like addition, subtraction, and multiplication by an integer
will automatically preserve fixed point.  Others operations, like division and
non-integer multiplication, will change the number of decimal places and need to
be followed-up with a <a class="reference internal" href="#decimal.Decimal.quantize" title="decimal.Decimal.quantize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quantize()</span></code></a> step:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;102.72&#39;</span><span class="p">)</span>           <span class="c1"># Initial fixed-point values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.17&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span>                           <span class="c1"># Addition preserves fixed-point</span>
<span class="go">Decimal(&#39;105.89&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
<span class="go">Decimal(&#39;99.55&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*</span> <span class="mi">42</span>                          <span class="c1"># So does integer multiplication</span>
<span class="go">Decimal(&#39;4314.24&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>     <span class="c1"># Must quantize non-integer multiplication</span>
<span class="go">Decimal(&#39;325.62&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">b</span> <span class="o">/</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">TWOPLACES</span><span class="p">)</span>     <span class="c1"># And quantize division</span>
<span class="go">Decimal(&#39;0.03&#39;)</span>
</pre></div>
</div>
<p>In developing fixed-point applications, it is convenient to define functions
to handle the <a class="reference internal" href="#decimal.Decimal.quantize" title="decimal.Decimal.quantize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quantize()</span></code></a> step:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="n">TWOPLACES</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="n">TWOPLACES</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>                       <span class="c1"># Automatically preserve fixed-point</span>
<span class="go">Decimal(&#39;325.62&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">div</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.03&#39;)</span>
</pre></div>
</div>
<p>Q. There are many ways to express the same value.  The numbers <code class="docutils literal notranslate"><span class="pre">200</span></code>,
<code class="docutils literal notranslate"><span class="pre">200.000</span></code>, <code class="docutils literal notranslate"><span class="pre">2E2</span></code>, and <code class="docutils literal notranslate"><span class="pre">.02E+4</span></code> all have the same value at
various precisions. Is there a way to transform them to a single recognizable
canonical value?</p>
<p>A. The <a class="reference internal" href="#decimal.Decimal.normalize" title="decimal.Decimal.normalize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">normalize()</span></code></a> method maps all equivalent values to a single
representative:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="s1">&#39;200 200.000 2E2 .02E+4&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
<span class="go">[Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;)]</span>
</pre></div>
</div>
<p>P. Algunos valores decimales siempre se imprimen usando notación exponencial. ¿Hay alguna forma de obtener una representación no exponencial?</p>
<p>A. For some values, exponential notation is the only way to express the number
of significant places in the coefficient.  For example, expressing
<code class="docutils literal notranslate"><span class="pre">5.0E+3</span></code> as <code class="docutils literal notranslate"><span class="pre">5000</span></code> keeps the value constant but cannot show the
original’s two-place significance.</p>
<p>Si una aplicación no necesita preocuparse por el seguimiento de significación, es fácil eliminar el exponente y los ceros finales, perdiendo significación, pero manteniendo el valor sin cambios:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">remove_exponent</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="n">d</span><span class="o">.</span><span class="n">to_integral</span><span class="p">()</span> <span class="k">else</span> <span class="n">d</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">remove_exponent</span><span class="p">(</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;5E+3&#39;</span><span class="p">))</span>
<span class="go">Decimal(&#39;5000&#39;)</span>
</pre></div>
</div>
<p>P. ¿Hay alguna forma de convertir un flotante regular en un <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>?</p>
<p>R. Sí, cualquier número de coma flotante binario se puede expresar exactamente mediante un Decimal, aunque una conversión exacta puede requerir más precisión de la que sugiere la intuición:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="go">Decimal(&#39;3.141592653589793115997963468544185161590576171875&#39;)</span>
</pre></div>
</div>
<p>P. Dentro de un cálculo complejo, cómo puedo asegurarme de que no he obtenido un resultado adulterado debido a una precisión insuficiente o anomalías de redondeo.</p>
<p>R. El módulo decimal facilita la comprobación de resultados. Una buena práctica es volver a ejecutar los cálculos con mayor precisión y con varios modos de redondeo. La obtención de resultados muy dispares indica una precisión insuficiente, problemas relacionados con el modo de redondeo, entradas mal acondicionadas o un algoritmo numéricamente inestable.</p>
<p>P. Noté que la precisión del contexto se aplica a los resultados de las operaciones pero no a las entradas. ¿Hay algo a tener en cuenta al mezclar valores con distintas precisiones?</p>
<p>R. Sí. El principio es que todos los valores se consideran exactos y también lo es la aritmética de esos valores. Solo se redondean los resultados. La ventaja para las entradas es que «lo que escribes es lo que obtienes». Una desventaja es que los resultados pueden parecer extraños si olvidas que las entradas no se han redondeado:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.104&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.104&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.21&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;3.104&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;0.000&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;2.104&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;5.20&#39;)</span>
</pre></div>
</div>
<p>La solución es aumentar la precisión o forzar el redondeo de las entradas utilizando la operación unaria más:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">+</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.23456789&#39;</span><span class="p">)</span>      <span class="c1"># unary plus triggers rounding</span>
<span class="go">Decimal(&#39;1.23&#39;)</span>
</pre></div>
</div>
<p>Alternativamente, las entradas se pueden redondear en el momento que se crean usando el método <a class="reference internal" href="#decimal.Context.create_decimal" title="decimal.Context.create_decimal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Context.create_decimal()</span></code></a>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span><span class="o">.</span><span class="n">create_decimal</span><span class="p">(</span><span class="s1">&#39;1.2345678&#39;</span><span class="p">)</span>
<span class="go">Decimal(&#39;1.2345&#39;)</span>
</pre></div>
</div>
<p>P. ¿La implementación de CPython es rápida para números grandes?</p>
<p>A. Yes.  In the CPython and PyPy3 implementations, the C/CFFI versions of
the decimal module integrate the high speed <a class="reference external" href="https://www.bytereef.org/mpdecimal/doc/libmpdec/index.html">libmpdec</a> library for
arbitrary precision correctly rounded decimal floating point arithmetic <a class="footnote-reference brackets" href="#id4" id="id2">1</a>.
<code class="docutils literal notranslate"><span class="pre">libmpdec</span></code> uses <a class="reference external" href="https://en.wikipedia.org/wiki/Karatsuba_algorithm">Karatsuba multiplication</a>
for medium-sized numbers and the <a class="reference external" href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform_(general)#Number-theoretic_transform">Number Theoretic Transform</a>
for very large numbers.</p>
<p>The context must be adapted for exact arbitrary precision arithmetic. <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emin</span></code>
and <code class="xref py py-attr docutils literal notranslate"><span class="pre">Emax</span></code> should always be set to the maximum values, <code class="xref py py-attr docutils literal notranslate"><span class="pre">clamp</span></code>
should always be 0 (the default).  Setting <code class="xref py py-attr docutils literal notranslate"><span class="pre">prec</span></code> requires some care.</p>
<p>The easiest approach for trying out bignum arithmetic is to use the maximum
value for <code class="xref py py-attr docutils literal notranslate"><span class="pre">prec</span></code> as well <a class="footnote-reference brackets" href="#id5" id="id3">2</a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="n">MAX_PREC</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="n">MAX_EMAX</span><span class="p">,</span> <span class="n">Emin</span><span class="o">=</span><span class="n">MIN_EMIN</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">256</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">/</span> <span class="mi">128</span>
<span class="go">Decimal(&#39;904625697166532776746648320380374280103671755200316906558262375061821325312&#39;)</span>
</pre></div>
</div>
<p>Para resultados inexactos, <a class="reference internal" href="#decimal.MAX_PREC" title="decimal.MAX_PREC"><code class="xref py py-attr docutils literal notranslate"><span class="pre">MAX_PREC</span></code></a> es demasiado grande en plataformas de 64 bits y la memoria disponible será insuficiente:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">MemoryError</span>
</pre></div>
</div>
<p>On systems with overallocation (e.g. Linux), a more sophisticated approach is to
adjust <code class="xref py py-attr docutils literal notranslate"><span class="pre">prec</span></code> to the amount of available RAM.  Suppose that you have 8GB of
RAM and expect 10 simultaneous operands using a maximum of 500MB each:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Maximum number of digits for a single operand using 500MB in 8-byte words</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># with 19 digits per word (4-byte and 9 digits for the 32-bit build):</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">maxdigits</span> <span class="o">=</span> <span class="mi">19</span> <span class="o">*</span> <span class="p">((</span><span class="mi">500</span> <span class="o">*</span> <span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Check that this works:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="n">maxdigits</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="n">MAX_EMAX</span><span class="p">,</span> <span class="n">Emin</span><span class="o">=</span><span class="n">MIN_EMIN</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">Inexact</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setcontext</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Fill the available precision with nines:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">logical_invert</span><span class="p">()</span> <span class="o">*</span> <span class="mi">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">524288112</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">  decimal.Inexact</span>: <span class="n">[&lt;class &#39;decimal.Inexact&#39;&gt;]</span>
</pre></div>
</div>
<p>En general (y especialmente en sistemas sin sobreasignación), se recomienda estimar límites aún más estrictos y establecer la trampa <a class="reference internal" href="#decimal.Inexact" title="decimal.Inexact"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Inexact</span></code></a> si se espera que todos los cálculos sean exactos.</p>
<dl class="footnote brackets">
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd>
<dt class="label" id="id5"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.9: </span>Este enfoque ahora funciona para todos los resultados exactos excepto para las potencias no enteras. También retro-portado a 3.7 y 3.8.</p>
</div>
</dd>
</dl>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code> — Aritmética decimal de coma fija y coma flotante</a><ul>
<li><a class="reference internal" href="#quick-start-tutorial">Tutorial de inicio rápido</a></li>
<li><a class="reference internal" href="#decimal-objects">Objetos Decimal</a><ul>
<li><a class="reference internal" href="#logical-operands">Operandos lógicos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#context-objects">Objetos context</a></li>
<li><a class="reference internal" href="#constants">Constantes</a></li>
<li><a class="reference internal" href="#rounding-modes">Modos de redondeo</a></li>
<li><a class="reference internal" href="#signals">Señales</a></li>
<li><a class="reference internal" href="#floating-point-notes">Notas sobre la representación en coma flotante</a><ul>
<li><a class="reference internal" href="#mitigating-round-off-error-with-increased-precision">Mitigación del error de redondeo usando mayor precisión</a></li>
<li><a class="reference internal" href="#special-values">Valores especiales</a></li>
</ul>
</li>
<li><a class="reference internal" href="#working-with-threads">Trabajando con hilos</a></li>
<li><a class="reference internal" href="#recipes">Casos prácticos</a></li>
<li><a class="reference internal" href="#decimal-faq">Preguntas frecuentes sobre decimal</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="cmath.html"
                          title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code> – Función matemática para números complejos</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="fractions.html"
                          title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fractions</span></code> — Números racionales</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/library/decimal.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="fractions.html" title="fractions — Números racionales"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="cmath.html" title="cmath – Función matemática para números complejos"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="numeric.html" >Módulos numéricos y matemáticos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code> — Aritmética decimal de coma fija y coma flotante</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 23, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>