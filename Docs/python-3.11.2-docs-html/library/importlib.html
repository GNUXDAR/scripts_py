
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="importlib — La implementación de import" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/importlib.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Código fuente: Lib/importlib/__init__.py Introducción: El propósito del paquete importlib es triple: Uno es proveer la implementación de la declaración de import(y así, por extensión, el método__im..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Código fuente: Lib/importlib/__init__.py Introducción: El propósito del paquete importlib es triple: Uno es proveer la implementación de la declaración de import(y así, por extensión, el método__im..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>importlib — La implementación de import &#8212; documentación de Python - 3.11.2</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=2d3badd06fe70b34b68db01f99471ce1624ffe4a" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.11.2"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="importlib.resources – Recursos" href="importlib.resources.html" />
    <link rel="prev" title="runpy — Localización y ejecución de módulos Python" href="runpy.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/importlib.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> — La implementación de <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a><ul>
<li><a class="reference internal" href="#introduction">Introducción</a></li>
<li><a class="reference internal" href="#functions">Funciones</a></li>
<li><a class="reference internal" href="#module-importlib.abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code> – Clases base abstractas relacionadas con la importación</a></li>
<li><a class="reference internal" href="#module-importlib.machinery"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.machinery</span></code> – Importadores y enlaces de ruta</a></li>
<li><a class="reference internal" href="#module-importlib.util"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code> – Código de utilidad para importadores</a></li>
<li><a class="reference internal" href="#examples">Ejemplos</a><ul>
<li><a class="reference internal" href="#importing-programmatically">Importar programáticamente</a></li>
<li><a class="reference internal" href="#checking-if-a-module-can-be-imported">Comprobando si se puede importar un módulo</a></li>
<li><a class="reference internal" href="#importing-a-source-file-directly">Importar un archivo fuente directamente</a></li>
<li><a class="reference internal" href="#implementing-lazy-imports">Implementar importaciones diferidas</a></li>
<li><a class="reference internal" href="#setting-up-an-importer">Configurar un importador</a></li>
<li><a class="reference internal" href="#approximating-importlib-import-module">Aproximando <code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="runpy.html"
                          title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code> — Localización y ejecución de módulos <em>Python</em></a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="importlib.resources.html"
                          title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.resources</span></code> – Recursos</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/library/importlib.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="importlib.resources.html" title="importlib.resources – Recursos"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="runpy.html" title="runpy — Localización y ejecución de módulos Python"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="modules.html" accesskey="U">Importando módulos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> — La implementación de <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-importlib">
<span id="importlib-the-implementation-of-import"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> — La implementación de <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code><a class="headerlink" href="#module-importlib" title="Enlazar permanentemente con este título">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
<p><strong>Código fuente:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.11/Lib/importlib/__init__.py">Lib/importlib/__init__.py</a></p>
<hr class="docutils" />
<section id="introduction">
<h2>Introducción<a class="headerlink" href="#introduction" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El propósito del paquete <a class="reference internal" href="#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> es triple:</p>
<p>Uno es proveer la implementación de la declaración de <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> (y así, por extensión, el método <a class="reference internal" href="functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> ) en el código fuente de Python. Esto provee una implementación de la <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> la cual es compatible con cualquier intérprete de Python. También provee una implementación que es más fácil de comprender que una implementada en un lenguajes que no es Python.</p>
<p>Dos, los componentes incluidos para implementar <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>  están expuestos en este paquete para que sea más fácil para los usuarios crear sus propios objetos (conocidos de forma genérica como <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a>) para participar en el proceso de importación.</p>
<p>Tres, el paquete contiene módulos exponiendo funcionalidad adicional para administrar aspectos de paquetes de Python:</p>
<ul class="simple">
<li><p><a class="reference internal" href="importlib.metadata.html#module-importlib.metadata" title="importlib.metadata: The implementation of the importlib metadata."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.metadata</span></code></a> presenta acceso a metadatos de distribuciones de terceros.</p></li>
<li><p><a class="reference internal" href="importlib.resources.html#module-importlib.resources" title="importlib.resources: Package resource reading, opening, and access"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.resources</span></code></a> provee rutinas para acceder a <em>recursos</em> que no son código de paquetes de Python.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><a class="reference internal" href="../reference/simple_stmts.html#import"><span class="std std-ref">La declaración import</span></a></dt><dd><p>La referencia en el lenguaje para la declaración de <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>.</p>
</dd>
<dt><a class="reference external" href="https://www.python.org/doc/essays/packages/">Especificaciones de paquetes</a></dt><dd><p>Especificaciones originales de los paquetes. Algunas semánticas han cambiado desde que este documento fue escrito (ejemplo, redirección de acuerdo a <code class="docutils literal notranslate"><span class="pre">None</span></code> en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>).</p>
</dd>
<dt>La función <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a></dt><dd><p>La declaración de <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> es una decoración sintáctica para esta función.</p>
</dd>
<dt><a class="reference internal" href="sys_path_init.html#sys-path-init"><span class="std std-ref">La inicialización de la ruta de búsqueda de módulo de sys.path</span></a></dt><dd><p>La inicialización de <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>.</p>
</dd>
<dt><span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0235/"><strong>PEP 235</strong></a></dt><dd><p>Importar en sistemas que no distinguen entre mayúsculas y minúsculas</p>
</dd>
<dt><span class="target" id="index-1"></span><a class="pep reference external" href="https://peps.python.org/pep-0263/"><strong>PEP 263</strong></a></dt><dd><p>Definiendo las codificaciones del código fuente de Python</p>
</dd>
<dt><span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a></dt><dd><p>Nuevos ganchos de importación</p>
</dd>
<dt><span class="target" id="index-3"></span><a class="pep reference external" href="https://peps.python.org/pep-0328/"><strong>PEP 328</strong></a></dt><dd><p>Importaciones: Multilíneas, y absolutos/relativos</p>
</dd>
<dt><span class="target" id="index-4"></span><a class="pep reference external" href="https://peps.python.org/pep-0366/"><strong>PEP 366</strong></a></dt><dd><p>Importaciones relativas, explicitas, del módulo principal</p>
</dd>
<dt><span class="target" id="index-5"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a></dt><dd><p>Paquetes implícitos en el espacio de nombres</p>
</dd>
<dt><span class="target" id="index-6"></span><a class="pep reference external" href="https://peps.python.org/pep-0451/"><strong>PEP 451</strong></a></dt><dd><p>Un tipo de ModuleSpec para el sistema de importación</p>
</dd>
<dt><span class="target" id="index-7"></span><a class="pep reference external" href="https://peps.python.org/pep-0488/"><strong>PEP 488</strong></a></dt><dd><p>Eliminación de archivos PYO</p>
</dd>
<dt><span class="target" id="index-8"></span><a class="pep reference external" href="https://peps.python.org/pep-0489/"><strong>PEP 489</strong></a></dt><dd><p>Inicialización de extensión de módulo en múltiples fases</p>
</dd>
<dt><span class="target" id="index-9"></span><a class="pep reference external" href="https://peps.python.org/pep-0552/"><strong>PEP 552</strong></a></dt><dd><p>Pycs determinísticos</p>
</dd>
<dt><span class="target" id="index-10"></span><a class="pep reference external" href="https://peps.python.org/pep-3120/"><strong>PEP 3120</strong></a></dt><dd><p>Usando UTF-8 como la codificación fuente por defecto</p>
</dd>
<dt><span class="target" id="index-11"></span><a class="pep reference external" href="https://peps.python.org/pep-3147/"><strong>PEP 3147</strong></a></dt><dd><p>Repositorio de directorios PYC</p>
</dd>
</dl>
</div>
</section>
<section id="functions">
<h2>Funciones<a class="headerlink" href="#functions" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="importlib.__import__">
<span class="sig-prename descclassname"><span class="pre">importlib.</span></span><span class="sig-name descname"><span class="pre">__import__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">globals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">locals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fromlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.__import__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una implementación de la función <a class="reference internal" href="functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> incorporada.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La importación programática los módulos debe usar <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a> en lugar de esta función.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.import_module">
<span class="sig-prename descclassname"><span class="pre">importlib.</span></span><span class="sig-name descname"><span class="pre">import_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">package</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.import_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Importar un módulo. El argumento llamado <em>name</em> especifica qué módulo importar en términos absolutos o relativos (ejemplo, puede ser <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code> o <code class="docutils literal notranslate"><span class="pre">..mod</span></code>). Si el nombre fuera especificado en términos relativos, entonces el argumento llamado <em>package</em> debe ser igual al nombre del paquete que será el ancla para resolver el nombre del paquete (ejemplo <code class="docutils literal notranslate"><span class="pre">import_module('..mod',</span> <span class="pre">'pkg.subpkg')</span></code> importará <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code>).</p>
<p>La función <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a> actúa como un envoltorio simplificador alrededor de <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.__import__()</span></code></a>.  Esto quiere decir que las semánticas de la función son derivadas de <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.__import__()</span></code></a>. La diferencia más importante entre las dos funciones es que <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a> retorna el paquete especificado o el módulo (ejemplo <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code>), mientras que <a class="reference internal" href="functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> retorna el paquete o módulo del nivel superior (ejemplo <code class="docutils literal notranslate"><span class="pre">pkg</span></code>).</p>
<p>Si está importando dinámicamente un módulo que se creó desde que el intérprete comenzó la ejecución (por ejemplo, creó un archivo fuente de Python), es posible que deba llamar a <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">invalidate_caches()</span></code></a> para que el nuevo módulo sea detectado por el sistema de importación.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Paquetes padres son importados automáticamente.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.find_loader">
<span class="sig-prename descclassname"><span class="pre">importlib.</span></span><span class="sig-name descname"><span class="pre">find_loader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.find_loader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Encuentra el cargador de un módulo, opcionalmente con el especificado en <em>path</em>. Si el módulo esta en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, entonces retorna el <code class="docutils literal notranslate"><span class="pre">sys.modules[name].__loader__</span></code> (a menos que el cargador sea <code class="docutils literal notranslate"><span class="pre">None</span></code> o no haya uno especificado, en tal caso se lanza un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>).Si no se encuentra ahí, se hace una búsqueda usando <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>. Se retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si no se encuentra un cargador.</p>
<p>Un nombre con puntos no tiene sus ascendientes importados implícitamente, ya que eso requeriría cargarlo y eso podría no ser deseado. Para importar un sub-módulo correctamente debes importar todos los paquetes ascendientes del sub-módulo y pase el argumento correcto a <em>path</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Si el <code class="docutils literal notranslate"><span class="pre">__loader__</span></code> no está configurado, lanza un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>, igual a si el atributo fuera <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>Utilice <a class="reference internal" href="#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.find_spec()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.invalidate_caches">
<span class="sig-prename descclassname"><span class="pre">importlib.</span></span><span class="sig-name descname"><span class="pre">invalidate_caches</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.invalidate_caches" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Invalide los cache internos de ubicadores encontrados en <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>.Si un buscador implementa <code class="docutils literal notranslate"><span class="pre">invalidate_caches()</span></code> entonces será llamado para realizar la invalidación.Esta función debe ser llamada si cualquier módulo ha sido creado/instalado mientras tu programa esta siendo ejecutado para garantizar que todos los buscadores noten la existencia del nuevo módulo.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Paquetes de espacio de nombres creados/instalados en una ubicación <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> distinta después de que el mismo espacio de nombres fue importado son notados.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.reload">
<span class="sig-prename descclassname"><span class="pre">importlib.</span></span><span class="sig-name descname"><span class="pre">reload</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.reload" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Recarga un <em>modulo</em> previamente importado. El argumento debe ser un objeto módulo, por lo que debe haber sido importado exitosamente. Esto es útil cuando has editado el código fuente de un archivo usando un editor externo y deseas probar la nueva versión sin abandonar el interprete de Python. El valor retornado es el objeto módulo (que puede ser diferente si la reimportación crea un nuevo objeto en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>).</p>
<p>Cuando <a class="reference internal" href="#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">reload()</span></code></a> es ejecutada:</p>
<ul class="simple">
<li><p>El código de un módulo de Python es recompilado y el código del módulo reejecutado, definiendo un nuevo conjunto de objetos que son asignados a los nombres de los módulos en el diccionario, reusando el <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> que originalmente carga los módulos. El método <code class="docutils literal notranslate"><span class="pre">init</span></code> de los módulos de extension no es llamado de nuevo.</p></li>
<li><p>Al igual que con todos los demás objetos en Python, los objetos antiguos solo se recuperan después de que sus recuentos de referencias caen a cero.</p></li>
<li><p>Los nombres en el espacio de nombres del módulo se actualizan para señalar cualquier objeto nuevo o modificado.</p></li>
<li><p>Otras referencias a los objetos antiguos (como los nombres externos al módulo) no se vuelven a vincular para hacer referencia a los nuevos objetos y deben actualizarse en cada espacio de nombres donde se produzcan si se desea.</p></li>
</ul>
<p>Hay una serie de otras advertencias:</p>
<p>Cuando se vuelve a cargar un módulo, se conserva su diccionario (que contiene las variables globales del módulo). Las redefiniciones de nombres anularán las antiguas definiciones, por lo que generalmente esto no es un problema. Si la nueva versión de un módulo no define un nombre que fue definido por la versión anterior, la definición anterior permanece. Esta característica se puede utilizar en beneficio del módulo si mantiene una tabla global o caché de objetos — con una declaración <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> puede probar la presencia de la tabla y omitir su inicialización si lo desea:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">cache</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
<p>Por lo general, no es muy útil recargar módulos integrados o cargados dinámicamente. No se recomienda recargar <a class="reference internal" href="sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a>, <a class="reference internal" href="__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a>, <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> y otros módulos clave. En muchos casos, los módulos de extensión no están diseñados para inicializarse más de una vez y pueden fallar de manera arbitraria cuando se vuelven a cargar.</p>
<p>Si un módulo importa objetos de otro módulo usando <a class="reference internal" href="../reference/simple_stmts.html#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> … <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> …, al llamar a <a class="reference internal" href="#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">reload()</span></code></a> para el otro módulo no redefine los objetos importados de él — una forma de evitar esto es volver a ejecutar la instrucción <code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code>, otra es usar <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> y nombres calificados (<em>module.name</em>) en su lugar.</p>
<p>Si un módulo crea instancias de una clase, volver a cargar el módulo que define la clase no afecta las definiciones de método de las instancias — continúan usando la definición de clase anterior. Lo mismo ocurre con las clases derivadas.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span><a class="reference internal" href="exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> se lanza cuando el módulo que se está recargando carece de <a class="reference internal" href="#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="module-importlib.abc">
<span id="importlib-abc-abstract-base-classes-related-to-import"></span><h2><a class="reference internal" href="#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> – Clases base abstractas relacionadas con la importación<a class="headerlink" href="#module-importlib.abc" title="Enlazar permanentemente con este título">¶</a></h2>
<p><strong>Código fuente:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.11/Lib/importlib/abc.py">Lib/importlib/abc.py</a></p>
<hr class="docutils" />
<p>El módulo <a class="reference internal" href="#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> contiene todas las clases base abstractas principales utilizadas por <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>. También se proporcionan algunas subclases de las clases base abstractas centrales para ayudar a implementar los ABC centrales.</p>
<p>Jerarquía ABC:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">object</span>
 <span class="o">+--</span> <span class="n">Finder</span> <span class="p">(</span><span class="n">deprecated</span><span class="p">)</span>
 <span class="o">+--</span> <span class="n">MetaPathFinder</span>
 <span class="o">+--</span> <span class="n">PathEntryFinder</span>
 <span class="o">+--</span> <span class="n">Loader</span>
      <span class="o">+--</span> <span class="n">ResourceLoader</span> <span class="o">--------+</span>
      <span class="o">+--</span> <span class="n">InspectLoader</span>          <span class="o">|</span>
           <span class="o">+--</span> <span class="n">ExecutionLoader</span> <span class="o">--+</span>
                                 <span class="o">+--</span> <span class="n">FileLoader</span>
                                 <span class="o">+--</span> <span class="n">SourceLoader</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.Finder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">Finder</span></span><a class="headerlink" href="#importlib.abc.Finder" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase base abstracta que representa <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.3: </span>Utilice <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaPathFinder</span></code></a> o <a class="reference internal" href="#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathEntryFinder</span></code></a> en su lugar.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Finder.find_module">
<em class="property"><span class="pre">abstractmethod</span> </em><span class="sig-name descname"><span class="pre">find_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Finder.find_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método abstracto para encontrar un <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> para el módulo especificado. Originalmente especificado en <span class="target" id="index-39"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a>, este método estaba destinado a ser utilizado en <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> y en el subsistema de importación basado en rutas.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> cuando se llama en lugar de generar <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.10: </span>Implemente <a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaPathFinder.find_spec()</span></code></a> o <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PathEntryFinder.find_spec()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.MetaPathFinder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">MetaPathFinder</span></span><a class="headerlink" href="#importlib.abc.MetaPathFinder" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase base abstracta que representa <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">meta path finder</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Ya no hereda de <a class="reference internal" href="#importlib.abc.Finder" title="importlib.abc.Finder"><code class="xref py py-class docutils literal notranslate"><span class="pre">Finder</span></code></a>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.MetaPathFinder.find_spec">
<span class="sig-name descname"><span class="pre">find_spec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.find_spec" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método abstracto para encontrar un <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a> para el módulo especificado. Si se trata de una importación de nivel superior, el <em>path</em> será <code class="docutils literal notranslate"><span class="pre">None</span></code>. De lo contrario, esta es una búsqueda de un subpaquete o módulo y <em>path</em> será el valor de <a class="reference internal" href="../reference/import.html#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> del paquete principal. Si no se puede encontrar una especificación, se retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>. Cuando se pasa, <code class="docutils literal notranslate"><span class="pre">target</span></code> es un objeto de módulo que el buscador puede usar para hacer una suposición más informada sobre qué especificación retornar. <a class="reference internal" href="#importlib.util.spec_from_loader" title="importlib.util.spec_from_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.spec_from_loader()</span></code></a> puede ser útil para implementar <code class="docutils literal notranslate"><span class="pre">MetaPathFinders</span></code> concretos.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.MetaPathFinder.find_module">
<span class="sig-name descname"><span class="pre">find_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.find_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método heredado para encontrar un <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> para el módulo especificado. Si se trata de una importación de nivel superior, el <em>path</em> será <code class="docutils literal notranslate"><span class="pre">None</span></code>. De lo contrario, esta es una búsqueda de un subpaquete o módulo y <em>path</em> será el valor de <a class="reference internal" href="../reference/import.html#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> del paquete principal. Si no se puede encontrar un cargador, se retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Si se define <a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>, se proporciona una funcionalidad compatible con versiones anteriores.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> cuando se llama en lugar de generar <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>. Puede usar <a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> para proporcionar funcionalidad.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>Use <a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.MetaPathFinder.invalidate_caches">
<span class="sig-name descname"><span class="pre">invalidate_caches</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.invalidate_caches" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método opcional que, cuando se llama, debería invalidar cualquier caché interno utilizado por el buscador. Utilizado por <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.invalidate_caches()</span></code></a> al invalidar los cachés de todos los buscadores en <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> cuando se llama en lugar de <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code>.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.PathEntryFinder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">PathEntryFinder</span></span><a class="headerlink" href="#importlib.abc.PathEntryFinder" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase base abstracta que representa un <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">buscador de entradas de ruta</span></a>. Aunque tiene algunas similitudes con <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaPathFinder</span></code></a>, <code class="docutils literal notranslate"><span class="pre">PathEntryFinder</span></code> está diseñado para usarse solo dentro del subsistema de importación basado en rutas proporcionado por <a class="reference internal" href="#importlib.machinery.PathFinder" title="importlib.machinery.PathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.PathFinder</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Ya no hereda de <a class="reference internal" href="#importlib.abc.Finder" title="importlib.abc.Finder"><code class="xref py py-class docutils literal notranslate"><span class="pre">Finder</span></code></a>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.PathEntryFinder.find_spec">
<span class="sig-name descname"><span class="pre">find_spec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.find_spec" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método abstracto para encontrar un <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a> para el módulo especificado. El buscador buscará el módulo solo dentro del <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">path entry</span></a> a la que está asignado. Si no se puede encontrar una especificación, se retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>. Cuando se pasa, <code class="docutils literal notranslate"><span class="pre">target</span></code> es un objeto de módulo que el buscador puede usar para hacer una suposición más informada sobre qué especificación retornar. <a class="reference internal" href="#importlib.util.spec_from_loader" title="importlib.util.spec_from_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.spec_from_loader()</span></code></a> puede ser útil para implementar <code class="docutils literal notranslate"><span class="pre">PathEntryFinders</span></code> concretos.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.PathEntryFinder.find_loader">
<span class="sig-name descname"><span class="pre">find_loader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.find_loader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método heredado para encontrar un <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> para el módulo especificado. Retorna una tupla de 2 de <code class="docutils literal notranslate"><span class="pre">(loader,</span> <span class="pre">portion)</span></code> donde <code class="docutils literal notranslate"><span class="pre">portion</span></code> es una secuencia de ubicaciones del sistema de archivos que contribuyen a parte de un paquete de espacio de nombres. El cargador puede ser <code class="docutils literal notranslate"><span class="pre">None</span></code> mientras se especifica <code class="docutils literal notranslate"><span class="pre">portion</span></code> para indicar la contribución de las ubicaciones del sistema de archivos a un paquete de espacio de nombres. Se puede usar una lista vacía para <code class="docutils literal notranslate"><span class="pre">portion</span></code> para indicar que el cargador no es parte de un paquete de espacio de nombres. Si <code class="docutils literal notranslate"><span class="pre">loader</span></code> es <code class="docutils literal notranslate"><span class="pre">None</span></code> y <code class="docutils literal notranslate"><span class="pre">portion</span></code> es la lista vacía, entonces no se encontró ningún cargador o ubicación para un paquete de espacio de nombres (es decir, no se pudo encontrar nada para el módulo).</p>
<p>Si se define <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>, se proporciona una funcionalidad compatible con versiones anteriores.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Retorna <code class="docutils literal notranslate"><span class="pre">(None,</span> <span class="pre">[])</span></code> en lugar de lanzar <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>. Usa <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> cuando está disponible para proporcionar funcionalidad.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>Use <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.PathEntryFinder.find_module">
<span class="sig-name descname"><span class="pre">find_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.find_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una implementación concreta de <a class="reference internal" href="#importlib.abc.Finder.find_module" title="importlib.abc.Finder.find_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Finder.find_module()</span></code></a> que es equivalente a <code class="docutils literal notranslate"><span class="pre">self.find_loader(fullname)[0]</span></code>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>Use <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.PathEntryFinder.invalidate_caches">
<span class="sig-name descname"><span class="pre">invalidate_caches</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.invalidate_caches" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método opcional que, cuando se llama, debería invalidar cualquier caché interno utilizado por el buscador. Usado por <a class="reference internal" href="#importlib.machinery.PathFinder.invalidate_caches" title="importlib.machinery.PathFinder.invalidate_caches"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.machinery.PathFinder.invalidate_caches()</span></code></a> al invalidar las cachés de todos los buscadores en caché.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.Loader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">Loader</span></span><a class="headerlink" href="#importlib.abc.Loader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase base abstracta para un <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>. Consulte <span class="target" id="index-40"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> para obtener la definición exacta de cargador.</p>
<p>Los cargadores que deseen admitir la lectura de recursos deben implementar un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_resource_reader()</span></code> según lo especificado por <code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ResourceReader</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Introducido el método opcional <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_resource_reader()</span></code>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Loader.create_module">
<span class="sig-name descname"><span class="pre">create_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.create_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método que retorna el objeto de módulo que se utilizará al importar un módulo. Este método puede retornar <code class="docutils literal notranslate"><span class="pre">None</span></code>, lo que indica que se debe llevar a cabo la semántica de creación de módulos predeterminada.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Este método ya no es opcional cuando se defina <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Loader.exec_module">
<span class="sig-name descname"><span class="pre">exec_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.exec_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método abstracto que ejecuta el módulo en su propio espacio de nombres cuando se importa o se vuelve a cargar un módulo. El módulo ya debería estar inicializado cuando se llama a <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>. Cuando existe este método, se debe definir <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span><a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a> también debe definirse.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Loader.load_module">
<span class="sig-name descname"><span class="pre">load_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.load_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método heredado para cargar un módulo. Si el módulo no se puede cargar, se lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>; de lo contrario, se retorna el módulo cargado.</p>
<p>Si el módulo solicitado ya existe en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, ese módulo debe usarse y recargarse. De lo contrario, el cargador debe crear un nuevo módulo e insertarlo en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> antes de que comience la carga, para evitar la recursividad de la importación. Si el cargador insertó un módulo y la carga falla, el cargador debe eliminarlo de <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>; los módulos que ya están en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> antes de que el cargador comenzara a ejecutarse deben dejarse en paz (ver <a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_for_loader()</span></code></a>).</p>
<p>El cargador debe establecer varios atributos en el módulo (tenga en cuenta que algunos de estos atributos pueden cambiar cuando se recarga un módulo):</p>
<ul class="simple">
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a></dt><dd><p>El nombre completo del módulo. Es <code class="docutils literal notranslate"><span class="pre">'__main__'</span></code> para un módulo ejecutado.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a></dt><dd><p>La ubicación que el <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">cargador</span></a> usó para cargar el módulo. Por ejemplo, para módulos cargados desde un archivo .py, éste es el nombre del archivo. No está establecido para todos los módulos (por ejemplo. módulos integrados).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#cached__" title="__cached__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code></a></dt><dd><p>El nombre de archivo de una versión compilada del código del módulo. No está establecido para todos los módulos (por ejemplo, módulos integrados).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a></dt><dd><p>La lista de ubicaciones donde los sub-módulos del paquete pueden ser encontrados. La mayoría de las veces es un solo directorio. El sistema de importación pasa este atributo a <code class="docutils literal notranslate"><span class="pre">__import__()</span></code> y a buscadores de la misma forma que <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.path</span></code></a> pero sólo para el paquete. No está establecido en módulos que no son paquetes, por lo que puede ser usado como un indicador si el módulo es un paquete.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a></dt><dd><p>El nombre completo del paquete bajo el cual está el módulo (o la cadena de caracteres vacía para los módulos de nivel superior). Si el módulo es un paquete es lo mismo que <a class="reference internal" href="../reference/import.html#name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a></dt><dd><p>El <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">cargador</span></a> usado para cargar el módulo.</p>
</dd>
</dl>
</li>
</ul>
<p>Cuando <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> está disponible, se proporciona una funcionalidad compatible con versiones anteriores.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> cuando se llama en lugar de <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>. Funcionalidad proporcionada cuando <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> está disponible.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>La API recomendada para cargar un módulo es <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> (y <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>). Los cargadores deberían implementarlo en lugar de <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_module()</span></code></a>. La maquinaria de importación se encarga de todas las demás responsabilidades de <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_module()</span></code></a> cuando se implementa <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Loader.module_repr">
<span class="sig-name descname"><span class="pre">module_repr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.module_repr" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método heredado que, cuando se implementa, calcula y retorna la representación del módulo dado, como una cadena. El método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code> predeterminado del tipo de módulo utilizará el resultado de este método según corresponda.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Hecho opcional en vez de un método abstracto (<em>abstractmethod</em>)</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>La maquinaria de importación ahora se encarga de esto automáticamente.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.ResourceLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">ResourceLoader</span></span><a class="headerlink" href="#importlib.abc.ResourceLoader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase base abstracta para un <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> que implementa el protocolo opcional <span class="target" id="index-41"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> para cargar recursos arbitrarios desde el back-end de almacenamiento.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.7: </span>Este ABC está en desuso a favor de admitir la carga de recursos a través de <a class="reference internal" href="importlib.resources.abc.html#importlib.resources.abc.ResourceReader" title="importlib.resources.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.resources.abc.ResourceReader</span></code></a>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.ResourceLoader.get_data">
<em class="property"><span class="pre">abstractmethod</span> </em><span class="sig-name descname"><span class="pre">get_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceLoader.get_data" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método abstracto para devolver los bytes de los datos ubicados en <em>path</em>. Los cargadores que tienen un back-end de almacenamiento similar a un archivo que permite almacenar datos arbitrarios pueden implementar este método abstracto para dar acceso directo a los datos almacenados. <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> se lanza si no se puede encontrar el <em>path</em>. Se espera que la <em>path</em> se construya utilizando el atributo <a class="reference internal" href="../reference/import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> de un módulo o un elemento de un paquete <a class="reference internal" href="../reference/import.html#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Lanza <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> en vez de <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.InspectLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">InspectLoader</span></span><a class="headerlink" href="#importlib.abc.InspectLoader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase base abstracta para un <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> que implementa el protocolo opcional <span class="target" id="index-42"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> para cargadores que inspeccionan módulos.</p>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.InspectLoader.get_code">
<span class="sig-name descname"><span class="pre">get_code</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.get_code" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el objeto código para un módulo, o <code class="docutils literal notranslate"><span class="pre">None</span></code> si el módulo no tiene un objeto código (como sería el caso, por ejemplo, para un módulo integrado). Lanza un <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> si el cargador no puede encontrar el módulo solicitado.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si bien el método tiene una implementación predeterminada, se sugiere que se anule si es posible para mejorar el rendimiento.</p>
</div>
<div class="versionchanged" id="index-16">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Ya no es un método abstracto y se proporciona una implementación concreta.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.InspectLoader.get_source">
<em class="property"><span class="pre">abstractmethod</span> </em><span class="sig-name descname"><span class="pre">get_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.get_source" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método abstracto para retornar la fuente de un módulo. Se retorna como una cadena de caracteres de texto usando <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a>, traduciendo todos los separadores de línea reconocidos en caracteres <code class="docutils literal notranslate"><span class="pre">'</span>
<span class="pre">'</span></code>. Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si no hay una fuente disponible (por ejemplo, un módulo integrado). Lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> si el cargador no puede encontrar el módulo especificado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> en vez de <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.InspectLoader.is_package">
<span class="sig-name descname"><span class="pre">is_package</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.is_package" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método opcional para retornar un valor verdadero si el módulo es un paquete, un valor falso en caso contrario. Se lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> si el <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">cargador</span></a> no puede encontrar el módulo.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> en vez de <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.InspectLoader.source_to_code">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">source_to_code</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'&lt;string&gt;'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.source_to_code" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Cree un objeto de código a partir de la fuente de Python.</p>
<p>El argumento <em>data</em> puede ser cualquier cosa que admita la función <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> (es decir, cadena de caracteres o bytes). El argumento <em>path</em> debe ser la «ruta» de donde se originó el código fuente, que puede ser un concepto abstracto (por ejemplo, ubicación en un archivo zip).</p>
<p>Con el objeto de código subsiguiente, uno puede ejecutarlo en un módulo ejecutando <code class="docutils literal notranslate"><span class="pre">exec(code,</span> <span class="pre">module.__dict__)</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Hace el método estático.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.InspectLoader.exec_module">
<span class="sig-name descname"><span class="pre">exec_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.exec_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Implementación de <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.InspectLoader.load_module">
<span class="sig-name descname"><span class="pre">load_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.load_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Implementación de <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.load_module()</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>use <a class="reference internal" href="#importlib.abc.InspectLoader.exec_module" title="importlib.abc.InspectLoader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.ExecutionLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">ExecutionLoader</span></span><a class="headerlink" href="#importlib.abc.ExecutionLoader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase base abstracta que hereda de <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">InspectLoader</span></code></a> que, cuando se implementa, ayuda a que un módulo se ejecute como un script. El ABC representa un protocolo opcional <span class="target" id="index-43"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.ExecutionLoader.get_filename">
<em class="property"><span class="pre">abstractmethod</span> </em><span class="sig-name descname"><span class="pre">get_filename</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ExecutionLoader.get_filename" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método abstracto que retorna el valor de <a class="reference internal" href="../reference/import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> para el módulo especificado. Si no hay una ruta disponible, se lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>.</p>
<p>Si el código fuente está disponible, entonces el método debe devolver la ruta al archivo fuente, independientemente de si se utilizó un código de bytes para cargar el módulo.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> en vez de <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.FileLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">FileLoader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase base abstracta que hereda de <a class="reference internal" href="#importlib.abc.ResourceLoader" title="importlib.abc.ResourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResourceLoader</span></code></a> y <a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExecutionLoader</span></code></a>, proporcionando implementaciones concretas de <a class="reference internal" href="#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ResourceLoader.get_data()</span></code></a> y <a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a>.</p>
<p>El argumento <em>fullname</em> es un nombre completamente resuelto del módulo que el cargador debe manejar. El argumento <em>path</em> es la ruta al archivo del módulo.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.abc.FileLoader.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#importlib.abc.FileLoader.name" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El nombre del módulo que puede manejar el cargador.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.abc.FileLoader.path">
<span class="sig-name descname"><span class="pre">path</span></span><a class="headerlink" href="#importlib.abc.FileLoader.path" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Ruta al archivo del módulo.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.FileLoader.load_module">
<span class="sig-name descname"><span class="pre">load_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.load_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llama a super’s <code class="docutils literal notranslate"><span class="pre">load_module()</span></code>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>Utilice <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.FileLoader.get_filename">
<em class="property"><span class="pre">abstractmethod</span> </em><span class="sig-name descname"><span class="pre">get_filename</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.get_filename" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="#importlib.abc.FileLoader.path" title="importlib.abc.FileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.FileLoader.get_data">
<em class="property"><span class="pre">abstractmethod</span> </em><span class="sig-name descname"><span class="pre">get_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.get_data" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Lee <em>path</em> como un archivo binario y devuelve los bytes de él.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">SourceLoader</span></span><a class="headerlink" href="#importlib.abc.SourceLoader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase base abstracta para implementar la carga de archivos fuente (y opcionalmente bytecode). La clase hereda tanto de <a class="reference internal" href="#importlib.abc.ResourceLoader" title="importlib.abc.ResourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResourceLoader</span></code></a> como de <a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExecutionLoader</span></code></a>, lo que requiere la implementación de:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ResourceLoader.get_data()</span></code></a></p></li>
<li><dl class="simple">
<dt><a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a></dt><dd><p>Solo debe devolver la ruta al archivo de origen; la carga sin fuente no es compatible.</p>
</dd>
</dl>
</li>
</ul>
<p>Los métodos abstractos definidos por esta clase son para agregar soporte de archivo de código de bytes opcional. No implementar estos métodos opcionales (o hacer que se lance <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>) hace que el cargador solo funcione con el código fuente. La implementación de los métodos permite que el cargador trabaje con archivos fuente <em>y</em> código de bytes; no permite la carga <em>sin fuente</em> donde solo se proporciona un código de bytes. Los archivos de código de bytes son una optimización para acelerar la carga al eliminar el paso de análisis del compilador de Python, por lo que no se expone ninguna API específica de código de bytes.</p>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.path_stats">
<span class="sig-name descname"><span class="pre">path_stats</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.path_stats" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Método abstracto opcional que devuelve un <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> que contiene metadatos sobre la ruta especificada. Las claves de diccionario admitidas son:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'mtime'</span></code> (obligatorio): un número entero o de punto flotante que representa la hora de modificación del código fuente;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'size'</span></code> (opcional): el tamaño en bytes del código fuente.</p></li>
</ul>
<p>Cualquier otra clave del diccionario se ignora para permitir futuras extensiones. Si no se puede manejar la ruta, se genera <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Lanza <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> en vez de <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.path_mtime">
<span class="sig-name descname"><span class="pre">path_mtime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.path_mtime" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Método abstracto opcional que retorna la hora de modificación de la ruta especificada.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.3: </span>Este método está obsoleto en favor de <a class="reference internal" href="#importlib.abc.SourceLoader.path_stats" title="importlib.abc.SourceLoader.path_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">path_stats()</span></code></a>. No tiene que implementarlo, pero aún está disponible para fines de compatibilidad. Lanza <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> si la ruta no se puede manejar.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Lanza <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> en vez de <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.set_data">
<span class="sig-name descname"><span class="pre">set_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.set_data" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Método abstracto opcional que escribe los bytes especificados en una ruta de archivo. Los directorios intermedios que no existan se crearán automáticamente.</p>
<p>Cuando la escritura en la ruta falla porque la ruta es de solo lectura (<a class="reference internal" href="errno.html#errno.EACCES" title="errno.EACCES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errno.EACCES</span></code></a>/<a class="reference internal" href="exceptions.html#PermissionError" title="PermissionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PermissionError</span></code></a>), no propague la excepción.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Ya no lanza <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> cuando se llama.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.get_code">
<span class="sig-name descname"><span class="pre">get_code</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.get_code" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Implementación concreta de <a class="reference internal" href="#importlib.abc.InspectLoader.get_code" title="importlib.abc.InspectLoader.get_code"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.get_code()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.exec_module">
<span class="sig-name descname"><span class="pre">exec_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.exec_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Implementación concreta de <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.load_module">
<span class="sig-name descname"><span class="pre">load_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.load_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Implementación concreta de <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.load_module()</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>Utilice <a class="reference internal" href="#importlib.abc.SourceLoader.exec_module" title="importlib.abc.SourceLoader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.get_source">
<span class="sig-name descname"><span class="pre">get_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.get_source" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Implementación concreta de <a class="reference internal" href="#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.get_source()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.is_package">
<span class="sig-name descname"><span class="pre">is_package</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.is_package" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Implementación concreta de <a class="reference internal" href="#importlib.abc.InspectLoader.is_package" title="importlib.abc.InspectLoader.is_package"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.is_package()</span></code></a>. Se determina que un módulo es un paquete si su ruta de archivo (proporcionada por <a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a>) es un archivo llamado <code class="docutils literal notranslate"><span class="pre">__init__</span></code> cuando se elimina la extensión del archivo <strong>y</strong> el nombre del módulo sí lo hace no termina en <code class="docutils literal notranslate"><span class="pre">__init__</span></code>.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-importlib.machinery">
<span id="importlib-machinery-importers-and-path-hooks"></span><h2><a class="reference internal" href="#module-importlib.machinery" title="importlib.machinery: Importers and path hooks"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.machinery</span></code></a> – Importadores y enlaces de ruta<a class="headerlink" href="#module-importlib.machinery" title="Enlazar permanentemente con este título">¶</a></h2>
<p><strong>Código fuente:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.11/Lib/importlib/machinery.py">Lib/importlib/machinery.py</a></p>
<hr class="docutils" />
<p>Este módulo contiene varios objetos que ayudan <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> buscar y cargar módulos.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.SOURCE_SUFFIXES">
<span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">SOURCE_SUFFIXES</span></span><a class="headerlink" href="#importlib.machinery.SOURCE_SUFFIXES" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una lista de cadenas de caracteres que representan los sufijos de archivo reconocidos para los módulos de origen.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.DEBUG_BYTECODE_SUFFIXES">
<span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">DEBUG_BYTECODE_SUFFIXES</span></span><a class="headerlink" href="#importlib.machinery.DEBUG_BYTECODE_SUFFIXES" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una lista de cadenas que representan los sufijos de archivo para módulos de código de bytes no optimizados.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.5: </span>Utilice <a class="reference internal" href="#importlib.machinery.BYTECODE_SUFFIXES" title="importlib.machinery.BYTECODE_SUFFIXES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BYTECODE_SUFFIXES</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES">
<span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">OPTIMIZED_BYTECODE_SUFFIXES</span></span><a class="headerlink" href="#importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una lista de cadenas de caracteres que representan los sufijos de archivo para módulos de código de bytes optimizados.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.5: </span>Utilice <a class="reference internal" href="#importlib.machinery.BYTECODE_SUFFIXES" title="importlib.machinery.BYTECODE_SUFFIXES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BYTECODE_SUFFIXES</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.BYTECODE_SUFFIXES">
<span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">BYTECODE_SUFFIXES</span></span><a class="headerlink" href="#importlib.machinery.BYTECODE_SUFFIXES" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una lista de cadenas de caracteres que representan los sufijos de archivo reconocidos para los módulos de código de bytes (incluido el punto inicial).</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>El valor ya no depende de <code class="docutils literal notranslate"><span class="pre">__debug__</span></code>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.EXTENSION_SUFFIXES">
<span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">EXTENSION_SUFFIXES</span></span><a class="headerlink" href="#importlib.machinery.EXTENSION_SUFFIXES" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una lista de cadenas de caracteres que representan los sufijos de archivo reconocidos para los módulos de extensión.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.machinery.all_suffixes">
<span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">all_suffixes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.all_suffixes" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una lista combinada de cadenas de caracteres que representan todos los sufijos de archivo para módulos reconocidos por la maquinaria de importación estándar. Este es un ayudante para el código que simplemente necesita saber si una ruta del sistema de archivos potencialmente se refiere a un módulo sin necesidad de detalles sobre el tipo de módulo (por ejemplo, <a class="reference internal" href="inspect.html#inspect.getmodulename" title="inspect.getmodulename"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getmodulename()</span></code></a>).</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.BuiltinImporter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">BuiltinImporter</span></span><a class="headerlink" href="#importlib.machinery.BuiltinImporter" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a> para módulos integrados. Todos los módulos integrados conocidos se enumeran en <a class="reference internal" href="sys.html#sys.builtin_module_names" title="sys.builtin_module_names"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.builtin_module_names</span></code></a>. Esta clase implementa los ABC <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> y <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader</span></code></a>.</p>
<p>Esta clase solo define los métodos de clase para aliviar la necesidad de instanciación.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Como parte de <span class="target" id="index-44"></span><a class="pep reference external" href="https://peps.python.org/pep-0489/"><strong>PEP 489</strong></a>, el importador integrado ahora implementa <code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.create_module()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.FrozenImporter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">FrozenImporter</span></span><a class="headerlink" href="#importlib.machinery.FrozenImporter" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a> para módulos congelados. Esta clase implementa los ABC <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> y <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader</span></code></a>.</p>
<p>Esta clase solo define los métodos de clase para aliviar la necesidad de instanciación.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Métodos obtenidos <code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.WindowsRegistryFinder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">WindowsRegistryFinder</span></span><a class="headerlink" href="#importlib.machinery.WindowsRegistryFinder" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">Finder</span></a> para los módulos declarados en el registro de Windows. Esta clase implementa el <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> ABC.</p>
<p>Esta clase solo define los métodos de clase para aliviar la necesidad de instanciación.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.6: </span>Utilice la configuración de <a class="reference internal" href="site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> en su lugar. Es posible que las versiones futuras de Python no habiliten este buscador de forma predeterminada.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.PathFinder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">PathFinder</span></span><a class="headerlink" href="#importlib.machinery.PathFinder" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">Finder</span></a> para <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> y atributos del paquete <code class="docutils literal notranslate"><span class="pre">__path__</span></code>. Esta clase implementa el <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> ABC.</p>
<p>Esta clase solo define los métodos de clase para aliviar la necesidad de instanciación.</p>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.PathFinder.find_spec">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">find_spec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.find_spec" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Método de clase que intenta encontrar un <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a> para el módulo especificado por <em>fullname</em> en <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> o, si está definido, en <em>path</em>. Para cada entrada de ruta que se busca, se comprueba <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>. Si se encuentra un objeto que no es falso, se utiliza como <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a> para buscar el módulo que se está buscando. Si no se encuentra ninguna entrada en <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>, entonces <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> se busca un buscador para la entrada de ruta y, si se encuentra, se almacena en <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> junto con ser consultado sobre el módulo. Si nunca se encuentra ningún buscador, entonces <code class="docutils literal notranslate"><span class="pre">None</span></code> se almacena en el caché y se retorna.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Si el directorio de trabajo actual, representado por una cadena de caracteres vacía, ya no es válido, se retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> pero no se almacena ningún valor en <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.PathFinder.find_module">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">find_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.find_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una envoltura heredada alrededor de <a class="reference internal" href="#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>Use <a class="reference internal" href="#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.PathFinder.invalidate_caches">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">invalidate_caches</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.invalidate_caches" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llama <a class="reference internal" href="#importlib.abc.PathEntryFinder.invalidate_caches" title="importlib.abc.PathEntryFinder.invalidate_caches"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder.invalidate_caches()</span></code></a> en todos los buscadores almacenados en <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> que definen el método. De lo contrario, las entradas en <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> establecidas en <code class="docutils literal notranslate"><span class="pre">None</span></code> se eliminan.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Se eliminan las entradas de <code class="docutils literal notranslate"><span class="pre">None</span></code> en <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>.</p>
</div>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Llama a objetos en <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> con el directorio de trabajo actual para <code class="docutils literal notranslate"><span class="pre">''</span></code> (es decir, la cadena de caracteres vacía).</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.FileFinder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">FileFinder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">loader_details</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una implementación concreta de <a class="reference internal" href="#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder</span></code></a> que almacena en caché los resultados del sistema de archivos.</p>
<p>El argumento <em>path</em> es el directorio que el buscador se encarga de buscar.</p>
<p>El argumento <em>loader_details</em> es un número variable de tuplas de 2 elementos, cada una de las cuales contiene un cargador y una secuencia de sufijos de archivo que el cargador reconoce. Se espera que los cargadores sean invocables que acepten dos argumentos del nombre del módulo y la ruta al archivo encontrado.</p>
<p>El buscador almacenará en caché el contenido del directorio según sea necesario, haciendo llamadas estadísticas para cada búsqueda de módulo para verificar que la caché no esté desactualizada. Debido a que la obsolescencia de la caché se basa en la granularidad de la información de estado del sistema operativo del sistema de archivos, existe una condición de carrera potencial de buscar un módulo, crear un nuevo archivo y luego buscar el módulo que representa el nuevo archivo. Si las operaciones ocurren lo suficientemente rápido como para ajustarse a la granularidad de las llamadas estadísticas, la búsqueda del módulo fallará. Para evitar que esto suceda, cuando cree un módulo dinámicamente, asegúrese de llamar a <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.invalidate_caches()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.FileFinder.path">
<span class="sig-name descname"><span class="pre">path</span></span><a class="headerlink" href="#importlib.machinery.FileFinder.path" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La ruta en la que buscará el buscador.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.FileFinder.find_spec">
<span class="sig-name descname"><span class="pre">find_spec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.find_spec" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Intente encontrar la especificación para manejar <em>fullname</em> dentro de <a class="reference internal" href="#importlib.machinery.FileFinder.path" title="importlib.machinery.FileFinder.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.FileFinder.find_loader">
<span class="sig-name descname"><span class="pre">find_loader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.find_loader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Intente encontrar el cargador para manejar <em>fullname</em> dentro de <a class="reference internal" href="#importlib.machinery.FileFinder.path" title="importlib.machinery.FileFinder.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.10: </span>Use <a class="reference internal" href="#importlib.machinery.FileFinder.find_spec" title="importlib.machinery.FileFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.FileFinder.invalidate_caches">
<span class="sig-name descname"><span class="pre">invalidate_caches</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.invalidate_caches" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Borrar el caché interno.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.FileFinder.path_hook">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">path_hook</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">loader_details</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.path_hook" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método de clase que devuelve un cierre para su uso en <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>. Una instancia de <a class="reference internal" href="#importlib.machinery.FileFinder" title="importlib.machinery.FileFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileFinder</span></code></a> es retornada por el cierre usando el argumento de ruta dado al cierre directamente y <em>loader_details</em> indirectamente.</p>
<p>Si el argumento del cierre no es un directorio existente, se lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.SourceFileLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">SourceFileLoader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una implementación concreta de <a class="reference internal" href="#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader</span></code></a> subclasificando <a class="reference internal" href="#importlib.abc.FileLoader" title="importlib.abc.FileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.FileLoader</span></code></a> y proporcionando algunas implementaciones concretas de otros métodos.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.SourceFileLoader.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.name" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El nombre del módulo que manejará este cargador.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.SourceFileLoader.path">
<span class="sig-name descname"><span class="pre">path</span></span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.path" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La ruta al archivo de origen.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourceFileLoader.is_package">
<span class="sig-name descname"><span class="pre">is_package</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.is_package" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Devuelve <code class="docutils literal notranslate"><span class="pre">True</span></code> si <a class="reference internal" href="#importlib.machinery.SourceFileLoader.path" title="importlib.machinery.SourceFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a> parece ser para un paquete.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourceFileLoader.path_stats">
<span class="sig-name descname"><span class="pre">path_stats</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.path_stats" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Implementación concreta de <a class="reference internal" href="#importlib.abc.SourceLoader.path_stats" title="importlib.abc.SourceLoader.path_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader.path_stats()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourceFileLoader.set_data">
<span class="sig-name descname"><span class="pre">set_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.set_data" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Implementación concreta de <a class="reference internal" href="#importlib.abc.SourceLoader.set_data" title="importlib.abc.SourceLoader.set_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader.set_data()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourceFileLoader.load_module">
<span class="sig-name descname"><span class="pre">load_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.load_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Implementación concreta de <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> donde especificar el nombre del módulo a cargar es opcional.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.6: </span>Utilice <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.SourcelessFileLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">SourcelessFileLoader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una implementación concreta de <a class="reference internal" href="#importlib.abc.FileLoader" title="importlib.abc.FileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.FileLoader</span></code></a> que puede importar archivos de código de bytes (es decir, no existen archivos de código fuente).</p>
<p>Tenga en cuenta que el uso directo de archivos de código de bytes (y, por lo tanto, no de archivos de código fuente) impide que sus módulos sean utilizables por todas las implementaciones de Python o las nuevas versiones de Python que cambian el formato de código de bytes.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.SourcelessFileLoader.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.name" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El nombre del módulo que manejará el cargador.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.SourcelessFileLoader.path">
<span class="sig-name descname"><span class="pre">path</span></span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.path" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La ruta al archivo de código de bytes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourcelessFileLoader.is_package">
<span class="sig-name descname"><span class="pre">is_package</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.is_package" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Determina si el módulo es un paquete basado en <a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.path" title="importlib.machinery.SourcelessFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourcelessFileLoader.get_code">
<span class="sig-name descname"><span class="pre">get_code</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.get_code" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el objeto de código para <a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.name" title="importlib.machinery.SourcelessFileLoader.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a> creado a partir de <a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.path" title="importlib.machinery.SourcelessFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourcelessFileLoader.get_source">
<span class="sig-name descname"><span class="pre">get_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.get_source" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Devuelve <code class="docutils literal notranslate"><span class="pre">None</span></code> ya que los archivos de código de bytes no tienen fuente cuando se usa este cargador.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourcelessFileLoader.load_module">
<span class="sig-name descname"><span class="pre">load_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.load_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<p>Implementación concreta de <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> donde especificar el nombre del módulo a cargar es opcional.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.6: </span>Utilice <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">ExtensionFileLoader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una implementación concreta de <a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ExecutionLoader</span></code></a> para módulos de extensión.</p>
<p>El argumento <em>fullname</em> especifica el nombre del módulo que el cargador debe admitir. El argumento <em>path</em> es la ruta al archivo del módulo de extensión.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.name" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Nombre del módulo que admite el cargador.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.path">
<span class="sig-name descname"><span class="pre">path</span></span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.path" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Ruta al módulo de extensión.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.create_module">
<span class="sig-name descname"><span class="pre">create_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.create_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea el objeto de módulo a partir de la especificación dada de acuerdo con <span class="target" id="index-45"></span><a class="pep reference external" href="https://peps.python.org/pep-0489/"><strong>PEP 489</strong></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.exec_module">
<span class="sig-name descname"><span class="pre">exec_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.exec_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Inicializa el objeto de módulo dado de acuerdo con <span class="target" id="index-46"></span><a class="pep reference external" href="https://peps.python.org/pep-0489/"><strong>PEP 489</strong></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.is_package">
<span class="sig-name descname"><span class="pre">is_package</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.is_package" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si la ruta del archivo apunta al módulo <code class="docutils literal notranslate"><span class="pre">__init__</span></code> de un paquete basado en <a class="reference internal" href="#importlib.machinery.EXTENSION_SUFFIXES" title="importlib.machinery.EXTENSION_SUFFIXES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">EXTENSION_SUFFIXES</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.get_code">
<span class="sig-name descname"><span class="pre">get_code</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_code" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> ya que los módulos de extensión carecen de un objeto de código.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.get_source">
<span class="sig-name descname"><span class="pre">get_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_source" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> ya que los módulos de extensión no tienen código fuente.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.get_filename">
<span class="sig-name descname"><span class="pre">get_filename</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_filename" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="#importlib.machinery.ExtensionFileLoader.path" title="importlib.machinery.ExtensionFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">NamespaceLoader(name,</span> <span class="pre">path,</span> <span class="pre">path_finder):</span></span></dt>
<dd><p>Una implementación concreta de <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader</span></code></a> para paquetes de espacio de nombres. Ésta es un alias para una clase privada y sólo se hace pública para introspeccionar el atributo <code class="docutils literal notranslate"><span class="pre">__loader__</span></code> en paquetes de espacio de nombres:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">importlib.machinery</span> <span class="kn">import</span> <span class="n">NamespaceLoader</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">my_namespace</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">my_namespace</span><span class="o">.</span><span class="n">__loader__</span><span class="p">,</span> <span class="n">NamespaceLoader</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">importlib.abc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">my_namespace</span><span class="o">.</span><span class="n">__loader__</span><span class="p">,</span> <span class="n">importlib</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Loader</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.11.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">ModuleSpec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loader</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loader_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_package</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ModuleSpec" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una especificación para el estado relacionado con el sistema de importación de un módulo. Esto generalmente se expone como el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__`</span></code> del módulo. En las descripciones siguientes, los nombres entre paréntesis dan el atributo correspondiente disponible directamente en el objeto del módulo, por ejemplo, <code class="docutils literal notranslate"><span class="pre">module.__spec__.origin</span> <span class="pre">==</span> <span class="pre">module.__file__</span></code>. Sin embargo, tenga en cuenta que, si bien los <em>valores</em> suelen ser equivalentes, pueden diferir ya que no hay sincronización entre los dos objetos. Por ejemplo, es posible actualizar el  <a class="reference internal" href="../reference/import.html#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> del módulo en tiempo de ejecución, y esto no se reflejará automáticamente en el <code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__.origin</span></code> del módulo, y viceversa.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#importlib.machinery.ModuleSpec.name" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<p>(<a class="reference internal" href="../reference/import.html#name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a>)</p>
<p>El nombre completo del módulo. El <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">buscador</span></a> debe siempre establecer este atributo a una cadena de caracteres no vacía.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.loader">
<span class="sig-name descname"><span class="pre">loader</span></span><a class="headerlink" href="#importlib.machinery.ModuleSpec.loader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<p>(<a class="reference internal" href="../reference/import.html#loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a>)</p>
<p>El <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">Cargador</span></a> que debe usarse para cargar el módulo. El <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">Buscador</span></a> siempre debe establecer este atributo.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.origin">
<span class="sig-name descname"><span class="pre">origin</span></span><a class="headerlink" href="#importlib.machinery.ModuleSpec.origin" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<p>(<a class="reference internal" href="../reference/import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a>)</p>
<p>La ubicación que el <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">cargador</span></a> debe usar para cargar el módulo. Por ejemplo, para módulos cargados de archivos .py éste es el nombre del archivo. El <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">buscador</span></a> debe siempre establecer este atributo a un valor significativo para que el <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">cargador</span></a> lo use. El en caso poco común de que no hay uno (como para paquetes de nombre de espacio), debe estar establecido en <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.submodule_search_locations">
<span class="sig-name descname"><span class="pre">submodule_search_locations</span></span><a class="headerlink" href="#importlib.machinery.ModuleSpec.submodule_search_locations" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<p>(<a class="reference internal" href="../reference/import.html#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a>)</p>
<p>La lista de ubicaciones donde los sub-módulos del paquete serán encontrados. La mayoría de las veces es un solo directorio. El <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">buscador</span></a> debe establecer este atributo a una lista, incluso una vacía, para indicar al sistema de importación que el módulo es un paquete. Debe ser establecido en <code class="docutils literal notranslate"><span class="pre">None</span></code> para módulos que no son paquetes. Es establecido automáticamente más tarde a un objeto especial para paquetes de espacio de nombres.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.loader_state">
<span class="sig-name descname"><span class="pre">loader_state</span></span><a class="headerlink" href="#importlib.machinery.ModuleSpec.loader_state" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<p>El <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">buscador</span></a> podría establecer este atributo a un objeto conteniendo datos adicionales y específicos al módulo para usar cuando se carga el módulo.. De lo contrario, debe establecerse en <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.cached">
<span class="sig-name descname"><span class="pre">cached</span></span><a class="headerlink" href="#importlib.machinery.ModuleSpec.cached" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<p>(<a class="reference internal" href="../reference/import.html#cached__" title="__cached__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code></a>)</p>
<p>El nombre de archivo de una versión compilada del código de el módulo. El <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">buscador</span></a> siempre debe establecer este atributo pero puede ser <code class="docutils literal notranslate"><span class="pre">None</span></code> para módulos que no necesitan guardar código compilado.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.parent">
<span class="sig-name descname"><span class="pre">parent</span></span><a class="headerlink" href="#importlib.machinery.ModuleSpec.parent" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<p>(<a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a>)</p>
<p>(Solo lectura) El nombre completo del paquete bajo el cual está este módulo (o la cadena de caracteres vacía para los módulos de nivel superior). Si el módulo es un paquete es lo mismo que <a class="reference internal" href="../reference/import.html#name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.has_location">
<span class="sig-name descname"><span class="pre">has_location</span></span><a class="headerlink" href="#importlib.machinery.ModuleSpec.has_location" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">True</span></code> si el <a class="reference internal" href="#importlib.machinery.ModuleSpec.origin" title="importlib.machinery.ModuleSpec.origin"><code class="xref py py-attr docutils literal notranslate"><span class="pre">origin</span></code></a> de la especificación se refiere a una ubicación cargable,</dt><dd><p><code class="docutils literal notranslate"><span class="pre">False</span></code> en caso contrario. Este valor impacta en cómo <a class="reference internal" href="#importlib.machinery.ModuleSpec.origin" title="importlib.machinery.ModuleSpec.origin"><code class="xref py py-attr docutils literal notranslate"><span class="pre">origin</span></code></a> es interpretado y cómo el atributo <a class="reference internal" href="../reference/import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> del módulo es poblado.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-importlib.util">
<span id="importlib-util-utility-code-for-importers"></span><h2><a class="reference internal" href="#module-importlib.util" title="importlib.util: Utility code for importers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code></a> – Código de utilidad para importadores<a class="headerlink" href="#module-importlib.util" title="Enlazar permanentemente con este título">¶</a></h2>
<p><strong>Código fuente:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.11/Lib/importlib/util.py">Lib/importlib/util.py</a></p>
<hr class="docutils" />
<p>Este módulo contiene los diversos objetos que ayudan en la construcción de un <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.util.MAGIC_NUMBER">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">MAGIC_NUMBER</span></span><a class="headerlink" href="#importlib.util.MAGIC_NUMBER" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Los bytes que representan el número de versión del código de bytes. Si necesita ayuda para cargar/escribir código de bytes, considere <a class="reference internal" href="#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.cache_from_source">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">cache_from_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">debug_override</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.cache_from_source" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la ruta <span class="target" id="index-47"></span><a class="pep reference external" href="https://peps.python.org/pep-3147/"><strong>PEP 3147</strong></a>/<span class="target" id="index-48"></span><a class="pep reference external" href="https://peps.python.org/pep-0488/"><strong>PEP 488</strong></a> al archivo compilado por bytes asociado con la <em>path</em> de origen. Por ejemplo, si <em>path</em> es <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code>, el valor de retorno sería <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code> para Python 3.2. La cadena de caracteres <code class="docutils literal notranslate"><span class="pre">cpython-32</span></code> proviene de la etiqueta mágica actual (ver <code class="xref py py-func docutils literal notranslate"><span class="pre">get_tag()</span></code>; si <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.implementation.cache_tag</span></code> no está definido, se lanzará <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>).</p>
<p>El parámetro <em>optimization</em> se utiliza para especificar el nivel de optimización del archivo de código de bytes. Una cadena de caracteres vacía no representa optimización, por lo que <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code> con una <em>optimization</em> de <code class="docutils literal notranslate"><span class="pre">''</span></code> dará como resultado una ruta de código de bytes de <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code>. <code class="docutils literal notranslate"><span class="pre">None</span></code> hace que se utilice el nivel de optimización del intérprete. Se usa la representación de cadena de caracteres de cualquier otro valor, por lo que <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code> con una <em>optimization</em> de <code class="docutils literal notranslate"><span class="pre">2</span></code> conducirá a la ruta del código de bytes de <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc</span></code>. La representación de cadena de caracteres <em>optimization</em> solo puede ser alfanumérica, de lo contrario se lanza <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
<p>El parámetro <em>debug_override</em> está obsoleto y se puede usar para anular el valor del sistema para <code class="docutils literal notranslate"><span class="pre">__debug__</span></code>. Un valor <code class="docutils literal notranslate"><span class="pre">True</span></code> es el equivalente a establecer <em>optimization</em> en la cadena de caracteres vacía. Un valor <code class="docutils literal notranslate"><span class="pre">False</span></code> es lo mismo que establecer <em>optimization</em> en <code class="docutils literal notranslate"><span class="pre">1</span></code>. Si tanto <em>debug_override</em> como <em>optimization</em> no es <code class="docutils literal notranslate"><span class="pre">None</span></code>, entonces se lanza <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Se agregó el parámetro <em>optimization</em> y el parámetro <em>debug_override</em> quedó obsoleto.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Acepta un <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.source_from_cache">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">source_from_cache</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.source_from_cache" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Dado el <em>path</em> a un nombre de archivo <span class="target" id="index-49"></span><a class="pep reference external" href="https://peps.python.org/pep-3147/"><strong>PEP 3147</strong></a>, retorna la ruta del archivo del código fuente asociado. Por ejemplo, si <em>path</em> es <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code>, la ruta retornada sería <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code>. <em>path</em> no necesita existir, sin embargo, si no se ajusta al formato <span class="target" id="index-50"></span><a class="pep reference external" href="https://peps.python.org/pep-3147/"><strong>PEP 3147</strong></a> o <span class="target" id="index-51"></span><a class="pep reference external" href="https://peps.python.org/pep-0488/"><strong>PEP 488</strong></a>, se lanza un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>. Si <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.implementation.cache_tag</span></code> no está definido, se lanza <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Acepta un <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.decode_source">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">decode_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_bytes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.decode_source" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Decodifica los bytes dados que representan el código fuente y los retorna como una cadena de caracteres con nuevas líneas universales (como lo requiere <a class="reference internal" href="#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader.get_source()</span></code></a>).</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.resolve_name">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">resolve_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">package</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.resolve_name" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Resuelve un nombre de módulo relativo a uno absoluto.</p>
<p>Si <strong>name</strong> no tiene puntos iniciales, entonces <strong>name</strong> simplemente se retorna. Esto permite el uso como <code class="docutils literal notranslate"><span class="pre">importlib.util.resolve_name('sys',</span> <span class="pre">__spec__.parent)</span></code> sin hacer una verificación para ver si se necesita el argumento <strong>package</strong>.</p>
<p><a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> se lanza si <strong>name</strong> es un nombre de módulo relativo pero <strong>package</strong> es un valor falso (por ejemplo, <code class="docutils literal notranslate"><span class="pre">None</span></code> o la cadena de caracteres vacía). También se lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> si un nombre relativo escaparía del paquete que lo contiene (por ejemplo, solicitando <code class="docutils literal notranslate"><span class="pre">..bacon</span></code> desde el paquete <code class="docutils literal notranslate"><span class="pre">spam</span></code>).</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.9: </span>Para mejorar la coherencia con las declaraciones de importación, aumente <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> en lugar de <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> para intentos de importación relativa no válidos.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.find_spec">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">find_spec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">package</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.find_spec" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Busca el <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a> para un módulo, opcionalmente relativo al nombre del <strong>package</strong> especificado. Si el módulo está en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, se retorna <code class="docutils literal notranslate"><span class="pre">sys.modules[name].__spec__</span></code> (a menos que la especificación sea <code class="docutils literal notranslate"><span class="pre">None</span></code> o no esté establecida, en cuyo caso se lanza <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>). De lo contrario, se realiza una búsqueda utilizando <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>. Se retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si no se encuentra ninguna especificación.</p>
<p>Si <strong>name</strong> es para un submódulo (contiene un punto), el módulo principal se importa automáticamente.</p>
<p><strong>name</strong> y <strong>package</strong> funcionan igual que para <code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Lanza <a class="reference internal" href="exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> en lugar de <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> si <strong>package</strong> no es de hecho un paquete (es decir, carece de un atributo <a class="reference internal" href="../reference/import.html#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a>).</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.module_from_spec">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">module_from_spec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.module_from_spec" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Cree un nuevo módulo basado en <strong>spec</strong> y <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spec.loader.create_module</span></code></a>.</p>
<p>Si <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spec.loader.create_module</span></code></a> no retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>, no se restablecerán los atributos preexistentes. Además, no se lanzará <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> si se activa mientras se accede a <strong>spec</strong> o se establece un atributo en el módulo.</p>
<p>Esta función es preferible a usar <a class="reference internal" href="types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a> para crear un nuevo módulo ya que <strong>spec</strong> se usa para establecer tantos atributos de importación controlados en el módulo como sea posible.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.module_for_loader">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">module_for_loader</span></span><a class="headerlink" href="#importlib.util.module_for_loader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> para <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> para manejar la selección del objeto de módulo adecuado para cargar. Se espera que el método decorado tenga una firma de llamada que tome dos argumentos posicionales (por ejemplo, <code class="docutils literal notranslate"><span class="pre">load_module(self,</span> <span class="pre">module)</span></code>) para los cuales el segundo argumento será el módulo <strong>object</strong> que usará el cargador. Tenga en cuenta que el decorador no funcionará con métodos estáticos debido a la suposición de dos argumentos.</p>
<p>El método decorado tomará el <strong>name</strong> del módulo que se cargará como se esperaba para un <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>. Si el módulo no se encuentra en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, se construye uno nuevo. Independientemente de la procedencia del módulo, <a class="reference internal" href="../reference/import.html#loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> se establece en <strong>self</strong> y <a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> se establece en función de lo que retorna <a class="reference internal" href="#importlib.abc.InspectLoader.is_package" title="importlib.abc.InspectLoader.is_package"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader.is_package()</span></code></a> (si está disponible) . Estos atributos se establecen incondicionalmente para admitir la recarga.</p>
<p>Si el método decorado lanza una excepción y se agrega un módulo a <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, entonces el módulo se eliminará para evitar que un módulo parcialmente inicializado quede en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>. Si el módulo ya estaba en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> entonces se deja solo.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span><a class="reference internal" href="../reference/import.html#loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> y <a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> se configuran automáticamente (cuando es posible).</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Establece <a class="reference internal" href="../reference/import.html#name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a>, <a class="reference internal" href="../reference/import.html#loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> <a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> incondicionalmente para apoyar la recarga.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>La maquinaria de importación ahora realiza directamente toda la funcionalidad proporcionada por esta función.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.set_loader">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">set_loader</span></span><a class="headerlink" href="#importlib.util.set_loader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> para <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> para establecer el atributo <a class="reference internal" href="../reference/import.html#loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> en el módulo retornado. Si el atributo ya está configurado, el decorador no hace nada. Se asume que el primer argumento posicional del método envuelto (es decir, <code class="docutils literal notranslate"><span class="pre">self</span></code>) es lo que se debe establecer en <a class="reference internal" href="../reference/import.html#loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Establece <code class="docutils literal notranslate"><span class="pre">__loader__</span></code> si está configurado como <code class="docutils literal notranslate"><span class="pre">None</span></code>, como si el atributo no existiera.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>La maquinaria de importación se encarga de esto automáticamente.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.set_package">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">set_package</span></span><a class="headerlink" href="#importlib.util.set_package" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> para <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> para establecer el atributo <a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> en el módulo retornado. Si <a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> está configurado y tiene un valor diferente a <code class="docutils literal notranslate"><span class="pre">None</span></code>, no se cambiará.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>La maquinaria de importación se encarga de esto automáticamente.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.spec_from_loader">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">spec_from_loader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loader</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_package</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.spec_from_loader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una función de fábrica para crear una instancia de <a class="reference internal" href="#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code></a> basada en un cargador. Los parámetros tienen el mismo significado que para ModuleSpec. La función utiliza APIs disponibles de <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>, tal como <code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.is_package()</span></code>, para completar cualquier información que falte en la especificación.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.spec_from_file_location">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">spec_from_file_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">location</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">submodule_search_locations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.spec_from_file_location" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una función de fábrica para crear una instancia de <a class="reference internal" href="#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code></a> basada en la ruta a un archivo. La información que falte se completará en la especificación mediante el uso de las API de loader y la implicación de que el módulo estará basado en archivos.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Acepta un <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.source_hash">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">source_hash</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_bytes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.source_hash" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el hash de <em>source_bytes</em> como bytes. Un archivo <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> basado en hash incrusta <a class="reference internal" href="#importlib.util.source_hash" title="importlib.util.source_hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">source_hash()</span></code></a> del contenido del archivo fuente correspondiente en su encabezado.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.util.LazyLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">LazyLoader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loader</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.LazyLoader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase que pospone la ejecución del cargador de un módulo hasta que el módulo tiene acceso a un atributo.</p>
<p>Esta clase <strong>solo</strong> funciona con cargadores que definen <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> ya que se requiere control sobre qué tipo de módulo se usa para el módulo. Por esas mismas razones, el método del cargador <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a> debe retornar <code class="docutils literal notranslate"><span class="pre">None</span></code> o un tipo para el cual su atributo <code class="docutils literal notranslate"><span class="pre">__class__</span></code> se puede mutar junto con no usar <a class="reference internal" href="../glossary.html#term-__slots__"><span class="xref std std-term">slots</span></a>. Finalmente, los módulos que sustituyen el objeto colocado en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.modules</span></code></a> no funcionarán ya que no hay forma de reemplazar correctamente las referencias del módulo en todo el intérprete de forma segura; <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> se genera si se detecta tal sustitución.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Para proyectos donde el tiempo de inicio es crítico, esta clase permite minimizar potencialmente el costo de cargar un módulo si nunca se usa. Para proyectos en los que el tiempo de inicio no es esencial, el uso de esta clase se desaconseja <strong>en gran medida</strong> debido a que los mensajes de error creados durante la carga se posponen y, por lo tanto, ocurren fuera de contexto.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Comenzó a llamar <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>, eliminando la advertencia de compatibilidad para <a class="reference internal" href="#importlib.machinery.BuiltinImporter" title="importlib.machinery.BuiltinImporter"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.BuiltinImporter</span></code></a> y <a class="reference internal" href="#importlib.machinery.ExtensionFileLoader" title="importlib.machinery.ExtensionFileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.ExtensionFileLoader</span></code></a>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.util.LazyLoader.factory">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">factory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loader</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.LazyLoader.factory" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>A class method which returns a callable that creates a lazy loader. This
is meant to be used in situations where the loader is passed by class
instead of by instance.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">suffixes</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SOURCE_SUFFIXES</span>
<span class="n">loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SourceFileLoader</span>
<span class="n">lazy_loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">LazyLoader</span><span class="o">.</span><span class="n">factory</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
<span class="n">finder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">FileFinder</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="p">(</span><span class="n">lazy_loader</span><span class="p">,</span> <span class="n">suffixes</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="examples">
<span id="importlib-examples"></span><h2>Ejemplos<a class="headerlink" href="#examples" title="Enlazar permanentemente con este título">¶</a></h2>
<section id="importing-programmatically">
<h3>Importar programáticamente<a class="headerlink" href="#importing-programmatically" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para importar un módulo mediante programación, use <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib</span>

<span class="n">itertools</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;itertools&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="checking-if-a-module-can-be-imported">
<h3>Comprobando si se puede importar un módulo<a class="headerlink" href="#checking-if-a-module-can-be-imported" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Si necesita averiguar si un módulo se puede importar sin realmente realizar la importación, entonces debe usar <a class="reference internal" href="#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.find_spec()</span></code></a>.</p>
<p>Note que si <code class="docutils literal notranslate"><span class="pre">name</span></code> es un sub-módulo (contiene sólo un punto), <a class="reference internal" href="#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.find_spec()</span></code></a> importará el módulo padre.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># For illustrative purposes.</span>
<span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;itertools&#39;</span>

<span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> already in sys.modules&quot;</span><span class="p">)</span>
<span class="k">elif</span> <span class="p">(</span><span class="n">spec</span> <span class="o">:=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># If you chose to perform the actual import ...</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> has been imported&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;can&#39;t find the </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> module&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="importing-a-source-file-directly">
<h3>Importar un archivo fuente directamente<a class="headerlink" href="#importing-a-source-file-directly" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para importar un archivo fuente de Python directamente, use la siguiente receta:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># For illustrative purposes.</span>
<span class="kn">import</span> <span class="nn">tokenize</span>
<span class="n">file_path</span> <span class="o">=</span> <span class="n">tokenize</span><span class="o">.</span><span class="vm">__file__</span>
<span class="n">module_name</span> <span class="o">=</span> <span class="n">tokenize</span><span class="o">.</span><span class="vm">__name__</span>

<span class="n">spec</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">spec_from_file_location</span><span class="p">(</span><span class="n">module_name</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>
<span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">module_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
<span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="implementing-lazy-imports">
<h3>Implementar importaciones diferidas<a class="headerlink" href="#implementing-lazy-imports" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El ejemplo de abajo muestra cómo implementar importaciones diferidas:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">lazy_import</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">spec</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">LazyLoader</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="o">=</span> <span class="n">loader</span>
<span class="gp">... </span>    <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
<span class="gp">... </span>    <span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">module</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lazy_typing</span> <span class="o">=</span> <span class="n">lazy_import</span><span class="p">(</span><span class="s2">&quot;typing&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#lazy_typing is a real module object,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#but it is not loaded in memory yet.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lazy_typing</span><span class="o">.</span><span class="n">TYPE_CHECKING</span>
<span class="go">False</span>
</pre></div>
</div>
</section>
<section id="setting-up-an-importer">
<h3>Configurar un importador<a class="headerlink" href="#setting-up-an-importer" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para personalizaciones profundas de la importación, normalmente desea implementar un <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importador</span></a>. Esto significa administrar tanto el lado <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> como <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> de las cosas. Para los buscadores, hay dos sabores para elegir según sus necesidades: un <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">meta path finder</span></a> o un <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a>. El primero es lo que pondrías en <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> mientras que el segundo es lo que creas usando un <a class="reference internal" href="../glossary.html#term-path-entry-hook"><span class="xref std std-term">path entry hook</span></a> en <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> que funciona con <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys</span> <span class="pre">.path</span></code> entradas para crear potencialmente un buscador. Este ejemplo le mostrará cómo registrar sus propios importadores para que import los utilice (para crear un importador para usted, lea la documentación de las clases apropiadas definidas dentro de este paquete):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.machinery</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># For illustrative purposes only.</span>
<span class="n">SpamMetaPathFinder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">PathFinder</span>
<span class="n">SpamPathEntryFinder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">FileFinder</span>
<span class="n">loader_details</span> <span class="o">=</span> <span class="p">(</span><span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SourceFileLoader</span><span class="p">,</span>
                  <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SOURCE_SUFFIXES</span><span class="p">)</span>

<span class="c1"># Setting up a meta path finder.</span>
<span class="c1"># Make sure to put the finder in the proper location in the list in terms of</span>
<span class="c1"># priority.</span>
<span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SpamMetaPathFinder</span><span class="p">)</span>

<span class="c1"># Setting up a path entry finder.</span>
<span class="c1"># Make sure to put the path hook in the proper location in the list in terms</span>
<span class="c1"># of priority.</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path_hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SpamPathEntryFinder</span><span class="o">.</span><span class="n">path_hook</span><span class="p">(</span><span class="n">loader_details</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="approximating-importlib-import-module">
<h3>Aproximando <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a><a class="headerlink" href="#approximating-importlib-import-module" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La importación en sí está implementada en código Python, lo que permite exponer la mayor parte de la maquinaria de importación a través de importlib. Lo siguiente ayuda a ilustrar las diversas API que importlib expone al proporcionar una implementación aproximada de <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">import_module</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An approximate implementation of import.&quot;&quot;&quot;</span>
    <span class="n">absolute_name</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">resolve_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">absolute_name</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">path</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">absolute_name</span><span class="p">:</span>
        <span class="n">parent_name</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">child_name</span> <span class="o">=</span> <span class="n">absolute_name</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">parent_module</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="n">parent_name</span><span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">parent_module</span><span class="o">.</span><span class="n">__spec__</span><span class="o">.</span><span class="n">submodule_search_locations</span>
    <span class="k">for</span> <span class="n">finder</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="p">:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">absolute_name</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;No module named </span><span class="si">{</span><span class="n">absolute_name</span><span class="si">!r}</span><span class="s1">&#39;</span>
        <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">absolute_name</span><span class="p">)</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">absolute_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">parent_module</span><span class="p">,</span> <span class="n">child_name</span><span class="p">,</span> <span class="n">module</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">module</span>
</pre></div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> — La implementación de <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a><ul>
<li><a class="reference internal" href="#introduction">Introducción</a></li>
<li><a class="reference internal" href="#functions">Funciones</a></li>
<li><a class="reference internal" href="#module-importlib.abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code> – Clases base abstractas relacionadas con la importación</a></li>
<li><a class="reference internal" href="#module-importlib.machinery"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.machinery</span></code> – Importadores y enlaces de ruta</a></li>
<li><a class="reference internal" href="#module-importlib.util"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code> – Código de utilidad para importadores</a></li>
<li><a class="reference internal" href="#examples">Ejemplos</a><ul>
<li><a class="reference internal" href="#importing-programmatically">Importar programáticamente</a></li>
<li><a class="reference internal" href="#checking-if-a-module-can-be-imported">Comprobando si se puede importar un módulo</a></li>
<li><a class="reference internal" href="#importing-a-source-file-directly">Importar un archivo fuente directamente</a></li>
<li><a class="reference internal" href="#implementing-lazy-imports">Implementar importaciones diferidas</a></li>
<li><a class="reference internal" href="#setting-up-an-importer">Configurar un importador</a></li>
<li><a class="reference internal" href="#approximating-importlib-import-module">Aproximando <code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="runpy.html"
                          title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code> — Localización y ejecución de módulos <em>Python</em></a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="importlib.resources.html"
                          title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.resources</span></code> – Recursos</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/library/importlib.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="importlib.resources.html" title="importlib.resources – Recursos"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="runpy.html" title="runpy — Localización y ejecución de módulos Python"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="modules.html" >Importando módulos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> — La implementación de <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 23, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>