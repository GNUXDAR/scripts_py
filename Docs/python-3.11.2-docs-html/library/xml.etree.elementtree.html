
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="xml.etree.ElementTree — La API XML de ElementTree" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/xml.etree.elementtree.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Código fuente: Lib/xml/etree/ElementTree.py El módulo xml.etree.ElementTree implementa una API simple y eficiente para parsear y crear datos XML. Tutorial: Este es un tutorial corto para usar xml.e..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Código fuente: Lib/xml/etree/ElementTree.py El módulo xml.etree.ElementTree implementa una API simple y eficiente para parsear y crear datos XML. Tutorial: Este es un tutorial corto para usar xml.e..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>xml.etree.ElementTree — La API XML de ElementTree &#8212; documentación de Python - 3.11.2</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=2d3badd06fe70b34b68db01f99471ce1624ffe4a" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.11.2"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="xml.dom — El API del Modelo de Objetos del Documento" href="xml.dom.html" />
    <link rel="prev" title="Módulos de procesamiento XML" href="xml.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/xml.etree.elementtree.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code> — La API XML de ElementTree</a><ul>
<li><a class="reference internal" href="#tutorial">Tutorial</a><ul>
<li><a class="reference internal" href="#xml-tree-and-elements">Árbol y elementos XML</a></li>
<li><a class="reference internal" href="#parsing-xml">Procesando XML</a></li>
<li><a class="reference internal" href="#pull-api-for-non-blocking-parsing">API de consulta para un procesamiento no bloqueante</a></li>
<li><a class="reference internal" href="#finding-interesting-elements">Encontrando elementos interesantes</a></li>
<li><a class="reference internal" href="#modifying-an-xml-file">Modificando un archivo XML</a></li>
<li><a class="reference internal" href="#building-xml-documents">Construyendo documentos XML</a></li>
<li><a class="reference internal" href="#parsing-xml-with-namespaces">Procesando XML con espacio de nombres</a></li>
</ul>
</li>
<li><a class="reference internal" href="#xpath-support">Soporte de XPath</a><ul>
<li><a class="reference internal" href="#example">Ejemplo</a></li>
<li><a class="reference internal" href="#supported-xpath-syntax">Sintaxis XPath soportada</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference">Referencia</a><ul>
<li><a class="reference internal" href="#functions">Funciones</a></li>
</ul>
</li>
<li><a class="reference internal" href="#xinclude-support">Soporte de XInclude</a><ul>
<li><a class="reference internal" href="#id3">Ejemplo</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4">Referencia</a><ul>
<li><a class="reference internal" href="#elementinclude-functions">Funciones</a></li>
<li><a class="reference internal" href="#element-objects">Objetos Element</a></li>
<li><a class="reference internal" href="#elementtree-objects">Objetos ElementTree</a></li>
<li><a class="reference internal" href="#qname-objects">Objetos QName</a></li>
<li><a class="reference internal" href="#treebuilder-objects">Objetos TreeBuilder</a></li>
<li><a class="reference internal" href="#xmlparser-objects">Objetos XMLParser</a></li>
<li><a class="reference internal" href="#xmlpullparser-objects">Objetos XMLPullParser</a></li>
<li><a class="reference internal" href="#exceptions">Excepciones</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="xml.html"
                          title="capítulo anterior">Módulos de procesamiento XML</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="xml.dom.html"
                          title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.dom</span></code> — El <em>API</em> del Modelo de Objetos del Documento</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/library/xml.etree.elementtree.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="xml.dom.html" title="xml.dom — El API del Modelo de Objetos del Documento"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="xml.html" title="Módulos de procesamiento XML"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="markup.html" accesskey="U">Herramientas Para Procesar Formatos de Marcado Estructurado</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code> — La API XML de ElementTree</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-xml.etree.ElementTree">
<span id="xml-etree-elementtree-the-elementtree-xml-api"></span><h1><a class="reference internal" href="#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code></a> — La API XML de ElementTree<a class="headerlink" href="#module-xml.etree.ElementTree" title="Enlazar permanentemente con este título">¶</a></h1>
<p><strong>Código fuente:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.11/Lib/xml/etree/ElementTree.py">Lib/xml/etree/ElementTree.py</a></p>
<hr class="docutils" />
<p>El módulo <a class="reference internal" href="#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code></a> implementa una API simple y eficiente para parsear y crear datos XML.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Este módulo utilizará una implementación rápida siempre que esté disponible.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.3: </span>El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.cElementTree</span></code> es obsoleto.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>El módulo <a class="reference internal" href="#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code></a> no es seguro contra datos construidos maliciosamente. Si necesita parsear datos no fiables o no autentificados, vea <a class="reference internal" href="xml.html#xml-vulnerabilities"><span class="std std-ref">Vulnerabilidades XML</span></a>.</p>
</div>
<section id="tutorial">
<h2>Tutorial<a class="headerlink" href="#tutorial" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Este es un tutorial corto para usar <a class="reference internal" href="#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code></a> (<code class="docutils literal notranslate"><span class="pre">ET</span></code> en resumen). El objetivo es demostrar algunos de los componentes y conceptos básicos del módulo.</p>
<section id="xml-tree-and-elements">
<h3>Árbol y elementos XML<a class="headerlink" href="#xml-tree-and-elements" title="Enlazar permanentemente con este título">¶</a></h3>
<p>XML es un formato de datos inherentemente jerárquico, y la forma más natural de representarlo es con un árbol. <code class="docutils literal notranslate"><span class="pre">ET</span></code> tiene dos clases para este propósito - <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a> representa todo el documento XML como un árbol, y <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> representa un solo nodo en este árbol. Las interacciones con todo el documento (leer y escribir en/desde archivos) se realizan normalmente en el nivel de <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a>. Las interacciones con un solo elemento XML y sus sub-elementos se realizan en el nivel <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a>.</p>
</section>
<section id="parsing-xml">
<span id="elementtree-parsing-xml"></span><h3>Procesando XML<a class="headerlink" href="#parsing-xml" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Usaremos el siguiente documento XML como los datos de muestra para esta sección:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="nt">&lt;data&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Liechtenstein&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank&gt;</span>1<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2008<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>141100<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Austria&quot;</span> <span class="na">direction=</span><span class="s">&quot;E&quot;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Switzerland&quot;</span> <span class="na">direction=</span><span class="s">&quot;W&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Singapore&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank&gt;</span>4<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2011<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>59900<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Malaysia&quot;</span> <span class="na">direction=</span><span class="s">&quot;N&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Panama&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank&gt;</span>68<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2011<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>13600<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Costa Rica&quot;</span> <span class="na">direction=</span><span class="s">&quot;W&quot;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Colombia&quot;</span> <span class="na">direction=</span><span class="s">&quot;E&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
<span class="nt">&lt;/data&gt;</span>
</pre></div>
</div>
<p>Podemos importar estos datos leyendo desde un archivo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">ET</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;country_data.xml&#39;</span><span class="p">)</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
</pre></div>
</div>
<p>O directamente desde una cadena de caracteres:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">country_data_as_string</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#xml.etree.ElementTree.fromstring" title="xml.etree.ElementTree.fromstring"><code class="xref py py-func docutils literal notranslate"><span class="pre">fromstring()</span></code></a> analiza el XML de una cadena de caracteres directamente en un <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a>, que es el elemento raíz del árbol analizado. Otras funciones de análisis pueden crear un <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a>. Compruebe la documentación para estar seguro.</p>
<p>Como un <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a>, <code class="docutils literal notranslate"><span class="pre">root</span></code> tiene una etiqueta y un diccionario de atributos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">tag</span>
<span class="go">&#39;data&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="o">.</span><span class="n">attrib</span>
<span class="go">{}</span>
</pre></div>
</div>
<p>También tiene nodos hijos sobre los cuales podemos iterar:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">country {&#39;name&#39;: &#39;Liechtenstein&#39;}</span>
<span class="go">country {&#39;name&#39;: &#39;Singapore&#39;}</span>
<span class="go">country {&#39;name&#39;: &#39;Panama&#39;}</span>
</pre></div>
</div>
<p>Los hijos están anidados, y podemos acceder a nodos hijos específicos por el índice:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">text</span>
<span class="go">&#39;2008&#39;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>No todos los elementos de la entrada XML acabarán siendo elementos del árbol analizado. Actualmente, este módulo omite cualquier comentario XML, instrucciones de procesamiento y declaraciones de tipo documento en la entrada. Sin embargo, los árboles construidos utilizando la API de este módulo, en lugar de analizar el texto XML, pueden contener comentarios e instrucciones de procesamiento, que se incluirán al generar la salida XML. Se puede acceder a una declaración de tipo documento pasando una instancia <a class="reference internal" href="#xml.etree.ElementTree.TreeBuilder" title="xml.etree.ElementTree.TreeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeBuilder</span></code></a> personalizada al constructor <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a>.</p>
</div>
</section>
<section id="pull-api-for-non-blocking-parsing">
<span id="elementtree-pull-parsing"></span><h3>API de consulta para un procesamiento no bloqueante<a class="headerlink" href="#pull-api-for-non-blocking-parsing" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La mayoría de las funciones de análisis proporcionadas por este módulo requieren que se lea todo el documento a la vez antes de retornar cualquier resultado. Es posible utilizar un <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> y alimentar los datos en él de forma incremental, pero se trata de una <em>push</em> API que llama a métodos en un objetivo invocable, que es demasiado bajo nivel e inconveniente para la mayoría de las necesidades. A veces, lo que el usuario realmente quiere es ser capaz de analizar XML de forma incremental, sin bloquear las operaciones, mientras disfruta de la comodidad de los objetos <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> totalmente construidos.</p>
<p>La herramienta más potente para hacer esto es <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser" title="xml.etree.ElementTree.XMLPullParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLPullParser</span></code></a>. No requiere una lectura de bloqueo para obtener los datos XML, y en su lugar se alimenta de datos de forma incremental con llamadas a <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser.feed" title="xml.etree.ElementTree.XMLPullParser.feed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XMLPullParser.feed()</span></code></a>. Para obtener los elementos XML analizados, llama a <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser.read_events" title="xml.etree.ElementTree.XMLPullParser.read_events"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XMLPullParser.read_events()</span></code></a>. He aquí un ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">XMLPullParser</span><span class="p">([</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;end&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">feed</span><span class="p">(</span><span class="s1">&#39;&lt;mytag&gt;sometext&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">read_events</span><span class="p">())</span>
<span class="go">[(&#39;start&#39;, &lt;Element &#39;mytag&#39; at 0x7fa66db2be58&gt;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">feed</span><span class="p">(</span><span class="s1">&#39; more text&lt;/mytag&gt;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">event</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">parser</span><span class="o">.</span><span class="n">read_events</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="s1">&#39;text=&#39;</span><span class="p">,</span> <span class="n">elem</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">end</span>
</pre></div>
</div>
<p>El caso de uso obvio es el de las aplicaciones que operan de forma no bloqueante, donde los datos XML se reciben de un socket o se leen de forma incremental desde algún dispositivo de almacenamiento. En estos casos, las lecturas bloqueantes son inaceptables.</p>
<p>Debido a su flexibilidad, <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser" title="xml.etree.ElementTree.XMLPullParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLPullParser</span></code></a> puede ser un inconveniente para los casos de uso más simples. Si no te importa que tu aplicación se bloquee en la lectura de datos XML pero te gustaría tener capacidades de análisis incremental, echa un vistazo a <a class="reference internal" href="#xml.etree.ElementTree.iterparse" title="xml.etree.ElementTree.iterparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">iterparse()</span></code></a>. Puede ser útil cuando estás leyendo un documento XML grande y no quieres mantenerlo completamente en memoria.</p>
</section>
<section id="finding-interesting-elements">
<h3>Encontrando elementos interesantes<a class="headerlink" href="#finding-interesting-elements" title="Enlazar permanentemente con este título">¶</a></h3>
<p><a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> tiene algunos métodos útiles que ayudan a iterar recursivamente sobre todo el sub-árbol por debajo de él (sus hijos, los hijos de sus hijos, y así sucesivamente). Por ejemplo, <a class="reference internal" href="#xml.etree.ElementTree.Element.iter" title="xml.etree.ElementTree.Element.iter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.iter()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s1">&#39;neighbor&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">neighbor</span><span class="o">.</span><span class="n">attrib</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">{&#39;name&#39;: &#39;Austria&#39;, &#39;direction&#39;: &#39;E&#39;}</span>
<span class="go">{&#39;name&#39;: &#39;Switzerland&#39;, &#39;direction&#39;: &#39;W&#39;}</span>
<span class="go">{&#39;name&#39;: &#39;Malaysia&#39;, &#39;direction&#39;: &#39;N&#39;}</span>
<span class="go">{&#39;name&#39;: &#39;Costa Rica&#39;, &#39;direction&#39;: &#39;W&#39;}</span>
<span class="go">{&#39;name&#39;: &#39;Colombia&#39;, &#39;direction&#39;: &#39;E&#39;}</span>
</pre></div>
</div>
<p><a class="reference internal" href="#xml.etree.ElementTree.Element.findall" title="xml.etree.ElementTree.Element.findall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.findall()</span></code></a> encuentra sólo los elementos con una etiqueta que son hijos directos del elemento actual. <a class="reference internal" href="#xml.etree.ElementTree.Element.find" title="xml.etree.ElementTree.Element.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.find()</span></code></a> encuentra el <em>primer</em> hijo con una etiqueta determinada, y <a class="reference internal" href="#xml.etree.ElementTree.Element.text" title="xml.etree.ElementTree.Element.text"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Element.text</span></code></a> accede al contenido de texto del elemento. <a class="reference internal" href="#xml.etree.ElementTree.Element.get" title="xml.etree.ElementTree.Element.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.get()</span></code></a> accede a los atributos del elemento:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">country</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;country&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">rank</span> <span class="o">=</span> <span class="n">country</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;rank&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span>
<span class="gp">... </span>    <span class="n">name</span> <span class="o">=</span> <span class="n">country</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Liechtenstein 1</span>
<span class="go">Singapore 4</span>
<span class="go">Panama 68</span>
</pre></div>
</div>
<p>Es posible especificar de forma más sofisticada qué elementos buscar utilizando <a class="reference internal" href="#elementtree-xpath"><span class="std std-ref">XPath</span></a>.</p>
</section>
<section id="modifying-an-xml-file">
<h3>Modificando un archivo XML<a class="headerlink" href="#modifying-an-xml-file" title="Enlazar permanentemente con este título">¶</a></h3>
<p><a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a> proporciona una forma sencilla de construir documentos XML y escribirlos en archivos. El método <a class="reference internal" href="#xml.etree.ElementTree.ElementTree.write" title="xml.etree.ElementTree.ElementTree.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ElementTree.write()</span></code></a> sirve para este propósito.</p>
<p>Una vez creado, un objeto <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> puede ser manipulado cambiando directamente sus campos (como <a class="reference internal" href="#xml.etree.ElementTree.Element.text" title="xml.etree.ElementTree.Element.text"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Element.text</span></code></a>), añadiendo y modificando atributos (método <a class="reference internal" href="#xml.etree.ElementTree.Element.set" title="xml.etree.ElementTree.Element.set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.set()</span></code></a>), así como añadiendo nuevos hijos (por ejemplo con <a class="reference internal" href="#xml.etree.ElementTree.Element.append" title="xml.etree.ElementTree.Element.append"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.append()</span></code></a>).</p>
<p>Digamos que queremos añadir uno al rango de cada país, y añadir un atributo <code class="docutils literal notranslate"><span class="pre">updated</span></code> al elemento rango:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s1">&#39;rank&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">new_rank</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rank</span><span class="o">.</span><span class="n">text</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="n">rank</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">new_rank</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">rank</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;updated&#39;</span><span class="p">,</span> <span class="s1">&#39;yes&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;output.xml&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Nuestro XML tiene ahora este aspecto:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="nt">&lt;data&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Liechtenstein&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank</span> <span class="na">updated=</span><span class="s">&quot;yes&quot;</span><span class="nt">&gt;</span>2<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2008<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>141100<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Austria&quot;</span> <span class="na">direction=</span><span class="s">&quot;E&quot;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Switzerland&quot;</span> <span class="na">direction=</span><span class="s">&quot;W&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Singapore&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank</span> <span class="na">updated=</span><span class="s">&quot;yes&quot;</span><span class="nt">&gt;</span>5<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2011<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>59900<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Malaysia&quot;</span> <span class="na">direction=</span><span class="s">&quot;N&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Panama&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank</span> <span class="na">updated=</span><span class="s">&quot;yes&quot;</span><span class="nt">&gt;</span>69<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2011<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>13600<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Costa Rica&quot;</span> <span class="na">direction=</span><span class="s">&quot;W&quot;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Colombia&quot;</span> <span class="na">direction=</span><span class="s">&quot;E&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
<span class="nt">&lt;/data&gt;</span>
</pre></div>
</div>
<p>Podemos eliminar elementos utilizando <a class="reference internal" href="#xml.etree.ElementTree.Element.remove" title="xml.etree.ElementTree.Element.remove"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.remove()</span></code></a>. Digamos que queremos eliminar todos los países con un rango superior a 50:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">country</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;country&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># using root.findall() to avoid removal during traversal</span>
<span class="gp">... </span>    <span class="n">rank</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">country</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;rank&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">rank</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">root</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">country</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;output.xml&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Tenga en cuenta que la modificación concurrente mientras se itera puede conducir a problemas, al igual que cuando se itera y modifica listas o diccionarios de Python. Por lo tanto, el ejemplo recoge primero todos los elementos coincidentes con <code class="docutils literal notranslate"><span class="pre">root.findall()</span></code>, y sólo entonces itera sobre la lista de coincidencias.</p>
<p>Nuestro XML tiene ahora este aspecto:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="nt">&lt;data&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Liechtenstein&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank</span> <span class="na">updated=</span><span class="s">&quot;yes&quot;</span><span class="nt">&gt;</span>2<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2008<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>141100<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Austria&quot;</span> <span class="na">direction=</span><span class="s">&quot;E&quot;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Switzerland&quot;</span> <span class="na">direction=</span><span class="s">&quot;W&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
    <span class="nt">&lt;country</span> <span class="na">name=</span><span class="s">&quot;Singapore&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;rank</span> <span class="na">updated=</span><span class="s">&quot;yes&quot;</span><span class="nt">&gt;</span>5<span class="nt">&lt;/rank&gt;</span>
        <span class="nt">&lt;year&gt;</span>2011<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;gdppc&gt;</span>59900<span class="nt">&lt;/gdppc&gt;</span>
        <span class="nt">&lt;neighbor</span> <span class="na">name=</span><span class="s">&quot;Malaysia&quot;</span> <span class="na">direction=</span><span class="s">&quot;N&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/country&gt;</span>
<span class="nt">&lt;/data&gt;</span>
</pre></div>
</div>
</section>
<section id="building-xml-documents">
<h3>Construyendo documentos XML<a class="headerlink" href="#building-xml-documents" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <a class="reference internal" href="#xml.etree.ElementTree.SubElement" title="xml.etree.ElementTree.SubElement"><code class="xref py py-func docutils literal notranslate"><span class="pre">SubElement()</span></code></a> también proporciona una forma cómoda de crear nuevos sub-elementos para un elemento dado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ET</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&lt;a&gt;&lt;b /&gt;&lt;c&gt;&lt;d /&gt;&lt;/c&gt;&lt;/a&gt;</span>
</pre></div>
</div>
</section>
<section id="parsing-xml-with-namespaces">
<h3>Procesando XML con espacio de nombres<a class="headerlink" href="#parsing-xml-with-namespaces" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Si la entrada XML tiene <a class="reference external" href="https://es.wikipedia.org/wiki/Espacio_de_nombres_XML">espacio de nombres</a>, las etiquetas y los atributos con prefijos de la forma <code class="docutils literal notranslate"><span class="pre">prefix:sometag</span></code> se expanden a <code class="docutils literal notranslate"><span class="pre">{uri}sometag</span></code> donde el <em>prefix</em> se sustituye por el <em>URI</em> completo. Además, si hay un <a class="reference external" href="https://www.w3.org/TR/xml-names/#defaulting">espacio de nombre por defecto</a>, ese URI completo se antepone a todas las etiquetas sin prefijo.</p>
<p>A continuación se muestra un ejemplo de XML que incorpora dos espacios de nombres, uno con el prefijo «fictional» y el otro que sirve como espacio de nombres por defecto:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="nt">&lt;actors</span> <span class="na">xmlns:fictional=</span><span class="s">&quot;http://characters.example.com&quot;</span>
        <span class="na">xmlns=</span><span class="s">&quot;http://people.example.com&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;actor&gt;</span>
        <span class="nt">&lt;name&gt;</span>John Cleese<span class="nt">&lt;/name&gt;</span>
        <span class="nt">&lt;fictional:character&gt;</span>Lancelot<span class="nt">&lt;/fictional:character&gt;</span>
        <span class="nt">&lt;fictional:character&gt;</span>Archie Leach<span class="nt">&lt;/fictional:character&gt;</span>
    <span class="nt">&lt;/actor&gt;</span>
    <span class="nt">&lt;actor&gt;</span>
        <span class="nt">&lt;name&gt;</span>Eric Idle<span class="nt">&lt;/name&gt;</span>
        <span class="nt">&lt;fictional:character&gt;</span>Sir Robin<span class="nt">&lt;/fictional:character&gt;</span>
        <span class="nt">&lt;fictional:character&gt;</span>Gunther<span class="nt">&lt;/fictional:character&gt;</span>
        <span class="nt">&lt;fictional:character&gt;</span>Commander Clement<span class="nt">&lt;/fictional:character&gt;</span>
    <span class="nt">&lt;/actor&gt;</span>
<span class="nt">&lt;/actors&gt;</span>
</pre></div>
</div>
<p>Una forma de buscar y explorar este ejemplo XML es añadir manualmente el URI a cada etiqueta o atributo en el XPath de un <a class="reference internal" href="#xml.etree.ElementTree.Element.find" title="xml.etree.ElementTree.Element.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a> o <a class="reference internal" href="#xml.etree.ElementTree.Element.findall" title="xml.etree.ElementTree.Element.findall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">findall()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">root</span> <span class="o">=</span> <span class="n">fromstring</span><span class="p">(</span><span class="n">xml_text</span><span class="p">)</span>
<span class="k">for</span> <span class="n">actor</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;{http://people.example.com}actor&#39;</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">actor</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;{http://people.example.com}name&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">actor</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;{http://characters.example.com}character&#39;</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; |--&gt;&#39;</span><span class="p">,</span> <span class="n">char</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
</pre></div>
</div>
<p>Una mejor manera de buscar en el ejemplo de XML con espacio para nombres es crear un diccionario con sus propios prefijos y utilizarlos en las funciones de búsqueda:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ns</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;real_person&#39;</span><span class="p">:</span> <span class="s1">&#39;http://people.example.com&#39;</span><span class="p">,</span>
      <span class="s1">&#39;role&#39;</span><span class="p">:</span> <span class="s1">&#39;http://characters.example.com&#39;</span><span class="p">}</span>

<span class="k">for</span> <span class="n">actor</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;real_person:actor&#39;</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">actor</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;real_person:name&#39;</span><span class="p">,</span> <span class="n">ns</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">actor</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;role:character&#39;</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; |--&gt;&#39;</span><span class="p">,</span> <span class="n">char</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
</pre></div>
</div>
<p>Estos dos enfoques dan como resultado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">John</span> <span class="n">Cleese</span>
 <span class="o">|--&gt;</span> <span class="n">Lancelot</span>
 <span class="o">|--&gt;</span> <span class="n">Archie</span> <span class="n">Leach</span>
<span class="n">Eric</span> <span class="n">Idle</span>
 <span class="o">|--&gt;</span> <span class="n">Sir</span> <span class="n">Robin</span>
 <span class="o">|--&gt;</span> <span class="n">Gunther</span>
 <span class="o">|--&gt;</span> <span class="n">Commander</span> <span class="n">Clement</span>
</pre></div>
</div>
</section>
</section>
<section id="xpath-support">
<span id="elementtree-xpath"></span><h2>Soporte de XPath<a class="headerlink" href="#xpath-support" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Este módulo proporciona un soporte limitado para las expresiones <a class="reference external" href="https://www.w3.org/TR/xpath">XPath</a> para localizar elementos en un árbol. El objetivo es soportar un pequeño subconjunto de la sintaxis abreviada; un motor XPath completo está fuera del alcance del módulo.</p>
<section id="example">
<h3>Ejemplo<a class="headerlink" href="#example" title="Enlazar permanentemente con este título">¶</a></h3>
<p>A continuación se muestra un ejemplo que demuestra algunas de las capacidades de XPath del módulo. Utilizaremos el documento XML <code class="docutils literal notranslate"><span class="pre">countrydata</span></code> de la sección <a class="reference internal" href="#elementtree-parsing-xml"><span class="std std-ref">Parsing XML</span></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">ET</span>

<span class="n">root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">countrydata</span><span class="p">)</span>

<span class="c1"># Top-level elements</span>
<span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>

<span class="c1"># All &#39;neighbor&#39; grand-children of &#39;country&#39; children of the top-level</span>
<span class="c1"># elements</span>
<span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;./country/neighbor&quot;</span><span class="p">)</span>

<span class="c1"># Nodes with name=&#39;Singapore&#39; that have a &#39;year&#39; child</span>
<span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;.//year/..[@name=&#39;Singapore&#39;]&quot;</span><span class="p">)</span>

<span class="c1"># &#39;year&#39; nodes that are children of nodes with name=&#39;Singapore&#39;</span>
<span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;.//*[@name=&#39;Singapore&#39;]/year&quot;</span><span class="p">)</span>

<span class="c1"># All &#39;neighbor&#39; nodes that are the second child of their parent</span>
<span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;.//neighbor[2]&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Para XML con espacios de nombre, use la notación calificada habitual <code class="docutils literal notranslate"><span class="pre">{namespace}tag</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># All dublin-core &quot;title&quot; tags in the document</span>
<span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;.//{http://purl.org/dc/elements/1.1/}title&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="supported-xpath-syntax">
<h3>Sintaxis XPath soportada<a class="headerlink" href="#supported-xpath-syntax" title="Enlazar permanentemente con este título">¶</a></h3>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Sintaxis</p></th>
<th class="head"><p>Significado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">tag</span></code></p></td>
<td><p>Selecciona todos los elementos hijos con la etiqueta dada. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">spam</span></code> selecciona todos los elementos hijos llamados <code class="docutils literal notranslate"><span class="pre">spam</span></code>, y <code class="docutils literal notranslate"><span class="pre">spam/egg</span></code> selecciona todos los nietos llamados <code class="docutils literal notranslate"><span class="pre">egg</span></code> en todos los hijos llamados <code class="docutils literal notranslate"><span class="pre">spam</span></code>. <code class="docutils literal notranslate"><span class="pre">{namespace}*</span></code> selecciona todas las etiquetas en el espacio de nombres dado, <code class="docutils literal notranslate"><span class="pre">{*}spam</span></code> selecciona las etiquetas llamadas <code class="docutils literal notranslate"><span class="pre">spam</span></code> en cualquier (o ningún) espacio de nombres, y <code class="docutils literal notranslate"><span class="pre">{}*</span></code> sólo selecciona las etiquetas que no están en un espacio de nombres.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Se ha añadido la posibilidad de utilizar comodines asterisco.</p>
</div>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">*</span></code></p></td>
<td><p>Selecciona todos los elementos hijos, incluidos los comentarios y las instrucciones de procesamiento. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">*/egg</span></code> selecciona todos los hijos llamados <code class="docutils literal notranslate"><span class="pre">egg</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">.</span></code></p></td>
<td><p>Selecciona el nodo actual. Esto es útil sobre todo al principio de la ruta, para indicar que es una ruta relativa.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">//</span></code></p></td>
<td><p>Selecciona todos los sub-elementos, en todos los niveles por debajo del elemento actual. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">.//egg</span></code> selecciona todos los elementos <code class="docutils literal notranslate"><span class="pre">egg</span></code> en todo el árbol.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">..</span></code></p></td>
<td><p>Selecciona el elemento padre. Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si la ruta intenta llegar a los ancestros del elemento inicial (el elemento <code class="docutils literal notranslate"><span class="pre">find</span></code> fue invocado).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">[&#64;attrib]</span></code></p></td>
<td><p>Selecciona todos los elementos que tengan el atributo dado.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">[&#64;attrib='value']</span></code></p></td>
<td><p>Selecciona todos los elementos para los que el atributo dado tiene el valor dado. El valor no puede contener comillas.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">[&#64;attrib!='value']</span></code></p></td>
<td><p>Selecciona todos los elementos para los que el atributo dado no tiene el valor dado. El valor no puede contener comillas.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">[tag]</span></code></p></td>
<td><p>Selecciona todos los elementos que tienen un hijo llamado <code class="docutils literal notranslate"><span class="pre">tag</span></code>. Sólo se admiten los hijos inmediatos.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">[.='text']</span></code></p></td>
<td><p>Selecciona todos los elementos cuyo contenido de texto completo, incluyendo los descendientes, es igual al «texto» dado.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">[.!='text']</span></code></p></td>
<td><p>Selecciona todos los elementos cuyo contenido de texto completo, incluidos los descendientes, no es igual al <code class="docutils literal notranslate"><span class="pre">text</span></code> proporcionado.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">[tag='text']</span></code></p></td>
<td><p>Selecciona todos los elementos que tienen un hijo llamado <code class="docutils literal notranslate"><span class="pre">tag</span></code> cuyo contenido de texto completo, incluyendo los descendientes, es igual al <code class="docutils literal notranslate"><span class="pre">text</span></code> dado.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">[tag!='text']</span></code></p></td>
<td><p>Selecciona todos los elementos que tienen un hijo llamado <code class="docutils literal notranslate"><span class="pre">tag</span></code> cuyo contenido de texto completo, incluidos los descendientes, no es igual al <code class="docutils literal notranslate"><span class="pre">text</span></code> dado.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">[position]</span></code></p></td>
<td><p>Selecciona todos los elementos que se encuentran en la posición dada. La posición puede ser un número entero (1 es la primera posición), la expresión <code class="docutils literal notranslate"><span class="pre">last()</span></code> (para la última posición), o una posición relativa a la última posición (por ejemplo, <code class="docutils literal notranslate"><span class="pre">last()-1</span></code>).</p></td>
</tr>
</tbody>
</table>
<p>Los predicados (expresiones entre corchetes) deben ir precedidos de un nombre de etiqueta, un asterisco u otro predicado. Los predicados <code class="docutils literal notranslate"><span class="pre">position</span></code> deben ir precedidos de un nombre de etiqueta.</p>
</section>
</section>
<section id="reference">
<h2>Referencia<a class="headerlink" href="#reference" title="Enlazar permanentemente con este título">¶</a></h2>
<section id="functions">
<span id="elementtree-functions"></span><h3>Funciones<a class="headerlink" href="#functions" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.canonicalize">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">canonicalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xml_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.canonicalize" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Función de transformación <a class="reference external" href="https://www.w3.org/TR/xml-c14n2/">C14N 2.0</a>.</p>
<p>La canonización es una forma de normalizar la salida de XML de manera que permita comparaciones byte a byte y firmas digitales. Reduce la libertad que tienen los serializadores XML y en su lugar genera una representación XML más restringida. Las principales restricciones se refieren a la colocación de las declaraciones de espacio de nombres, el orden de los atributos y los espacios en blanco ignorables.</p>
<p>Esta función toma una cadena de datos XML (<em>xml_data</em>) o una ruta de archivo o un objeto tipo archivo (<em>from_file</em>) como entrada, la convierte a la forma canónica y la escribe utilizando el objeto archivo (o tipo archivo) <em>out</em>, si se proporciona, o la devuelve como una cadena de texto si no. El archivo de salida recibe texto, no bytes. Por tanto, debe abrirse en modo texto con codificación <code class="docutils literal notranslate"><span class="pre">utf-8</span></code>.</p>
<p>Usos típicos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">xml_data</span> <span class="o">=</span> <span class="s2">&quot;&lt;root&gt;...&lt;/root&gt;&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">canonicalize</span><span class="p">(</span><span class="n">xml_data</span><span class="p">))</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;c14n_output.xml&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out_file</span><span class="p">:</span>
    <span class="n">canonicalize</span><span class="p">(</span><span class="n">xml_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out_file</span><span class="p">)</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;c14n_output.xml&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out_file</span><span class="p">:</span>
    <span class="n">canonicalize</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s2">&quot;inputfile.xml&quot;</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out_file</span><span class="p">)</span>
</pre></div>
</div>
<p>Las opciones de configuración <em>options</em> son las siguientes:</p>
<ul class="simple">
<li><p><em>with_comments</em>: configurar a <code class="docutils literal notranslate"><span class="pre">True</span></code> para incluir los comentarios (por defecto: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p></li>
<li><dl class="simple">
<dt><em>strip_text</em>: configurar a <code class="docutils literal notranslate"><span class="pre">True</span></code> para eliminar los espacios en blanco antes y después del contenido del texto</dt><dd><p>(por defecto: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><em>rewrite_prefixes</em>: configurar a <code class="docutils literal notranslate"><span class="pre">True</span></code> para sustituir los prefijos de espacios de nombres por «n{number}»</dt><dd><p>(por defecto: <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><em>qname_aware_tags</em>: un conjunto de nombres de etiquetas conscientes de qname en el que los prefijos</dt><dd><p>deben ser reemplazados en el contenido del texto (por defecto: vacío)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><em>qname_aware_attrs</em>: un conjunto de nombres de atributos conscientes de qname en el que los prefijos</dt><dd><p>deben ser reemplazados en el contenido del texto (por defecto: vacío)</p>
</dd>
</dl>
</li>
<li><p><em>exclude_attrs</em>: un conjunto de nombres de atributos que no deben serializarse</p></li>
<li><p><em>exclude_tags</em>: un conjunto de nombres de etiquetas que no deben serializarse</p></li>
</ul>
<p>En la lista de opciones anterior, «un conjunto» se refiere a cualquier colección o iterable de cadenas, no se espera ningún orden.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Comment">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">Comment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Comment" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Fábrica de elementos de comentario. Esta función de fábrica crea un elemento especial que será serializado como un comentario XML por el serializador estándar. La cadena de comentario puede ser una cadena de bytes o una cadena Unicode. <em>text</em> es una cadena que contiene la cadena de comentario. Devuelve una instancia de elemento que representa un comentario.</p>
<p>Tenga en cuenta que <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> omite los comentarios en la entrada en lugar de crear objetos de comentario para ellos. Un <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a> sólo contendrá nodos de comentario si se han insertado en el árbol utilizando uno de los métodos <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.dump">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">dump</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elem</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.dump" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Escribe un árbol de elementos o una estructura de elementos en sys.stdout. Esta función debe utilizarse únicamente para debugging.</p>
<p>El formato de salida exacto depende de la implementación. En esta versión, se escribe como un archivo XML ordinario.</p>
<p><em>elem</em> es un árbol de elementos o un elemento individual.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>La función <a class="reference internal" href="#xml.etree.ElementTree.dump" title="xml.etree.ElementTree.dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">dump()</span></code></a> ahora preserva el orden de atributos especificado por el usuario.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.fromstring">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">fromstring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.fromstring" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Analiza una sección XML a partir de una constante de cadena. Igual que <a class="reference internal" href="#xml.etree.ElementTree.XML" title="xml.etree.ElementTree.XML"><code class="xref py py-func docutils literal notranslate"><span class="pre">XML()</span></code></a>. <em>text</em> es una cadena que contiene datos XML. <em>parser</em> es una instancia de parser opcional. Si no se da, se utiliza el analizador estándar <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a>. Devuelve una instancia de <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.fromstringlist">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">fromstringlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.fromstringlist" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Analiza un documento XML a partir de una secuencia de fragmentos de cadena de caracteres. <em>sequence</em> es una lista u otra secuencia que contiene fragmentos de datos XML. <em>parser</em> es una instancia de parser opcional. Si no se da, se utiliza el analizador estándar <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a>. Retorna una instancia de <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.indent">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">indent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'</span>&#160; <span class="pre">'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.indent" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Añade espacios en blanco al subárbol para indentar el árbol visualmente. Esto puede utilizarse para generar una salida XML con una impresión bonita. <em>tree</em> puede ser un Element o ElementTree. <em>space</em> es la cadena de espacio en blanco que se insertará para cada nivel de indentación, dos caracteres de espacio por defecto. Para indentar subárboles parciales dentro de un árbol ya indentado, pase el nivel de indentación inicial como <em>level</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.iselement">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">iselement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.iselement" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Comprueba si un objeto parece ser un objeto elemento válido. <em>element</em> es una instancia de elemento. Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si se trata de un objeto elemento.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.iterparse">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">iterparse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">events</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.iterparse" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Analiza una sección XML en un árbol de elementos de forma incremental, e informa al usuario de lo que ocurre. <em>source</em> es un nombre de archivo o un <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a> que contiene datos XML. <em>events</em> es una secuencia de eventos para informar. Los eventos soportados son las cadenas <code class="docutils literal notranslate"><span class="pre">&quot;start&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;end&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;comment&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;pi&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;start-ns&quot;</span></code> y <code class="docutils literal notranslate"><span class="pre">&quot;end-ns&quot;</span></code> (los eventos «ns» se utilizan para obtener información detallada del espacio de nombres). Si se omite <em>events</em>, sólo se informará de los eventos <code class="docutils literal notranslate"><span class="pre">&quot;end&quot;</span></code>. <em>parser</em> es una instancia opcional de parser. Si no se da, se utiliza el analizador estándar de <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a>. <em>parser</em> debe ser una subclase de <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> y sólo puede utilizar el <a class="reference internal" href="#xml.etree.ElementTree.TreeBuilder" title="xml.etree.ElementTree.TreeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeBuilder</span></code></a> por defecto como objetivo. Devuelve un <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> que proporciona pares <code class="docutils literal notranslate"><span class="pre">(event,</span> <span class="pre">elem)</span></code>.</p>
<p>Tenga en cuenta que mientras <a class="reference internal" href="#xml.etree.ElementTree.iterparse" title="xml.etree.ElementTree.iterparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">iterparse()</span></code></a> construye el árbol de forma incremental, emite lecturas de bloqueo en la <em>source</em> (o en el fichero que nombra). Por lo tanto, no es adecuado para aplicaciones en las que no se pueden realizar lecturas de bloqueo. Para un análisis completamente no bloqueante, véase <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser" title="xml.etree.ElementTree.XMLPullParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLPullParser</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><a class="reference internal" href="#xml.etree.ElementTree.iterparse" title="xml.etree.ElementTree.iterparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">iterparse()</span></code></a> sólo garantiza que ha visto el carácter «&gt;» de una etiqueta de inicio cuando emite un evento «start», por lo que los atributos están definidos, pero el contenido de los atributos text y tail está indefinido en ese momento. Lo mismo ocurre con los hijos del elemento; pueden estar presentes o no.</p>
<p>Si necesita un elemento totalmente poblado, busque los eventos «end» en su lugar.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>El argumento <em>parser</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Los eventos <code class="docutils literal notranslate"><span class="pre">comment</span></code> y <code class="docutils literal notranslate"><span class="pre">pi</span></code> han sido añadidos.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.parse">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">parse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.parse" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Analiza una sección XML en un árbol de elementos. <em>source</em> es un nombre de archivo o un objeto de archivo que contiene datos XML. <em>parser</em> es una instancia de parser opcional. Si no se da, se utiliza el analizador estándar <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a>. Devuelve una instancia de <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ProcessingInstruction">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">ProcessingInstruction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ProcessingInstruction" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Fábrica de elementos PI. Esta función de fábrica crea un elemento especial que será serializado como una instrucción de procesamiento XML. <em>target</em> es una cadena que contiene el objetivo de PI. <em>text</em> es una cadena que contiene el contenido de PI, si se da. Devuelve una instancia de elemento, representando una instrucción de procesamiento.</p>
<p>Tenga en cuenta que <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> omite las instrucciones de procesamiento en la entrada en lugar de crear objetos de comentario para ellas. Un <a class="reference internal" href="#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a> sólo contendrá nodos de instrucciones de procesamiento si se han insertado en el árbol utilizando uno de los métodos <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.register_namespace">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">register_namespace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uri</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.register_namespace" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Registra un prefijo de espacio de nombres. El registro es global, y cualquier asignación existente para el prefijo dado o el URI del espacio de nombres será eliminado. <em>prefix</em> es un prefijo de espacio de nombres. <em>uri</em> es una uri del espacio de nombres. Las etiquetas y los atributos de este espacio de nombres se serializarán con el prefijo dado, si es posible.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.SubElement">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">SubElement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrib</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">extra</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.SubElement" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Fábrica de sub-elementos. Esta función crea una instancia de elemento y la añade a un elemento existente.</p>
<p>El nombre del elemento, los nombres de los atributos y los valores de los atributos pueden ser cadenas de bytes o cadenas de caracteres Unicode. <em>parent</em> es el elemento padre. <em>tag</em> es el nombre del sub-elemento. <em>attrib</em> es un diccionario opcional que contiene los atributos del elemento. <em>extra</em> contiene atributos adicionales, dados como argumentos de palabras clave. Devuelve una instancia de elemento.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.tostring">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">tostring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'us-ascii'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'xml'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xml_declaration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default_namespace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">short_empty_elements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.tostring" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Genera una representación de cadena de caracteres de un elemento XML, incluyendo todos los sub-elementos. <em>element</em> es una instancia de <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a>. <em>encoding</em> <a class="footnote-reference brackets" href="#id9" id="id1">1</a> es la codificación de salida (por defecto es US-ASCII). Utilice <code class="docutils literal notranslate"><span class="pre">encoding=&quot;unicode&quot;</span></code> para generar una cadena de caracteres Unicode (de lo contrario, se genera una cadena de bytes). <em>method</em> es <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;html&quot;</span></code> o <code class="docutils literal notranslate"><span class="pre">&quot;text&quot;</span></code> (por defecto es <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>). <em>xml_declaration</em>, <em>default_namespace</em> y <em>short_empty_elements</em> tienen el mismo significado que en <a class="reference internal" href="#xml.etree.ElementTree.ElementTree.write" title="xml.etree.ElementTree.ElementTree.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ElementTree.write()</span></code></a>. Devuelve una cadena (opcionalmente) codificada que contiene los datos XML.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4: </span>El parámetro <em>short_empty_elements</em>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8: </span>Los parámetros <em>xml_declaration</em> y <em>default_namespace</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>La función <a class="reference internal" href="#xml.etree.ElementTree.tostring" title="xml.etree.ElementTree.tostring"><code class="xref py py-func docutils literal notranslate"><span class="pre">tostring()</span></code></a> ahora preserva el orden de atributos especificado por el usuario.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.tostringlist">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">tostringlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'us-ascii'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'xml'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xml_declaration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default_namespace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">short_empty_elements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.tostringlist" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Genera una representación de cadena de caracteres de un elemento XML, incluyendo todos los sub-elementos. <em>element</em> es una instancia de <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a>. <em>encoding</em> <a class="footnote-reference brackets" href="#id9" id="id2">1</a> es la codificación de salida (por defecto es US-ASCII). Utilice <code class="docutils literal notranslate"><span class="pre">encoding=&quot;unicode&quot;</span></code> para generar una cadena de caracteres Unicode (de lo contrario, se genera una cadena de bytes). <em>method</em> es <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;html&quot;</span></code> o <code class="docutils literal notranslate"><span class="pre">&quot;text&quot;</span></code> (por defecto es <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>). <em>xml_declaration</em>, <em>default_namespace</em> y <em>short_empty_elements</em> tienen el mismo significado que en <a class="reference internal" href="#xml.etree.ElementTree.ElementTree.write" title="xml.etree.ElementTree.ElementTree.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ElementTree.write()</span></code></a>. Devuelve una lista de cadenas (opcionalmente) codificadas que contienen los datos XML. No garantiza ninguna secuencia específica, excepto que <code class="docutils literal notranslate"><span class="pre">b&quot;&quot;.join(tostringlist(element))</span> <span class="pre">==</span> <span class="pre">tostring(element)</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4: </span>El parámetro <em>short_empty_elements</em>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8: </span>Los parámetros <em>xml_declaration</em> y <em>default_namespace</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>La función <a class="reference internal" href="#xml.etree.ElementTree.tostringlist" title="xml.etree.ElementTree.tostringlist"><code class="xref py py-func docutils literal notranslate"><span class="pre">tostringlist()</span></code></a> ahora preserva el orden de atributos especificado por el usuario.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.XML">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">XML</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XML" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Analiza una sección XML a partir de una constante de cadena de caracteres. Esta función puede utilizarse para incrustar «literales XML» en el código de Python. <em>text</em> es una cadena de caracteres que contiene datos XML. <em>parser</em> es una instancia de parser opcional. Si no se da, se utiliza el analizador estándar <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a>. Devuelve una instancia de <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementTree.XMLID">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">XMLID</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLID" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Analiza una sección XML a partir de una constante de cadena de caracteres, y también devuelve un diccionario que mapea los id:s de elementos a elementos. <em>text</em> es una cadena de caracteres que contiene datos XML. <em>parser</em> es una instancia de parser opcional. Si no se da, se utiliza el analizador estándar de <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a>. Devuelve una tupla que contiene una instancia de <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> y un diccionario.</p>
</dd></dl>

</section>
</section>
<section id="xinclude-support">
<span id="elementtree-xinclude"></span><h2>Soporte de XInclude<a class="headerlink" href="#xinclude-support" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Este módulo proporciona un soporte limitado para las directivas <a class="reference external" href="https://www.w3.org/TR/xinclude/">XInclude</a>, a través del módulo de ayuda <code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementInclude</span></code>. Este módulo puede utilizarse para insertar subárboles y cadenas de texto en árboles de elementos, basándose en la información del árbol.</p>
<section id="id3">
<h3>Ejemplo<a class="headerlink" href="#id3" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Aquí hay un ejemplo que demuestra el uso del módulo XInclude. Para incluir un documento XML en el documento actual, utilice el elemento <code class="docutils literal notranslate"><span class="pre">{http://www.w3.org/2001/XInclude}include</span></code> y establezca el atributo <strong>parse</strong> como <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>, y utilice el atributo <strong>href</strong> para especificar el documento a incluir.</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="nt">&lt;document</span> <span class="na">xmlns:xi=</span><span class="s">&quot;http://www.w3.org/2001/XInclude&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;xi:include</span> <span class="na">href=</span><span class="s">&quot;source.xml&quot;</span> <span class="na">parse=</span><span class="s">&quot;xml&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/document&gt;</span>
</pre></div>
</div>
<p>Por defecto, el atributo <strong>href</strong> se trata como un nombre de archivo. Puede utilizar cargadores personalizados para anular este comportamiento. También tenga en cuenta que el ayudante estándar no soporta la sintaxis XPointer.</p>
<p>Para procesar este archivo, cárguelo como de costumbre y pase el elemento raíz al módulo <a class="reference internal" href="#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xml.etree</span> <span class="kn">import</span> <span class="n">ElementTree</span><span class="p">,</span> <span class="n">ElementInclude</span>

<span class="n">tree</span> <span class="o">=</span> <span class="n">ElementTree</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;document.xml&quot;</span><span class="p">)</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>

<span class="n">ElementInclude</span><span class="o">.</span><span class="n">include</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
</pre></div>
</div>
<p>El módulo ElementInclude sustituye el elemento <code class="docutils literal notranslate"><span class="pre">{http://www.w3.org/2001/XInclude}include</span></code> por el elemento raíz del documento <strong>source.xml</strong>. El resultado podría ser algo así:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;document</span> <span class="na">xmlns:xi=</span><span class="s">&quot;http://www.w3.org/2001/XInclude&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;para&gt;</span>This is a paragraph.<span class="nt">&lt;/para&gt;</span>
<span class="nt">&lt;/document&gt;</span>
</pre></div>
</div>
<p>Si se omite el atributo <strong>parse</strong>, el valor por defecto es «xml». El atributo href es obligatorio.</p>
<p>Para incluir un documento de texto, utilice el elemento <code class="docutils literal notranslate"><span class="pre">{http://www.w3.org/2001/XInclude}include</span></code> y establezca el atributo <strong>parse</strong> como «text»:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="nt">&lt;document</span> <span class="na">xmlns:xi=</span><span class="s">&quot;http://www.w3.org/2001/XInclude&quot;</span><span class="nt">&gt;</span>
  Copyright (c) <span class="nt">&lt;xi:include</span> <span class="na">href=</span><span class="s">&quot;year.txt&quot;</span> <span class="na">parse=</span><span class="s">&quot;text&quot;</span> <span class="nt">/&gt;</span>.
<span class="nt">&lt;/document&gt;</span>
</pre></div>
</div>
<p>El resultado podría ser algo así:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;document</span> <span class="na">xmlns:xi=</span><span class="s">&quot;http://www.w3.org/2001/XInclude&quot;</span><span class="nt">&gt;</span>
  Copyright (c) 2003.
<span class="nt">&lt;/document&gt;</span>
</pre></div>
</div>
</section>
</section>
<section id="id4">
<h2>Referencia<a class="headerlink" href="#id4" title="Enlazar permanentemente con este título">¶</a></h2>
<section id="elementinclude-functions">
<span id="id5"></span><h3>Funciones<a class="headerlink" href="#elementinclude-functions" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementInclude.default_loader">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementInclude.</span></span><span class="sig-name descname"><span class="pre">default_loader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">href</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parse</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementInclude.default_loader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Cargador por defecto. Este cargador por defecto lee un recurso incluido del disco. <em>href</em> es una URL. <em>parse</em> es para el modo de análisis «xml» o «text». <em>encoding</em> es una codificación de texto opcional. Si no se da, la codificación es <code class="docutils literal notranslate"><span class="pre">utf-8</span></code>. Retorna el recurso expandido. Si el modo de análisis es <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>, es una instancia de ElementTree. Si el modo de análisis es «text», se trata de una cadena Unicode. Si el cargador falla, puede retornar None o lanzar una excepción.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xml.etree.ElementInclude.include">
<span class="sig-prename descclassname"><span class="pre">xml.etree.ElementInclude.</span></span><span class="sig-name descname"><span class="pre">include</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_url</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementInclude.include" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta función expande las directivas XInclude. <em>elem</em> es el elemento raíz. <em>loader</em> es un cargador de recursos opcional. Si se omite, se utiliza por defecto <a class="reference internal" href="#xml.etree.ElementInclude.default_loader" title="xml.etree.ElementInclude.default_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">default_loader()</span></code></a>. Si se da, debe ser un callable que implemente la misma interfaz que <a class="reference internal" href="#xml.etree.ElementInclude.default_loader" title="xml.etree.ElementInclude.default_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">default_loader()</span></code></a>. <em>base_url</em> es la URL base del archivo original, para resolver las referencias relativas al archivo de inclusión. <em>max_depth</em> es el número máximo de inclusiones recursivas. Limitado para reducir el riesgo de explosión de contenido malicioso. Pase un valor negativo para desactivar la limitación.</p>
<p>Retorna el recurso expandido. Si el modo de análisis es <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>, se trata de una instancia de ElementTree. Si el modo de análisis es «text», se trata de una cadena Unicode. Si el cargador falla, puede retornar None o lanzar una excepción.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9: </span>Los parámetros <em>base_url</em> y <em>max_depth</em>.</p>
</div>
</dd></dl>

</section>
<section id="element-objects">
<span id="elementtree-element-objects"></span><h3>Objetos Element<a class="headerlink" href="#element-objects" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">Element</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrib</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">extra</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Clase Element. Esta clase define la interfaz Element, y provee una implementación de referencia de esta interfaz.</p>
<p>El nombre del elemento, los nombres de los atributos y los valores de los atributos pueden ser cadenas de bytes o cadenas Unicode. <em>tag</em> es el nombre del elemento. <em>attrib</em> es un diccionario opcional que contiene los atributos del elemento. <em>extra</em> contiene atributos adicionales, dados como argumentos de palabras clave.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.tag">
<span class="sig-name descname"><span class="pre">tag</span></span><a class="headerlink" href="#xml.etree.ElementTree.Element.tag" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una cadena de caracteres que identifica qué tipo de datos representa este elemento (el tipo de elemento, en otras palabras).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.text">
<span class="sig-name descname"><span class="pre">text</span></span><a class="headerlink" href="#xml.etree.ElementTree.Element.text" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.tail">
<span class="sig-name descname"><span class="pre">tail</span></span><a class="headerlink" href="#xml.etree.ElementTree.Element.tail" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Estos atributos pueden utilizarse para contener datos adicionales asociados al elemento. Sus valores suelen ser cadenas, pero pueden ser cualquier objeto específico de la aplicación. Si el elemento se crea a partir de un archivo XML, el atributo <em>text</em> contiene el texto entre la etiqueta inicial del elemento y su primera etiqueta hija o final, o <code class="docutils literal notranslate"><span class="pre">None</span></code>, y el atributo <em>tail</em> contiene el texto entre la etiqueta final del elemento y la siguiente etiqueta, o <code class="docutils literal notranslate"><span class="pre">None</span></code>. Para los datos XML</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;a&gt;&lt;b&gt;</span>1<span class="nt">&lt;c&gt;</span>2<span class="nt">&lt;d/&gt;</span>3<span class="nt">&lt;/c&gt;&lt;/b&gt;</span>4<span class="nt">&lt;/a&gt;</span>
</pre></div>
</div>
<p>el elemento <em>a</em> tiene <code class="docutils literal notranslate"><span class="pre">None</span></code> para los atributos <em>text</em> y <em>tail</em>, el elemento <em>b</em> tiene <em>text</em> <code class="docutils literal notranslate"><span class="pre">&quot;1&quot;</span></code> y <em>tail</em> <code class="docutils literal notranslate"><span class="pre">&quot;4&quot;</span></code>, el elemento <em>c</em> tiene <em>text</em> <code class="docutils literal notranslate"><span class="pre">&quot;2&quot;</span></code> y <em>tail</em> <code class="docutils literal notranslate"><span class="pre">None</span></code>, y el elemento <em>d</em> tiene <em>text</em> <code class="docutils literal notranslate"><span class="pre">None</span></code> y <em>tail</em> <code class="docutils literal notranslate"><span class="pre">&quot;3&quot;</span></code>.</p>
<p>Para recoger el texto interior de un elemento, véase <a class="reference internal" href="#xml.etree.ElementTree.Element.itertext" title="xml.etree.ElementTree.Element.itertext"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itertext()</span></code></a>, por ejemplo <code class="docutils literal notranslate"><span class="pre">&quot;&quot;.join(element.itertext())</span></code>.</p>
<p>Las aplicaciones pueden almacenar objetos arbitrarios en estos atributos.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.attrib">
<span class="sig-name descname"><span class="pre">attrib</span></span><a class="headerlink" href="#xml.etree.ElementTree.Element.attrib" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un diccionario que contiene los atributos del elemento. Ten en cuenta que aunque el valor <em>attrib</em> es siempre un diccionario mutable real de Python, una implementación de ElementTree puede elegir utilizar otra representación interna, y crear el diccionario sólo si alguien lo pide. Para aprovechar este tipo de implementaciones, utiliza los métodos de diccionario que aparecen a continuación siempre que sea posible.</p>
</dd></dl>

<p>Los siguientes métodos tipo diccionario funcionan con los atributos de los elementos.</p>
<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.clear" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Restablece un elemento.  Esta función elimina todos los sub-elementos, borra todos los atributos y establece los atributos de texto y cola como <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.get">
<span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.get" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Obtiene el atributo del elemento llamado <em>key</em>.</p>
<p>Retorna el valor del atributo, o <em>default</em> si el atributo no fue encontrado.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.items" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna los atributos del elemento como una secuencia de pares (nombre, valor). Los atributos se retornan en un orden arbitrario.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.keys" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna los nombres de los atributos de los elementos como una lista. Los nombres se retornan en un orden arbitrario.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.set">
<span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.set" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establecer el atributo <em>key</em> en el elemento a <em>value</em>.</p>
</dd></dl>

<p>Los siguientes métodos actúan sobre los hijos del elemento (sub-elementos).</p>
<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subelement</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.append" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Añade el elemento <em>subelement</em> al final de la lista interna de sub-elementos de este elemento. Lanza <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> si <em>subelement</em> no es un <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.extend">
<span class="sig-name descname"><span class="pre">extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subelements</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.extend" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Añade <em>subelements</em> de un objeto de secuencia con cero o más elementos. Lanza <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> si un sub-elemento no es un <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.find">
<span class="sig-name descname"><span class="pre">find</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namespaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.find" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Encuentra el primer sub-elemento que coincide con <em>match</em>. <em>match</em> puede ser un nombre de etiqueta o un <a class="reference internal" href="#elementtree-xpath"><span class="std std-ref">path</span></a>. Retorna una instancia de elemento o <code class="docutils literal notranslate"><span class="pre">None</span></code>. <em>namespaces</em> es un mapeo opcional del prefijo del espacio de nombres al nombre completo. Pasa <code class="docutils literal notranslate"><span class="pre">''</span></code> como prefijo para mover todos los nombres de etiquetas sin prefijo en la expresión al espacio de nombres dado.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.findall">
<span class="sig-name descname"><span class="pre">findall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namespaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.findall" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Encuentra todos los sub-elementos coincidentes, por nombre de etiqueta o <a class="reference internal" href="#elementtree-xpath"><span class="std std-ref">path</span></a>. Retorna una lista que contiene todos los elementos coincidentes en el orden del documento. <em>namespaces</em> es un mapeo opcional del prefijo del espacio de nombres al nombre completo. Pasa <code class="docutils literal notranslate"><span class="pre">''</span></code> como prefijo para mover todos los nombres de etiquetas sin prefijo en la expresión al espacio de nombres dado.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.findtext">
<span class="sig-name descname"><span class="pre">findtext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namespaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.findtext" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Busca el texto del primer sub-elemento que coincida con <em>match</em>. <em>match</em> puede ser un nombre de etiqueta o un <a class="reference internal" href="#elementtree-xpath"><span class="std std-ref">path</span></a>. Retorna el contenido del texto del primer elemento que coincida, o <em>default</em> si no se encuentra ningún elemento. Tenga en cuenta que si el elemento coincidente no tiene contenido de texto se devuelve una cadena vacía. <em>namespaces</em> es un mapeo opcional del prefijo del espacio de nombres al nombre completo. Pasa <code class="docutils literal notranslate"><span class="pre">''</span></code> como prefijo para mover todos los nombres de etiquetas sin prefijo en la expresión al espacio de nombres dado.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.insert">
<span class="sig-name descname"><span class="pre">insert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subelement</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.insert" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Inserta <em>subelement</em> en la posición dada en este elemento. Lanza <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> si <em>subelement</em> no es un <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.iter">
<span class="sig-name descname"><span class="pre">iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.iter" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un árbol <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> con el elemento actual como raíz. El iterador itera sobre este elemento y todos los elementos por debajo de él, en el orden del documento (profundidad primero). Si <em>tag</em> no es <code class="docutils literal notranslate"><span class="pre">None</span></code> o <code class="docutils literal notranslate"><span class="pre">'*'</span></code>, sólo los elementos cuya etiqueta es igual a <em>tag</em> son retornados por el iterador. Si la estructura del árbol se modifica durante la iteración, el resultado es indefinido.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.iterfind">
<span class="sig-name descname"><span class="pre">iterfind</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namespaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.iterfind" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Encuentra todos los subelementos que coinciden, por nombre de etiqueta o <a class="reference internal" href="#elementtree-xpath"><span class="std std-ref">ruta</span></a>. Retorna un iterable con todos los elementos coincidentes en el orden del documento. <em>namespaces</em> es un mapeo opcional del prefijo del espacio de nombres al nombre completo.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.itertext">
<span class="sig-name descname"><span class="pre">itertext</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.itertext" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un iterador de texto. El iterador hace un bucle sobre este elemento y todos los subelementos, en el orden del documento, y retorna todo el texto interior.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.makeelement">
<span class="sig-name descname"><span class="pre">makeelement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrib</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.makeelement" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un nuevo objeto elemento del mismo tipo que este elemento. No llame a este método, utilice la función de fábrica <a class="reference internal" href="#xml.etree.ElementTree.SubElement" title="xml.etree.ElementTree.SubElement"><code class="xref py py-func docutils literal notranslate"><span class="pre">SubElement()</span></code></a> en su lugar.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.Element.remove">
<span class="sig-name descname"><span class="pre">remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">subelement</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.Element.remove" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Elimina el <em>subelement</em> del elemento. A diferencia de los métodos find*, este método compara los elementos basándose en la identidad de la instancia, no en el valor de la etiqueta o el contenido.</p>
</dd></dl>

<p>Los objetos <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> también soportan los siguientes métodos de tipo secuencia para trabajar con subelementos: <a class="reference internal" href="../reference/datamodel.html#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delitem__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a>.</p>
<p>Precaución: Los elementos que no tengan subelementos serán evaluados como <code class="docutils literal notranslate"><span class="pre">False</span></code>. Este comportamiento cambiará en futuras versiones. Utilizar en su lugar el test específico <code class="docutils literal notranslate"><span class="pre">len(elem)</span></code> o <code class="docutils literal notranslate"><span class="pre">elem</span> <span class="pre">is</span> <span class="pre">None</span></code>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">element</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">element</span><span class="p">:</span>  <span class="c1"># careful!</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;element not found, or element has no subelements&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="n">element</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;element not found&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Antes de Python 3.8, el orden de serialización de los atributos XML de los elementos se hacía predecible artificialmente ordenando los atributos por su nombre. Basado en el ordenamiento -ahora garantizado- de los diccionarios, este reordenamiento arbitrario fue eliminado en Python 3.8 para preservar el orden en que los atributos fueron originalmente analizados o creados por el código del usuario.</p>
<p>En general, el código del usuario debería intentar no depender de un orden específico de los atributos, dado que el <a class="reference external" href="https://www.w3.org/TR/xml-infoset/">XML Information Set</a> excluye explícitamente el orden de los atributos para transmitir información. El código debe estar preparado para hacer frente a cualquier orden en la entrada. En los casos en los que se requiere una salida XML determinista, por ejemplo, para la firma criptográfica o los conjuntos de datos de prueba, la serialización canónica está disponible con la función <a class="reference internal" href="#xml.etree.ElementTree.canonicalize" title="xml.etree.ElementTree.canonicalize"><code class="xref py py-func docutils literal notranslate"><span class="pre">canonicalize()</span></code></a>.</p>
<p>En los casos en los que la salida canónica no es aplicable, pero un orden de atributos específico sigue siendo deseable en la salida, el código debe tratar de crear los atributos directamente en el orden deseado, para evitar desajustes perceptivos para los lectores del código. En los casos en que esto es difícil de lograr, una receta como la siguiente se puede aplicar antes de la serialización para hacer cumplir un orden independientemente de la creación de elementos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">reorder_attributes</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">():</span>
        <span class="n">attrib</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">attrib</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attrib</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># adjust attribute order, e.g. by sorting</span>
            <span class="n">attribs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">attrib</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="n">attrib</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">attrib</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">attribs</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="elementtree-objects">
<span id="elementtree-elementtree-objects"></span><h3>Objetos ElementTree<a class="headerlink" href="#elementtree-objects" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ElementTree">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">ElementTree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Clase envoltorio de un ElementTree. Esta clase representa una jerarquía de elementos completa, y añade algún soporte extra para la serialización hacia y desde XML estándar.</p>
<p><em>element</em> es el elemento raíz. El árbol se inicializa con el contenido del <em>file</em> XML si se da.</p>
<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ElementTree._setroot">
<span class="sig-name descname"><span class="pre">_setroot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree._setroot" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Reemplaza el elemento raíz de este árbol. Esto descarta el contenido actual del árbol, y lo reemplaza con el elemento dado. Utilícelo con cuidado. <em>element</em> es una instancia de elemento.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ElementTree.find">
<span class="sig-name descname"><span class="pre">find</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namespaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.find" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Igual que <a class="reference internal" href="#xml.etree.ElementTree.Element.find" title="xml.etree.ElementTree.Element.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.find()</span></code></a>, empezando por la raíz del árbol.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ElementTree.findall">
<span class="sig-name descname"><span class="pre">findall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namespaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.findall" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Igual que <a class="reference internal" href="#xml.etree.ElementTree.Element.findall" title="xml.etree.ElementTree.Element.findall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.findall()</span></code></a>, empezando por la raíz del árbol.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ElementTree.findtext">
<span class="sig-name descname"><span class="pre">findtext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namespaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.findtext" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Igual que <a class="reference internal" href="#xml.etree.ElementTree.Element.findtext" title="xml.etree.ElementTree.Element.findtext"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.findtext()</span></code></a>, empezando por la raíz del árbol.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ElementTree.getroot">
<span class="sig-name descname"><span class="pre">getroot</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.getroot" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el elemento raíz de este árbol.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ElementTree.iter">
<span class="sig-name descname"><span class="pre">iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.iter" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea y retorna un iterador de árbol para el elemento raíz. El iterador recorre todos los elementos de este árbol, en orden de sección. <em>tag</em> es la etiqueta a buscar (por defecto devuelve todos los elementos).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ElementTree.iterfind">
<span class="sig-name descname"><span class="pre">iterfind</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">namespaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.iterfind" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Igual que <a class="reference internal" href="#xml.etree.ElementTree.Element.iterfind" title="xml.etree.ElementTree.Element.iterfind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.iterfind()</span></code></a>, empezando por la raíz del árbol.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ElementTree.parse">
<span class="sig-name descname"><span class="pre">parse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.parse" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Carga una sección XML externa en este árbol de elementos. <em>source</em> es un nombre de archivo o un <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>. <em>parser</em> es una instancia opcional del analizador. Si no se da, se utiliza el analizador estándar <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a>. Retorna el elemento raíz de la sección.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ElementTree.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'us-ascii'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xml_declaration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default_namespace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'xml'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">short_empty_elements</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.ElementTree.write" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Escribe el árbol de elementos en un archivo, como XML. <em>file</em> es un nombre de archivo, o un <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a> abierto para escritura. <em>encoding</em> <a class="footnote-reference brackets" href="#id9" id="id6">1</a> es la codificación de salida (por defecto es US-ASCII). <em>xml_declaration</em> controla si se debe añadir una declaración XML al archivo. Utilice <code class="docutils literal notranslate"><span class="pre">False</span></code> para nunca, <code class="docutils literal notranslate"><span class="pre">True</span></code> para siempre, <code class="docutils literal notranslate"><span class="pre">None</span></code> para sólo si no es US-ASCII o UTF-8 o Unicode (por defecto es <code class="docutils literal notranslate"><span class="pre">None</span></code>). <em>default_namespace</em> establece el espacio de nombres XML por defecto (para «xmlns»). <em>method</em> es <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;html&quot;</span></code> o <code class="docutils literal notranslate"><span class="pre">&quot;text&quot;</span></code> (por defecto es <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>). El parámetro <em>short_empty_elements</em> controla el formato de los elementos sin contenido. Si es <code class="docutils literal notranslate"><span class="pre">True</span></code> (por defecto), se emiten como una sola etiqueta autocerrada, de lo contrario se emiten como un par de etiquetas de inicio/fin.</p>
<p>La salida es una cadena de caracteres (<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) o binaria (<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>). Esto es controlado por el argumento <em>encoding</em>. Si <em>encoding</em> es <code class="docutils literal notranslate"><span class="pre">unicode</span></code>, la salida es una cadena de caracteres; en caso contrario, es binaria. Tenga en cuenta que esto puede entrar en conflicto con el tipo de <em>file</em> si es un <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a> abierto; asegúrese de no intentar escribir una cadena en un flujo binario y viceversa.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4: </span>El parámetro <em>short_empty_elements</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>El método <a class="reference internal" href="#xml.etree.ElementTree.ElementTree.write" title="xml.etree.ElementTree.ElementTree.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> ahora conserva el orden de los atributos especificado por el usuario.</p>
</div>
</dd></dl>

</dd></dl>

<p>Este es el archivo XML que será manipulado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">html</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">head</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">title</span><span class="o">&gt;</span><span class="n">Example</span> <span class="n">page</span><span class="o">&lt;/</span><span class="n">title</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="n">head</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">body</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">Moved</span> <span class="n">to</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;http://example.org/&quot;</span><span class="o">&gt;</span><span class="n">example</span><span class="o">.</span><span class="n">org</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
        <span class="ow">or</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;http://example.com/&quot;</span><span class="o">&gt;</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;.&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="n">body</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">html</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Ejemplo de cambio del atributo «target» de cada enlace en el primer párrafo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">xml.etree.ElementTree</span> <span class="kn">import</span> <span class="n">ElementTree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">ElementTree</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;index.xhtml&quot;</span><span class="p">)</span>
<span class="go">&lt;Element &#39;html&#39; at 0xb77e6fac&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;body/p&quot;</span><span class="p">)</span>     <span class="c1"># Finds first occurrence of tag p in body</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">&lt;Element &#39;p&#39; at 0xb77ec26c&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">links</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">))</span>   <span class="c1"># Returns list of all links</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">links</span>
<span class="go">[&lt;Element &#39;a&#39; at 0xb77ec2ac&gt;, &lt;Element &#39;a&#39; at 0xb77ec1cc&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>             <span class="c1"># Iterates through all found links</span>
<span class="gp">... </span>    <span class="n">i</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;blank&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;output.xhtml&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="qname-objects">
<span id="elementtree-qname-objects"></span><h3>Objetos QName<a class="headerlink" href="#qname-objects" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="xml.etree.ElementTree.QName">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">QName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text_or_uri</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.QName" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>QName wrapper. Se puede utilizar para envolver un valor de atributo QName, con el fin de obtener un manejo adecuado del espacio de nombres en la salida. <em>text_or_uri</em> es una cadena de caracteres que contiene el valor QName, en la forma {uri}local, o, si se da el argumento tag, la parte URI de un QName. Si se da <em>tag</em>, el primer argumento se interpreta como un URI, y este argumento se interpreta como un nombre local. Las instancias de <a class="reference internal" href="#xml.etree.ElementTree.QName" title="xml.etree.ElementTree.QName"><code class="xref py py-class docutils literal notranslate"><span class="pre">QName</span></code></a> son opacas.</p>
</dd></dl>

</section>
<section id="treebuilder-objects">
<span id="elementtree-treebuilder-objects"></span><h3>Objetos TreeBuilder<a class="headerlink" href="#treebuilder-objects" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="xml.etree.ElementTree.TreeBuilder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">TreeBuilder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">element_factory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_factory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pi_factory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">insert_comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">insert_pis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Constructor genérico de estructuras de elementos. Este constructor convierte una secuencia de llamadas a los métodos start, data, end, comment y pi en una estructura de elementos bien formada. Puedes utilizar esta clase para construir una estructura de elementos utilizando un analizador XML personalizado, o un analizador para algún otro formato similar a XML.</p>
<p><em>element_factory</em>, cuando se da, debe ser un callable que acepta dos argumentos posicionales: una etiqueta y un diccionario de atributos. Se espera que retorne una nueva instancia de elemento.</p>
<p>Las funciones <em>comment_factory</em> y <em>pi_factory</em>, cuando se dan, deben comportarse como las funciones <a class="reference internal" href="#xml.etree.ElementTree.Comment" title="xml.etree.ElementTree.Comment"><code class="xref py py-func docutils literal notranslate"><span class="pre">Comment()</span></code></a> y <a class="reference internal" href="#xml.etree.ElementTree.ProcessingInstruction" title="xml.etree.ElementTree.ProcessingInstruction"><code class="xref py py-func docutils literal notranslate"><span class="pre">ProcessingInstruction()</span></code></a> para crear comentarios e instrucciones de procesamiento. Si no se dan, se utilizarán las fábricas por defecto. Cuando <em>insert_comments</em> y/o <em>insert_pis</em> es verdadero, los comentarios/pis se insertarán en el árbol si aparecen dentro del elemento raíz (pero no fuera de él).</p>
<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.TreeBuilder.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.close" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Vacía los buffers del constructor y retorna el elemento del documento de nivel superior. Retorna una instancia de <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.TreeBuilder.data">
<span class="sig-name descname"><span class="pre">data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.data" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Añade texto al elemento actual. <em>data</em> es una cadena. Debe ser una cadena de bytes o una cadena Unicode.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.TreeBuilder.end">
<span class="sig-name descname"><span class="pre">end</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.end" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Cierra el elemento actual. <em>tag</em> es el nombre del elemento. Retorna el elemento cerrado.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.TreeBuilder.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attrs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.start" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Abre un nuevo elemento. <em>tag</em> es el nombre del elemento. <em>attrs</em> es un diccionario que contiene los atributos del elemento. Retorna el elemento abierto.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.TreeBuilder.comment">
<span class="sig-name descname"><span class="pre">comment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">text</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.comment" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un comentario con el <em>texto</em> dado. Si <code class="docutils literal notranslate"><span class="pre">insert_comments</span></code> es verdadero, esto también lo añadirá al árbol.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.TreeBuilder.pi">
<span class="sig-name descname"><span class="pre">pi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.pi" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un comentario con el nombre <em>target</em> y el <em>texto</em> dados. Si <code class="docutils literal notranslate"><span class="pre">insert_pis</span></code> es verdadero, esto también lo añadirá al árbol.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

<p>Además, un objeto <a class="reference internal" href="#xml.etree.ElementTree.TreeBuilder" title="xml.etree.ElementTree.TreeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeBuilder</span></code></a> personalizado puede proporcionar los siguientes métodos:</p>
<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.TreeBuilder.doctype">
<span class="sig-name descname"><span class="pre">doctype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pubid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.doctype" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Maneja una declaración de doctype. <em>name</em> es el nombre del doctype. <em>pubid</em> es el identificador público. <em>system</em> es el identificador del sistema. Este método no existe en la clase por defecto <a class="reference internal" href="#xml.etree.ElementTree.TreeBuilder" title="xml.etree.ElementTree.TreeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeBuilder</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.TreeBuilder.start_ns">
<span class="sig-name descname"><span class="pre">start_ns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">uri</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.start_ns" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Se llama cada vez que el analizador encuentra una nueva declaración de espacio de nombres, antes de la llamada de retorno <code class="docutils literal notranslate"><span class="pre">start()</span></code> para el elemento de apertura que lo define. <em>prefix</em> es <code class="docutils literal notranslate"><span class="pre">''</span></code> para el espacio de nombres por defecto y el nombre del prefijo del espacio de nombres declarado en caso contrario. <em>uri</em> es el URI del espacio de nombres.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.TreeBuilder.end_ns">
<span class="sig-name descname"><span class="pre">end_ns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.TreeBuilder.end_ns" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Se llama después de la llamada de retorno <code class="docutils literal notranslate"><span class="pre">end()</span></code> de un elemento que declaró un mapeo de prefijo de espacio de nombres, con el nombre del <em>prefijo</em> que salió del ámbito.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="xml.etree.ElementTree.C14NWriterTarget">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">C14NWriterTarget</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">write</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strip_text</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rewrite_prefixes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qname_aware_tags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qname_aware_attrs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_attrs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_tags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.C14NWriterTarget" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un escritor <a class="reference external" href="https://www.w3.org/TR/xml-c14n2/">C14N 2.0</a>. Los argumentos son los mismos que para la función <a class="reference internal" href="#xml.etree.ElementTree.canonicalize" title="xml.etree.ElementTree.canonicalize"><code class="xref py py-func docutils literal notranslate"><span class="pre">canonicalize()</span></code></a>. Esta clase no construye un árbol, sino que traduce los eventos de devolución de llamada directamente a una forma serializada utilizando la función <em>write</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

</section>
<section id="xmlparser-objects">
<span id="elementtree-xmlparser-objects"></span><h3>Objetos XMLParser<a class="headerlink" href="#xmlparser-objects" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="xml.etree.ElementTree.XMLParser">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">XMLParser</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLParser" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta clase es el bloque de construcción de bajo nivel del módulo. Utiliza <a class="reference internal" href="pyexpat.html#module-xml.parsers.expat" title="xml.parsers.expat: An interface to the Expat non-validating XML parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.parsers.expat</span></code></a> para un análisis eficiente de XML basado en eventos. Puede ser alimentada con datos XML de forma incremental con el método <a class="reference internal" href="#xml.etree.ElementTree.XMLParser.feed" title="xml.etree.ElementTree.XMLParser.feed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">feed()</span></code></a>, y los eventos de análisis se traducen en una API push - invocando callbacks en el objeto <em>target</em>. Si se omite <em>target</em>, se utiliza la clase estándar <a class="reference internal" href="#xml.etree.ElementTree.TreeBuilder" title="xml.etree.ElementTree.TreeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeBuilder</span></code></a>. Si se da <em>encoding</em> <a class="footnote-reference brackets" href="#id9" id="id8">1</a>, el valor anula la codificación especificada en el archivo XML.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Los parámetros son ahora <a class="reference internal" href="../glossary.html#keyword-only-parameter"><span class="std std-ref">keyword-only</span></a>. El argumento <em>html</em> ya no se admite.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.XMLParser.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLParser.close" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Finaliza la alimentación de datos al analizador. Retorna el resultado de llamar al método <code class="docutils literal notranslate"><span class="pre">close()</span></code> del <em>target</em> pasado durante la construcción; por defecto, es el elemento del documento de nivel superior.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.XMLParser.feed">
<span class="sig-name descname"><span class="pre">feed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLParser.feed" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Introduce los datos en el analizador sintáctico. <em>data</em> son datos codificados.</p>
</dd></dl>

<p><a class="reference internal" href="#xml.etree.ElementTree.XMLParser.feed" title="xml.etree.ElementTree.XMLParser.feed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XMLParser.feed()</span></code></a> llama al método <code class="docutils literal notranslate"><span class="pre">start(tag,</span> <span class="pre">attrs_dict)</span></code> de <em>target</em> para cada etiqueta de apertura, a su método <code class="docutils literal notranslate"><span class="pre">end(tag)</span></code> para cada etiqueta de cierre, y los datos son procesados por el método <code class="docutils literal notranslate"><span class="pre">data(data)</span></code>. Para más métodos de callback soportados, véase la clase <a class="reference internal" href="#xml.etree.ElementTree.TreeBuilder" title="xml.etree.ElementTree.TreeBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">TreeBuilder</span></code></a>. <a class="reference internal" href="#xml.etree.ElementTree.XMLParser.close" title="xml.etree.ElementTree.XMLParser.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XMLParser.close()</span></code></a> llama al método <code class="docutils literal notranslate"><span class="pre">close()</span></code> de <em>target</em>. <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> puede utilizarse no sólo para construir una estructura de árbol. Este es un ejemplo de contar la profundidad máxima de un archivo XML:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">xml.etree.ElementTree</span> <span class="kn">import</span> <span class="n">XMLParser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MaxDepth</span><span class="p">:</span>                     <span class="c1"># The target object of the parser</span>
<span class="gp">... </span>    <span class="n">maxDepth</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">attrib</span><span class="p">):</span>   <span class="c1"># Called for each opening tag.</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxDepth</span><span class="p">:</span>
<span class="gp">... </span>            <span class="bp">self</span><span class="o">.</span><span class="n">maxDepth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>             <span class="c1"># Called for each closing tag.</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">-=</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">pass</span>            <span class="c1"># We do not need to do anything with data.</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>    <span class="c1"># Called when all data has been parsed.</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxDepth</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span> <span class="o">=</span> <span class="n">MaxDepth</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">XMLParser</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exampleXml</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="gp">... </span><span class="s2">&lt;a&gt;</span>
<span class="gp">... </span><span class="s2">  &lt;b&gt;</span>
<span class="gp">... </span><span class="s2">  &lt;/b&gt;</span>
<span class="gp">... </span><span class="s2">  &lt;b&gt;</span>
<span class="gp">... </span><span class="s2">    &lt;c&gt;</span>
<span class="gp">... </span><span class="s2">      &lt;d&gt;</span>
<span class="gp">... </span><span class="s2">      &lt;/d&gt;</span>
<span class="gp">... </span><span class="s2">    &lt;/c&gt;</span>
<span class="gp">... </span><span class="s2">  &lt;/b&gt;</span>
<span class="gp">... </span><span class="s2">&lt;/a&gt;&quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">feed</span><span class="p">(</span><span class="n">exampleXml</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="xmlpullparser-objects">
<span id="elementtree-xmlpullparser-objects"></span><h3>Objetos XMLPullParser<a class="headerlink" href="#xmlpullparser-objects" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="xml.etree.ElementTree.XMLPullParser">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">XMLPullParser</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">events</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLPullParser" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un analizador sintáctico pull adecuado para aplicaciones no bloqueantes. Su API de entrada es similar a la de <a class="reference internal" href="#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a>, pero en lugar de enviar llamadas a un objetivo de devolución de llamada, <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser" title="xml.etree.ElementTree.XMLPullParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLPullParser</span></code></a> recoge una lista interna de eventos de análisis y permite al usuario leer de ella. <em>events</em> son una secuencia de eventos a reportar. Los eventos soportados son las cadenas <code class="docutils literal notranslate"><span class="pre">&quot;start&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;end&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;comment&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;pi&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;start-ns&quot;</span></code> y <code class="docutils literal notranslate"><span class="pre">&quot;end-ns&quot;</span></code> (los eventos «ns» se utilizan para obtener información detallada del espacio de nombres). Si se omite <em>events</em>, sólo se informará de los eventos <code class="docutils literal notranslate"><span class="pre">&quot;end&quot;</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.XMLPullParser.feed">
<span class="sig-name descname"><span class="pre">feed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLPullParser.feed" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Introduce los datos de los bytes dados en el analizador.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.XMLPullParser.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLPullParser.close" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Señala al analizador que el flujo de datos ha terminado. A diferencia de <a class="reference internal" href="#xml.etree.ElementTree.XMLParser.close" title="xml.etree.ElementTree.XMLParser.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">XMLParser.close()</span></code></a>, este método siempre retorna <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>. Cualquier evento que no haya sido recuperado cuando el analizador se cierra puede ser leído con <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser.read_events" title="xml.etree.ElementTree.XMLPullParser.read_events"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_events()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xml.etree.ElementTree.XMLPullParser.read_events">
<span class="sig-name descname"><span class="pre">read_events</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#xml.etree.ElementTree.XMLPullParser.read_events" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un iterador sobre los eventos que se han encontrado en los datos alimentados al analizador. El iterador retorna pares <code class="docutils literal notranslate"><span class="pre">(event,</span> <span class="pre">elem)</span></code>, donde <em>event</em> es una cadena de caracteres que representa el tipo de evento (por ejemplo, <code class="docutils literal notranslate"><span class="pre">&quot;fin&quot;</span></code>) y <em>elem</em> es el objeto <a class="reference internal" href="#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> encontrado, u otro valor de contexto como el siguiente.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">end</span></code>: el Element actual.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">comment</span></code>, <code class="docutils literal notranslate"><span class="pre">pi</span></code>: el comentario / la instrucción de procesamiento actual</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">start-ns</span></code>: una tupla <code class="docutils literal notranslate"><span class="pre">(prefix,</span> <span class="pre">uri)</span></code> que nombra el mapeo del espacio de nombres declarado.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">end-ns</span></code>: <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> (esto puede cambiar en una versión futura)</p></li>
</ul>
<p>Los eventos proporcionados en una llamada anterior a <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser.read_events" title="xml.etree.ElementTree.XMLPullParser.read_events"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_events()</span></code></a> no serán retornados nuevamente. Los eventos se consumen de la cola interna sólo cuando se recuperan del iterador, por lo que múltiples lectores iterando en paralelo sobre iteradores obtenidos de <a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser.read_events" title="xml.etree.ElementTree.XMLPullParser.read_events"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_events()</span></code></a> tendrán resultados impredecibles.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><a class="reference internal" href="#xml.etree.ElementTree.XMLPullParser" title="xml.etree.ElementTree.XMLPullParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLPullParser</span></code></a> sólo garantiza que ha visto el carácter «&gt;» de una etiqueta de inicio cuando emite un evento «start», por lo que los atributos están definidos, pero el contenido de los atributos text y tail está indefinido en ese momento. Lo mismo ocurre con los hijos del elemento; pueden estar presentes o no.</p>
<p>Si necesita un elemento totalmente poblado, busque los eventos «end» en su lugar.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Los eventos <code class="docutils literal notranslate"><span class="pre">comment</span></code> y <code class="docutils literal notranslate"><span class="pre">pi</span></code> han sido añadidos.</p>
</div>
</dd></dl>

</section>
<section id="exceptions">
<h3>Excepciones<a class="headerlink" href="#exceptions" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ParseError">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xml.etree.ElementTree.</span></span><span class="sig-name descname"><span class="pre">ParseError</span></span><a class="headerlink" href="#xml.etree.ElementTree.ParseError" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Error de análisis de XML, lanzado por los distintos métodos de análisis de este módulo cuando el análisis falla. La representación en cadena de caracteres de una instancia de esta excepción contendrá un mensaje de error fácil de entender. Además, tendrá los siguientes atributos disponibles:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ParseError.code">
<span class="sig-name descname"><span class="pre">code</span></span><a class="headerlink" href="#xml.etree.ElementTree.ParseError.code" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un código de error numérico del analizador sintáctico expat. Consulte la documentación de <a class="reference internal" href="pyexpat.html#module-xml.parsers.expat" title="xml.parsers.expat: An interface to the Expat non-validating XML parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.parsers.expat</span></code></a> para ver la lista de códigos de error y sus significados.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xml.etree.ElementTree.ParseError.position">
<span class="sig-name descname"><span class="pre">position</span></span><a class="headerlink" href="#xml.etree.ElementTree.ParseError.position" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una tupla de números de <em>line</em>, <em>column</em>, que especifica dónde se produjo el error.</p>
</dd></dl>

</dd></dl>

<p class="rubric">Notas al pie de página</p>
<dl class="footnote brackets">
<dt class="label" id="id9"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id2">2</a>,<a href="#id6">3</a>,<a href="#id8">4</a>)</span></dt>
<dd><p>La cadena de caracteres de codificación incluida en la salida XML debe ajustarse a los estándares adecuados. Por ejemplo, «UTF-8» es válido, pero «UTF8» no lo es. Consulte <a class="reference external" href="https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl">https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl</a> y <a class="reference external" href="https://www.iana.org/assignments/character-sets/character-sets.xhtml">https://www.iana.org/assignments/character-sets/character-sets.xhtml</a>.</p>
</dd>
</dl>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code> — La API XML de ElementTree</a><ul>
<li><a class="reference internal" href="#tutorial">Tutorial</a><ul>
<li><a class="reference internal" href="#xml-tree-and-elements">Árbol y elementos XML</a></li>
<li><a class="reference internal" href="#parsing-xml">Procesando XML</a></li>
<li><a class="reference internal" href="#pull-api-for-non-blocking-parsing">API de consulta para un procesamiento no bloqueante</a></li>
<li><a class="reference internal" href="#finding-interesting-elements">Encontrando elementos interesantes</a></li>
<li><a class="reference internal" href="#modifying-an-xml-file">Modificando un archivo XML</a></li>
<li><a class="reference internal" href="#building-xml-documents">Construyendo documentos XML</a></li>
<li><a class="reference internal" href="#parsing-xml-with-namespaces">Procesando XML con espacio de nombres</a></li>
</ul>
</li>
<li><a class="reference internal" href="#xpath-support">Soporte de XPath</a><ul>
<li><a class="reference internal" href="#example">Ejemplo</a></li>
<li><a class="reference internal" href="#supported-xpath-syntax">Sintaxis XPath soportada</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference">Referencia</a><ul>
<li><a class="reference internal" href="#functions">Funciones</a></li>
</ul>
</li>
<li><a class="reference internal" href="#xinclude-support">Soporte de XInclude</a><ul>
<li><a class="reference internal" href="#id3">Ejemplo</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4">Referencia</a><ul>
<li><a class="reference internal" href="#elementinclude-functions">Funciones</a></li>
<li><a class="reference internal" href="#element-objects">Objetos Element</a></li>
<li><a class="reference internal" href="#elementtree-objects">Objetos ElementTree</a></li>
<li><a class="reference internal" href="#qname-objects">Objetos QName</a></li>
<li><a class="reference internal" href="#treebuilder-objects">Objetos TreeBuilder</a></li>
<li><a class="reference internal" href="#xmlparser-objects">Objetos XMLParser</a></li>
<li><a class="reference internal" href="#xmlpullparser-objects">Objetos XMLPullParser</a></li>
<li><a class="reference internal" href="#exceptions">Excepciones</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="xml.html"
                          title="capítulo anterior">Módulos de procesamiento XML</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="xml.dom.html"
                          title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.dom</span></code> — El <em>API</em> del Modelo de Objetos del Documento</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/library/xml.etree.elementtree.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="xml.dom.html" title="xml.dom — El API del Modelo de Objetos del Documento"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="xml.html" title="Módulos de procesamiento XML"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="markup.html" >Herramientas Para Procesar Formatos de Marcado Estructurado</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code> — La API XML de ElementTree</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 23, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>