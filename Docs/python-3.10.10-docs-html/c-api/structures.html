
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Estructuras de objetos comunes &#8212; documentación de Python - 3.10.10</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.10.10"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="Objetos Tipo" href="typeobj.html" />
    <link rel="prev" title="Asignación de objetos en el montículo" href="allocation.html" />
    <link rel="canonical" href="https://docs.python.org/3/c-api/structures.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#">Estructuras de objetos comunes</a><ul>
<li><a class="reference internal" href="#base-object-types-and-macros">Tipos objeto base y macros</a></li>
<li><a class="reference internal" href="#implementing-functions-and-methods">Implementando funciones y métodos</a></li>
<li><a class="reference internal" href="#accessing-attributes-of-extension-types">Acceder a atributos de tipos de extensión</a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="allocation.html"
                        title="capítulo anterior">Asignación de objetos en el montículo</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="typeobj.html"
                        title="próximo capítulo">Objetos Tipo</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/c-api/structures.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="typeobj.html" title="Objetos Tipo"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="allocation.html" title="Asignación de objetos en el montículo"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Manual de referencia de la API en C de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="objimpl.html" accesskey="U">Soporte de implementación de objetos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Estructuras de objetos comunes</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="common-object-structures">
<span id="common-structs"></span><h1>Estructuras de objetos comunes<a class="headerlink" href="#common-object-structures" title="Enlazar permanentemente con este título">¶</a></h1>
<p>Hay un gran número de estructuras que se utilizan en la definición de los tipos de objetos de Python. Esta sección describe estas estructuras y la forma en que se utilizan.</p>
<section id="base-object-types-and-macros">
<h2>Tipos objeto base y macros<a class="headerlink" href="#base-object-types-and-macros" title="Enlazar permanentemente con este título">¶</a></h2>
<p>En última instancia, todos los objetos de Python comparten un pequeño número de campos en el comienzo de la representación del objeto en la memoria. Estos están representados por la <a class="reference internal" href="#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> y <a class="reference internal" href="#c.PyVarObject" title="PyVarObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyVarObject</span></code></a>,que se definen, a su vez, por las expansiones de algunos macros también se utilizan, ya sea directa o indirectamente, en la definición de todos otros objetos de Python.</p>
<dl class="c type">
<dt id="c.PyObject">
<em class="property">type </em><code class="sig-name descname">PyObject</code><a class="headerlink" href="#c.PyObject" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Limited API</span></a>. (Only some members are part of the stable ABI.)</em><p>All object types are extensions of this type.  This is a type which
contains the information Python needs to treat a pointer to an object as an
object.  In a normal «release» build, it contains only the object’s
reference count and a pointer to the corresponding type object.
Nothing is actually declared to be a <a class="reference internal" href="#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a>, but every pointer
to a Python object can be cast to a <code class="xref c c-expr docutils literal notranslate"><a class="reference internal" href="#c.PyObject" title="PyObject"><span class="pre">PyObject</span></a><span class="pre">*</span></code>.  Access to the
members must be done by using the macros <a class="reference internal" href="#c.Py_REFCNT" title="Py_REFCNT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_REFCNT</span></code></a> and
<a class="reference internal" href="#c.Py_TYPE" title="Py_TYPE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TYPE</span></code></a>.</p>
</dd></dl>

<dl class="c type">
<dt id="c.PyVarObject">
<em class="property">type </em><code class="sig-name descname">PyVarObject</code><a class="headerlink" href="#c.PyVarObject" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Limited API</span></a>. (Only some members are part of the stable ABI.)</em><p>Esta es una extensión de <a class="reference internal" href="#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> que se suma el campo <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_size</span></code>. Esto sólo se utiliza para objetos que tienen cierta noción de longitud (<em>length</em>). Este tipo no suele aparecer en la API Python/C. El acceso a los miembros debe hacerse mediante el uso de las macros <a class="reference internal" href="#c.Py_REFCNT" title="Py_REFCNT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_REFCNT</span></code></a>, <a class="reference internal" href="#c.Py_TYPE" title="Py_TYPE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TYPE</span></code></a>, y <a class="reference internal" href="#c.Py_SIZE" title="Py_SIZE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_SIZE</span></code></a>.</p>
</dd></dl>

<dl class="c macro">
<dt id="c.PyObject_HEAD">
<code class="sig-name descname">PyObject_HEAD</code><a class="headerlink" href="#c.PyObject_HEAD" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><p>Esta es una macro utilizado cuando se declara nuevos tipos que representan objetos sin una longitud variable. La macro PyObject_HEAD se expande a:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="n">ob_base</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Consulte la documentación de <a class="reference internal" href="#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> en secciones anteriores.</p>
</dd></dl>

<dl class="c macro">
<dt id="c.PyObject_VAR_HEAD">
<code class="sig-name descname">PyObject_VAR_HEAD</code><a class="headerlink" href="#c.PyObject_VAR_HEAD" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><p>Esta es una macro utilizado cuando se declara nuevos tipos que representan objetos con una longitud que varía de una instancia a otra instancia. La macro PyObject_VAR_HEAD se expande a:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyVarObject</span><span class="w"> </span><span class="n">ob_base</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Consulte la documentación de <a class="reference internal" href="#c.PyVarObject" title="PyVarObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyVarObject</span></code></a> anteriormente.</p>
</dd></dl>

<dl class="c function">
<dt id="c.Py_Is">
int <code class="sig-name descname">Py_Is</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#c.PyObject" title="PyObject">PyObject</a> *<em>x</em>, <em class="property">const</em> <a class="reference internal" href="#c.PyObject" title="PyObject">PyObject</a> *<em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_Is" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.10.</em><p>Prueba si el objeto <em>x</em> es el objeto <em>y</em>, lo mismo que <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> en Python.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt id="c.Py_IsNone">
int <code class="sig-name descname">Py_IsNone</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#c.PyObject" title="PyObject">PyObject</a> *<em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_IsNone" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.10.</em><p>Prueba si un objeto es la instancia única <code class="docutils literal notranslate"><span class="pre">None</span></code>, lo mismo que <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">None</span></code> en Python.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt id="c.Py_IsTrue">
int <code class="sig-name descname">Py_IsTrue</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#c.PyObject" title="PyObject">PyObject</a> *<em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_IsTrue" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.10.</em><p>Prueba si un objeto es la instancia única <code class="docutils literal notranslate"><span class="pre">True</span></code>, lo mismo que <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">True</span></code> en Python.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt id="c.Py_IsFalse">
int <code class="sig-name descname">Py_IsFalse</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#c.PyObject" title="PyObject">PyObject</a> *<em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_IsFalse" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.10.</em><p>Prueba si un objeto es la instancia única <code class="docutils literal notranslate"><span class="pre">False</span></code>, lo mismo que <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">False</span></code> en Python.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt id="c.Py_TYPE">
<a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject">PyTypeObject</a> *<code class="sig-name descname">Py_TYPE</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#c.PyObject" title="PyObject">PyObject</a> *<em>o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_TYPE" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><p>Obtiene el tipo de objeto Python <em>o</em>.</p>
<p>Retorna una referencia prestada (<a class="reference internal" href="../glossary.html#term-borrowed-reference"><span class="xref std std-term">borrowed reference</span></a>).</p>
<p>Use the <a class="reference internal" href="#c.Py_SET_TYPE" title="Py_SET_TYPE"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SET_TYPE()</span></code></a> function to set an object type.</p>
</dd></dl>

<dl class="c function">
<dt id="c.Py_IS_TYPE">
int <code class="sig-name descname">Py_IS_TYPE</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyObject" title="PyObject">PyObject</a> *<em>o</em>, <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject">PyTypeObject</a> *<em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_IS_TYPE" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><p>Retorna un valor distinto de cero si el objeto <em>o</em> tipo es <em>type</em>. Retorna cero en caso contrario. Equivalente a: <code class="docutils literal notranslate"><span class="pre">Py_TYPE(o)</span> <span class="pre">==</span> <span class="pre">type</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt id="c.Py_SET_TYPE">
void <code class="sig-name descname">Py_SET_TYPE</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyObject" title="PyObject">PyObject</a> *<em>o</em>, <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject">PyTypeObject</a> *<em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_SET_TYPE" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><p>Establece el tipo del objeto <em>o</em> a <em>type</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt id="c.Py_REFCNT">
<a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t">Py_ssize_t</a> <code class="sig-name descname">Py_REFCNT</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#c.PyObject" title="PyObject">PyObject</a> *<em>o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_REFCNT" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><p>Obtiene la cuenta de referencias del objeto Python <em>o</em>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span><a class="reference internal" href="#c.Py_REFCNT" title="Py_REFCNT"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_REFCNT()</span></code></a> se cambia a la función estática en línea. Use <a class="reference internal" href="#c.Py_SET_REFCNT" title="Py_SET_REFCNT"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SET_REFCNT()</span></code></a> para establecer una cuenta de referencias de objetos.</p>
</div>
</dd></dl>

<dl class="c function">
<dt id="c.Py_SET_REFCNT">
void <code class="sig-name descname">Py_SET_REFCNT</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyObject" title="PyObject">PyObject</a> *<em>o</em>, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t">Py_ssize_t</a> <em>refcnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_SET_REFCNT" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><p>Establece el conteo de referencia del objeto <em>o</em> a <em>refcnt</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt id="c.Py_SIZE">
<a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t">Py_ssize_t</a> <code class="sig-name descname">Py_SIZE</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#c.PyVarObject" title="PyVarObject">PyVarObject</a> *<em>o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_SIZE" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><p>Obtiene el tamaño del objeto Python <em>o</em>.</p>
<p>Use the <a class="reference internal" href="#c.Py_SET_SIZE" title="Py_SET_SIZE"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SET_SIZE()</span></code></a> function to set an object size.</p>
</dd></dl>

<dl class="c function">
<dt id="c.Py_SET_SIZE">
void <code class="sig-name descname">Py_SET_SIZE</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyVarObject" title="PyVarObject">PyVarObject</a> *<em>o</em>, <a class="reference internal" href="intro.html#c.Py_ssize_t" title="Py_ssize_t">Py_ssize_t</a> <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_SET_SIZE" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><p>Establece el tamaño del objeto <em>o</em> a <em>size</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

<dl class="c macro">
<dt id="c.PyObject_HEAD_INIT">
<code class="sig-name descname">PyObject_HEAD_INIT</code><span class="sig-paren">(</span><em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_HEAD_INIT" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><p>Esta es una macro que se expande para valores de inicialización para un nuevo tipo <a class="reference internal" href="#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a>. Esta macro expande:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">_PyObject_EXTRA_INIT</span><span class="w"></span>
<span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"></span>
</pre></div>
</div>
</dd></dl>

<dl class="c macro">
<dt id="c.PyVarObject_HEAD_INIT">
<code class="sig-name descname">PyVarObject_HEAD_INIT</code><span class="sig-paren">(</span><em>type</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyVarObject_HEAD_INIT" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><p>Esta es una macro que se expande para valores de inicialización para un nuevo tipo <a class="reference internal" href="#c.PyVarObject" title="PyVarObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyVarObject</span></code></a>, incluyendo el campo <code class="xref py py-attr docutils literal notranslate"><span class="pre">ob_size</span></code>. Esta macro se expande a:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">_PyObject_EXTRA_INIT</span><span class="w"></span>
<span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"></span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="implementing-functions-and-methods">
<h2>Implementando funciones y métodos<a class="headerlink" href="#implementing-functions-and-methods" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="c type">
<dt id="c.PyCFunction">
<em class="property">type </em><code class="sig-name descname">PyCFunction</code><a class="headerlink" href="#c.PyCFunction" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Type of the functions used to implement most Python callables in C.
Functions of this type take two <code class="xref c c-expr docutils literal notranslate"><a class="reference internal" href="#c.PyObject" title="PyObject"><span class="pre">PyObject</span></a><span class="pre">*</span></code> parameters and return
one such value.  If the return value is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, an exception shall have
been set.  If not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the return value is interpreted as the return
value of the function as exposed in Python.  The function must return a new
reference.</p>
<p>La firma de la función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">PyCFunction</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</dd></dl>

<dl class="c type">
<dt id="c.PyCFunctionWithKeywords">
<em class="property">type </em><code class="sig-name descname">PyCFunctionWithKeywords</code><a class="headerlink" href="#c.PyCFunctionWithKeywords" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p>Tipo de las funciones que se utilizan para implementar invocables Python en C con la firma <code class="xref py py-const docutils literal notranslate"><span class="pre">METH_VARARGS</span> <span class="pre">|</span> <span class="pre">METH_KEYWORDS</span></code>. La firma de la función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">PyCFunctionWithKeywords</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">kwargs</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</dd></dl>

<dl class="c type">
<dt id="c._PyCFunctionFast">
<em class="property">type </em><code class="sig-name descname">_PyCFunctionFast</code><a class="headerlink" href="#c._PyCFunctionFast" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><p>Tipo de las funciones que se utilizan para implementar invocables Python en C con la firma <a class="reference internal" href="#METH_FASTCALL" title="METH_FASTCALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">METH_FASTCALL</span></code></a>. La firma de la función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">_PyCFunctionFast</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="n">nargs</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</dd></dl>

<dl class="c type">
<dt id="c._PyCFunctionFastWithKeywords">
<em class="property">type </em><code class="sig-name descname">_PyCFunctionFastWithKeywords</code><a class="headerlink" href="#c._PyCFunctionFastWithKeywords" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><p>Tipo de las funciones que se utilizan para implementar invocables Python en C con la firma <code class="xref py py-const docutils literal notranslate"><span class="pre">METH_FASTCALL</span> <span class="pre">|</span> <span class="pre">METH_KEYWORDS</span></code>. La firma de la función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="nf">_PyCFunctionFastWithKeywords</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"></span>
<span class="w">                                       </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"></span>
<span class="w">                                       </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="n">nargs</span><span class="p">,</span><span class="w"></span>
<span class="w">                                       </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">kwnames</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</dd></dl>

<dl class="c type">
<dt id="c.PyCMethod">
<em class="property">type </em><code class="sig-name descname">PyCMethod</code><a class="headerlink" href="#c.PyCMethod" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><p>Tipo de las funciones que se utilizan para implementar invocables Python en C con la firma <code class="xref py py-const docutils literal notranslate"><span class="pre">METH_METHOD</span> <span class="pre">|</span> <span class="pre">METH_FASTCALL</span> <span class="pre">|</span> <span class="pre">METH_KEYWORDS</span></code>. La firma de la función es:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">PyCMethod</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">PyTypeObject</span><span class="w"> </span><span class="o">*</span><span class="n">defining_class</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="n">nargs</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">kwnames</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

<dl class="c type">
<dt id="c.PyMethodDef">
<em class="property">type </em><code class="sig-name descname">PyMethodDef</code><a class="headerlink" href="#c.PyMethodDef" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> (including all members).</em><p>Estructura utiliza para describir un método de un tipo de extensión. Esta estructura tiene cuatro campos:</p>
<dl class="c member">
<dt id="c.PyMethodDef.ml_name">
<em class="property">const</em> char *<code class="sig-name descname">ml_name</code><a class="headerlink" href="#c.PyMethodDef.ml_name" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><p>nombre del método</p>
</dd></dl>

<dl class="c member">
<dt id="c.PyMethodDef.ml_meth">
<a class="reference internal" href="#c.PyCFunction" title="PyCFunction">PyCFunction</a> <code class="sig-name descname">ml_meth</code><a class="headerlink" href="#c.PyMethodDef.ml_meth" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><p>puntero a la implementación en C</p>
</dd></dl>

<dl class="c member">
<dt id="c.PyMethodDef.ml_flags">
int <code class="sig-name descname">ml_flags</code><a class="headerlink" href="#c.PyMethodDef.ml_flags" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><p>flags bits indicating how the call should be constructed</p>
</dd></dl>

<dl class="c member">
<dt id="c.PyMethodDef.ml_doc">
<em class="property">const</em> char *<code class="sig-name descname">ml_doc</code><a class="headerlink" href="#c.PyMethodDef.ml_doc" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><p>puntos a los contenidos del docstring</p>
</dd></dl>

</dd></dl>

<p>The <code class="xref c c-member docutils literal notranslate"><span class="pre">ml_meth</span></code> is a C function pointer.  The functions may be of different
types, but they always return <code class="xref c c-expr docutils literal notranslate"><a class="reference internal" href="#c.PyObject" title="PyObject"><span class="pre">PyObject</span></a><span class="pre">*</span></code>.  If the function is not of
the <a class="reference internal" href="#c.PyCFunction" title="PyCFunction"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCFunction</span></code></a>, the compiler will require a cast in the method table.
Even though <a class="reference internal" href="#c.PyCFunction" title="PyCFunction"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCFunction</span></code></a> defines the first parameter as
<code class="xref c c-expr docutils literal notranslate"><a class="reference internal" href="#c.PyObject" title="PyObject"><span class="pre">PyObject</span></a><span class="pre">*</span></code>, it is common that the method implementation uses the
specific C type of the <em>self</em> object.</p>
<p>The <code class="xref c c-member docutils literal notranslate"><span class="pre">ml_flags</span></code> field is a bitfield which can include the following flags.
The individual flags indicate either a calling convention or a binding
convention.</p>
<p>Existen estas convenciones de llamada:</p>
<dl class="py data">
<dt id="METH_VARARGS">
<code class="sig-name descname">METH_VARARGS</code><a class="headerlink" href="#METH_VARARGS" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>This is the typical calling convention, where the methods have the type
<a class="reference internal" href="#c.PyCFunction" title="PyCFunction"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCFunction</span></code></a>. The function expects two <code class="xref c c-expr docutils literal notranslate"><a class="reference internal" href="#c.PyObject" title="PyObject"><span class="pre">PyObject</span></a><span class="pre">*</span></code> values.
The first one is the <em>self</em> object for methods; for module functions, it is
the module object.  The second parameter (often called <em>args</em>) is a tuple
object representing all arguments. This parameter is typically processed
using <a class="reference internal" href="arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> or <a class="reference internal" href="arg.html#c.PyArg_UnpackTuple" title="PyArg_UnpackTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_UnpackTuple()</span></code></a>.</p>
</dd></dl>

<dl class="py data">
<dt>
<code class="sig-name descname">METH_VARARGS | METH_KEYWORDS</code></dt>
<dd><p>Los métodos con estas <em>flags</em> deben ser del tipo <a class="reference internal" href="#c.PyCFunctionWithKeywords" title="PyCFunctionWithKeywords"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCFunctionWithKeywords</span></code></a>. La función espera tres parámetros: <em>self</em>, <em>args</em>, <em>kwargs</em> donde <em>kwargs</em> es un diccionario de todos los argumentos de palabras clave o, posiblemente, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> si no hay argumentos de palabra clave. Los parámetros se procesan típicamente usando <a class="reference internal" href="arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a>.</p>
</dd></dl>

<dl class="py data">
<dt id="METH_FASTCALL">
<code class="sig-name descname">METH_FASTCALL</code><a class="headerlink" href="#METH_FASTCALL" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Fast calling convention supporting only positional arguments.
The methods have the type <a class="reference internal" href="#c._PyCFunctionFast" title="_PyCFunctionFast"><code class="xref c c-type docutils literal notranslate"><span class="pre">_PyCFunctionFast</span></code></a>.
The first parameter is <em>self</em>, the second parameter is a C array
of <code class="xref c c-expr docutils literal notranslate"><a class="reference internal" href="#c.PyObject" title="PyObject"><span class="pre">PyObject</span></a><span class="pre">*</span></code> values indicating the arguments and the third
parameter is the number of arguments (the length of the array).</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Ahora <code class="docutils literal notranslate"><span class="pre">METH_FASTCALL</span></code> es parte de la ABI estable.</p>
</div>
</dd></dl>

<dl class="py data">
<dt>
<code class="sig-name descname">METH_FASTCALL | METH_KEYWORDS</code></dt>
<dd><p>Extension of <a class="reference internal" href="#METH_FASTCALL" title="METH_FASTCALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">METH_FASTCALL</span></code></a> supporting also keyword arguments,
with methods of type <a class="reference internal" href="#c._PyCFunctionFastWithKeywords" title="_PyCFunctionFastWithKeywords"><code class="xref c c-type docutils literal notranslate"><span class="pre">_PyCFunctionFastWithKeywords</span></code></a>.
Keyword arguments are passed the same way as in the
<a class="reference internal" href="call.html#vectorcall"><span class="std std-ref">vectorcall protocol</span></a>:
there is an additional fourth <code class="xref c c-expr docutils literal notranslate"><a class="reference internal" href="#c.PyObject" title="PyObject"><span class="pre">PyObject</span></a><span class="pre">*</span></code> parameter
which is a tuple representing the names of the keyword arguments
(which are guaranteed to be strings)
or possibly <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if there are no keywords.  The values of the keyword
arguments are stored in the <em>args</em> array, after the positional arguments.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt>
<code class="sig-name descname">METH_METHOD | METH_FASTCALL | METH_KEYWORDS</code></dt>
<dd><p>Extensión de <code class="xref py py-const docutils literal notranslate"><span class="pre">METH_FASTCALL</span> <span class="pre">|</span> <span class="pre">METH_KEYWORDS</span></code> que admite la <em>clase definitoria</em>, es decir, la clase que contiene el método en cuestión. La clase definitoria podría ser una superclase de <code class="docutils literal notranslate"><span class="pre">Py_TYPE(self)</span></code>.</p>
<p>El método debe ser de tipo <a class="reference internal" href="#c.PyCMethod" title="PyCMethod"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCMethod</span></code></a>, lo mismo que para <code class="docutils literal notranslate"><span class="pre">METH_FASTCALL</span> <span class="pre">|</span> <span class="pre">METH_KEYWORDS</span></code> con el argumento <code class="docutils literal notranslate"><span class="pre">defining_clase</span></code> añadido después de <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="METH_NOARGS">
<code class="sig-name descname">METH_NOARGS</code><a class="headerlink" href="#METH_NOARGS" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Métodos sin parámetros no tienen que comprobar si los argumentos se dan si están registrados con el <em>flag</em> <a class="reference internal" href="#METH_NOARGS" title="METH_NOARGS"><code class="xref py py-const docutils literal notranslate"><span class="pre">METH_NOARGS</span></code></a>. Tienen que ser de tipo <a class="reference internal" href="#c.PyCFunction" title="PyCFunction"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCFunction</span></code></a>. El primer parámetro normalmente se denomina <em>self</em> y llevará a cabo una referencia a la instancia módulo u objeto. En todos los casos el segundo parámetro será <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd></dl>

<dl class="py data">
<dt id="METH_O">
<code class="sig-name descname">METH_O</code><a class="headerlink" href="#METH_O" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Methods with a single object argument can be listed with the <a class="reference internal" href="#METH_O" title="METH_O"><code class="xref py py-const docutils literal notranslate"><span class="pre">METH_O</span></code></a>
flag, instead of invoking <a class="reference internal" href="arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> with a <code class="docutils literal notranslate"><span class="pre">&quot;O&quot;</span></code> argument.
They have the type <a class="reference internal" href="#c.PyCFunction" title="PyCFunction"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCFunction</span></code></a>, with the <em>self</em> parameter, and a
<code class="xref c c-expr docutils literal notranslate"><a class="reference internal" href="#c.PyObject" title="PyObject"><span class="pre">PyObject</span></a><span class="pre">*</span></code> parameter representing the single argument.</p>
</dd></dl>

<p>Estas dos constantes no se utilizan para indicar la convención de llamada si no la vinculación cuando su usan con métodos de las clases. Estos no se pueden usar para funciones definidas para módulos. A lo sumo uno de estos <em>flags</em> puede establecerse en un método dado.</p>
<dl class="py data">
<dt id="METH_CLASS">
<code class="sig-name descname">METH_CLASS</code><a class="headerlink" href="#METH_CLASS" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p id="index-0">Al método se le pasará el objeto tipo como primer parámetro, en lugar de una instancia del tipo. Esto se utiliza para crear métodos de clase (<em>class methods</em>), similar a lo que se crea cuando se utiliza la función <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> incorporada.</p>
</dd></dl>

<dl class="py data">
<dt id="METH_STATIC">
<code class="sig-name descname">METH_STATIC</code><a class="headerlink" href="#METH_STATIC" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p id="index-1">El método pasará <code class="docutils literal notranslate"><span class="pre">NULL</span></code> como el primer parámetro en lugar de una instancia del tipo. Esto se utiliza para crear métodos estáticos (<em>static methods</em>), similar a lo que se crea cuando se utiliza la función <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a> incorporada.</p>
</dd></dl>

<p>En otros controles constantes dependiendo si se carga un método en su lugar (<em>in place</em>) de otra definición con el mismo nombre del método.</p>
<dl class="py data">
<dt id="METH_COEXIST">
<code class="sig-name descname">METH_COEXIST</code><a class="headerlink" href="#METH_COEXIST" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El método se cargará en lugar de las definiciones existentes. Sin <em>METH_COEXIST</em>, el comportamiento predeterminado es saltarse las definiciones repetidas. Desde envolturas de ranura se cargan antes de la tabla de métodos, la existencia de una ranura <em>sq_contains</em>, por ejemplo, generaría un método envuelto llamado <code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code> e impediría la carga de una PyCFunction correspondiente con el mismo nombre. Con el <em>flag</em> definido, la PyCFunction se cargará en lugar del objeto envoltorio y coexistirá con la ranura. Esto es útil porque las llamadas a PyCFunctions se optimizan más que las llamadas a objetos envolvente.</p>
</dd></dl>

</section>
<section id="accessing-attributes-of-extension-types">
<h2>Acceder a atributos de tipos de extensión<a class="headerlink" href="#accessing-attributes-of-extension-types" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="c type">
<dt id="c.PyMemberDef">
<em class="property">type </em><code class="sig-name descname">PyMemberDef</code><a class="headerlink" href="#c.PyMemberDef" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> (including all members).</em><p>Estructura que describe un atributo de un tipo que corresponde a un miembro de la estructura de C. Sus campos son:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 23%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Campo</p></th>
<th class="head"><p>Tipo C</p></th>
<th class="head"><p>Significado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></p></td>
<td><p>const char *</p></td>
<td><p>nombre del miembro</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">type</span></code></p></td>
<td><p>int</p></td>
<td><p>el tipo de miembro en la estructura de C</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">offset</span></code></p></td>
<td><p>Py_ssize_t</p></td>
<td><p>el desplazamiento en bytes que el miembro se encuentra en la estructura de objetos tipo</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">flags</span></code></p></td>
<td><p>int</p></td>
<td><p><em>flags</em> bits que indican si el campo debe ser de sólo lectura o de escritura</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">doc</span></code></p></td>
<td><p>const char *</p></td>
<td><p>puntos a los contenidos del docstring</p></td>
</tr>
</tbody>
</table>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">type</span></code> puede ser uno de muchos macros <code class="docutils literal notranslate"><span class="pre">T_</span></code> correspondientes a diversos tipos C. Cuando se accede al miembro en Python, será convertida al tipo Python equivalente.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 45%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Nombre de la macro</p></th>
<th class="head"><p>Tipo C</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>T_SHORT</p></td>
<td><p>short</p></td>
</tr>
<tr class="row-odd"><td><p>T_INT</p></td>
<td><p>int</p></td>
</tr>
<tr class="row-even"><td><p>T_LONG</p></td>
<td><p>long</p></td>
</tr>
<tr class="row-odd"><td><p>T_FLOAT</p></td>
<td><p>float</p></td>
</tr>
<tr class="row-even"><td><p>T_DOUBLE</p></td>
<td><p>double</p></td>
</tr>
<tr class="row-odd"><td><p>T_STRING</p></td>
<td><p>const char *</p></td>
</tr>
<tr class="row-even"><td><p>T_OBJECT</p></td>
<td><p>PyObject *</p></td>
</tr>
<tr class="row-odd"><td><p>T_OBJECT_EX</p></td>
<td><p>PyObject *</p></td>
</tr>
<tr class="row-even"><td><p>T_CHAR</p></td>
<td><p>char</p></td>
</tr>
<tr class="row-odd"><td><p>T_BYTE</p></td>
<td><p>char</p></td>
</tr>
<tr class="row-even"><td><p>T_UBYTE</p></td>
<td><p>unsigned char</p></td>
</tr>
<tr class="row-odd"><td><p>T_UINT</p></td>
<td><p>unsigned int</p></td>
</tr>
<tr class="row-even"><td><p>T_USHORT</p></td>
<td><p>unsigned short</p></td>
</tr>
<tr class="row-odd"><td><p>T_ULONG</p></td>
<td><p>unsigned long</p></td>
</tr>
<tr class="row-even"><td><p>T_BOOL</p></td>
<td><p>char</p></td>
</tr>
<tr class="row-odd"><td><p>T_LONGLONG</p></td>
<td><p>long long</p></td>
</tr>
<tr class="row-even"><td><p>T_ULONGLONG</p></td>
<td><p>unsigned long long</p></td>
</tr>
<tr class="row-odd"><td><p>T_PYSSIZET</p></td>
<td><p>Py_ssize_t</p></td>
</tr>
</tbody>
</table>
<p><code class="xref c c-macro docutils literal notranslate"><span class="pre">T_OBJECT</span></code> y <code class="xref c c-macro docutils literal notranslate"><span class="pre">T_OBJECT_EX</span></code> se diferencian en que <code class="xref c c-macro docutils literal notranslate"><span class="pre">T_OBJECT</span></code> retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si el miembro es <code class="docutils literal notranslate"><span class="pre">NULL</span></code> y <code class="xref c c-macro docutils literal notranslate"><span class="pre">T_OBJECT_EX</span></code> lanza un <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Trate de usar <code class="xref c c-macro docutils literal notranslate"><span class="pre">T_OBJECT_EX</span></code> sobre <code class="xref c c-macro docutils literal notranslate"><span class="pre">T_OBJECT</span></code> porque <code class="xref c c-macro docutils literal notranslate"><span class="pre">T_OBJECT_EX</span></code> maneja el uso de la declaración <a class="reference internal" href="../reference/simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> en ese atributo más correctamente que <code class="xref c c-macro docutils literal notranslate"><span class="pre">T_OBJECT</span></code>.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">flags</span></code> puede ser <code class="docutils literal notranslate"><span class="pre">0</span></code> para el acceso de escritura y lectura o <code class="xref c c-macro docutils literal notranslate"><span class="pre">READONLY</span></code> para el acceso de sólo lectura. El uso de <code class="xref c c-macro docutils literal notranslate"><span class="pre">T_STRING</span></code> para <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">type</span></code></a> implica <code class="xref c c-macro docutils literal notranslate"><span class="pre">READONLY</span></code>. Los datos <code class="xref c c-macro docutils literal notranslate"><span class="pre">T_STRING</span></code> se interpretan como UTF-8. Sólo se pueden eliminar <code class="xref c c-macro docutils literal notranslate"><span class="pre">T_OBJECT</span></code> y miembros <code class="xref c c-macro docutils literal notranslate"><span class="pre">T_OBJECT_EX</span></code>. (Se establecen a <code class="docutils literal notranslate"><span class="pre">NULL</span></code>).</p>
<p id="pymemberdef-offsets">Los tipos asignados al heap (creados usando <a class="reference internal" href="type.html#c.PyType_FromSpec" title="PyType_FromSpec"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_FromSpec()</span></code></a> o similar), <code class="docutils literal notranslate"><span class="pre">PyMemberDef</span></code> pueden contener definiciones para los miembros especiales <code class="docutils literal notranslate"><span class="pre">__dictoffset__</span></code>, <code class="docutils literal notranslate"><span class="pre">__weaklistoffset__</span></code> y <code class="docutils literal notranslate"><span class="pre">__vectorcalloffset__</span></code>, correspondientes a <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_dictoffset" title="PyTypeObject.tp_dictoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dictoffset</span></code></a>, <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_weaklistoffset" title="PyTypeObject.tp_weaklistoffset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_weaklistoffset</span></code></a> y <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_vectorcall_offset" title="PyTypeObject.tp_vectorcall_offset"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_vectorcall_offset</span></code></a> en objetos de tipo. Estos deben definirse con <code class="docutils literal notranslate"><span class="pre">T_PYSSIZET</span></code> y <code class="docutils literal notranslate"><span class="pre">READONLY</span></code>, por ejemplo:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">PyMemberDef</span><span class="w"> </span><span class="n">spam_type_members</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="s">&quot;__dictoffset__&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">T_PYSSIZET</span><span class="p">,</span><span class="w"> </span><span class="n">offsetof</span><span class="p">(</span><span class="n">Spam_object</span><span class="p">,</span><span class="w"> </span><span class="n">dict</span><span class="p">),</span><span class="w"> </span><span class="n">READONLY</span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="nb">NULL</span><span class="p">}</span><span class="w">  </span><span class="cm">/* Sentinel */</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</dd></dl>

<dl class="c function">
<dt id="c.PyMember_GetOne">
<a class="reference internal" href="#c.PyObject" title="PyObject">PyObject</a> *<code class="sig-name descname">PyMember_GetOne</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>obj_addr</em>, <em class="property">struct</em> <a class="reference internal" href="#c.PyMemberDef" title="PyMemberDef">PyMemberDef</a> *<em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMember_GetOne" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><p>Obtiene un atributo que pertenece al objeto en la dirección <em>obj_addr</em>. El atributo se describe por <code class="docutils literal notranslate"><span class="pre">PyMemberDef</span></code> <em>m</em>. Retorna <code class="docutils literal notranslate"><span class="pre">NULL</span></code> en caso de error.</p>
</dd></dl>

<dl class="c function">
<dt id="c.PyMember_SetOne">
int <code class="sig-name descname">PyMember_SetOne</code><span class="sig-paren">(</span>char *<em>obj_addr</em>, <em class="property">struct</em> <a class="reference internal" href="#c.PyMemberDef" title="PyMemberDef">PyMemberDef</a> *<em>m</em>, <a class="reference internal" href="#c.PyObject" title="PyObject">PyObject</a> *<em>o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMember_SetOne" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><p>Establece un atributo que pertenece al objeto en la dirección <em>obj_addr</em> al objeto <em>o</em>. El atributo a establecer se describe por <code class="docutils literal notranslate"><span class="pre">PyMemberDef</span></code> <em>m</em>. Retorna <code class="docutils literal notranslate"><span class="pre">0</span></code> si tiene éxito y un valor negativo si falla.</p>
</dd></dl>

<dl class="c type">
<dt id="c.PyGetSetDef">
<em class="property">type </em><code class="sig-name descname">PyGetSetDef</code><a class="headerlink" href="#c.PyGetSetDef" title="Enlazar permanentemente con esta definición">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> (including all members).</em><p>Estructura para definir el acceso para un tipo como el de una propiedad. Véase también la descripción de la ranura <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_getset" title="PyTypeObject.tp_getset"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyTypeObject.tp_getset</span></code></a>.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 27%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Campo</p></th>
<th class="head"><p>Tipo C</p></th>
<th class="head"><p>Significado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>nombre</p></td>
<td><p>const char *</p></td>
<td><p>nombre del atributo</p></td>
</tr>
<tr class="row-odd"><td><p>get</p></td>
<td><p>getter</p></td>
<td><p>C function to get the attribute</p></td>
</tr>
<tr class="row-even"><td><p>set</p></td>
<td><p>setter</p></td>
<td><p>función opcional C para establecer o eliminar el atributo, si se omite el atributo es de sólo lectura</p></td>
</tr>
<tr class="row-odd"><td><p>doc</p></td>
<td><p>const char *</p></td>
<td><p>docstring opcional</p></td>
</tr>
<tr class="row-even"><td><p>clausura (<em>closure</em>)</p></td>
<td><p>void *</p></td>
<td><p>puntero de función opcional, proporcionar datos adicionales para <em>getter</em> y <em>setter</em></p></td>
</tr>
</tbody>
</table>
<p>The <code class="docutils literal notranslate"><span class="pre">get</span></code> function takes one <code class="xref c c-expr docutils literal notranslate"><a class="reference internal" href="#c.PyObject" title="PyObject"><span class="pre">PyObject</span></a><span class="pre">*</span></code> parameter (the
instance) and a function pointer (the associated <code class="docutils literal notranslate"><span class="pre">closure</span></code>):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">getter</span><span class="p">)(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Debe retornar una nueva referencia en caso de éxito o <code class="docutils literal notranslate"><span class="pre">NULL</span></code> con una excepción establecida en caso de error.</p>
<p><code class="docutils literal notranslate"><span class="pre">set</span></code> functions take two <code class="xref c c-expr docutils literal notranslate"><a class="reference internal" href="#c.PyObject" title="PyObject"><span class="pre">PyObject</span></a><span class="pre">*</span></code> parameters (the instance and
the value to be set) and a function pointer (the associated <code class="docutils literal notranslate"><span class="pre">closure</span></code>):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">setter</span><span class="p">)(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>En caso de que el atributo deba suprimirse el segundo parámetro es <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. Debe retornar <code class="docutils literal notranslate"><span class="pre">0</span></code> en caso de éxito o <code class="docutils literal notranslate"><span class="pre">-1</span></code> con una excepción explícita en caso de fallo.</p>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#">Estructuras de objetos comunes</a><ul>
<li><a class="reference internal" href="#base-object-types-and-macros">Tipos objeto base y macros</a></li>
<li><a class="reference internal" href="#implementing-functions-and-methods">Implementando funciones y métodos</a></li>
<li><a class="reference internal" href="#accessing-attributes-of-extension-types">Acceder a atributos de tipos de extensión</a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="allocation.html"
                        title="capítulo anterior">Asignación de objetos en el montículo</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="typeobj.html"
                        title="próximo capítulo">Objetos Tipo</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/c-api/structures.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="typeobj.html" title="Objetos Tipo"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="allocation.html" title="Asignación de objetos en el montículo"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Manual de referencia de la API en C de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="objimpl.html" >Soporte de implementación de objetos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Estructuras de objetos comunes</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 27, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>