
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Bucle de eventos &#8212; documentación de Python - 3.10.10</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.10.10"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="Futures" href="asyncio-future.html" />
    <link rel="prev" title="Excepciones" href="asyncio-exceptions.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/asyncio-eventloop.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#">Bucle de eventos</a><ul>
<li><a class="reference internal" href="#event-loop-methods">Métodos del bucle de eventos</a><ul>
<li><a class="reference internal" href="#running-and-stopping-the-loop">Iniciar y para el bucle</a></li>
<li><a class="reference internal" href="#scheduling-callbacks">Programación de llamadas de retorno</a></li>
<li><a class="reference internal" href="#scheduling-delayed-callbacks">Planificando llamadas retardadas</a></li>
<li><a class="reference internal" href="#creating-futures-and-tasks">Creando Futuros y Tareas</a></li>
<li><a class="reference internal" href="#opening-network-connections">Abriendo conexiones de red</a></li>
<li><a class="reference internal" href="#creating-network-servers">Creando servidores de red</a></li>
<li><a class="reference internal" href="#transferring-files">Transfiriendo archivos</a></li>
<li><a class="reference internal" href="#tls-upgrade">Actualización de TLS</a></li>
<li><a class="reference internal" href="#watching-file-descriptors">Viendo descriptores de archivos</a></li>
<li><a class="reference internal" href="#working-with-socket-objects-directly">Trabajar con objetos sockets directamente</a></li>
<li><a class="reference internal" href="#dns">DNS</a></li>
<li><a class="reference internal" href="#working-with-pipes">Trabajando con tuberías</a></li>
<li><a class="reference internal" href="#unix-signals">Señales Unix</a></li>
<li><a class="reference internal" href="#executing-code-in-thread-or-process-pools">Ejecutando código en un hilos o grupos de procesos</a></li>
<li><a class="reference internal" href="#error-handling-api">API para manejo de errores</a></li>
<li><a class="reference internal" href="#enabling-debug-mode">Habilitando el modo depuración</a></li>
<li><a class="reference internal" href="#running-subprocesses">Ejecutando Subprocesos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#callback-handles">Gestores de llamadas</a></li>
<li><a class="reference internal" href="#server-objects">Objetos Servidor</a></li>
<li><a class="reference internal" href="#event-loop-implementations">Implementaciones del bucle de eventos</a></li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#hello-world-with-call-soon">Hola Mundo con call_soon()</a></li>
<li><a class="reference internal" href="#display-the-current-date-with-call-later">Muestra la fecha actual con call_later()</a></li>
<li><a class="reference internal" href="#watch-a-file-descriptor-for-read-events">Mirar un descriptor de archivo para leer eventos</a></li>
<li><a class="reference internal" href="#set-signal-handlers-for-sigint-and-sigterm">Establece los gestores de señal para SIGINT y SIGTERM</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="asyncio-exceptions.html"
                        title="capítulo anterior">Excepciones</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="asyncio-future.html"
                        title="próximo capítulo">Futures</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/asyncio-eventloop.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="asyncio-future.html" title="Futures"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="asyncio-exceptions.html" title="Excepciones"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La Biblioteca Estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >Comunicación en redes y entre procesos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" accesskey="U"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code> — E/S Asíncrona</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Bucle de eventos</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="event-loop">
<span id="asyncio-event-loop"></span><h1>Bucle de eventos<a class="headerlink" href="#event-loop" title="Enlazar permanentemente con este título">¶</a></h1>
<p><strong>Código fuente:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/asyncio/events.py">Lib/asyncio/events.py</a>, <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/asyncio/base_events.py">Lib/asyncio/base_events.py</a></p>
<hr class="docutils" />
<p class="rubric">Prólogo</p>
<p>El bucle de eventos es el núcleo de cada aplicación asyncio. Los bucles de eventos ejecutan tareas asíncronas y llamadas de retorno, realizan operaciones de E/S de red y ejecutan subprocesos.</p>
<p>Los desarrolladores de aplicaciones normalmente deberían usar las funciones asyncio de alto nivel, como: <a class="reference internal" href="asyncio-task.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>, y rara vez deberían necesitar hacer referencia al objeto de bucle o llamar a sus métodos. Esta sección esta dirigida principalmente a autores de código de nivel inferior, bibliotecas y frameworks, quienes necesitan un control mas preciso sobre el comportamiento del bucle de eventos.</p>
<p class="rubric">Obtención del bucle de eventos</p>
<p>Las siguientes funciones de bajo nivel se pueden utilizar para obtener, establecer o crear un bucle de eventos:</p>
<dl class="py function">
<dt id="asyncio.get_running_loop">
<code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">get_running_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.get_running_loop" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el bucle de eventos en ejecución en el hilo del sistema operativo actual.</p>
<p>Raise a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> if there is no running event loop.</p>
<p>This function can only be called from a coroutine or a callback.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="asyncio.get_event_loop">
<code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">get_event_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.get_event_loop" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Obtiene bucle de eventos actual.</p>
<p>When called from a coroutine or a callback (e.g. scheduled with
call_soon or similar API), this function will always return the
running event loop.</p>
<p>If there is no running event loop set, the function will return
the result of the <code class="docutils literal notranslate"><span class="pre">get_event_loop_policy().get_event_loop()</span></code> call.</p>
<p>Dado que esta función tiene un comportamiento bastante complejo (especialmente cuando están en uso las políticas de bucle de eventos personalizadas), usar la función <a class="reference internal" href="#asyncio.get_running_loop" title="asyncio.get_running_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_running_loop()</span></code></a> es preferible antes que <a class="reference internal" href="#asyncio.get_event_loop" title="asyncio.get_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_event_loop()</span></code></a> en corrutinas y llamadas de retorno.</p>
<p>As noted above, consider using the higher-level <a class="reference internal" href="asyncio-task.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a> function,
instead of using these lower level functions to manually create and close an
event loop.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>In Python versions 3.10.0–3.10.8 and 3.11.0 this function
(and other functions which use it implicitly) emitted a
<a class="reference internal" href="exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> if there was no running event loop, even if
the current loop was set on the policy.
In Python versions 3.10.9, 3.11.1 and 3.12 they emit a
<a class="reference internal" href="exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> if there is no running event loop and no
current loop is set.
In some future Python release this will become an error.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="asyncio.set_event_loop">
<code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">set_event_loop</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">loop</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.set_event_loop" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Set <em>loop</em> as the current event loop for the current OS thread.</p>
</dd></dl>

<dl class="py function">
<dt id="asyncio.new_event_loop">
<code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">new_event_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.new_event_loop" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Create and return a new event loop object.</p>
</dd></dl>

<p>Tenga en cuenta que el comportamiento de las funciones <a class="reference internal" href="#asyncio.get_event_loop" title="asyncio.get_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_event_loop()</span></code></a>, <a class="reference internal" href="#asyncio.set_event_loop" title="asyncio.set_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_event_loop()</span></code></a>, y <a class="reference internal" href="#asyncio.new_event_loop" title="asyncio.new_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">new_event_loop()</span></code></a> puede ser modificado mediante <a class="reference internal" href="asyncio-policy.html#asyncio-policies"><span class="std std-ref">estableciendo una política de bucle de eventos personalizada</span></a>.</p>
<p class="rubric">Contenidos</p>
<p>Esta página de documentación contiene las siguientes secciones:</p>
<ul class="simple">
<li><p>La sección <a class="reference internal" href="#event-loop-methods">Métodos del bucle de eventos</a> es la documentación de referencia de las APIs del bucle de eventos;</p></li>
<li><p>La sección <a class="reference internal" href="#callback-handles">Callback Handles</a> documenta las instancias <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handle</span></code></a> y <a class="reference internal" href="#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimerHandle</span></code></a> las cuales son retornadas por métodos planificados como <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a> y <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a>;</p></li>
<li><p>La sección <a class="reference internal" href="#server-objects">Objetos del servidor</a> documenta tipos retornados por los métodos del bucle de eventos como <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>;</p></li>
<li><p>La sección <a class="reference internal" href="#event-loop-implementations">Implementaciones de bucle de eventos</a> documenta las clases <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> y <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>;</p></li>
<li><p>La sección <a class="reference internal" href="#examples">Ejemplos</a> muestra como trabajar con algunas APIs de bucle de eventos.</p></li>
</ul>
<section id="event-loop-methods">
<span id="asyncio-event-loop-methods"></span><h2>Métodos del bucle de eventos<a class="headerlink" href="#event-loop-methods" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los bucles de eventos tienen APIs de <strong>bajo nivel</strong> para lo siguiente:</p>
<div class="contents local topic" id="contenido">
<ul class="simple">
<li><p><a class="reference internal" href="#running-and-stopping-the-loop" id="id1">Iniciar y para el bucle</a></p></li>
<li><p><a class="reference internal" href="#scheduling-callbacks" id="id2">Programación de llamadas de retorno</a></p></li>
<li><p><a class="reference internal" href="#scheduling-delayed-callbacks" id="id3">Planificando llamadas retardadas</a></p></li>
<li><p><a class="reference internal" href="#creating-futures-and-tasks" id="id4">Creando Futuros y Tareas</a></p></li>
<li><p><a class="reference internal" href="#opening-network-connections" id="id5">Abriendo conexiones de red</a></p></li>
<li><p><a class="reference internal" href="#creating-network-servers" id="id6">Creando servidores de red</a></p></li>
<li><p><a class="reference internal" href="#transferring-files" id="id7">Transfiriendo archivos</a></p></li>
<li><p><a class="reference internal" href="#tls-upgrade" id="id8">Actualización de TLS</a></p></li>
<li><p><a class="reference internal" href="#watching-file-descriptors" id="id9">Viendo descriptores de archivos</a></p></li>
<li><p><a class="reference internal" href="#working-with-socket-objects-directly" id="id10">Trabajar con objetos sockets directamente</a></p></li>
<li><p><a class="reference internal" href="#dns" id="id11">DNS</a></p></li>
<li><p><a class="reference internal" href="#working-with-pipes" id="id12">Trabajando con tuberías</a></p></li>
<li><p><a class="reference internal" href="#unix-signals" id="id13">Señales Unix</a></p></li>
<li><p><a class="reference internal" href="#executing-code-in-thread-or-process-pools" id="id14">Ejecutando código en un hilos o grupos de procesos</a></p></li>
<li><p><a class="reference internal" href="#error-handling-api" id="id15">API para manejo de errores</a></p></li>
<li><p><a class="reference internal" href="#enabling-debug-mode" id="id16">Habilitando el modo depuración</a></p></li>
<li><p><a class="reference internal" href="#running-subprocesses" id="id17">Ejecutando Subprocesos</a></p></li>
</ul>
</div>
<section id="running-and-stopping-the-loop">
<h3><a class="toc-backref" href="#id1">Iniciar y para el bucle</a><a class="headerlink" href="#running-and-stopping-the-loop" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.run_until_complete">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">run_until_complete</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">future</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.run_until_complete" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Se ejecuta hasta que <em>future</em> (una instancia de <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>) se haya completado.</p>
<p>Si el argumento es un <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">objeto corrutina</span></a> está implícitamente planificado para ejecutarse como una <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a>.</p>
<p>Retorna el resultado del Futuro o genera una excepción.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.run_forever">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">run_forever</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.run_forever" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Ejecuta el bucle de eventos hasta que <a class="reference internal" href="#asyncio.loop.stop" title="asyncio.loop.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> es llamado.</p>
<p>Si <a class="reference internal" href="#asyncio.loop.stop" title="asyncio.loop.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> es llamado antes que <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_forever()</span></code></a>, el bucle va a sondear el selector de E/S una sola vez con un plazo de ejecución de cero, ejecuta todas las llamadas planificadas como respuesta a eventos E/S (y aquellas que ya hayan sido planificados), y entonces termina.</p>
<p>Si <a class="reference internal" href="#asyncio.loop.stop" title="asyncio.loop.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> es llamado mientras <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_forever()</span></code></a> se está ejecutando, el loop ejecutará el lote actual de llamadas y después finalizará. Tenga en cuenta que llamadas planificadas por otras llamadas no se ejecutarán en este caso; en su lugar, ellas correrán la próxima vez que <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_forever()</span></code></a> o <a class="reference internal" href="#asyncio.loop.run_until_complete" title="asyncio.loop.run_until_complete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_until_complete()</span></code></a> sean llamados.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.stop">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.stop" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Detener el bucle de eventos.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.is_running">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">is_running</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.is_running" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si el bucle de eventos esta en ejecución actualmente.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.is_closed">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">is_closed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.is_closed" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si el bucle de eventos se cerró.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.close">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.close" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Cierra el bucle de eventos.</p>
<p>El bucle no debe estar en ejecución cuando se llama a esta función. Cualquier llamada de retorno pendiente será descartada.</p>
<p>Este método limpia todas las colas y apaga el ejecutor, pero no espera a que el ejecutor termine.</p>
<p>Este método es idempotente e irreversible. No se debe llamar ningún otro método después que el bucle de eventos es cerrado.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.shutdown_asyncgens">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">shutdown_asyncgens</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.shutdown_asyncgens" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Programa todos los objetos <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">asynchronous generator</span></a> abiertos actualmente para cerrarlos con una llamada <a class="reference internal" href="../reference/expressions.html#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a>. Después de llamar este método, el bucle de eventos emitirá una advertencia si un nuevo generador asíncrono es iterado. Esto debe ser usado para finalizar de manera confiable todos los generadores asíncronos planificados.</p>
<p>Tenga en cuenta que no hay necesidad de llamar esta función cuando <a class="reference internal" href="asyncio-task.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a> es utilizado.</p>
<p>Ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">shutdown_asyncgens</span><span class="p">())</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.shutdown_default_executor">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">shutdown_default_executor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.shutdown_default_executor" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Schedule the closure of the default executor and wait for it to join all of
the threads in the <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a>.
Once this method has been called,
using the default executor with <a class="reference internal" href="#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_in_executor()</span></code></a>
will raise a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Do not call this method when using <a class="reference internal" href="asyncio-task.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>,
as the latter handles default executor shutdown automatically.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

</section>
<section id="scheduling-callbacks">
<h3><a class="toc-backref" href="#id2">Programación de llamadas de retorno</a><a class="headerlink" href="#scheduling-callbacks" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.call_soon">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">call_soon</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">callback</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_soon" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Programa el <em>callback</em> (retrollamada) <a class="reference internal" href="../glossary.html#term-callback"><span class="xref std std-term">callback</span></a> para que se llame con argumentos <em>args</em> en la próxima iteración del ciclo de eventos.</p>
<p>Return an instance of <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Handle</span></code></a>,
which can be used later to cancel the callback.</p>
<p>Llamadas que son ejecutadas en el orden en el que fueron registradas. Cada llamada será ejecutada exactamente una sola vez.</p>
<p>The optional keyword-only <em>context</em> argument specifies a
custom <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> for the <em>callback</em> to run in.
Callbacks use the current context when no <em>context</em> is provided.</p>
<p>Unlike <a class="reference internal" href="#asyncio.loop.call_soon_threadsafe" title="asyncio.loop.call_soon_threadsafe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_soon_threadsafe()</span></code></a>, this method is not thread-safe.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.call_soon_threadsafe">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">call_soon_threadsafe</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">callback</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_soon_threadsafe" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>A thread-safe variant of <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_soon()</span></code></a>. When scheduling callbacks from
another thread, this function <em>must</em> be used, since <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_soon()</span></code></a> is not
thread-safe.</p>
<p>Lanza <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> si se llama en un bucle que ha sido cerrado. Esto puede suceder en un hilo secundario cuando la aplicación principal se está apagando.</p>
<p>Vea sección <a class="reference internal" href="asyncio-dev.html#asyncio-multithreading"><span class="std std-ref">concurrencia y multiproceso</span></a> de la documentación.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Fue agregado el parámetro solo de palabra clave <em>context</em>. Vea <span class="target" id="index-12"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0567"><strong>PEP 567</strong></a> para mas detalles.</p>
</div>
<div class="admonition note" id="asyncio-pass-keywords">
<p class="admonition-title">Nota</p>
<p>La mayoría de las funciones planificadas de <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> no permiten pasar argumentos de palabra clave. Para hacer eso utilice <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># will schedule &quot;print(&quot;Hello&quot;, flush=True)&quot;</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span>
    <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="s2">&quot;Hello&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
<p>El uso de objetos parciales es usualmente mas conveniente que utilizar lambdas, ya que asyncio puede renderizar mejor objetos parciales en mensajes de depuración y error.</p>
</div>
</section>
<section id="scheduling-delayed-callbacks">
<span id="asyncio-delayed-calls"></span><h3><a class="toc-backref" href="#id3">Planificando llamadas retardadas</a><a class="headerlink" href="#scheduling-delayed-callbacks" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El bucle de eventos provee mecanismos para planificar funciones de llamadas que serán ejecutadas en algún punto en el futuro. El bucle de eventos usa relojes monotónicos para seguir el tiempo.</p>
<dl class="py method">
<dt id="asyncio.loop.call_later">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">call_later</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">delay</span></em>, <em class="sig-param"><span class="n">callback</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_later" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Planifica <em>callback</em> para ser ejecutada luego de <em>delay</em> número de segundos (puede ser tanto un entero como un flotante).</p>
<p>Una instancia de <a class="reference internal" href="#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.TimerHandle</span></code></a> es retornada, la que puede ser utilizada para cancelar la ejecución.</p>
<p><em>callback</em> será ejecutada exactamente una sola vez. Si dos llamadas son planificadas para el mismo momento exacto, el orden en el que son ejecutadas es indefinido.</p>
<p>El argumento posicional opcional <em>args</em> será pasado a la llamada cuando esta sea ejecutada. Si quieres que la llamada sea ejecutada con argumentos de palabra clave usa <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>.</p>
<p>Un argumento <em>context</em> opcional y solo de palabra clave que permite especificar una clase <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> personalizada en la cual <em>callback</em> será ejecutada. Cuando no se provee <em>context</em> el contexto actual es utilizado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Fue agregado el parámetro solo de palabra clave <em>context</em>. Vea <span class="target" id="index-13"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0567"><strong>PEP 567</strong></a> para mas detalles.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>En Python 3.7 y versiones anteriores con la implementación del bucle de eventos predeterminada, el <em>delay</em> no puede exceder un día. Esto fue arreglado en Python 3.8.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.call_at">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">call_at</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">when</span></em>, <em class="sig-param"><span class="n">callback</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_at" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Planifica <em>callback</em> para ser ejecutada en una marca de tiempo absoluta <em>when</em> (un entero o un flotante), usando la misma referencia de tiempo que <a class="reference internal" href="#asyncio.loop.time" title="asyncio.loop.time"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.time()</span></code></a>.</p>
<p>El comportamiento de este método es el mismo que <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_later()</span></code></a>.</p>
<p>Una instancia de <a class="reference internal" href="#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.TimerHandle</span></code></a> es retornada, la que puede ser utilizada para cancelar la ejecución.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Fue agregado el parámetro solo de palabra clave <em>context</em>. Vea <span class="target" id="index-14"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0567"><strong>PEP 567</strong></a> para mas detalles.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>En Python 3.7 y versiones anteriores con la implementación del bucle de eventos predeterminada, la diferencia entre <em>when</em> y el tiempo actual no puede exceder un día. Esto fue arreglado en Python 3.8.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.time">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.time" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el tiempo actual, como un <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, de acuerdo al reloj monotónico interno del bucle de evento.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Nota</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>En Python 3.7 y versiones anteriores los tiempos de espera (<em>delay</em> relativo o <em>when</em> absoluto) no deben exceder un día. Esto fue arreglado en Python 3.8.</p>
</div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>La función <a class="reference internal" href="asyncio-task.html#asyncio.sleep" title="asyncio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.sleep()</span></code></a>.</p>
</div>
</section>
<section id="creating-futures-and-tasks">
<h3><a class="toc-backref" href="#id4">Creando Futuros y Tareas</a><a class="headerlink" href="#creating-futures-and-tasks" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.create_future">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">create_future</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_future" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un objeto <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> adjunto al bucle de eventos.</p>
<p>Esta es la manera preferida de crear Futures en asyncio. Esto permite que bucles de eventos de terceros provean implementaciones alternativas del objeto Future (con mejor rendimiento o instrumentación).</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.create_task">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">create_task</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">coro</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_task" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Schedule the execution of <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">coroutine</span></a> <em>coro</em>.
Return a <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> object.</p>
<p>Bucles de eventos de terceros pueden usar sus propias subclases de <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> por interoperabilidad. En este caso, el tipo de resultado es una subclase de <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a>.</p>
<p>Si el argumento <em>name</em> es provisto y no <code class="docutils literal notranslate"><span class="pre">None</span></code>, se establece como el nombre de la tarea usando <a class="reference internal" href="asyncio-task.html#asyncio.Task.set_name" title="asyncio.Task.set_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Task.set_name()</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Added the <em>name</em> parameter.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.set_task_factory">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">set_task_factory</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">factory</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_task_factory" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece una fábrica de tareas que será utilizada por <a class="reference internal" href="#asyncio.loop.create_task" title="asyncio.loop.create_task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_task()</span></code></a>.</p>
<p>Si <em>factory</em> es <code class="docutils literal notranslate"><span class="pre">None</span></code> se establecerá la fábrica de tareas por defecto. En cualquier otro caso, <em>factory</em> debe ser un <em>callable</em> con la misma firma <code class="docutils literal notranslate"><span class="pre">(loop,</span> <span class="pre">coro)</span></code>, donde <em>loop</em> es una referencia al bucle de eventos activo y <em>coro</em> es un objeto de corrutina. El ejecutable debe retornar una objeto <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> compatible.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.get_task_factory">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">get_task_factory</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.get_task_factory" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una fábrica de tareas o <code class="docutils literal notranslate"><span class="pre">None</span></code> si la predefinida está en uso.</p>
</dd></dl>

</section>
<section id="opening-network-connections">
<h3><a class="toc-backref" href="#id5">Abriendo conexiones de red</a><a class="headerlink" href="#opening-network-connections" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.create_connection">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">create_connection</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocol_factory</span></em>, <em class="sig-param"><span class="n">host</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">port</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">ssl</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">family</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">proto</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">sock</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">local_addr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">server_hostname</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ssl_handshake_timeout</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">happy_eyeballs_delay</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">interleave</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_connection" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Abre una conexión de transmisión de transporte a una dirección especificada por <em>host</em> y <em>port</em>.</p>
<p>La familia de sockets puede ser tanto <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET</span></code></a> como <a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET6</span></code></a> dependiendo de <em>host</em> (o del argumento <em>family</em> si es que fue provisto).</p>
<p>El tipo de socket será <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>.</p>
<p><em>protocol_factory</em> debe ser un ejecutable que retorna una implementación del <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">asyncio protocol</span></a>.</p>
<p>Este método tratará de establecer la conexión en un segundo plano. Cuando es exitosa, retorna un par <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>.</p>
<p>La sinopsis cronológica de las operaciones subyacentes es como sigue:</p>
<ol class="arabic simple">
<li><p>La conexión es establecida y un <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><span class="std std-ref">transporte</span></a> es creado para ello.</p></li>
<li><p><em>protocol_factory</em> es llamado sin argumentos y se espera que retorne una instancia de <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocol</span></a>.</p></li>
<li><p>La instancia del protocolo se acopla con el transporte mediante el llamado de su método <a class="reference internal" href="asyncio-protocol.html#asyncio.BaseProtocol.connection_made" title="asyncio.BaseProtocol.connection_made"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connection_made()</span></code></a>.</p></li>
<li><p>Una tupla <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> es retornada cuando se tiene éxito.</p></li>
</ol>
<p>El transporte creado es una transmisión (<em>stream</em>) bidireccional que depende de la implementación.</p>
<p>Otros argumentos:</p>
<ul>
<li><p><em>ssl</em>: si se provee y no es falso, un transporte SSL/TLS es creado (de manera predeterminada se crea un transporte TCP plano).  Si <em>ssl</em> es un objeto <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a>, este contexto es utilizado para crear el transporte; si <em>ssl</em> es <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>, se utiliza un contexto predeterminado retornado por <a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p><a class="reference internal" href="ssl.html#ssl-security"><span class="std std-ref">Consideraciones de seguridad SSL/TLS</span></a></p>
</div>
</li>
<li><p><em>server_hostname</em> establece o reemplaza el nombre de servidor (<em>hostname</em>) contra el cual el certificado del servidor de destino será comparado. Sólo debería ser pasado si <em>ssl</em> no es <code class="docutils literal notranslate"><span class="pre">None</span></code>. De manera predeterminada es usado el valor del argumento <em>host</em>.  Si <em>host</em> está vacío, no hay valor predeterminado y debes pasar un valor para <em>server_hostname</em>. Si <em>server_hostname</em> es una cadena vacía, la comparación de nombres de servidores es deshabilitada (lo que es un riesgo de seguridad serio, permitiendo potenciales ataques de hombre-en-el-medio, <em>man-in-the-middle attacks</em>).</p></li>
<li><p><em>family</em>, <em>proto</em>, <em>flags</em> son dirección de familia, protocolo y banderas opcionales que serán pasadas a través de <cite>getaddrinfo()</cite> para la resolución de <em>host</em>. Si están dados, todos ellos deberían ser enteros de las constantes del módulo <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> correspondiente.</p></li>
<li><p><em>happy_eyeballs_delay</em>, si se proporciona, habilita Happy Eyeballs para esta conexión. Debe ser un número de punto flotante que represente la cantidad de tiempo en segundos para esperar a que se complete un intento de conexión, antes de comenzar el siguiente intento en paralelo. Este es el «Retraso de intento de conexión» como se define en <span class="target" id="index-15"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8305.html"><strong>RFC 8305</strong></a>. Un valor predeterminado sensato recomendado por el RFC es <code class="docutils literal notranslate"><span class="pre">0.25</span></code> (250 milisegundos).</p></li>
<li><p><em>interleave</em> controla reordenamientos de dirección cuando un nombre de servidor resuelve a múltiples direcciones IP. Si es <code class="docutils literal notranslate"><span class="pre">0</span></code> o no es especificado, no se hace ningún reordenamiento, y las direcciones son intentadas en el orden retornado por <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>. Si un entero positivo es especificado, las direcciones son intercaladas por dirección de familia, y el entero dado es interpretado como «Número de familias de la primera dirección» (<em>First Address Family Count</em>) como es definida en <span class="target" id="index-16"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8305.html"><strong>RFC 8305</strong></a>. El valor predefinido es <code class="docutils literal notranslate"><span class="pre">0</span></code> si <em>happy_eyeballs_delay</em> no es especificado, y <code class="docutils literal notranslate"><span class="pre">1</span></code> si lo es.</p></li>
<li><p><em>sock</em>, si está dado, debe ser un objeto <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> existente y ya conectado, que será utilizado por el transporte. Si <em>sock</em> es dado, ningún <em>host</em>, <em>port</em>, <em>family</em>, <em>proto</em>, <em>flags</em>, <em>happy_eyeballs_delay</em>, <em>interleave</em> o <em>local_addr</em> deben ser especificados.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>The <em>sock</em> argument transfers ownership of the socket to the
transport created. To close the socket, call the transport’s
<a class="reference internal" href="asyncio-protocol.html#asyncio.BaseTransport.close" title="asyncio.BaseTransport.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> method.</p>
</div>
</li>
<li><p><em>local_addr</em>, si está dado, es una tupla <code class="docutils literal notranslate"><span class="pre">(local_host,</span> <span class="pre">local_port)``usada</span> <span class="pre">para</span> <span class="pre">enlazar</span> <span class="pre">el</span> <span class="pre">socket</span> <span class="pre">localmente.</span>&#160; <span class="pre">Los</span> <span class="pre">*local_host*</span> <span class="pre">y</span> <span class="pre">*local_port*</span> <span class="pre">son</span> <span class="pre">buscados</span> <span class="pre">usando</span> <span class="pre">``getaddrinfo()</span></code>, de manera similar que con <em>host</em> y <em>port</em>.</p></li>
<li><p><em>ssl_handshake_timeout</em> es (para una conexión TLS) el tiempo en segundos a esperar que se complete el apretón de manos (<em>handshake</em>) TLS antes de abortar la conexión. <code class="docutils literal notranslate"><span class="pre">60.0</span></code> segundos si es <code class="docutils literal notranslate"><span class="pre">None</span></code> (predefinido).</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Agregado el soporte para SSL/TLS en <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>La opción del socket <code class="xref py py-data docutils literal notranslate"><span class="pre">TCP_NODELAY</span></code> es establecida de manera predeterminada para todas las conexiones TCP.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Added the <em>ssl_handshake_timeout</em> parameter.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Agregados los parámetros <em>happy_eyeballs_delay</em> y <em>interleave</em>.</p>
<p>Happy Eyeballs Algorithm: Success with Dual-Stack Hosts.
When a server’s IPv4 path and protocol are working, but the server’s
IPv6 path and protocol are not working, a dual-stack client
application experiences significant connection delay compared to an
IPv4-only client.  This is undesirable because it causes the
dual-stack client to have a worse user experience.  This document
specifies requirements for algorithms that reduce this user-visible
delay and provides an algorithm.</p>
<p>Para mas información: <a class="reference external" href="https://tools.ietf.org/html/rfc6555">https://tools.ietf.org/html/rfc6555</a></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>La función <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_connection()</span></code></a> es una API alternativa de alto nivel. Retorna un par de (<a class="reference internal" href="asyncio-stream.html#asyncio.StreamReader" title="asyncio.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.StreamWriter" title="asyncio.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a>) que puede ser usado directamente en código async/await.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.create_datagram_endpoint">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">create_datagram_endpoint</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocol_factory</span></em>, <em class="sig-param"><span class="n">local_addr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">remote_addr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">family</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">proto</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">reuse_address</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reuse_port</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">allow_broadcast</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sock</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_datagram_endpoint" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><div class="admonition note">
<p class="admonition-title">Nota</p>
<p>El parámetro <em>reuse_address</em> ya no es soportado, como utiliza <code class="xref py py-data docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code> plantea un problema de seguridad importante para UDP. Pasando explícitamente <code class="docutils literal notranslate"><span class="pre">reuse_address=True</span></code> lanzará una excepción.</p>
<p>Cuando múltiples procesos con UIDs diferentes asignan sockets a una misma dirección socket UDP con <code class="docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code>, los paquetes entrantes pueden distribuirse aleatoriamente entre los sockets.</p>
<p>Para plataformas soportadas, <em>reuse_port</em> puede ser utilizado como un reemplazo para funcionalidades similares. Con <em>reuse_port</em>, <code class="xref py py-data docutils literal notranslate"><span class="pre">SO_REUSEPORT</span></code> es usado en su lugar, que específicamente previene que procesos con distintos UIDs asignen sockets a la misma dirección de socket.</p>
</div>
<p>Crea un datagrama de conexión.</p>
<p>La familia de socket puede ser tanto <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET</span></code></a>, <a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET6</span></code></a>, como <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>, dependiendo de <em>host</em> (o del argumento <em>family</em>, si fue provisto).</p>
<p>El tipo de socket será <a class="reference internal" href="socket.html#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-data docutils literal notranslate"><span class="pre">SOCK_DGRAM</span></code></a>.</p>
<p><em>protocol_factory</em> debe ser un ejecutable que retorne una implementación de <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocol</span></a>.</p>
<p>Una tupla de <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> es retornada cuando se tiene éxito.</p>
<p>Otros argumentos:</p>
<ul>
<li><p><em>local_addr</em>, si está dado, es una tupla <code class="docutils literal notranslate"><span class="pre">(local_host,</span> <span class="pre">local_port)</span></code> usada para enlazar el socket localmente.  Los <em>local_host</em> y <em>local_port</em> son buscados utilizando <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>.</p></li>
<li><p><em>remote_addr</em>, si está dado, es una tupla <code class="docutils literal notranslate"><span class="pre">(remote_host,</span> <span class="pre">remote_port)</span></code> utilizada para conectar el socket a una dirección remota. Los <em>remote_host</em> y <em>remote_port</em> son buscados utilizando <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>.</p></li>
<li><p><em>family</em>, <em>proto</em>, <em>flags</em> son direcciones de familia, protocolo y banderas opcionales que serán pasadas a través de <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> para la resolución de <em>host</em>. Si está dado, estos deben ser todos enteros de las constantes del módulo <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> correspondiente.</p></li>
<li><p><em>reuse_port</em> dice al kernel que habilite este punto de conexión para ser unido al mismo puerto de la misma forma que otros puntos de conexión existentes también están unidos, siempre y cuando todos ellos establezcan esta bandera al ser creados. Esta opción no es soportada en Windows y algunos sistemas Unix. Si la constante <code class="xref py py-data docutils literal notranslate"><span class="pre">SO_REUSEPORT</span></code> no está definida entonces esta funcionalidad no es soportada.</p></li>
<li><p><em>allow_broadcast</em> dice al kernel que habilite este punto de conexión para enviar mensajes a la dirección de transmisión (<em>broadcast</em>).</p></li>
<li><p><em>sock</em> puede opcionalmente ser especificado para usar un objeto <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> preexistente y ya conectado que será utilizado por el transporte. Si están especificados, <em>local_addr</em> y <em>remote_addr</em> deben ser omitidos (tienen que ser <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>).</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>The <em>sock</em> argument transfers ownership of the socket to the
transport created. To close the socket, call the transport’s
<a class="reference internal" href="asyncio-protocol.html#asyncio.BaseTransport.close" title="asyncio.BaseTransport.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> method.</p>
</div>
</li>
</ul>
<p>Refiérase a los ejemplos <a class="reference internal" href="asyncio-protocol.html#asyncio-udp-echo-client-protocol"><span class="std std-ref">UDP echo client protocol</span></a> y <a class="reference internal" href="asyncio-protocol.html#asyncio-udp-echo-server-protocol"><span class="std std-ref">UDP echo server protocol</span></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4.4: </span>Los parámetros <em>family</em>, <em>proto</em>, <em>flags</em>, <em>reuse_address</em>, <em>reuse_port</em>, <em>allow_broadcast</em> y <em>sock</em> fueron agregados.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8.1: </span>El parámetro <em>reuse_address</em> ya no es soportado debido a problemas de seguridad.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Se agregó soporte para Windows.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.create_unix_connection">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">create_unix_connection</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocol_factory</span></em>, <em class="sig-param"><span class="n">path</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">ssl</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sock</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">server_hostname</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ssl_handshake_timeout</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_unix_connection" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crear una conexión Unix.</p>
<p>La familia de sockets será <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>; el tipo de socket será <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>.</p>
<p>Una tupla de <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> es retornada cuando se tiene éxito.</p>
<p><em>path</em> es el nombre de un dominio de un socket Unix y es requerido, a menos que un parámetro <em>sock</em> sea especificado. Los socket Unix abstractos, <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, y <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> son soportados.</p>
<p>Vea la documentación del método <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> para información acerca de los argumentos de este método.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Added the <em>ssl_handshake_timeout</em> parameter.
The <em>path</em> parameter can now be a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
</dd></dl>

</section>
<section id="creating-network-servers">
<h3><a class="toc-backref" href="#id6">Creando servidores de red</a><a class="headerlink" href="#creating-network-servers" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.create_server">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">create_server</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocol_factory</span></em>, <em class="sig-param"><span class="n">host</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">port</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">family</span><span class="o">=</span><span class="default_value">socket.AF_UNSPEC</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">socket.AI_PASSIVE</span></em>, <em class="sig-param"><span class="n">sock</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">backlog</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">ssl</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reuse_address</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reuse_port</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ssl_handshake_timeout</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">start_serving</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_server" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un servidor TCP (tipo de socket <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>) escuchando en <em>port</em> de la dirección <em>host</em>.</p>
<p>Retorna un objeto <a class="reference internal" href="#asyncio.Server" title="asyncio.Server"><code class="xref py py-class docutils literal notranslate"><span class="pre">Server</span></code></a>.</p>
<p>Argumentos:</p>
<ul>
<li><p><em>protocol_factory</em> debe ser un ejecutable que retorne una implementación de <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocol</span></a>.</p></li>
<li><p>El parámetro <em>host</em> puede ser establecido a distintos tipos que determinan donde el servidor estaría escuchando:</p>
<ul class="simple">
<li><p>Si <em>host</em> es una cadena, el servidor TCP está enlazado a una sola interfaz de red especificada por <em>host</em>.</p></li>
<li><p>Si <em>host</em> es una secuencia de cadenas, el servidor TCP está enlazado a todas las interfaces de red especificadas por la secuencia.</p></li>
<li><p>Si <em>host</em> es una cadena vacía o <code class="docutils literal notranslate"><span class="pre">None</span></code>, se asumen todas las interfaces y una lista con múltiples sockets será retornada (mas probablemente uno para IPv4 y otro para IPv6).</p></li>
</ul>
</li>
<li><p>The <em>port</em> parameter can be set to specify which port the server should
listen on. If <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default), a random unused port will
be selected (note that if <em>host</em> resolves to multiple network interfaces,
a different random port will be selected for each interface).</p></li>
<li><p><em>family</em> puede ser establecido como <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-data docutils literal notranslate"><span class="pre">socket.AF_INET</span></code></a> o <a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET6</span></code></a> para forzar al socket a usar IPv4 o IPv6. Si no es establecido, la <em>family</em> será determinada por medio del nombre del host (por defecto será <code class="xref py py-data docutils literal notranslate"><span class="pre">AF_UNSPEC</span></code>).</p></li>
<li><p><em>flags</em> es una máscara de bits para <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>.</p></li>
<li><p><em>sock</em> puede ser especificado opcionalmente para usar objetos socket preexistentes. Si se utiliza, entonces <em>host</em> y <em>port</em> no deben ser especificados.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>The <em>sock</em> argument transfers ownership of the socket to the
server created. To close the socket, call the server’s
<a class="reference internal" href="#asyncio.Server.close" title="asyncio.Server.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> method.</p>
</div>
</li>
<li><p><em>backlog</em> es el número máximo de conexiones encoladas pasadas a <a class="reference internal" href="socket.html#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">listen()</span></code></a> (el valor predeterminado es 100).</p></li>
<li><p><em>ssl</em> puede ser establecido como una instancia de <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> para habilitar TLS sobre las conexiones aceptadas.</p></li>
<li><p><em>reuse_address</em> indica al kernel que reutilice un socket local en estado <code class="docutils literal notranslate"><span class="pre">TIME_WAIT</span></code>, sin esperar que su plazo de ejecución expire. Si no es especificado será establecido automáticamente como <code class="docutils literal notranslate"><span class="pre">True</span></code> en Unix.</p></li>
<li><p><em>reuse_port</em> dice al kernel que habilite este punto de conexión para ser unido al mismo puerto de la misma forma que otros puntos de conexión existentes también están unidos, siempre y cuando todos ellos establezcan esta bandera al ser creados.</p></li>
<li><p><em>ssl_handshake_timeout</em> es (para un servidor TLS) el tiempo en segundos a esperar por el apretón de manos (<em>handshake</em>) TLS a ser completado antes de abortar la conexión. <code class="docutils literal notranslate"><span class="pre">60.0</span></code> si es <code class="docutils literal notranslate"><span class="pre">None</span></code> (su valor predeterminado).</p></li>
<li><p><em>start_serving</em> establecido como <code class="docutils literal notranslate"><span class="pre">True</span></code> (de manera predeterminada) produce que los servidores creados comiencen a aceptar conexiones inmediatamente. Si es establecido como <code class="docutils literal notranslate"><span class="pre">False</span></code>, el usuario debe esperar por <a class="reference internal" href="#asyncio.Server.start_serving" title="asyncio.Server.start_serving"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Server.start_serving()</span></code></a> o <a class="reference internal" href="#asyncio.Server.serve_forever" title="asyncio.Server.serve_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Server.serve_forever()</span></code></a> para que el servidor comience a aceptar conexiones.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Agregado el soporte para SSL/TLS en <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5.1: </span>El parámetro <em>host</em> puede ser una secuencia de cadenas.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Added <em>ssl_handshake_timeout</em> and <em>start_serving</em> parameters.
The socket option <code class="xref py py-data docutils literal notranslate"><span class="pre">TCP_NODELAY</span></code> is set by default
for all TCP connections.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>La función <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_server()</span></code></a> es una API alternativa de alto nivel que retorna un par de <a class="reference internal" href="asyncio-stream.html#asyncio.StreamReader" title="asyncio.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> y <a class="reference internal" href="asyncio-stream.html#asyncio.StreamWriter" title="asyncio.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> que pueden ser usados en código async/await.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.create_unix_server">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">create_unix_server</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocol_factory</span></em>, <em class="sig-param"><span class="n">path</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">sock</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">backlog</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">ssl</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ssl_handshake_timeout</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">start_serving</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_unix_server" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Similar a <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> pero funciona con la familia de sockets <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>.</p>
<p><em>path</em> es el nombre de un dominio de socket Unix, y es requerido a menos que el argumento <em>sock</em> sea provisto. Son soportados sockets unix abstractos, <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, y rutas <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a>.</p>
<p>Vea la documentación de el método <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> para mas información acerca de los argumentos de este método.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Added the <em>ssl_handshake_timeout</em> and <em>start_serving</em> parameters.
The <em>path</em> parameter can now be a <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> object.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.connect_accepted_socket">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">connect_accepted_socket</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocol_factory</span></em>, <em class="sig-param"><span class="n">sock</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">ssl</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ssl_handshake_timeout</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.connect_accepted_socket" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Envuelve una conexión ya aceptada en un par de transporte/protocolo.</p>
<p>Este método puede ser usado por servidores que acepten conexiones por fuera de asyncio, pero que usen asyncio para manejarlas.</p>
<p>Parámetros:</p>
<ul>
<li><p><em>protocol_factory</em> debe ser un ejecutable que retorne una implementación de <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocol</span></a>.</p></li>
<li><p><em>sock</em> es un objeto socket preexistente retornado por <a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.accept</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>The <em>sock</em> argument transfers ownership of the socket to the
transport created. To close the socket, call the transport’s
<a class="reference internal" href="asyncio-protocol.html#asyncio.BaseTransport.close" title="asyncio.BaseTransport.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> method.</p>
</div>
</li>
<li><p><em>ssl</em> puede ser establecido como un <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> para habilitar SSL sobre las conexiones aceptadas.</p></li>
<li><p><em>ssl_handshake_timeout</em> es (para una conexión SSL) el tiempo en segundos que se esperará para que se complete el apretón de manos (<em>handshake</em>) SSL antes de abortar la conexión. <code class="docutils literal notranslate"><span class="pre">60.0</span></code> si es <code class="docutils literal notranslate"><span class="pre">None</span></code> (su valor predeterminado).</p></li>
</ul>
<p>Retorna un par <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Added the <em>ssl_handshake_timeout</em> parameter.</p>
</div>
</dd></dl>

</section>
<section id="transferring-files">
<h3><a class="toc-backref" href="#id7">Transfiriendo archivos</a><a class="headerlink" href="#transferring-files" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.sendfile">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">sendfile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">transport</span></em>, <em class="sig-param"><span class="n">file</span></em>, <em class="sig-param"><span class="n">offset</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">count</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">fallback</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sendfile" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Envía un <em>file</em> a través de un <em>transport</em>. Retorna el numero total de bytes enviados.</p>
<p>El método usa <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">os.sendfile()</span></code></a> de alto rendimiento si está disponible.</p>
<p><em>file</em> debe ser un objeto de archivo regular abierto en modo binario.</p>
<p><em>offset</em> indica desde donde se empezará a leer el archivo. Si es especificado, <em>count</em> es el número total de bytes a transmitir en contraposición con enviar el archivo hasta que se alcance EOF. La posición del archivo es actualizada siempre, incluso cuando este método genere un error, y <a class="reference internal" href="io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">file.tell()</span></code></a> puede ser usado para obtener el número de bytes enviados hasta el momento.</p>
<p><em>fallback</em> establecido como <code class="docutils literal notranslate"><span class="pre">True</span></code> hace que asyncio lea y envíe el archivo manualmente cuando la plataforma no soporta la llamada de envío de archivos del sistema (por ejemplo, Windows o sockets SSL en Unix).</p>
<p>Lanza <a class="reference internal" href="asyncio-exceptions.html#asyncio.SendfileNotAvailableError" title="asyncio.SendfileNotAvailableError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SendfileNotAvailableError</span></code></a> si el sistema no soporta la llamada de envío de archivos del sistema y <em>fallback</em> es <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

</section>
<section id="tls-upgrade">
<h3><a class="toc-backref" href="#id8">Actualización de TLS</a><a class="headerlink" href="#tls-upgrade" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.start_tls">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">start_tls</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">transport</span></em>, <em class="sig-param"><span class="n">protocol</span></em>, <em class="sig-param"><span class="n">sslcontext</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">server_side</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">server_hostname</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ssl_handshake_timeout</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.start_tls" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Actualiza una conexión basada en transporte ya existente a TLS.</p>
<p>Create a TLS coder/decoder instance and insert it between the <em>transport</em>
and the <em>protocol</em>. The coder/decoder implements both <em>transport</em>-facing
protocol and <em>protocol</em>-facing transport.</p>
<p>Return the created two-interface instance. After <em>await</em>, the <em>protocol</em>
must stop using the original <em>transport</em> and communicate with the returned
object only because the coder caches <em>protocol</em>-side data and sporadically
exchanges extra TLS session packets with <em>transport</em>.</p>
<p>Parámetros:</p>
<ul class="simple">
<li><p>Las instancias <em>transport</em> y <em>protocol</em> que retornan los métodos como <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_server()</span></code></a> y <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_connection()</span></code></a>.</p></li>
<li><p><em>sslcontext</em>: una instancia configurada de <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a>.</p></li>
<li><p><em>server_side</em> pasa <cite>True</cite> cuando se actualiza una conexión del lado del servidor (como en el caso de una creada por <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_server()</span></code></a>).</p></li>
<li><p><em>server_hostname</em>: establece o reemplaza el nombre del host contra el cual se compara el certificado del servidor de destino.</p></li>
<li><p><em>ssl_handshake_timeout</em> es (para una conexión TLS) el tiempo en segundos a esperar que se complete el apretón de manos (<em>handshake</em>) TLS antes de abortar la conexión. <code class="docutils literal notranslate"><span class="pre">60.0</span></code> segundos si es <code class="docutils literal notranslate"><span class="pre">None</span></code> (predefinido).</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

</section>
<section id="watching-file-descriptors">
<h3><a class="toc-backref" href="#id9">Viendo descriptores de archivos</a><a class="headerlink" href="#watching-file-descriptors" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.add_reader">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">add_reader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fd</span></em>, <em class="sig-param"><span class="n">callback</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.add_reader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Empieza a monitorear el descriptor de archivos <em>fd</em> para disponibilidad de lectura e invoca <em>callback</em> con los argumentos especificados una vez que <em>fd</em> está habilitado para ser leído.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.remove_reader">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">remove_reader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fd</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.remove_reader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Stop monitoring the <em>fd</em> file descriptor for read availability. Returns
<code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>fd</em> was previously being monitored for reads.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.add_writer">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">add_writer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fd</span></em>, <em class="sig-param"><span class="n">callback</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.add_writer" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Empieza a monitorear el descriptor de archivos <em>fd</em> para disponibilidad de escritura e invoca <em>callback</em> con los argumentos especificados una vez que <em>fd</em> está habilitado para ser escrito.</p>
<p>Use <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a> <a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">para pasar argumentos de palabra clave</span></a> a <em>callback</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.remove_writer">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">remove_writer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fd</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.remove_writer" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Stop monitoring the <em>fd</em> file descriptor for write availability. Returns
<code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>fd</em> was previously being monitored for writes.</p>
</dd></dl>

<p>Vea también la sección <a class="reference internal" href="asyncio-platforms.html#asyncio-platform-support"><span class="std std-ref">Soporte de plataforma</span></a> para algunas limitaciones de estos métodos.</p>
</section>
<section id="working-with-socket-objects-directly">
<h3><a class="toc-backref" href="#id10">Trabajar con objetos sockets directamente</a><a class="headerlink" href="#working-with-socket-objects-directly" title="Enlazar permanentemente con este título">¶</a></h3>
<p>En general, implementaciones de protocolo que usen APIs basadas en transporte como <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> y <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> son mas rápidas que aquellas implementaciones que trabajan con directamente con sockets. De cualquier forma, hay algunos casos de uso en los cuales el rendimiento no es crítico, y trabajar directamente con objetos <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> es mas conveniente.</p>
<dl class="py method">
<dt id="asyncio.loop.sock_recv">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">sock_recv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sock</span></em>, <em class="sig-param"><span class="n">nbytes</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_recv" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Recibe hasta <em>nbytes</em> de <em>sock</em>. Versión asíncrona de <a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recv()</span></code></a>.</p>
<p>Retorna los datos recibidos como un objeto bytes.</p>
<p><em>sock</em> debe ser un socket no bloqueante.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>A pesar de que este método siempre fue documentado como un método de corrutina, los lanzamientos previos a Python 3.7 retornaban un <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>. Desde Python 3.7 este es un método <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.sock_recv_into">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">sock_recv_into</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sock</span></em>, <em class="sig-param"><span class="n">buf</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_recv_into" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Recibe datos desde <em>sock</em> en el búfer <em>buf</em>. Modelado después del método bloqueante <a class="reference internal" href="socket.html#socket.socket.recv_into" title="socket.socket.recv_into"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recv_into()</span></code></a>.</p>
<p>Retorna el número de bytes escritos en el búfer.</p>
<p><em>sock</em> debe ser un socket no bloqueante.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.sock_sendall">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">sock_sendall</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sock</span></em>, <em class="sig-param"><span class="n">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_sendall" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Envía <em>data</em> al socket <em>sock</em>. Versión asíncrona de <a class="reference internal" href="socket.html#socket.socket.sendall" title="socket.socket.sendall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.sendall()</span></code></a>.</p>
<p>Este método continua enviando al socket hasta que se hayan enviado todos los datos en <em>data</em> u ocurra un error. <code class="docutils literal notranslate"><span class="pre">None</span></code> es retornado cuando se tiene éxito. Cuando ocurre un error, se lanza una excepción. Adicionalmente, no hay manera de determinar cuantos datos, si es que se hubo alguno, se procesaron correctamente por el extremo receptor de la conexión.</p>
<p><em>sock</em> debe ser un socket no bloqueante.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>A pesar de que este método siempre fue documentado como un método de corrutina, antes de Python 3.7 retorna un <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>. Desde Python 3.7, este es un método <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.sock_connect">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">sock_connect</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sock</span></em>, <em class="sig-param"><span class="n">address</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_connect" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Conecta <em>sock</em> a un socket remoto en <em>address</em>.</p>
<p>Versión asíncrona de <a class="reference internal" href="socket.html#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.connect()</span></code></a>.</p>
<p><em>sock</em> debe ser un socket no bloqueante.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5.2: </span><code class="docutils literal notranslate"><span class="pre">address</span></code> ya no necesita ser resuelto. <code class="docutils literal notranslate"><span class="pre">sock_connect</span></code> va a intentar verificar si <em>address</em> ya fue resuelto a partir del llamado de <a class="reference internal" href="socket.html#socket.inet_pton" title="socket.inet_pton"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.inet_pton()</span></code></a>. Si no lo fue, se utilizará <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.getaddrinfo()</span></code></a> ara resolver <em>address</em>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p><a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> y <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.open_connection()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.sock_accept">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">sock_accept</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sock</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_accept" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Acepta una conexión. Modelado después del método bloqueante <a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.accept()</span></code></a>.</p>
<p>The socket must be bound to an address and listening
for connections. The return value is a pair <code class="docutils literal notranslate"><span class="pre">(conn,</span> <span class="pre">address)</span></code> where <em>conn</em>
is a <em>new</em> socket object usable to send and receive data on the connection,
and <em>address</em> is the address bound to the socket on the other end of the
connection.</p>
<p><em>sock</em> debe ser un socket no bloqueante.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>A pesar de que este método siempre fue documentado como un método de corrutina, antes de Python 3.7 retorna un <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>. Desde Python 3.7, este es un método <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p><a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> y <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_server()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.sock_sendfile">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">sock_sendfile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sock</span></em>, <em class="sig-param"><span class="n">file</span></em>, <em class="sig-param"><span class="n">offset</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">count</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">fallback</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_sendfile" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Envía un archivo usando <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.sendfile</span></code></a> de alto rendimiento si es posible. Retorna el número total de bytes enviados.</p>
<p>Versión asíncrona de <a class="reference internal" href="socket.html#socket.socket.sendfile" title="socket.socket.sendfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.sendfile()</span></code></a>.</p>
<p><em>sock</em> debe ser un <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">socket.SOCK_STREAM</span></code></a> <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> no bloqueante.</p>
<p><em>file</em> debe ser un objeto de archivo regular abierto en modo binario.</p>
<p><em>offset</em> indica desde donde se empezará a leer el archivo. Si es especificado, <em>count</em> es el número total de bytes a transmitir en contraposición con enviar el archivo hasta que se alcance EOF. La posición del archivo es actualizada siempre, incluso cuando este método genere un error, y <a class="reference internal" href="io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">file.tell()</span></code></a> puede ser usado para obtener el número de bytes enviados hasta el momento.</p>
<p><em>fallback</em>, cuando es establecida como <code class="docutils literal notranslate"><span class="pre">True</span></code>, hace que asyncio lea y escriba el archivo manualmente cuando el sistema no soporta la llamada de envío de archivos del sistema (por ejemplo, Windows o sockets SSL en Unix).</p>
<p>Lanza <a class="reference internal" href="asyncio-exceptions.html#asyncio.SendfileNotAvailableError" title="asyncio.SendfileNotAvailableError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SendfileNotAvailableError</span></code></a> si el sistema no soporta la llamada de envío de archivos del sistema <em>sendfile</em> y <em>fallback</em> es <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p><em>sock</em> debe ser un socket no bloqueante.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

</section>
<section id="dns">
<h3><a class="toc-backref" href="#id11">DNS</a><a class="headerlink" href="#dns" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.getaddrinfo">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">getaddrinfo</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">host</span></em>, <em class="sig-param"><span class="n">port</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">family</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">type</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">proto</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.getaddrinfo" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Versión asíncrona de <a class="reference internal" href="socket.html#socket.getaddrinfo" title="socket.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.getaddrinfo()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.getnameinfo">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">getnameinfo</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sockaddr</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.getnameinfo" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Asynchronous version of <a class="reference internal" href="socket.html#socket.getnameinfo" title="socket.getnameinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.getnameinfo()</span></code></a>.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Ambos métodos <em>getaddrinfo</em> y <em>getnameinfo</em> siempre fueron documentados para retornar una corrutina, pero antes de Python 3.7 retornaban, de hecho, objetos <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>. A partir de Python 3.7, ambos métodos son corrutinas.</p>
</div>
</section>
<section id="working-with-pipes">
<h3><a class="toc-backref" href="#id12">Trabajando con tuberías</a><a class="headerlink" href="#working-with-pipes" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.connect_read_pipe">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">connect_read_pipe</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocol_factory</span></em>, <em class="sig-param"><span class="n">pipe</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.connect_read_pipe" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Registra el fin de lectura de <em>pipe</em> en el bucle de eventos.</p>
<p><em>protocol_factory</em> debe ser un ejecutable que retorna una implementación del <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">asyncio protocol</span></a>.</p>
<p><em>pipe</em> es un <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">objeto de tipo archivo</span></a>.</p>
<p>Retorna un par <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>, donde <em>transport</em>  soporta la interface <a class="reference internal" href="asyncio-protocol.html#asyncio.ReadTransport" title="asyncio.ReadTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReadTransport</span></code></a> y <em>protocol</em> es un objeto instanciado por <em>protocol_factory</em>.</p>
<p>Con el bucle de eventos <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a>, el <em>pipe</em> es establecido en modo no bloqueante.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.connect_write_pipe">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">connect_write_pipe</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocol_factory</span></em>, <em class="sig-param"><span class="n">pipe</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.connect_write_pipe" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Registra el fin de escritura de <em>pipe</em> en el bucle de eventos.</p>
<p><em>protocol_factory</em> debe ser un ejecutable que retorna una implementación del <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">asyncio protocol</span></a>.</p>
<p><em>pipe</em> es un <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">objeto de tipo archivo</span></a>.</p>
<p>Retorna un par <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>, donde <em>transport</em> soporta la interface <a class="reference internal" href="asyncio-protocol.html#asyncio.WriteTransport" title="asyncio.WriteTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">WriteTransport</span></code></a> y <em>protocol</em> es un objeto inicializado por <em>protocol_factory</em>.</p>
<p>Con el bucle de eventos <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a>, el <em>pipe</em> es establecido en modo no bloqueante.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> no soporta los métodos anteriores en windows. En su lugar, use <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a> para Windows.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Los métodos <a class="reference internal" href="#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_exec()</span></code></a> y <a class="reference internal" href="#asyncio.loop.subprocess_shell" title="asyncio.loop.subprocess_shell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_shell()</span></code></a>.</p>
</div>
</section>
<section id="unix-signals">
<h3><a class="toc-backref" href="#id13">Señales Unix</a><a class="headerlink" href="#unix-signals" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.add_signal_handler">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">add_signal_handler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">signum</span></em>, <em class="sig-param"><span class="n">callback</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.add_signal_handler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece <em>callback</em> como el gestor para la señal <em>signum</em>.</p>
<p>La llamada será invocada por <em>loop</em>, junto con otras llamadas encoladas y corrutinas ejecutables de ese bucle de eventos. A menos que los gestores de señal la registren usando <a class="reference internal" href="signal.html#signal.signal" title="signal.signal"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.signal()</span></code></a>, una llamada registrada con esta función tiene permitido interactuar con el bucle de eventos.</p>
<p>Lanza <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> si el número de señal es invalido o inalcanzable. Lanza <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> si hay algún problema preparando el gestor.</p>
<p>Use <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a> <a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">para pasar argumentos de palabra clave</span></a> a <em>callback</em>.</p>
<p>Como <a class="reference internal" href="signal.html#signal.signal" title="signal.signal"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.signal()</span></code></a>, esta función debe ser invocada en el hilo principal.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.remove_signal_handler">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">remove_signal_handler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sig</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.remove_signal_handler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Elimina el gestor para la señal <em>sig</em>.</p>
<p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si el gestor de señal fue eliminado, o <code class="docutils literal notranslate"><span class="pre">False</span></code> si no se estableció gestor para la señal dada.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>El módulo <a class="reference internal" href="signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a>.</p>
</div>
</section>
<section id="executing-code-in-thread-or-process-pools">
<h3><a class="toc-backref" href="#id14">Ejecutando código en un hilos o grupos de procesos</a><a class="headerlink" href="#executing-code-in-thread-or-process-pools" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.run_in_executor">
<em class="property">awaitable </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">run_in_executor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">executor</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.run_in_executor" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Hace arreglos para que <em>func</em> sea llamado en el ejecutor especificado.</p>
<p>El argumento <em>executor</em> debe ser una instancia de <a class="reference internal" href="concurrent.futures.html#concurrent.futures.Executor" title="concurrent.futures.Executor"><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures.Executor</span></code></a>. El ejecutor predeterminado es usado si <em>executor</em> es <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">concurrent.futures</span>

<span class="k">def</span> <span class="nf">blocking_io</span><span class="p">():</span>
    <span class="c1"># File operations (such as logging) can block the</span>
    <span class="c1"># event loop: run them in a thread pool.</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/dev/urandom&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cpu_bound</span><span class="p">():</span>
    <span class="c1"># CPU-bound operations will block the event loop:</span>
    <span class="c1"># in general it is preferable to run them in a</span>
    <span class="c1"># process pool.</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">7</span><span class="p">))</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="c1">## Options:</span>

    <span class="c1"># 1. Run in the default loop&#39;s executor:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
        <span class="kc">None</span><span class="p">,</span> <span class="n">blocking_io</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;default thread pool&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="c1"># 2. Run in a custom thread pool:</span>
    <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
            <span class="n">pool</span><span class="p">,</span> <span class="n">blocking_io</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;custom thread pool&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="c1"># 3. Run in a custom process pool:</span>
    <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ProcessPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
            <span class="n">pool</span><span class="p">,</span> <span class="n">cpu_bound</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;custom process pool&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<p>Note that the entry point guard (<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code>)
is required for option 3 due to the peculiarities of <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a>,
which is used by <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" title="concurrent.futures.ProcessPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProcessPoolExecutor</span></code></a>.
See <a class="reference internal" href="multiprocessing.html#multiprocessing-safe-main-import"><span class="std std-ref">Safe importing of main module</span></a>.</p>
<p>Este método retorna un objeto <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a>.</p>
<p>Use <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a> <a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">para pasar argumentos de palabra clave</span></a> a <em>func</em>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5.3: </span><a class="reference internal" href="#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_in_executor()</span></code></a> ya no configura el <code class="docutils literal notranslate"><span class="pre">max_workers</span></code> del ejecutor del grupo de subprocesos que crea, sino que lo deja en manos del ejecutor del grupo de subprocesos (<a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a>) para establecer el valor por defecto.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.set_default_executor">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">set_default_executor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">executor</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_default_executor" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece <em>executor</em> como el ejecutor predeterminado utilizado por <a class="reference internal" href="#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_in_executor()</span></code></a>. <em>executor</em> debe ser una instancia de <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.8: </span>Usar un ejecutor que no es una instancia de <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a> es obsoleto y disparará un error en Python 3.9.</p>
</div>
<p><em>executor</em> debe ser una instancia de <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures.ThreadPoolExecutor</span></code></a>.</p>
</dd></dl>

</section>
<section id="error-handling-api">
<h3><a class="toc-backref" href="#id15">API para manejo de errores</a><a class="headerlink" href="#error-handling-api" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Permite personalizar como son manejadas las excepciones en el bucle de eventos.</p>
<dl class="py method">
<dt id="asyncio.loop.set_exception_handler">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">set_exception_handler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">handler</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_exception_handler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece <em>handler</em> como el nuevo gestor de excepciones del bucle de eventos.</p>
<p>Si <em>handler</em> es <code class="docutils literal notranslate"><span class="pre">None</span></code>, se establecerá el gestor de excepciones predeterminado. De otro modo, <em>handler</em> debe ser un invocable con la misma firma <code class="docutils literal notranslate"><span class="pre">(loop,</span> <span class="pre">context)</span></code>, donde <code class="docutils literal notranslate"><span class="pre">loop</span></code> es una referencia al bucle de eventos activo, y <code class="docutils literal notranslate"><span class="pre">context</span></code> es un objeto <code class="docutils literal notranslate"><span class="pre">dict</span></code> que contiene los detalles de la excepción (vea la documentación de <a class="reference internal" href="#asyncio.loop.call_exception_handler" title="asyncio.loop.call_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_exception_handler()</span></code></a> para detalles acerca del contexto).</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.get_exception_handler">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">get_exception_handler</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.get_exception_handler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el gesto de excepciones actual, o <code class="docutils literal notranslate"><span class="pre">None</span></code> si no fue establecido ningún gestor de excepciones personalizado.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.default_exception_handler">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">default_exception_handler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">context</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.default_exception_handler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Gestor de excepciones por defecto.</p>
<p>Esto es llamado cuando ocurre una excepción y no se estableció ningún gestor de excepciones. Esto puede ser llamado por un gestor de excepciones personalizado que quiera cambiar el comportamiento del gestor predeterminado.</p>
<p>El parámetro <em>context</em> tiene el mismo significado que en <a class="reference internal" href="#asyncio.loop.call_exception_handler" title="asyncio.loop.call_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_exception_handler()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.call_exception_handler">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">call_exception_handler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">context</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_exception_handler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llama al gestor de excepciones del bucle de eventos actual.</p>
<p><em>context</em> es un objeto <code class="docutils literal notranslate"><span class="pre">dict</span></code> conteniendo las siguientes claves (en futuras versiones de Python podrían introducirse nuevas claves):</p>
<ul class="simple">
<li><p>“message”: Mensaje de error;</p></li>
<li><p>“exception” (opcional): Objeto de excepción;</p></li>
<li><p>“future” (opcional): instancia de <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a>;</p></li>
<li><p>“task” (opcional): instancia de <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a>;</p></li>
<li><p>“handle” (opcional): instancia de <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Handle</span></code></a>;</p></li>
<li><p>“protocol” (opcional): instancia de <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">Protocol</span></a>;</p></li>
<li><p>“transport” (opcional): instancia de <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><span class="std std-ref">Transport</span></a>;</p></li>
<li><p>“socket” (opcional): instancia de <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a>;</p></li>
<li><dl class="simple">
<dt>“asyncgen” (opcional): Generador asíncrono que causó</dt><dd><p>la excepción.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Este método no debe ser sobrecargado en bucles de eventos en subclase. Para gestión de excepciones personalizadas, use el método <a class="reference internal" href="#asyncio.loop.set_exception_handler" title="asyncio.loop.set_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_exception_handler()</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="enabling-debug-mode">
<h3><a class="toc-backref" href="#id16">Habilitando el modo depuración</a><a class="headerlink" href="#enabling-debug-mode" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py method">
<dt id="asyncio.loop.get_debug">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">get_debug</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.get_debug" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Obtiene el modo depuración (<a class="reference internal" href="functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>) del bucle de eventos.</p>
<p>El valor predeterminado es <code class="docutils literal notranslate"><span class="pre">True</span></code> si la variable de entorno <span class="target" id="index-17"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONASYNCIODEBUG"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONASYNCIODEBUG</span></code></a> es establecida a una cadena no vacía, de otro modo será <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.set_debug">
<code class="sig-prename descclassname">loop.</code><code class="sig-name descname">set_debug</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">enabled</span><span class="p">:</span> <span class="n"><a class="reference internal" href="functions.html#bool" title="bool">bool</a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_debug" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece el modo de depuración del bucle de eventos.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>El nuevo <a class="reference internal" href="devmode.html#devmode"><span class="std std-ref">Python Modo de Desarrollo</span></a> ahora también se puede usar para habilitar el modo de depuración.</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>El <a class="reference internal" href="asyncio-dev.html#asyncio-debug-mode"><span class="std std-ref">modo depuración de asyncio</span></a>.</p>
</div>
</section>
<section id="running-subprocesses">
<h3><a class="toc-backref" href="#id17">Ejecutando Subprocesos</a><a class="headerlink" href="#running-subprocesses" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Los métodos descritos en esta subsección son de bajo nivel. En código async/await regular considere usar las convenientes funciones de alto nivel <a class="reference internal" href="asyncio-subprocess.html#asyncio.create_subprocess_shell" title="asyncio.create_subprocess_shell"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_subprocess_shell()</span></code></a> y <a class="reference internal" href="asyncio-subprocess.html#asyncio.create_subprocess_exec" title="asyncio.create_subprocess_exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_subprocess_exec()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>On Windows, the default event loop <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a> supports
subprocesses, whereas <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> does not. See
<a class="reference internal" href="asyncio-platforms.html#asyncio-windows-subprocess"><span class="std std-ref">Subprocess Support on Windows</span></a> for
details.</p>
</div>
<dl class="py method">
<dt id="asyncio.loop.subprocess_exec">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">subprocess_exec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocol_factory</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">stdin</span><span class="o">=</span><span class="default_value">subprocess.PIPE</span></em>, <em class="sig-param"><span class="n">stdout</span><span class="o">=</span><span class="default_value">subprocess.PIPE</span></em>, <em class="sig-param"><span class="n">stderr</span><span class="o">=</span><span class="default_value">subprocess.PIPE</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.subprocess_exec" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un subproceso de uno o mas argumentos de cadena especificados por <em>args</em>.</p>
<p><em>args</em> debe ser una lista de cadenas representadas por:</p>
<ul class="simple">
<li><p><a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>;</p></li>
<li><p>o <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, codificados a la <a class="reference internal" href="os.html#filesystem-encoding"><span class="std std-ref">codificación del sistema de archivos</span></a>.</p></li>
</ul>
<p>La primer cadena especifica el programa ejecutable, y las cadenas restantes especifican los argumentos. En conjunto, los argumentos de cadena forman el <code class="docutils literal notranslate"><span class="pre">argv</span></code> del programa.</p>
<p>Esto es similar a la clase de la librería estándar <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> llamada con <code class="docutils literal notranslate"><span class="pre">shell=False</span></code> y la lista de cadenas pasadas como el primer argumento; de cualquier forma, cuando <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">Popen</span></code></a> toma un sólo argumento que es una lista de cadenas, <em>subprocess_exec</em> toma múltiples cadenas como argumentos.</p>
<p>El <em>protocol_factory</em> debe ser un ejecutable que retorne una subclase de la clase <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessProtocol" title="asyncio.SubprocessProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.SubprocessProtocol</span></code></a>.</p>
<p>Otros parámetros:</p>
<ul>
<li><p><em>stdin</em> puede ser cualquier de estos:</p>
<ul class="simple">
<li><p>un objeto de tipo archivo representando una tubería que será conectada al flujo de entrada estándar del subproceso utilizando <a class="reference internal" href="#asyncio.loop.connect_write_pipe" title="asyncio.loop.connect_write_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect_write_pipe()</span></code></a></p></li>
<li><p>la constante <a class="reference internal" href="subprocess.html#subprocess.PIPE" title="subprocess.PIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code></a> (predeterminado) que creará una tubería nueva y la conectará,</p></li>
<li><p>el valor <code class="docutils literal notranslate"><span class="pre">None</span></code> que hará que el subproceso herede el descriptor de archivo de este proceso</p></li>
<li><p>la constante <a class="reference internal" href="subprocess.html#subprocess.DEVNULL" title="subprocess.DEVNULL"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code></a> que indica que el archivo especial <a class="reference internal" href="os.html#os.devnull" title="os.devnull"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.devnull</span></code></a> será utilizado</p></li>
</ul>
</li>
<li><p><em>stdout</em> puede ser cualquier de estos:</p>
<ul class="simple">
<li><p>un objeto de tipo archivo representando una tubería que será conectada al flujo de salida estándar del subproceso utilizando <a class="reference internal" href="#asyncio.loop.connect_write_pipe" title="asyncio.loop.connect_write_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect_write_pipe()</span></code></a></p></li>
<li><p>la constante <a class="reference internal" href="subprocess.html#subprocess.PIPE" title="subprocess.PIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code></a> (predeterminado) que creará una tubería nueva y la conectará,</p></li>
<li><p>el valor <code class="docutils literal notranslate"><span class="pre">None</span></code> que hará que el subproceso herede el descriptor de archivo de este proceso</p></li>
<li><p>la constante <a class="reference internal" href="subprocess.html#subprocess.DEVNULL" title="subprocess.DEVNULL"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code></a> que indica que el archivo especial <a class="reference internal" href="os.html#os.devnull" title="os.devnull"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.devnull</span></code></a> será utilizado</p></li>
</ul>
</li>
<li><p><em>stderr</em> puede ser cualquier de estos:</p>
<ul class="simple">
<li><p>un objeto de tipo archivo representando una tubería que será conectada al flujo de error estándar del subproceso utilizando <a class="reference internal" href="#asyncio.loop.connect_write_pipe" title="asyncio.loop.connect_write_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect_write_pipe()</span></code></a></p></li>
<li><p>la constante <a class="reference internal" href="subprocess.html#subprocess.PIPE" title="subprocess.PIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code></a> (predeterminado) que creará una tubería nueva y la conectará,</p></li>
<li><p>el valor <code class="docutils literal notranslate"><span class="pre">None</span></code> que hará que el subproceso herede el descriptor de archivo de este proceso</p></li>
<li><p>la constante <a class="reference internal" href="subprocess.html#subprocess.DEVNULL" title="subprocess.DEVNULL"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code></a> que indica que el archivo especial <a class="reference internal" href="os.html#os.devnull" title="os.devnull"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.devnull</span></code></a> será utilizado</p></li>
<li><p>la constante <a class="reference internal" href="subprocess.html#subprocess.STDOUT" title="subprocess.STDOUT"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.STDOUT</span></code></a> que conectará el flujo de errores predeterminado al flujo de salida predeterminado del proceso</p></li>
</ul>
</li>
<li><p>El resto de argumentos de palabra clave son pasados a <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> sin interpretación, excepto por <em>bufsize</em>, <em>universal_newlines</em>, <em>shell</em>, <em>text</em>, <em>encoding</em> y <em>errors</em>, que no deben ser especificados en lo absoluto.</p>
<p>La API subproceso <code class="docutils literal notranslate"><span class="pre">asyncio</span></code> no soporta decodificar los flujos como texto. <a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> puede ser usado para convertir a texto los bytes retornados por el flujo.</p>
</li>
</ul>
<p>Vea el constructor de la clase <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> para documentación acerca de otros argumentos.</p>
<p>Retorna un par de <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>, donde <em>transport</em> se ajusta a la clase base <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessTransport" title="asyncio.SubprocessTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.SubprocessTransport</span></code></a> y <em>protocol</em> es un objeto instanciado por <em>protocol_factory</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.loop.subprocess_shell">
<em class="property">coroutine </em><code class="sig-prename descclassname">loop.</code><code class="sig-name descname">subprocess_shell</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocol_factory</span></em>, <em class="sig-param"><span class="n">cmd</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">stdin</span><span class="o">=</span><span class="default_value">subprocess.PIPE</span></em>, <em class="sig-param"><span class="n">stdout</span><span class="o">=</span><span class="default_value">subprocess.PIPE</span></em>, <em class="sig-param"><span class="n">stderr</span><span class="o">=</span><span class="default_value">subprocess.PIPE</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.subprocess_shell" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un subproceso desde <em>cmd</em>, que puede ser una cadena <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> o <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> codificado a la <a class="reference internal" href="os.html#filesystem-encoding"><span class="std std-ref">codificación del sistema de archivos</span></a>, usando la sintaxis «shell» de la plataforma.</p>
<p>Esto es similar a la clase de la librería estándar <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> llamada con <code class="docutils literal notranslate"><span class="pre">shell=True</span></code>.</p>
<p>El <em>protocol_factory</em> debe ser un ejecutable que retorne una subclase de la clase <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessProtocol" title="asyncio.SubprocessProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.SubprocessProtocol</span></code></a>.</p>
<p>Vea <a class="reference internal" href="#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subprocess_exec()</span></code></a> para mas detalles acerca de los argumentos restantes.</p>
<p>Retorna un par de <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>, donde <em>transport</em> se ajusta a la clase base <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessTransport" title="asyncio.SubprocessTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">SubprocessTransport</span></code></a> y <em>protocol</em> es un objeto instanciado por <em>protocol_factory</em>.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Es responsabilidad de la aplicación asegurar que todos los espacios en blanco y caracteres especiales estén escapados correctamente para evitar vulnerabilidades de <a class="reference external" href="https://en.wikipedia.org/wiki/Shell_injection#Shell_injection">inyección de código</a>. La función <a class="reference internal" href="shlex.html#shlex.quote" title="shlex.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">shlex.quote()</span></code></a> puede ser usada para escapar apropiadamente espacios en blanco y caracteres especiales en cadenas que van a ser usadas para construir comandos de consola.</p>
</div>
</section>
</section>
<section id="callback-handles">
<h2>Gestores de llamadas<a class="headerlink" href="#callback-handles" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="py class">
<dt id="asyncio.Handle">
<em class="property">class </em><code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">Handle</code><a class="headerlink" href="#asyncio.Handle" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un objeto de contenedor de llamada retornado por <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a>, <a class="reference internal" href="#asyncio.loop.call_soon_threadsafe" title="asyncio.loop.call_soon_threadsafe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon_threadsafe()</span></code></a>.</p>
<dl class="py method">
<dt id="asyncio.Handle.cancel">
<code class="sig-name descname">cancel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Handle.cancel" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Cancela la llamada. Si la llamada ya fue cancelada o ejecutada, este método no tiene efecto.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Handle.cancelled">
<code class="sig-name descname">cancelled</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Handle.cancelled" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si la llamada fue cancelada.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="asyncio.TimerHandle">
<em class="property">class </em><code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">TimerHandle</code><a class="headerlink" href="#asyncio.TimerHandle" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un objeto de contenedor de llamada retornado por <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a>, and <a class="reference internal" href="#asyncio.loop.call_at" title="asyncio.loop.call_at"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_at()</span></code></a>.</p>
<p>Esta clase es una subclase de <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handle</span></code></a>.</p>
<dl class="py method">
<dt id="asyncio.TimerHandle.when">
<code class="sig-name descname">when</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.TimerHandle.when" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el tiempo de una llamada planificada como <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> segundos.</p>
<p>El tiempo es una marca de tiempo absoluta, usando la misma referencia de tiempo que <a class="reference internal" href="#asyncio.loop.time" title="asyncio.loop.time"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.time()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="server-objects">
<h2>Objetos Servidor<a class="headerlink" href="#server-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los objetos de servidor son creados por las funciones <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>, <a class="reference internal" href="#asyncio.loop.create_unix_server" title="asyncio.loop.create_unix_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_unix_server()</span></code></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_server()</span></code></a>, y <a class="reference internal" href="asyncio-stream.html#asyncio.start_unix_server" title="asyncio.start_unix_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_unix_server()</span></code></a>.</p>
<p>No instanciar la clase directamente.</p>
<dl class="py class">
<dt id="asyncio.Server">
<em class="property">class </em><code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">Server</code><a class="headerlink" href="#asyncio.Server" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Los objetos <em>Server</em> son gestores de asíncronos de contexto. Cuando son usados en una declaración <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code>, está garantizado que el objeto Servidor está cerrado y no está aceptando nuevas conexiones cuando la declaración <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> es completada:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">srv</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_server</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="k">async</span> <span class="k">with</span> <span class="n">srv</span><span class="p">:</span>
    <span class="c1"># some code</span>

<span class="c1"># At this point, srv is closed and no longer accepts new connections.</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>El objeto Servidor es un gestor asíncrono de contexto desde Python 3.7.</p>
</div>
<dl class="py method">
<dt id="asyncio.Server.close">
<code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.close" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Deja de servir: deja de escuchar sockets y establece el atributo <a class="reference internal" href="#asyncio.Server.sockets" title="asyncio.Server.sockets"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sockets</span></code></a> a <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Los sockets que representan conexiones entrantes existentes de clientes se dejan abiertas.</p>
<p>El servidor es cerrado de manera asíncrona, usa la corrutina <a class="reference internal" href="#asyncio.Server.wait_closed" title="asyncio.Server.wait_closed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_closed()</span></code></a> para esperar hasta que el servidor esté cerrado.</p>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Server.get_loop">
<code class="sig-name descname">get_loop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.get_loop" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el bucle de eventos asociado con el objeto Servidor.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Server.start_serving">
<em class="property">coroutine </em><code class="sig-name descname">start_serving</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.start_serving" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Comienza a aceptar conexiones.</p>
<p>Este método es idempotente, así que puede ser llamado cuando el servidor ya está sirviendo.</p>
<p>El parámetro sólo de palabra clave <em>start_serving</em> de <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> y <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asyncio.start_server()</span></code></a> permite crear un objeto Servidor que no está aceptando conexiones inicialmente. En este caso <code class="docutils literal notranslate"><span class="pre">Server.start_serving()</span></code>, o <a class="reference internal" href="#asyncio.Server.serve_forever" title="asyncio.Server.serve_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Server.serve_forever()</span></code></a> pueden ser usados para hacer que el servidor empiece a aceptar conexiones.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Server.serve_forever">
<em class="property">coroutine </em><code class="sig-name descname">serve_forever</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.serve_forever" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Comienza a aceptar conexiones hasta que la corrutina sea cancelada. La cancelación de la tarea <code class="docutils literal notranslate"><span class="pre">serve_forever</span></code> hace que el servidor sea cerrado.</p>
<p>Este método puede ser llamado si el servidor ya está aceptando conexiones. Solamente una tarea <code class="docutils literal notranslate"><span class="pre">serve_forever</span></code> puede existir para un objeto <em>Server</em>.</p>
<p>Ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">client_connected</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">writer</span><span class="p">):</span>
    <span class="c1"># Communicate with the client with</span>
    <span class="c1"># reader/writer streams.  For example:</span>
    <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="n">srv</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">start_server</span><span class="p">(</span>
        <span class="n">client_connected</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">srv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Server.is_serving">
<code class="sig-name descname">is_serving</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.is_serving" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si el servidor está aceptando nuevas conexiones.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="asyncio.Server.wait_closed">
<em class="property">coroutine </em><code class="sig-name descname">wait_closed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.wait_closed" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Espera hasta que el método <a class="reference internal" href="#asyncio.Server.close" title="asyncio.Server.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> se complete.</p>
</dd></dl>

<dl class="py attribute">
<dt id="asyncio.Server.sockets">
<code class="sig-name descname">sockets</code><a class="headerlink" href="#asyncio.Server.sockets" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Lista todos los objetos <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> en los que el servidor está escuchando.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Antes de Python 3.7 <code class="docutils literal notranslate"><span class="pre">Server.sockets</span></code> solía retornar directamente una lista interna de servidores socket. En 3.7 se retorna una copia de esa lista.</p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="event-loop-implementations">
<span id="asyncio-event-loop-implementations"></span><span id="asyncio-event-loops"></span><h2>Implementaciones del bucle de eventos<a class="headerlink" href="#event-loop-implementations" title="Enlazar permanentemente con este título">¶</a></h2>
<p>asyncio viene con dos implementaciones diferentes del bucle de eventos: <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> y <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>.</p>
<p>De manera predefinida asyncio está configurado para usar <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> en Unix y <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a> en Windows.</p>
<dl class="py class">
<dt id="asyncio.SelectorEventLoop">
<em class="property">class </em><code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">SelectorEventLoop</code><a class="headerlink" href="#asyncio.SelectorEventLoop" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un bucle de eventos basado en el módulo <a class="reference internal" href="selectors.html#module-selectors" title="selectors: High-level I/O multiplexing."><code class="xref py py-mod docutils literal notranslate"><span class="pre">selectors</span></code></a>.</p>
<p>Usa el <em>selector</em> disponible mas eficiente para la plataforma dada. También es posible configurar manualmente la implementación exacta del selector a utilizar:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">selectors</span>

<span class="k">class</span> <span class="nc">MyPolicy</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">DefaultEventLoopPolicy</span><span class="p">):</span>
   <span class="k">def</span> <span class="nf">new_event_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">selector</span> <span class="o">=</span> <span class="n">selectors</span><span class="o">.</span><span class="n">SelectSelector</span><span class="p">()</span>
      <span class="k">return</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">SelectorEventLoop</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">set_event_loop_policy</span><span class="p">(</span><span class="n">MyPolicy</span><span class="p">())</span>
</pre></div>
</div>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Disponibilidad</span></a>: Unix, Windows.</p>
</dd></dl>

<dl class="py class">
<dt id="asyncio.ProactorEventLoop">
<em class="property">class </em><code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">ProactorEventLoop</code><a class="headerlink" href="#asyncio.ProactorEventLoop" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un bucle de eventos para Windows que usa «E/S Puertos de Finalización» (IOCP).</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Disponibilidad</span></a>: Windows.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p><a class="reference external" href="https://docs.microsoft.com/en-ca/windows/desktop/FileIO/i-o-completion-ports">Documentaci´on de MSDN sobre E/S Puertos de Finalización</a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="asyncio.AbstractEventLoop">
<em class="property">class </em><code class="sig-prename descclassname">asyncio.</code><code class="sig-name descname">AbstractEventLoop</code><a class="headerlink" href="#asyncio.AbstractEventLoop" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Clase base abstracta para bucles de evento compatibles con asyncio.</p>
<p>The <a class="reference internal" href="#asyncio-event-loop-methods"><span class="std std-ref">Métodos del bucle de eventos</span></a> section lists all
methods that an alternative implementation of <code class="docutils literal notranslate"><span class="pre">AbstractEventLoop</span></code>
should have defined.</p>
</dd></dl>

</section>
<section id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Nótese que todos los ejemplos en esta sección muestran <strong>a propósito</strong> como usar las APIs de bucle de eventos de bajo nivel, como ser <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_forever()</span></code></a> y <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a>. Aplicaciones asyncio modernas raramente necesitan ser escritas de esta manera; considere utilizar funciones de alto nivel como <a class="reference internal" href="asyncio-task.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>.</p>
<section id="hello-world-with-call-soon">
<span id="asyncio-example-lowlevel-helloworld"></span><h3>Hola Mundo con call_soon()<a class="headerlink" href="#hello-world-with-call-soon" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Un ejemplo usando el método <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a> para planificar una llamada. La llamada muestra <code class="docutils literal notranslate"><span class="pre">&quot;Hello</span> <span class="pre">World&quot;</span></code> y luego para el bucle de eventos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">def</span> <span class="nf">hello_world</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A callback to print &#39;Hello World&#39; and stop the event loop&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Hello World&#39;</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="c1"># Schedule a call to hello_world()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">hello_world</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c1"># Blocking call interrupted by loop.stop()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Un ejemplo similar de <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">Hola Mundo</span></a> creado con una corrutina y la función <a class="reference internal" href="asyncio-task.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a>.</p>
</div>
</section>
<section id="display-the-current-date-with-call-later">
<span id="asyncio-example-call-later"></span><h3>Muestra la fecha actual con call_later()<a class="headerlink" href="#display-the-current-date-with-call-later" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Un ejemplo de llamada mostrando la fecha actual cada un segundo. La llamada usa el método <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a> para volver a planificarse después de 5 segundos, y después para el bucle de eventos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="k">def</span> <span class="nf">display_date</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">end_time</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">display_date</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="c1"># Schedule the first call to display_date()</span>
<span class="n">end_time</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">5.0</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">display_date</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c1"># Blocking call interrupted by loop.stop()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Un ejemplo similar a <a class="reference internal" href="asyncio-task.html#asyncio-example-sleep"><span class="std std-ref">fecha actual</span></a> creado con una corrutina y la función <a class="reference internal" href="asyncio-task.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a>.</p>
</div>
</section>
<section id="watch-a-file-descriptor-for-read-events">
<span id="asyncio-example-watch-fd"></span><h3>Mirar un descriptor de archivo para leer eventos<a class="headerlink" href="#watch-a-file-descriptor-for-read-events" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Espera hasta que el descriptor de archivo reciba algún dato usando el método <a class="reference internal" href="#asyncio.loop.add_reader" title="asyncio.loop.add_reader"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.add_reader()</span></code></a> y entonces cierra el bucle de eventos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">socketpair</span>

<span class="c1"># Create a pair of connected file descriptors</span>
<span class="n">rsock</span><span class="p">,</span> <span class="n">wsock</span> <span class="o">=</span> <span class="n">socketpair</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">reader</span><span class="p">():</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">rsock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Received:&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>

    <span class="c1"># We are done: unregister the file descriptor</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">remove_reader</span><span class="p">(</span><span class="n">rsock</span><span class="p">)</span>

    <span class="c1"># Stop the event loop</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="c1"># Register the file descriptor for read event</span>
<span class="n">loop</span><span class="o">.</span><span class="n">add_reader</span><span class="p">(</span><span class="n">rsock</span><span class="p">,</span> <span class="n">reader</span><span class="p">)</span>

<span class="c1"># Simulate the reception of data from the network</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">wsock</span><span class="o">.</span><span class="n">send</span><span class="p">,</span> <span class="s1">&#39;abc&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c1"># Run the event loop</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="c1"># We are done. Close sockets and the event loop.</span>
    <span class="n">rsock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">wsock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<ul class="simple">
<li><p>Un <a class="reference internal" href="asyncio-protocol.html#asyncio-example-create-connection"><span class="std std-ref">ejemplo</span></a> similar usando transportes, protocolos y el método <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a>.</p></li>
<li><p>Otro <a class="reference internal" href="asyncio-stream.html#asyncio-example-create-connection-streams"><span class="std std-ref">ejemplo</span></a> similar usando la función de alto nivel <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.open_connection()</span></code></a> y transmisiones.</p></li>
</ul>
</div>
</section>
<section id="set-signal-handlers-for-sigint-and-sigterm">
<span id="asyncio-example-unix-signals"></span><h3>Establece los gestores de señal para SIGINT y SIGTERM<a class="headerlink" href="#set-signal-handlers-for-sigint-and-sigterm" title="Enlazar permanentemente con este título">¶</a></h3>
<p>(Este ejemplo de <code class="docutils literal notranslate"><span class="pre">signals</span></code> solamente funcionan en Unix.)</p>
<p>Registra gestores para las señales <code class="xref py py-data docutils literal notranslate"><span class="pre">SIGINT</span></code> y <code class="xref py py-data docutils literal notranslate"><span class="pre">SIGTERM</span></code> usando el método <a class="reference internal" href="#asyncio.loop.add_signal_handler" title="asyncio.loop.add_signal_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.add_signal_handler()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">signal</span>

<span class="k">def</span> <span class="nf">ask_exit</span><span class="p">(</span><span class="n">signame</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;got signal </span><span class="si">%s</span><span class="s2">: exit&quot;</span> <span class="o">%</span> <span class="n">signame</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">signame</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;SIGINT&#39;</span><span class="p">,</span> <span class="s1">&#39;SIGTERM&#39;</span><span class="p">}:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">add_signal_handler</span><span class="p">(</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">signame</span><span class="p">),</span>
            <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">ask_exit</span><span class="p">,</span> <span class="n">signame</span><span class="p">,</span> <span class="n">loop</span><span class="p">))</span>

    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3600</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Event loop running for 1 hour, press Ctrl+C to interrupt.&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;pid </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span><span class="si">}</span><span class="s2">: send SIGINT or SIGTERM to exit.&quot;</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#">Bucle de eventos</a><ul>
<li><a class="reference internal" href="#event-loop-methods">Métodos del bucle de eventos</a><ul>
<li><a class="reference internal" href="#running-and-stopping-the-loop">Iniciar y para el bucle</a></li>
<li><a class="reference internal" href="#scheduling-callbacks">Programación de llamadas de retorno</a></li>
<li><a class="reference internal" href="#scheduling-delayed-callbacks">Planificando llamadas retardadas</a></li>
<li><a class="reference internal" href="#creating-futures-and-tasks">Creando Futuros y Tareas</a></li>
<li><a class="reference internal" href="#opening-network-connections">Abriendo conexiones de red</a></li>
<li><a class="reference internal" href="#creating-network-servers">Creando servidores de red</a></li>
<li><a class="reference internal" href="#transferring-files">Transfiriendo archivos</a></li>
<li><a class="reference internal" href="#tls-upgrade">Actualización de TLS</a></li>
<li><a class="reference internal" href="#watching-file-descriptors">Viendo descriptores de archivos</a></li>
<li><a class="reference internal" href="#working-with-socket-objects-directly">Trabajar con objetos sockets directamente</a></li>
<li><a class="reference internal" href="#dns">DNS</a></li>
<li><a class="reference internal" href="#working-with-pipes">Trabajando con tuberías</a></li>
<li><a class="reference internal" href="#unix-signals">Señales Unix</a></li>
<li><a class="reference internal" href="#executing-code-in-thread-or-process-pools">Ejecutando código en un hilos o grupos de procesos</a></li>
<li><a class="reference internal" href="#error-handling-api">API para manejo de errores</a></li>
<li><a class="reference internal" href="#enabling-debug-mode">Habilitando el modo depuración</a></li>
<li><a class="reference internal" href="#running-subprocesses">Ejecutando Subprocesos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#callback-handles">Gestores de llamadas</a></li>
<li><a class="reference internal" href="#server-objects">Objetos Servidor</a></li>
<li><a class="reference internal" href="#event-loop-implementations">Implementaciones del bucle de eventos</a></li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#hello-world-with-call-soon">Hola Mundo con call_soon()</a></li>
<li><a class="reference internal" href="#display-the-current-date-with-call-later">Muestra la fecha actual con call_later()</a></li>
<li><a class="reference internal" href="#watch-a-file-descriptor-for-read-events">Mirar un descriptor de archivo para leer eventos</a></li>
<li><a class="reference internal" href="#set-signal-handlers-for-sigint-and-sigterm">Establece los gestores de señal para SIGINT y SIGTERM</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="asyncio-exceptions.html"
                        title="capítulo anterior">Excepciones</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="asyncio-future.html"
                        title="próximo capítulo">Futures</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/asyncio-eventloop.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="asyncio-future.html" title="Futures"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="asyncio-exceptions.html" title="Excepciones"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La Biblioteca Estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >Comunicación en redes y entre procesos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" ><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code> — E/S Asíncrona</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Bucle de eventos</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 27, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>