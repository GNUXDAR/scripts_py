
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="Qué hay de nuevo en Python 2.2" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/whatsnew/2.2.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Autor, A.M. Kuchling,. Introducción: Este artículo explica las nuevas características en Python 2.2.2, publicado el 14 de octubre de 2002. Python 2.2.2 es una versión de corrección de errores de Py..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Autor, A.M. Kuchling,. Introducción: Este artículo explica las nuevas características en Python 2.2.2, publicado el 14 de octubre de 2002. Python 2.2.2 es una versión de corrección de errores de Py..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>Qué hay de nuevo en Python 2.2 &#8212; documentación de Python - 3.11.2</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=2d3badd06fe70b34b68db01f99471ce1624ffe4a" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.11.2"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="Qué hay de nuevo en Python 2.1" href="2.1.html" />
    <link rel="prev" title="Qué hay de nuevo en Python 2.3" href="2.3.html" />
    <link rel="canonical" href="https://docs.python.org/3/whatsnew/2.2.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">Qué hay de nuevo en Python 2.2</a><ul>
<li><a class="reference internal" href="#introduction">Introducción</a></li>
<li><a class="reference internal" href="#peps-252-and-253-type-and-class-changes">PEPs 252 y 253: Cambios de tipo y clase</a><ul>
<li><a class="reference internal" href="#old-and-new-classes">Clases antiguas y nuevas</a></li>
<li><a class="reference internal" href="#descriptors">Descriptores</a></li>
<li><a class="reference internal" href="#multiple-inheritance-the-diamond-rule">Herencia múltiple: la regla del diamante</a></li>
<li><a class="reference internal" href="#attribute-access">Acceso a atributos</a></li>
<li><a class="reference internal" href="#related-links">Enlaces relacionados</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-234-iterators">PEP 234: Iteradores</a></li>
<li><a class="reference internal" href="#pep-255-simple-generators">PEP 255: Generadores simples</a></li>
<li><a class="reference internal" href="#pep-237-unifying-long-integers-and-integers">PEP 237: Unificación de enteros largos y enteros</a></li>
<li><a class="reference internal" href="#pep-238-changing-the-division-operator">PEP 238: Cambio del operador de división</a></li>
<li><a class="reference internal" href="#unicode-changes">Cambios en Unicode</a></li>
<li><a class="reference internal" href="#pep-227-nested-scopes">PEP 227: Ámbitos anidados</a></li>
<li><a class="reference internal" href="#new-and-improved-modules">Módulos nuevos y mejorados</a></li>
<li><a class="reference internal" href="#interpreter-changes-and-fixes">Cambios y correcciones en el intérprete</a></li>
<li><a class="reference internal" href="#other-changes-and-fixes">Otros cambios y correcciones</a></li>
<li><a class="reference internal" href="#acknowledgements">Agradecimientos</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="2.3.html"
                          title="capítulo anterior">Qué hay de nuevo en Python 2.3</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="2.1.html"
                          title="próximo capítulo">Qué hay de nuevo en Python 2.1</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/whatsnew/2.2.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="2.1.html" title="Qué hay de nuevo en Python 2.1"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="2.3.html" title="Qué hay de nuevo en Python 2.3"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Qué hay de nuevo en Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Qué hay de nuevo en Python 2.2</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-2-2">
<h1>Qué hay de nuevo en Python 2.2<a class="headerlink" href="#what-s-new-in-python-2-2" title="Enlazar permanentemente con este título">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Autor</dt>
<dd class="field-odd"><p>A.M. Kuchling</p>
</dd>
</dl>
<section id="introduction">
<h2>Introducción<a class="headerlink" href="#introduction" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Este artículo explica las nuevas características en Python 2.2.2, publicado el 14 de octubre de 2002. Python 2.2.2 es una versión de corrección de errores de Python 2.2, lanzada originalmente el 21 de diciembre de 2001.</p>
<p>Python 2.2 se puede considerar como la «versión de limpieza». Hay algunas características como los generadores e iteradores que son completamente nuevas, pero la mayoría de los cambios, aunque sean significativos y de gran alcance, tienen como objetivo limpiar las irregularidades y los rincones oscuros del diseño del lenguaje.</p>
<p>Este artículo no procura proporcionar una especificación completa de las nuevas características, pero en su lugar proporciona una descripción general conveniente. Para más detalles, deberías consultar la documentación de Python 2.2, como <a class="reference external" href="https://docs.python.org/2.2/lib/lib.html">Python Library Reference</a> y <a class="reference external" href="https://docs.python.org/2.2/ref/ref.html">Python Reference Manual</a>. Si quieres comprender la justificación completa de la implementación y el diseño de un cambio, consultar la PEP para conocer una característica nueva en particular.</p>
</section>
<section id="peps-252-and-253-type-and-class-changes">
<h2>PEPs 252 y 253: Cambios de tipo y clase<a class="headerlink" href="#peps-252-and-253-type-and-class-changes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los cambios más grandes y de mayor alcance en Python 2.2 son el modelo de objetos y clases de Python. Los cambios deben ser compatibles con versiones anteriores, por lo que es probable que tu código continuará ejecutándose sin cambios, pero los cambios proporcionan algunas capacidades nuevas increíbles. Antes de comenzar esta, la sección más larga y complicada de este artículo, brindaré una descripción general de los cambios y ofreceré algunos comentarios.</p>
<p>Hace mucho tiempo escribí una página web que enumeraba los defectos en el diseño de Python. Una de las fallas más importantes fue que es imposible subclasificar tipos de Python implementados en C. En particular, no es posible subclasificar tipos incorporados, por lo que no se puede solo subclasificar, digamos, listas para agregar un solo método útil para ellos. El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">UserList</span></code> proporciona una clase que admite todos los métodos de listas y que puede subclasificarse aún más, pero hay mucho código C que espera una lista normal de Python y no aceptará una instancia <code class="xref py py-class docutils literal notranslate"><span class="pre">UserList</span></code>.</p>
<p>Python 2.2 corrige esto y, en el proceso, agrega algunas capacidades nuevas interesantes. Un breve resumen:</p>
<ul class="simple">
<li><p>Puedes subclasificar tipos incorporados como listas e incluso enteros, y tus subclases deberían funcionar en todos los lugares que requieran el tipo original.</p></li>
<li><p>Ahora es posible definir métodos estáticos y de clase, además de los métodos de instancia disponibles en versiones anteriores de Python.</p></li>
<li><p>También es posible llamar automáticamente métodos al acceder o configurar un atributo de instancia mediante el uso de un nuevo mecanismo llamado <em class="dfn">properties</em>. Muchos usos de <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code> se pueden reescribir para usar propiedades en su lugar, haciendo que el código resultante sea más simple y rápido. Como un pequeño beneficio secundario, ahora también los atributos pueden tener docstrings.</p></li>
<li><p>La lista de atributos legales para una instancia se puede limitar a un conjunto particular usando <em class="dfn">slots</em>, lo que hace posible protegerse contra errores tipográficos y quizás hacer posibles más optimizaciones en versiones futuras de Python.</p></li>
</ul>
<p>Algunos usuarios han expresado preocupación por todos estos cambios. Claro, dicen, las nuevas características son ordenadas y se prestan a todo tipo de trucos que no eran posibles en versiones anteriores de Python, pero también hacen que el lenguaje sea más complicado. Algunas personas han dicho que siempre han recomendado Python por su simplicidad, y sienten que su simplicidad se está perdiendo.</p>
<p>Personalmente. pienso que no hay que preocuparse. Muchas de las nuevas características son bastante esotéricas, y puedes escribir mucho código de Python sin tener que estar al tanto de ellas. Escribir una clase simple no es más difícil de lo que nunca fue, así que no necesitas molestarte en aprender o enseñarlos a menos que realmente sean necesarios. Algunas tareas muy complicadas que antes solo eran posibles desde C ahora serán posibles en Python puro, y en mi opinión, esto es todo para mejor.</p>
<p>No voy a intentar cubrir todas los casos de las esquinas y los pequeños cambios que fueron necesarios para hacer que las nuevas características funcionen. En su lugar, esta sección pintará solo a grandes rasgos. Consultar la sección <a class="reference internal" href="#sect-rellinks"><span class="std std-ref">Enlaces relacionados</span></a>, «Enlaces relacionados», para más fuentes de información sobre el nuevo modelo de objetos de Python 2.2.</p>
<section id="old-and-new-classes">
<h3>Clases antiguas y nuevas<a class="headerlink" href="#old-and-new-classes" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Primero, debes saber que realmente Python 2.2 tiene dos tipos de clases: clases clásicas o de estilo antiguo y clases de estilo nuevo. El modelo de clase de estilo antiguo exactamente es el mismo que el modelo de clase en versiones anteriores de Python. Todas las nuevas características descritas en esta sección se aplican solo a las clases de estilo nuevo. Esta divergencia no está destinada a durar para siempre; eventualmente las clases de estilo antiguo se eliminarán, posiblemente en Python 3.0.</p>
<p>Entonces, ¿cómo defines una clase de estilo nuevo? Lo haces subclasificando una clases de estilo nuevo existente. La mayoría de los tipos integrados de Python, como enteros, listas, diccionarios e incluso archivos, ahora son clases de estilo nuevo. También se agregó una clase de estilo nuevo llamada <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>, la clase base para todos los tipos integrados, por lo que si ningún tipo integrado es apropiado, puedes solo subclasificar <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Esto significa que las declaraciones <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a> que no tienen ninguna clase base siempre son clases clásicas en Python 2.2. (Realmente también puedes cambiar esto configurando una variable de nivel de módulo llamada <code class="xref py py-attr docutils literal notranslate"><span class="pre">__metaclass__</span></code> — consultar <span class="target" id="index-46"></span><a class="pep reference external" href="https://peps.python.org/pep-0253/"><strong>PEP 253</strong></a> para más detalles — pero es más fácil solo subclasificar <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>.)</p>
<p>Los objetos de tipo para los tipos integrados están disponibles como incorporados, nombrados mediante un truco inteligente. Python siempre ha tenido funciones incorporadas llamadas <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>, <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a> y <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a>. En la versión 2.2, ya no son funciones, sino objetos de tipo que se comportan como fábricas cuando se les llaman.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span>
<span class="go">&lt;type &#39;int&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;123&#39;</span><span class="p">)</span>
<span class="go">123</span>
</pre></div>
</div>
<p>Para completar el conjunto de tipos, se agregaron nuevos objetos de tipo como <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">dict()</span></code></a> y <code class="xref py py-func docutils literal notranslate"><span class="pre">file()</span></code>. Aquí hay un ejemplo más interesante, agregando un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">lock()</span></code> a los objetos de archivo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LockableFile</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">lock</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">whence</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">fcntl</span>
        <span class="k">return</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">lockf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">operation</span><span class="p">,</span>
                           <span class="n">length</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">whence</span><span class="p">)</span>
</pre></div>
</div>
<p>El módulo ahora obsoleto <code class="xref py py-mod docutils literal notranslate"><span class="pre">posixfile</span></code> contenía una clase que emulaba todos los métodos de un objeto de archivo y también agregaba un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">lock()</span></code>, pero esta clase no podía pasarse a funciones internas que esperaban un archivo incorporado, algo que es posible con nuestra nueva clase <code class="xref py py-class docutils literal notranslate"><span class="pre">LockableFile</span></code>.</p>
</section>
<section id="descriptors">
<h3>Descriptores<a class="headerlink" href="#descriptors" title="Enlazar permanentemente con este título">¶</a></h3>
<p>En versiones anteriores de Python, no había una forma consistente de descubrir qué atributos y métodos eran compatibles con un objeto. Había algunas convenciones informales, como definir atributos <code class="xref py py-attr docutils literal notranslate"><span class="pre">__members__</span></code> y <code class="xref py py-attr docutils literal notranslate"><span class="pre">__methods__</span></code> que eran listas de nombres, pero a menudo el autor de un tipo de extensión o una clase no se molestaría en definirlos. Podrías recurrir a inspeccionar el <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> de un objeto, pero cuando la herencia de una clase o un gancho arbitrario <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code> estuvieran en uso, esto podría ser inexacto.</p>
<p>La única gran idea que subyace al nuevo modelo de clases es que se ha formalizado una API para describir los atributos de un objeto usando <em class="dfn">descriptors</em>. Los descriptores especifican el valor de un atributo, indicando si es un método o un campo. Con la API de un descriptor, los métodos estáticos y de clase se vuelven posibles, así como constructos más exóticos.</p>
<p>Los descriptores de atributos son objetos que viven dentro de los objetos de clase y tienen algunos atributos propios:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> es el nombre del atributo.</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> es el docstring del atributo.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__get__(object)</span></code> es un método que recupera el valor del atributo de <em>object</em>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__set__(object,</span> <span class="pre">value)</span></code> establece el atributo de <em>object</em> en <em>value</em>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__delete__(object,</span> <span class="pre">value)</span></code> elimina el atributo <em>value</em> de <em>object</em>.</p></li>
</ul>
<p>Por ejemplo, cuando escribes <code class="docutils literal notranslate"><span class="pre">obj.x</span></code>, los pasos que realmente Python realiza son:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">x</span>
<span class="n">descriptor</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
<p>Para los métodos, <code class="xref py py-meth docutils literal notranslate"><span class="pre">descriptor.__get__()</span></code> retorna un objeto temporal que se puede llamar y contiene la instancia y el método que se llamará en él. También esto es el por qué los métodos estáticos y de clase ahora son posibles; tienen descriptores que contienen solo el método o el método y la clase. Como una breve explicación de estos tipos nuevos de métodos, los métodos estáticos no se pasan a la instancia y, por lo tanto, se asemejan a funciones regulares. Los métodos de clase se pasan a la clase del objeto, pero no al objeto en sí. Los métodos estáticos y de clase se definen así:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">):</span>
        <span class="o">...</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">):</span>
        <span class="o">...</span>
    <span class="n">g</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</pre></div>
</div>
<p>La función <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a> toma la función <code class="xref py py-func docutils literal notranslate"><span class="pre">f()</span></code> y la retorna en un descriptor para que pueda almacenarse en el objeto de clase. Puedes esperar que haya una sintaxis especial para crear tales métodos (<code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">static</span> <span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">defstatic</span> <span class="pre">f()</span></code> o algo así) pero aún no se ha definido dicha sintaxis; que se ha dejado para versiones futuras de Python.</p>
<p>También se implementan más características nuevas, como ranuras y propiedades, como nuevos tipos de descriptores, y no es difícil escribir una clase de descriptor que haga algo nuevo. Por ejemplo, sería posible escribir una clase de descriptor que hiciera posible escribir condiciones previas al estilo Eiffel y posteriores para un método. Una clase que usó esta característica podría definirse así:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">eiffel</span> <span class="kn">import</span> <span class="n">eiffelmethod</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">):</span>
        <span class="c1"># The actual function</span>
        <span class="o">...</span>
    <span class="k">def</span> <span class="nf">pre_f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Check preconditions</span>
        <span class="o">...</span>
    <span class="k">def</span> <span class="nf">post_f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Check postconditions</span>
        <span class="o">...</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">eiffelmethod</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">pre_f</span><span class="p">,</span> <span class="n">post_f</span><span class="p">)</span>
</pre></div>
</div>
<p>Toma en cuenta que una persona que usa la nueva función <code class="xref py py-func docutils literal notranslate"><span class="pre">eiffelmethod()</span></code> no tiene que entender nada sobre descriptores. Esta es la razón por la que creo que las nuevas características no incrementan la complejidad básica del lenguaje. Habrá algunos asistentes que necesitarán conocerlo para escribir <code class="xref py py-func docutils literal notranslate"><span class="pre">eiffelmethod()</span></code> o la ZODB o lo que sea, pero la mayoría de los usuarios solo escribirán código sobre las bibliotecas resultantes e ignorarán los detalles de implementación.</p>
</section>
<section id="multiple-inheritance-the-diamond-rule">
<h3>Herencia múltiple: la regla del diamante<a class="headerlink" href="#multiple-inheritance-the-diamond-rule" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La herencia múltiple también se ha hecho más útil al cambiar las reglas bajo las cuales se resuelven los nombres. Considera este conjunto de clases (diagrama tomado de <span class="target" id="index-47"></span><a class="pep reference external" href="https://peps.python.org/pep-0253/"><strong>PEP 253</strong></a> de Guido van Rossum):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>      <span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
        <span class="o">^</span> <span class="o">^</span>  <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>
       <span class="o">/</span>   \
      <span class="o">/</span>     \
     <span class="o">/</span>       \
    <span class="o">/</span>         \
<span class="k">class</span> <span class="nc">B</span>     <span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="o">^</span>         <span class="o">^</span>  <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>
     \       <span class="o">/</span>
      \     <span class="o">/</span>
       \   <span class="o">/</span>
        \ <span class="o">/</span>
      <span class="k">class</span> <span class="nc">D</span>
</pre></div>
</div>
<p>La regla de búsqueda para clases clásicas es simple pero no muy inteligente; se buscan las clases base primero en profundidad, yendo de izquierda a derecha. Una referencia a <code class="xref py py-meth docutils literal notranslate"><span class="pre">D.save()</span></code> buscará las clases <code class="xref py py-class docutils literal notranslate"><span class="pre">D</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">B</span></code> y luego <code class="xref py py-class docutils literal notranslate"><span class="pre">A</span></code>, donde <code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code> se encontraría y retornaría. <code class="xref py py-meth docutils literal notranslate"><span class="pre">C.save()</span></code> nunca se encontraría en absoluto. Esto es malo, porque si el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code> de <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> está guardando algún estado interno específico de <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>, no llamarlo resultará en que este estado nunca se guardará.</p>
<p>Las clases de estilo nuevo siguen un algoritmo diferente que es más complicado de explicar, pero hace lo correcto en esta situación. (Toma en cuenta que Python 2.3 cambia este algoritmo a uno que produce los mismos resultados en la mayoría de los casos, pero produce resultados más útiles para gráficos de herencia realmente complicados.)</p>
<ol class="arabic simple">
<li><p>Enumera todas las clases base, siguiendo la regla de búsqueda clásica e incluye una clase varias veces si se visita repetidamente. En el ejemplo anterior, la lista de clases visitadas es [<code class="xref py py-class docutils literal notranslate"><span class="pre">D</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">B</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">A</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">A</span></code>].</p></li>
<li><p>Escanea la lista en busca de clases duplicadas. Si encuentra alguna, elimina todas menos una, dejando la <em>última</em> en la lista. En el ejemplo anterior, la lista se convierte en [<code class="xref py py-class docutils literal notranslate"><span class="pre">D</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">B</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">A</span></code>] después de eliminar las duplicadas.</p></li>
</ol>
<p>Siguiendo esta regla, refiriéndose a <code class="xref py py-meth docutils literal notranslate"><span class="pre">D.save()</span></code> retornará <code class="xref py py-meth docutils literal notranslate"><span class="pre">C.save()</span></code>, el cual es el comportamiento que buscamos. Esta regla de búsqueda es la misma que sigue Common Lisp. Una nueva función incorporada, <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a>, proporciona una forma de acceder a las superclases de una clase sin tener que volver a implementar el algoritmo de Python. La forma más utilizada será <code class="docutils literal notranslate"><span class="pre">super(class,</span> <span class="pre">obj)</span></code>, la cual retorna un objeto de superclase vinculado. Esta forma se usará en métodos para llamar a un método en la superclase; por ejemplo, el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code> de <code class="xref py py-class docutils literal notranslate"><span class="pre">D</span></code> se vería así:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">D</span> <span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">save</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Call superclass .save()</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
        <span class="c1"># Save D&#39;s private information here</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>También <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> puede retornar objetos de superclase no vinculados cuando se llama como <code class="docutils literal notranslate"><span class="pre">super(class)</span></code> o <code class="docutils literal notranslate"><span class="pre">super(class1,</span> <span class="pre">class2)</span></code>, pero probablemente esto no sea útil a menudo.</p>
</section>
<section id="attribute-access">
<h3>Acceso a atributos<a class="headerlink" href="#attribute-access" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Un buen número de clases sofisticadas de Python definen ganchos para el acceso de atributos usando <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code>; más comúnmente, esto se hace por conveniencia, para hacer que el código sea más legible al mapear automáticamente un acceso de atributo como <code class="docutils literal notranslate"><span class="pre">obj.parent</span></code> en una llamada de método como <code class="docutils literal notranslate"><span class="pre">obj.get_parent</span></code>. Python 2.2 agrega algunas formas nuevas de controlar el acceso de atributos.</p>
<p>Primero, <code class="docutils literal notranslate"><span class="pre">__getattr__(attr_name)</span></code> aún es compatible con las clases de nuevo estilo, y nada al respecto ha cambiado. Como antes, se llamará cuando se intente acceder a <code class="docutils literal notranslate"><span class="pre">obj.foo</span></code> y no se encuentre ningún atributo llamado <code class="docutils literal notranslate"><span class="pre">foo</span></code> en el diccionario de la instancia.</p>
<p>Las clases de nuevo estilo también admiten un nuevo método, <code class="docutils literal notranslate"><span class="pre">__getattribute__(attr_name)</span></code>. La diferencia entre los dos métodos es que <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code> <em>siempre</em> se llama cada vez que se accede a cualquier atributo, mientras que el antiguo <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code> se llama solo si no se encuentra <code class="docutils literal notranslate"><span class="pre">foo</span></code> en el diccionario de la instancia.</p>
<p>Sin embargo, el soporte de Python 2.2 para <em class="dfn">properties</em> será a menudo una forma más simple de atrapar referencias de atributos. Escribir un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code> es complicado porque para evitar la recursividad no puedes usar accesos regulares a atributos dentro de ellos, y en su lugar tienes que jugar con el contenido de <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>. Los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code> también terminan siendo llamados por Python cuando busca otros métodos como <code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code> o <code class="xref py py-meth docutils literal notranslate"><span class="pre">__coerce__()</span></code>, por lo que se tienen que escribirse teniendo esto en cuenta. Finalmente, llamar una función en cada acceso de atributo resulta en una pérdida de rendimiento considerable.</p>
<p><a class="reference internal" href="../library/functions.html#property" title="property"><code class="xref py py-class docutils literal notranslate"><span class="pre">property</span></code></a> es un nuevo tipo integrado que empaqueta tres funciones obtienen, establecen o eliminan un atributo y una docstring. Por ejemplo, si quieres definir un atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code> que se calcula, pero que también se puede configurar, puedes escribir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_size</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="o">...</span> <span class="n">computation</span> <span class="o">...</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">def</span> <span class="nf">set_size</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="o">...</span> <span class="n">compute</span> <span class="n">something</span> <span class="n">based</span> <span class="n">on</span> <span class="n">the</span> <span class="n">size</span>
        <span class="ow">and</span> <span class="nb">set</span> <span class="n">internal</span> <span class="n">state</span> <span class="n">appropriately</span> <span class="o">...</span>

    <span class="c1"># Define a property.  The &#39;delete this attribute&#39;</span>
    <span class="c1"># method is defined as None, so the attribute</span>
    <span class="c1"># can&#39;t be deleted.</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_size</span><span class="p">,</span> <span class="n">set_size</span><span class="p">,</span>
                    <span class="kc">None</span><span class="p">,</span>
                    <span class="s2">&quot;Storage size of this instance&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Eso es ciertamente más claro y fácil de escribir que un par de métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code>/<code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code> que verifican el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code> y lo manejan especialmente mientras recuperan todos los demás atributos <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> de la instancia. Los accesos a <code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code> también son los únicos que tienen que realizar el trabajo de llamar a una función, por lo que las referencias a otros atributos se ejecutan a su velocidad habitual.</p>
<p>Finalmente, es posible restringir la lista de atributos que se pueden referenciar en un objeto usando el nuevo atributo de clase <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a>. Los objetos de Python por lo general son muy dinámicos; en cualquier momento es posible definir un nuevo atributo en una instancia haciendo simplemente <code class="docutils literal notranslate"><span class="pre">obj.new_attr=1</span></code>. Una clase de estilo nuevo puede definir un atributo de clase llamado <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> para limitar los atributos legales a un conjunto particular de nombres. Un ejemplo hará esto claro:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;template&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">obj</span><span class="o">.</span><span class="n">template</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">template</span> <span class="o">=</span> <span class="s1">&#39;Test&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">obj</span><span class="o">.</span><span class="n">template</span>
<span class="go">Test</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">newattr</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;C&#39; object has no attribute &#39;newattr&#39;</span>
</pre></div>
</div>
<p>Toma en cuenta cómo obtienes un <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> en el intento de asignar a un atributo que no aparece en <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a>.</p>
</section>
<section id="related-links">
<span id="sect-rellinks"></span><h3>Enlaces relacionados<a class="headerlink" href="#related-links" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Esta sección solo ha sido una descripción rápida de las nuevas características, brindando una explicación suficiente para comenzar a programar, pero muchos detalles se han simplificado o ignorado. ¿Dónde deberías ir para obtener una imagen más completa?</p>
<p>The <a class="reference internal" href="../howto/descriptor.html#descriptorhowto"><span class="std std-ref">Guía práctica de uso de los descriptores</span></a> is a lengthy tutorial introduction to
the descriptor features, written by Guido van Rossum. If my description has
whetted your appetite, go read this tutorial next, because it goes into much
more detail about the new features while still remaining quite easy to read.</p>
<p>A continuación, hay dos PEPs relevantes, <span class="target" id="index-48"></span><a class="pep reference external" href="https://peps.python.org/pep-0252/"><strong>PEP 252</strong></a> y <span class="target" id="index-49"></span><a class="pep reference external" href="https://peps.python.org/pep-0253/"><strong>PEP 253</strong></a>. <span class="target" id="index-50"></span><a class="pep reference external" href="https://peps.python.org/pep-0252/"><strong>PEP 252</strong></a> se titula «Hacer que los tipos se parezcan más a las clases», y cubre la API del descriptor. <span class="target" id="index-51"></span><a class="pep reference external" href="https://peps.python.org/pep-0253/"><strong>PEP 253</strong></a> se titula «Subtipado de tipos incorporados», y describe los cambios de los objetos de tipo que hacen posible el subtipo de objetos incorporados. <span class="target" id="index-52"></span><a class="pep reference external" href="https://peps.python.org/pep-0253/"><strong>PEP 253</strong></a> es la PEP más complicada de las dos, y en algunos puntos las explicaciones necesarias de tipos y meta-tipos pueden causar que tu cabeza explote. Ambas PEPs se escribieron e implementaron por Guido van Rossum con la asistencia sustancial del resto del equipo de Zope Corp.</p>
<p>Finalmente, está la máxima autoridad: el código fuente. La mayoría de la maquinaria para el manejo de tipos está en <code class="file docutils literal notranslate"><span class="pre">Objects/typeobject.c</span></code>, pero solo debes recurrir a él después de que se hayan agotado todas las demás vías, incluida la publicación de una pregunta en python-list o python-dev.</p>
</section>
</section>
<section id="pep-234-iterators">
<h2>PEP 234: Iteradores<a class="headerlink" href="#pep-234-iterators" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Otra adición significativa a la versión 2.2 es una interfaz de iteración tanto a nivel de C como de Python.  Los objetos pueden definir cómo pueden ser iterados por quienes los llaman.</p>
<p>En las versiones de Python hasta la 2.1, la forma habitual de hacer que funcione <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">obj</span></code> es definir un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code> que se parezca a esto:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">&lt;</span><span class="nb">next</span> <span class="n">item</span><span class="o">&gt;</span>
</pre></div>
</div>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code> se utiliza más adecuadamente para definir una operación de indexación en un objeto, de modo que se puede escribir <code class="docutils literal notranslate"><span class="pre">obj[5]</span></code> para recuperar el sexto elemento.  Es un poco engañoso cuando se utiliza esto sólo para soportar bucles <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>. Considere algún objeto tipo archivo que quiera ser revisado en bucle; el parámetro <em>index</em> no tiene sentido, ya que la clase probablemente asume que se hará una serie de llamadas a <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code> con <em>index</em> incrementándose en uno cada vez.  En otras palabras, la presencia del método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code> no significa que el uso de <code class="docutils literal notranslate"><span class="pre">file[5]</span></code> para acceder al azar al sexto elemento vaya a funcionar, aunque realmente debería hacerlo.</p>
<p>En Python 2.2, la iteración puede implementarse por separado, y los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code> pueden limitarse a las clases que realmente soportan el acceso aleatorio.  La idea básica de los iteradores es simple.  Una nueva función incorporada, <code class="docutils literal notranslate"><span class="pre">iter(obj)</span></code> o <code class="docutils literal notranslate"><span class="pre">iter(C,</span> <span class="pre">sentinel)</span></code>, se utiliza para obtener un iterador. <code class="docutils literal notranslate"><span class="pre">iter(obj)</span></code> retorna un iterador para el objeto <em>obj</em>, mientras que <code class="docutils literal notranslate"><span class="pre">iter(C,</span> <span class="pre">sentinel)</span></code> retorna un iterador que invocará al objeto invocable <em>C</em> hasta que retorne <em>sentinel</em> para señalar que el iterador ha terminado.</p>
<p>Las clases de Python pueden definir un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code>, que debe crear y retornar un nuevo iterador para el objeto; si el objeto es su propio iterador, este método puede simplemente retornar <code class="docutils literal notranslate"><span class="pre">self</span></code>.  En particular, los iteradores suelen ser sus propios iteradores.  Los tipos de extensión implementados en C pueden implementar una función <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iter</span></code></a> para retornar un iterador, y los tipos de extensión que quieran comportarse como iteradores pueden definir una función <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iternext</span></code></a>.</p>
<p>Entonces, después de todo esto, ¿qué hacen realmente los iteradores?  Tienen un método obligatorio, <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a>, que no toma argumentos y retorna el siguiente valor.  Cuando no hay más valores que retornar, la llamada a <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a> debería lanzar la excepción <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">i</span>
<span class="go">&lt;iterator object at 0x8116870&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">StopIteration</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>En 2.2, la sentencia <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> de Python ya no espera una secuencia; espera algo para lo que <a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> retornará un iterador. Por compatibilidad y comodidad, se construye automáticamente un iterador para las secuencias que no implementan <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> o una ranura <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iter</span></code></a>, por lo que <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">[1,2,3]</span></code> seguirá funcionando.  Dondequiera que el intérprete de Python haga un bucle sobre una secuencia, se ha cambiado para utilizar el protocolo de los iteradores.  Esto significa que puedes hacer cosas como esta:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">i</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span>
<span class="go">(1, 2, 3)</span>
</pre></div>
</div>
<p>Se ha añadido soporte de iteradores a algunos de los tipos básicos de Python.   Llamar a <a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> sobre un diccionario retornará un iterador que hace un bucle sobre sus claves:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Jan&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Feb&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Mar&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;Apr&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;May&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;Jun&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
<span class="gp">... </span>     <span class="s1">&#39;Jul&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;Aug&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;Sep&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s1">&#39;Oct&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;Nov&#39;</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="s1">&#39;Dec&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span> <span class="nb">print</span> <span class="n">key</span><span class="p">,</span> <span class="n">m</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">Mar 3</span>
<span class="go">Feb 2</span>
<span class="go">Aug 8</span>
<span class="go">Sep 9</span>
<span class="go">May 5</span>
<span class="go">Jun 6</span>
<span class="go">Jul 7</span>
<span class="go">Jan 1</span>
<span class="go">Apr 4</span>
<span class="go">Nov 11</span>
<span class="go">Dec 12</span>
<span class="go">Oct 10</span>
</pre></div>
</div>
<p>Este es el comportamiento por defecto.  Si quieres iterar sobre claves, valores o pares clave/valor, puedes llamar explícitamente a los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">iterkeys()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">itervalues()</span></code> o <code class="xref py py-meth docutils literal notranslate"><span class="pre">iteritems()</span></code> para obtener un iterador apropiado. En un cambio menor relacionado, el operador <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> ahora funciona en los diccionarios, por lo que <code class="docutils literal notranslate"><span class="pre">key</span> <span class="pre">in</span> <span class="pre">dict</span></code> es ahora equivalente a <code class="docutils literal notranslate"><span class="pre">dict.has_key(key)</span></code>.</p>
<p>Los archivos también proporcionan un iterador, que llama al método <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> hasta que no hay más líneas en el archivo.  Esto significa que ahora puede leer cada línea de un archivo utilizando un código como este:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
    <span class="c1"># do something for each line</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Tenga en cuenta que sólo puede avanzar en un iterador; no hay forma de obtener el elemento anterior, reiniciar el iterador o hacer una copia del mismo. Un objeto iterador podría proporcionar estas capacidades adicionales, pero el protocolo iterador sólo requiere un método <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-53"></span><a class="pep reference external" href="https://peps.python.org/pep-0234/"><strong>PEP 234</strong></a> - Iteradores</dt><dd><p>Escrito por Ka-Ping Yee y GvR; implementado por el equipo de Python Labs, principalmente por GvR y Tim Peters.</p>
</dd>
</dl>
</div>
</section>
<section id="pep-255-simple-generators">
<h2>PEP 255: Generadores simples<a class="headerlink" href="#pep-255-simple-generators" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los generadores son otra novedad que interactúa con la introducción de los iteradores.</p>
<p>Sin duda estás familiarizado con cómo funcionan las llamadas a funciones en Python o C. Cuando llamas a una función, ésta obtiene un espacio de nombres privado donde se crean sus variables locales.  Cuando la función llega a una declaración <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a>, las variables locales se destruyen y el valor resultante se retorna a quien la llamó.  Una llamada posterior a la misma función obtendrá un nuevo conjunto de variables locales. Pero, ¿qué pasaría si las variables locales no se tiraran al salir de una función? ¿Qué pasaría si pudieras reanudar la función donde la dejaste?  Esto es lo que proporcionan los generadores; se puede pensar en ellos como funciones reanudables.</p>
<p>Este es el ejemplo más sencillo de una función generadora:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_ints</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">i</span>
</pre></div>
</div>
<p>Se ha introducido una nueva palabra clave, <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>, para los generadores.  Cualquier función que contenga una declaración <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> es una función generadora; esto es detectado por el compilador de código de bits de Python que compila la función especialmente como resultado.  Debido a la introducción de una nueva palabra clave, los generadores deben ser explícitamente habilitados en un módulo incluyendo una declaración <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">generators</span></code> cerca de la parte superior del código fuente del módulo.  En Python 2.3 esta declaración será innecesaria.</p>
<p>Cuando se llama a una función generadora, ésta no retorna un único valor, sino que retorna un objeto generador que soporta el protocolo de los iteradores.  Al ejecutar la sentencia <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>, el generador retorna el valor de <code class="docutils literal notranslate"><span class="pre">i</span></code>, de forma similar a una sentencia <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a>.  La gran diferencia entre <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> y una sentencia <code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code> es que al llegar a una sentencia <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> se suspende el estado de ejecución del generador y se conservan las variables locales.  En la siguiente llamada al método <code class="docutils literal notranslate"><span class="pre">next()</span></code> del generador, la función se reanudará la ejecución inmediatamente después de la sentencia <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code>.  (Por razones complicadas, la sentencia <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> no está permitida dentro del bloque <code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code> de una sentencia <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>…`<a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a>; lea <span class="target" id="index-54"></span><a class="pep reference external" href="https://peps.python.org/pep-0255/"><strong>PEP 255</strong></a> para una explicación completa de la interacción entre <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> y las excepciones)</p>
<p>Este es un ejemplo de uso del generador <code class="xref py py-func docutils literal notranslate"><span class="pre">generate_ints()</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="n">generate_ints</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span>
<span class="go">&lt;generator object at 0x8117f90&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">generate_ints</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<p>También podrías escribir <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">generate_ints(5)</span></code>, o <code class="docutils literal notranslate"><span class="pre">a,b,c</span> <span class="pre">=</span> <span class="pre">generate_ints(3)</span></code>.</p>
<p>Dentro de una función generadora, la sentencia <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> sólo puede usarse sin un valor, y señala el final de la procesión de valores; después el generador no puede retornar más valores. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code> con un valor, como <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">5</span></code>, es un error de sintaxis dentro de una función generadora.  El final de los resultados del generador también puede indicarse levantando manualmente <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>, o simplemente dejando que el flujo de ejecución caiga en el fondo de la función.</p>
<p>Puedes conseguir el efecto de los generadores manualmente escribiendo tu propia clase y almacenando todas las variables locales del generador como variables de instancia.  Por ejemplo, la lución de una lista de enteros podría hacerse estableciendo <code class="docutils literal notranslate"><span class="pre">self.count</span></code> a 0, y haciendo que el método <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a> incremente <code class="docutils literal notranslate"><span class="pre">self.count</span></code> y lo retorne. Sin embargo, para un generador medianamente complicado, escribir la clase correspondiente sería mucho más complicado. <code class="file docutils literal notranslate"><span class="pre">Lib/test/test_generators.py</span></code> contiene varios ejemplos más interesantes.  El más sencillo implementa un recorrido en orden de un árbol utilizando generadores de forma recursiva</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># A recursive generator that generates Tree leaves in in-order.</span>
<span class="k">def</span> <span class="nf">inorder</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">t</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inorder</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">left</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
        <span class="k">yield</span> <span class="n">t</span><span class="o">.</span><span class="n">label</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inorder</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">right</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
</pre></div>
</div>
<p>Otros dos ejemplos en <code class="file docutils literal notranslate"><span class="pre">Lib/test/test_generators.py</span></code> producen soluciones para el problema de las N reinas (colocar $N$ reinas en un tablero de ajedrez $NxN$ de forma que ninguna reina amenace a otra) y el recorrido del caballero (una ruta que lleva a un caballo a cada casilla de un tablero de ajedrez $NxN$ sin visitar ninguna casilla dos veces).</p>
<p>La idea de los generadores proviene de otros lenguajes de programación, especialmente de Icon (<a class="reference external" href="https://www.cs.arizona.edu/icon/">https://www.cs.arizona.edu/icon/</a>), donde la idea de los generadores es fundamental.  En Icon, cada expresión y llamada a una función se comporta como un generador.  Un ejemplo de «<em>An Overview of the Icon Programming Language</em>» en <a class="reference external" href="https://www.cs.arizona.edu/icon/docs/ipd266.htm">https://www.cs.arizona.edu/icon/docs/ipd266.htm</a> da una idea de cómo es esto:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sentence</span> <span class="o">:=</span> <span class="s2">&quot;Store it in the neighboring harbor&quot;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">:=</span> <span class="n">find</span><span class="p">(</span><span class="s2">&quot;or&quot;</span><span class="p">,</span> <span class="n">sentence</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="n">then</span> <span class="n">write</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>En Icon la función <code class="xref py py-func docutils literal notranslate"><span class="pre">find()</span></code> retorna los índices en los que se encuentra la subcadena «o»: 3, 23, 33.  En la sentencia <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>, a <code class="docutils literal notranslate"><span class="pre">i</span></code> se le asigna primero un valor de 3, pero 3 es menor que 5, por lo que la comparación falla, e Icon la reintenta con el segundo valor de 23. 23 es mayor que 5, por lo que la comparación ahora tiene éxito, y el código imprime el valor 23 en la pantalla.</p>
<p>Python no va tan lejos como Icon en la adopción de generadores como concepto central.  Los generadores se consideran una nueva parte del núcleo del lenguaje Python, pero aprenderlos o utilizarlos no es obligatorio; si no resuelven ningún problema que tengas, siéntete libre de ignorarlos. Una característica novedosa de la interfaz de Python en comparación con la de Icon es que el estado de un generador se representa como un objeto concreto (el iterador) que puede pasarse a otras funciones o almacenarse en una estructura de datos.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-55"></span><a class="pep reference external" href="https://peps.python.org/pep-0255/"><strong>PEP 255</strong></a> - Generadores simples</dt><dd><p>Escrito por Neil Schemenauer, Tim Peters, Magnus Lie Hetland.  Implementado principalmente por Neil Schemenauer y Tim Peters, con otras correcciones del equipo de Python Labs.</p>
</dd>
</dl>
</div>
</section>
<section id="pep-237-unifying-long-integers-and-integers">
<h2>PEP 237: Unificación de enteros largos y enteros<a class="headerlink" href="#pep-237-unifying-long-integers-and-integers" title="Enlazar permanentemente con este título">¶</a></h2>
<p>En versiones recientes, la distinción entre enteros regulares, que son valores de 32 bits en la mayoría de las máquinas, y enteros largos, que pueden tener un tamaño arbitrario, se estaba convirtiendo en una molestia.  Por ejemplo, en las plataformas que soportan archivos de más de <code class="docutils literal notranslate"><span class="pre">2**32</span></code> bytes, el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">tell()</span></code> de los objetos archivo tiene que retornar un entero largo. Sin embargo, había varias partes de Python que esperaban números enteros simples y que daban un error si se proporcionaba un número entero largo en su lugar.  Por ejemplo, en Python 1.5, sólo podían usarse enteros normales como índice de corte, y <code class="docutils literal notranslate"><span class="pre">'abc'[1L:]</span></code> lanzaba una excepción <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> con el mensaje “slice index must be int”.</p>
<p>Python 2.2 cambiará los valores de enteros cortos a enteros largos según sea necesario. El sufijo “L” ya no es necesario para indicar un literal entero largo, ya que ahora el compilador elegirá el tipo apropiado.  (El uso del sufijo “L” se desaconsejará en futuras versiones 2.x de Python, provocando una advertencia en Python 2.4, y probablemente se eliminará en Python 3.0)  Muchas operaciones que solían lanzar un <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a> ahora retornarán un entero largo como resultado.  Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1234567890123</span>
<span class="go">1234567890123L</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span> <span class="o">**</span> <span class="mi">64</span>
<span class="go">18446744073709551616L</span>
</pre></div>
</div>
<p>En la mayoría de los casos, los enteros y los enteros largos se tratarán ahora de forma idéntica.  Todavía se pueden distinguir con la función incorporada <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a>, pero rara vez se necesita.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-56"></span><a class="pep reference external" href="https://peps.python.org/pep-0237/"><strong>PEP 237</strong></a> - Unificación de enteros largos y enteros</dt><dd><p>Escrito por Moshe Zadka y Guido van Rossum.  Implementado principalmente por Guido van Rossum.</p>
</dd>
</dl>
</div>
</section>
<section id="pep-238-changing-the-division-operator">
<h2>PEP 238: Cambio del operador de división<a class="headerlink" href="#pep-238-changing-the-division-operator" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El cambio más controvertido de Python 2.2 anuncia el inicio de un esfuerzo por arreglar un viejo defecto de diseño que ha estado en Python desde el principio. Actualmente, el operador de división de Python, <code class="docutils literal notranslate"><span class="pre">/</span></code>, se comporta como el operador de división de C cuando se le presentan dos argumentos enteros: retorna un resultado entero que se trunca cuando hay una parte fraccionaria.  Por ejemplo, <code class="docutils literal notranslate"><span class="pre">3/2</span></code> es 1, no 1,5, y <code class="docutils literal notranslate"><span class="pre">(-1)/2</span></code> es -1, no -0,5.  Esto significa que los resultados de la división pueden variar inesperadamente dependiendo del tipo de los dos operandos y, como Python está tipado dinámicamente, puede ser difícil determinar los posibles tipos de los operandos.</p>
<p>(La controversia se centra en si esto es <em>realmente</em> un defecto de diseño, y si vale la pena romper el código existente para arreglarlo.  Ha provocado interminables discusiones en python-dev, y en julio de 2001 estalló una tormenta de publicaciones ácidamente sarcásticas en <em class="newsgroup">comp.lang.python</em>. No argumentaré aquí a favor de ninguno de los dos bandos y me limitaré a describir lo que se ha implementado en la 2.2.  Lea <span class="target" id="index-57"></span><a class="pep reference external" href="https://peps.python.org/pep-0238/"><strong>PEP 238</strong></a> para un resumen de los argumentos y contra-argumentos)</p>
<p>Debido a que este cambio podría romper el código, se está introduciendo de forma muy gradual. Python 2.2 comienza la transición, pero el cambio no será completo hasta Python 3.0.</p>
<p>En primer lugar, tomaré prestada alguna terminología de <span class="target" id="index-58"></span><a class="pep reference external" href="https://peps.python.org/pep-0238/"><strong>PEP 238</strong></a>.  La «división verdadera» es la división con la que la mayoría de los no programadores están familiarizados: 3/2 es 1,5, 1/4 es 0,25, y así sucesivamente.  La «división por el piso» es lo que hace actualmente el operador <code class="docutils literal notranslate"><span class="pre">/</span></code> de Python cuando se le dan operandos enteros; el resultado es el piso del valor retornado por la división verdadera.  La «división clásica» es el comportamiento mixto actual de <code class="docutils literal notranslate"><span class="pre">/</span></code>; retorna el resultado de la división por el suelo cuando los operandos son enteros, y retorna el resultado de la división verdadera cuando uno de los operandos es un número de punto flotante.</p>
<p>Estos son los cambios que introduce la versión 2.2:</p>
<ul>
<li><p>Un nuevo operador, <code class="docutils literal notranslate"><span class="pre">//</span></code>, es el operador de división por el suelo. (Sí, ya sabemos que se parece al símbolo de comentario de C++.) <code class="docutils literal notranslate"><span class="pre">//</span></code> <em>siempre</em> realiza la división por el suelo sin importar los tipos de sus operandos, así que <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">//</span> <span class="pre">2</span></code> es 0 y <code class="docutils literal notranslate"><span class="pre">1.0</span> <span class="pre">//</span> <span class="pre">2.0</span></code> también es 0.0.</p>
<p><code class="docutils literal notranslate"><span class="pre">//</span></code> está siempre disponible en Python 2.2; no es necesario habilitarlo mediante una sentencia <code class="docutils literal notranslate"><span class="pre">__future__</span></code>.</p>
</li>
<li><p>Al incluir una declaración <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">division</span></code> en un módulo, el operador <code class="docutils literal notranslate"><span class="pre">/</span></code> se cambiará para retornar el resultado de la división verdadera, por lo que <code class="docutils literal notranslate"><span class="pre">1/2</span></code> es 0,5.  Sin la declaración <code class="docutils literal notranslate"><span class="pre">__future__</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code> sigue significando la división clásica. El significado por defecto de <code class="docutils literal notranslate"><span class="pre">/</span></code> no cambiará hasta Python 3.0.</p></li>
<li><p>Las clases pueden definir métodos llamados <code class="xref py py-meth docutils literal notranslate"><span class="pre">__truediv__()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__floordiv__()</span></code> para sobrecargar los dos operadores de división.  En el nivel C, también hay ranuras en la estructura <a class="reference internal" href="../c-api/typeobj.html#c.PyNumberMethods" title="PyNumberMethods"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyNumberMethods</span></code></a> para que los tipos de extensión puedan definir los dos operadores.</p></li>
<li><p>Python 2.2 admite algunos argumentos de línea de comandos para comprobar si el código funcionará con la semántica de división modificada.  Ejecutar python con <code class="xref std std-option docutils literal notranslate"><span class="pre">-Q</span> <span class="pre">warn</span></code> hará que se emita una advertencia cada vez que se aplique la división a dos enteros.  Puedes usar esto para encontrar el código que está afectado por el cambio y arreglarlo.  Por defecto, Python 2.2 simplemente realizará la división clásica sin una advertencia; la advertencia se activará por defecto en Python 2.3.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-59"></span><a class="pep reference external" href="https://peps.python.org/pep-0238/"><strong>PEP 238</strong></a> - Cambio del operador de división</dt><dd><p>Escrito por Moshe Zadka y Guido van Rossum.  Implementado por Guido van Rossum..</p>
</dd>
</dl>
</div>
</section>
<section id="unicode-changes">
<h2>Cambios en Unicode<a class="headerlink" href="#unicode-changes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El soporte de Unicode de Python se ha mejorado un poco en la versión 2.2.  Las cadenas Unicode se almacenan normalmente como UCS-2, como enteros sin signo de 16 bits. Python 2.2 también puede ser compilado para usar UCS-4, enteros sin signo de 32 bits, como su codificación interna suministrando <code class="xref std std-option docutils literal notranslate"><span class="pre">--enable-unicode=ucs4</span></code> al script de configuración.   (También es posible especificar <code class="xref std std-option docutils literal notranslate"><span class="pre">--disable-unicode</span></code> para desactivar completamente el soporte de Unicode)</p>
<p>Cuando se compila para usar UCS-4 (un «Python amplio»), el intérprete puede manejar de forma nativa caracteres Unicode desde U+000000 hasta U+110000, por lo que el rango de valores legales para la función <code class="xref py py-func docutils literal notranslate"><span class="pre">unichr()</span></code> se expande en consecuencia.  Utilizando un intérprete compilado para usar UCS-2 (un «Python estrecho»), los valores mayores de 65535 seguirán provocando que <code class="xref py py-func docutils literal notranslate"><span class="pre">unichr()</span></code> lance una excepción <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>. Todo esto se describe en <span class="target" id="index-60"></span><a class="pep reference external" href="https://peps.python.org/pep-0261/"><strong>PEP 261</strong></a>, «Soporte para caracteres Unicode “anchos”»; consúltelo para más detalles.</p>
<p>Otro cambio es más sencillo de explicar. Desde su introducción, las cadenas Unicode han soportado un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> para convertir la cadena a una codificación seleccionada como UTF-8 o Latin-1.  Un método simétrico <code class="docutils literal notranslate"><span class="pre">decode([*encoding*])</span></code> ha sido añadido a las cadenas de 8 bits (aunque no a las cadenas Unicode) en 2.2. <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> asume que la cadena está en la codificación especificada y la decodifica, retornando lo que sea retornado por el códec.</p>
<p>Gracias a esta nueva función, se han añadido códecs para tareas no relacionadas directamente con Unicode.  Por ejemplo, se han añadido códecs para la codificación uu, la codificación base64 de MIME y la compresión con el módulo <a class="reference internal" href="../library/zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Here is a lengthy piece of redundant, overly verbose,</span>
<span class="gp">... </span><span class="s2">and repetitive text.</span>
<span class="gp">... </span><span class="s2">&quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;zlib&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">&#39;x\x9c\r\xc9\xc1\r\x80 \x10\x04\xc0?Ul...&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;zlib&#39;</span><span class="p">)</span>
<span class="go">&#39;Here is a lengthy piece of redundant, overly verbose,\nand repetitive text.\n&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">s</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;uu&#39;</span><span class="p">)</span>
<span class="go">begin 666 &lt;data&gt;</span>
<span class="go">M2&amp;5R92!I&lt;R!A(&amp;QE;F=T:&#39;D@&lt;&amp;EE8V4@;V8@&lt;F5D=6YD86YT+&quot;!O=F5R;&#39;D@</span>
<span class="go">&gt;=F5R8F]S92P*86YD(&#39;)E&lt;&amp;5T:71I=F4@=&amp;5X=&quot;X*</span>

<span class="go">end</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;sheesh&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;rot-13&#39;</span><span class="p">)</span>
<span class="go">&#39;furrfu&#39;</span>
</pre></div>
</div>
<p>Para convertir una instancia de clase a Unicode, se puede definir un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__unicode__()</span></code> por clase, análogo a <code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code>.</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code>, y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__unicode__()</span></code> fueron implementados por Marc-André Lemburg.  Los cambios para soportar el uso de UCS-4 internamente fueron implementados por Fredrik Lundh y Martin von Löwis.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-61"></span><a class="pep reference external" href="https://peps.python.org/pep-0261/"><strong>PEP 261</strong></a> - Soporte para caracteres Unicode “anchos”</dt><dd><p>Escrito por Paul Prescod.</p>
</dd>
</dl>
</div>
</section>
<section id="pep-227-nested-scopes">
<h2>PEP 227: Ámbitos anidados<a class="headerlink" href="#pep-227-nested-scopes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>En Python 2.1, los ámbitos anidados estáticamente se añadieron como una característica opcional, que se activaba mediante una directiva <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">nested_scopes</span></code>.  En 2.2 los ámbitos anidados ya no necesitan ser habilitados especialmente, y ahora están siempre presentes.  El resto de esta sección es una copia de la descripción de los ámbitos anidados de mi documento «What’s New in Python 2.1»; si lo leíste cuando salió la 2.1, puedes saltarte el resto de esta sección.</p>
<p>El mayor cambio introducido en Python 2.1, y completado en 2.2, es el de las reglas de alcance de Python.  En Python 2.0, en cualquier momento hay como máximo tres espacios de nombres utilizados para buscar nombres de variables: local, a nivel de módulo y el espacio de nombres incorporado.  Esto a menudo sorprendía a la gente porque no coincidía con sus expectativas intuitivas.  Por ejemplo, una definición de función recursiva anidada no funciona:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="n">g</span><span class="p">(</span><span class="n">value</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>La función <code class="xref py py-func docutils literal notranslate"><span class="pre">g()</span></code> siempre lanzará una excepción <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a>, porque el enlace del nombre <code class="docutils literal notranslate"><span class="pre">g</span></code> no está ni en su espacio de nombres local ni en el espacio de nombres a nivel de módulo.  Esto no es un gran problema en la práctica (¿con qué frecuencia se definen recursivamente funciones interiores como ésta?), pero esto también hacía más torpe el uso de la expresión <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a>, y esto era un problema en la práctica. En el código que utiliza <code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code> a menudo se pueden encontrar variables locales que se copian al pasarlas como valores por defecto de los argumentos.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="s2">&quot;Return list of any entries equal to &#39;name&#39;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="n">name</span><span class="p">,</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">list_attribute</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">L</span>
</pre></div>
</div>
<p>La legibilidad del código Python escrito en un estilo fuertemente funcional sufre mucho como resultado.</p>
<p>El cambio más significativo de Python 2.2 es que se ha añadido al lenguaje el ámbito estático para solucionar este problema.  Como primer efecto, el argumento por defecto <code class="docutils literal notranslate"><span class="pre">name=name</span></code> es ahora innecesario en el ejemplo anterior.  En pocas palabras, cuando a un nombre de variable dado no se le asigna un valor dentro de una función (mediante una asignación, o las sentencias <a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a>, <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a>, o <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>), las referencias a la variable se buscarán en el espacio de nombres local del ámbito que la rodea.  Puede encontrar una explicación más detallada de las reglas y una disección de la implementación en el PEP.</p>
<p>Este cambio puede causar algunos problemas de compatibilidad para el código en el que el mismo nombre de variable se utiliza tanto a nivel de módulo como de variable local dentro de una función que contiene otras definiciones de función. Sin embargo, esto parece bastante improbable, ya que dicho código habría sido bastante confuso de leer en primer lugar.</p>
<p>Un efecto secundario del cambio es que las sentencias <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> y <code class="docutils literal notranslate"><span class="pre">exec</span></code> se han hecho ilegales dentro del ámbito de una función bajo ciertas condiciones.  El manual de referencia de Python ha dicho todo el tiempo que <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> sólo es legal en el nivel superior de un módulo, pero el intérprete de CPython nunca ha aplicado esto antes.  Como parte de la implementación de los ámbitos anidados, el compilador que convierte el código fuente de Python en bytecodes tiene que generar un código diferente para acceder a las variables de un ámbito contenedor.  Los códigos <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> y <code class="docutils literal notranslate"><span class="pre">exec</span></code> hacen que el compilador no pueda averiguar esto, porque añaden nombres al espacio de nombres local que son desconocidos en tiempo de compilación. Por lo tanto, si una función contiene definiciones de funciones o expresiones <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> con variables libres, el compilador lo señalará lanzando una excepción <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>.</p>
<p>Para que la explicación anterior quede un poco más clara, he aquí un ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="c1"># The next line is a syntax error</span>
    <span class="n">exec</span> <span class="s1">&#39;x=2&#39;</span>
    <span class="k">def</span> <span class="nf">g</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>La línea 4 que contiene la sentencia <code class="docutils literal notranslate"><span class="pre">exec</span></code> es un error de sintaxis, ya que <code class="docutils literal notranslate"><span class="pre">exec</span></code> definiría una nueva variable local llamada <code class="docutils literal notranslate"><span class="pre">x</span></code> cuyo valor debería ser accedido por <code class="xref py py-func docutils literal notranslate"><span class="pre">g()</span></code>.</p>
<p>Esto no debería ser una gran limitación, ya que <code class="docutils literal notranslate"><span class="pre">exec</span></code> rara vez se utiliza en la mayoría del código de Python (y cuando se utiliza, a menudo es un signo de un mal diseño de todos modos).</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-62"></span><a class="pep reference external" href="https://peps.python.org/pep-0227/"><strong>PEP 227</strong></a> - Ámbitos anidados estáticamente</dt><dd><p>Escrito e implementado por Jeremy Hylton.</p>
</dd>
</dl>
</div>
</section>
<section id="new-and-improved-modules">
<h2>Módulos nuevos y mejorados<a class="headerlink" href="#new-and-improved-modules" title="Enlazar permanentemente con este título">¶</a></h2>
<ul>
<li><p>El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpclib</span></code> fue aportado a la biblioteca estándar por Fredrik Lundh, proporcionando soporte para escribir clientes XML-RPC.  XML-RPC es un sencillo protocolo de llamada a procedimientos remotos construido sobre HTTP y XML. Por ejemplo, el siguiente fragmento recupera una lista de canales RSS de la red O’Reilly y, a continuación, muestra los titulares recientes de un canal:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">xmlrpclib</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">xmlrpclib</span><span class="o">.</span><span class="n">Server</span><span class="p">(</span>
      <span class="s1">&#39;http://www.oreillynet.com/meerkat/xml-rpc/server.php&#39;</span><span class="p">)</span>
<span class="n">channels</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">meerkat</span><span class="o">.</span><span class="n">getChannels</span><span class="p">()</span>
<span class="c1"># channels is a list of dictionaries, like this:</span>
<span class="c1"># [{&#39;id&#39;: 4, &#39;title&#39;: &#39;Freshmeat Daily News&#39;}</span>
<span class="c1">#  {&#39;id&#39;: 190, &#39;title&#39;: &#39;32Bits Online&#39;},</span>
<span class="c1">#  {&#39;id&#39;: 4549, &#39;title&#39;: &#39;3DGamers&#39;}, ... ]</span>

<span class="c1"># Get the items for one channel</span>
<span class="n">items</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">meerkat</span><span class="o">.</span><span class="n">getItems</span><span class="p">(</span> <span class="p">{</span><span class="s1">&#39;channel&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span> <span class="p">)</span>

<span class="c1"># &#39;items&#39; is another list of dictionaries, like this:</span>
<span class="c1"># [{&#39;link&#39;: &#39;http://freshmeat.net/releases/52719/&#39;,</span>
<span class="c1">#   &#39;description&#39;: &#39;A utility which converts HTML to XSL FO.&#39;,</span>
<span class="c1">#   &#39;title&#39;: &#39;html2fo 0.3 (Default)&#39;}, ... ]</span>
</pre></div>
</div>
<p>El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">SimpleXMLRPCServer</span></code> facilita la creación de servidores XML-RPC sencillos.  Consulte <a class="reference external" href="http://xmlrpc.scripting.com/">http://xmlrpc.scripting.com/</a> para obtener más información sobre XML-RPC.</p>
</li>
<li><p>El nuevo módulo <a class="reference internal" href="../library/hmac.html#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hmac</span></code></a> implementa el algoritmo HMAC descrito por <span class="target" id="index-63"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2104.html"><strong>RFC 2104</strong></a>. (Contribución de Gerhard Häring)</p></li>
<li><p>Varias funciones que originalmente retornaban tuplas largas ahora retornan pseudo-secuencias que siguen comportándose como tuplas pero que también tienen atributos mnemónicos como memberst_mtime o <code class="xref py py-attr docutils literal notranslate"><span class="pre">tm_year</span></code>. Las funciones mejoradas incluyen <a class="reference internal" href="../library/stat.html#module-stat" title="stat: Utilities for interpreting the results of os.stat(), os.lstat() and os.fstat()."><code class="xref py py-func docutils literal notranslate"><span class="pre">stat()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">fstat()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">statvfs()</span></code> y <code class="xref py py-func docutils literal notranslate"><span class="pre">fstatvfs()</span></code> en el módulo <a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a>, y <code class="xref py py-func docutils literal notranslate"><span class="pre">localtime()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">gmtime()</span></code> y <code class="xref py py-func docutils literal notranslate"><span class="pre">strptime()</span></code> en el módulo <a class="reference internal" href="../library/time.html#module-time" title="time: Time access and conversions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">time</span></code></a>.</p>
<p>Por ejemplo, para obtener el tamaño de un archivo utilizando las antiguas tuplas, se terminaba escribiendo algo como <code class="docutils literal notranslate"><span class="pre">tamaño_de_archivo</span> <span class="pre">=</span> <span class="pre">os.stat(nombre_de_archivo)[stat.ST_SIZE]</span></code>, pero ahora se puede escribir más claramente como <code class="docutils literal notranslate"><span class="pre">tamaño_de_archivo</span> <span class="pre">=</span> <span class="pre">os.stat(nombre_de_archivo).st_size</span></code>.</p>
<p>El parche original para esta función fue aportado por Nick Mathewson.</p>
</li>
<li><p>El perfilador de Python ha sido ampliamente revisado y se han corregido varios errores en su salida.  (Contribución de Fred L. Drake, Jr. y Tim Peters)</p></li>
<li><p>El módulo <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> puede ser compilado para soportar IPv6; especifica la opción <code class="xref std std-option docutils literal notranslate"><span class="pre">--enable-ipv6</span></code> al script configure de Python.  (Contribución de Jun-ichiro «itojun» Hagino)</p></li>
<li><p>Se agregaron dos nuevos caracteres de formato al módulo <a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> para enteros de 64 bits en plataformas que admiten el tipo C <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span>. <code class="docutils literal notranslate"><span class="pre">q</span></code> es para un entero de 64 bits con signo y <code class="docutils literal notranslate"><span class="pre">Q</span></code> es para uno sin firmar. El valor se retorna en el tipo de entero largo de Python. (Aportado por Tim Peters.)</p></li>
<li><p>En el modo interactivo del intérprete, hay una nueva función incorporada <a class="reference internal" href="../library/functions.html#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a> que utiliza el módulo <a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> introducido en Python 2.1 para proporcionar ayuda interactiva. <a class="reference internal" href="../library/functions.html#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a> sin ningún argumento te sitúa en una utilidad de ayuda online, donde puedes introducir los nombres de las funciones, clases o módulos para leer su texto de ayuda. (Contribuido por Guido van Rossum, usando el módulo <a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> de Ka-Ping Yee)</p></li>
<li><p>Se han realizado varias correcciones de errores y mejoras de rendimiento en el motor SRE subyacente al módulo <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a>.  Por ejemplo, las funciones <a class="reference internal" href="../library/re.html#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.sub()</span></code></a> y <a class="reference internal" href="../library/re.html#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.split()</span></code></a> han sido reescritas en C. Otro parche contribuido acelera ciertos rangos de caracteres Unicode por un factor de dos, y un nuevo método <code class="xref py py-meth docutils literal notranslate"><span class="pre">finditer()</span></code> que retorna un iterador sobre todas las coincidencias no superpuestas en una cadena dada.  (El mantenimiento de SRE corre a cargo de Fredrik Lundh.  El parche BIGCHARSET fue aportado por Martin von Löwis)</p></li>
<li><p>El módulo <a class="reference internal" href="../library/smtplib.html#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a> soporta ahora <span class="target" id="index-64"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2487.html"><strong>RFC 2487</strong></a>, «Secure SMTP over TLS», por lo que ahora es posible cifrar el tráfico SMTP entre un programa Python y el agente de transporte de correo que recibe un mensaje. <a class="reference internal" href="../library/smtplib.html#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a> también soporta la autenticación SMTP.  (Contribución de Gerhard Häring)</p></li>
<li><p>El módulo <a class="reference internal" href="../library/imaplib.html#module-imaplib" title="imaplib: IMAP4 protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">imaplib</span></code></a>, mantenido por Piers Lauder, tiene soporte para varias extensiones nuevas: la extensión NAMESPACE definida en <span class="target" id="index-65"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2342.html"><strong>RFC 2342</strong></a>, SORT, GETACL y SETACL.  (Contribución de Anthony Baxter y Michel Pelletier)</p></li>
<li><p>El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">rfc822</span></code> que analiza las direcciones de correo electrónico cumple ahora con <span class="target" id="index-66"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2822.html"><strong>RFC 2822</strong></a>, una actualización de <span class="target" id="index-67"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc822.html"><strong>RFC 822</strong></a>.  (El nombre del módulo <em>no</em> se va a cambiar a <code class="docutils literal notranslate"><span class="pre">rfc2822</span></code>.) También se ha añadido un nuevo paquete, <a class="reference internal" href="../library/email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a>, para analizar y generar mensajes de correo electrónico.  (Contribuido por Barry Warsaw, y surgido de su trabajo en Mailman)</p></li>
<li><p>El módulo <a class="reference internal" href="../library/difflib.html#module-difflib" title="difflib: Helpers for computing differences between objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code></a> contiene ahora una nueva clase <code class="xref py py-class docutils literal notranslate"><span class="pre">Differ</span></code> para producir listas legibles por humanos de cambios (un «delta») entre dos secuencias de líneas de texto.  También hay dos funciones generadoras, <code class="xref py py-func docutils literal notranslate"><span class="pre">ndiff()</span></code> y <code class="xref py py-func docutils literal notranslate"><span class="pre">restore()</span></code>, que retornan respectivamente un delta de dos secuencias, o una de las secuencias originales de un delta. (Trabajo de gruñido contribuido por David Goodger, a partir del código ndiff.py de Tim Peters que luego hizo la generización)</p></li>
<li><p>Se han añadido las nuevas constantes <code class="xref py py-const docutils literal notranslate"><span class="pre">ascii_letters</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">ascii_lowercase</span></code> y <code class="xref py py-const docutils literal notranslate"><span class="pre">ascii_uppercase</span></code> al módulo <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a>.  Había varios módulos en la biblioteca estándar que utilizaban <code class="xref py py-const docutils literal notranslate"><span class="pre">string.letters</span></code> para referirse a los rangos A-Za-z, pero esa suposición es incorrecta cuando se utilizan locales, porque <code class="xref py py-const docutils literal notranslate"><span class="pre">string.letters</span></code> varía dependiendo del conjunto de caracteres legales definidos por el local actual.  Los módulos con errores se han corregido para que utilicen <code class="xref py py-const docutils literal notranslate"><span class="pre">ascii_letters</span></code> en su lugar. (Informado por una persona desconocida; corregido por Fred L. Drake, Jr.)</p></li>
<li><p>El módulo <a class="reference internal" href="../library/mimetypes.html#module-mimetypes" title="mimetypes: Mapping of filename extensions to MIME types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">mimetypes</span></code></a> facilita ahora el uso de bases de datos de tipos MIME alternativos mediante la adición de una clase <code class="xref py py-class docutils literal notranslate"><span class="pre">MimeTypes</span></code>, que toma una lista de nombres de archivo para ser analizados.  (Contribución de Fred L. Drake, Jr.)</p></li>
<li><p>Se ha añadido una clase <code class="xref py py-class docutils literal notranslate"><span class="pre">Timer</span></code> al módulo <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> que permite programar una actividad para que ocurra en algún momento futuro.  (Contribución de Itamar Shtull-Trauring)</p></li>
</ul>
</section>
<section id="interpreter-changes-and-fixes">
<h2>Cambios y correcciones en el intérprete<a class="headerlink" href="#interpreter-changes-and-fixes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Algunos de los cambios sólo afectan a la gente que trata con el intérprete de Python a nivel de C porque están escribiendo módulos de extensión de Python, incrustando el intérprete, o simplemente hackeando el propio intérprete. Si sólo escribes código Python, ninguno de los cambios descritos aquí te afectará mucho.</p>
<ul>
<li><p>Las funciones de perfilado y rastreo pueden implementarse ahora en C, que puede operar a velocidades mucho mayores que las funciones basadas en Python y debería reducir la sobrecarga de perfilado y rastreo.  Esto será de interés para los autores de entornos de desarrollo para Python.  Se han añadido dos nuevas funciones en C a la API de Python, <a class="reference internal" href="../c-api/init.html#c.PyEval_SetProfile" title="PyEval_SetProfile"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetProfile()</span></code></a> y <a class="reference internal" href="../c-api/init.html#c.PyEval_SetTrace" title="PyEval_SetTrace"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetTrace()</span></code></a>. Las funciones <a class="reference internal" href="../library/sys.html#sys.setprofile" title="sys.setprofile"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setprofile()</span></code></a> y <a class="reference internal" href="../library/sys.html#sys.settrace" title="sys.settrace"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.settrace()</span></code></a> existentes siguen existiendo, y simplemente se han cambiado para utilizar la nueva interfaz de nivel C.  (Contribución de Fred L. Drake, Jr.)</p></li>
<li><p>Se ha añadido otra API de bajo nivel, principalmente de interés para los implementadores de depuradores y herramientas de desarrollo de Python. <a class="reference internal" href="../c-api/init.html#c.PyInterpreterState_Head" title="PyInterpreterState_Head"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Head()</span></code></a> y <a class="reference internal" href="../c-api/init.html#c.PyInterpreterState_Next" title="PyInterpreterState_Next"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Next()</span></code></a> permiten al usuario recorrer todos los objetos intérpretes existentes; <a class="reference internal" href="../c-api/init.html#c.PyInterpreterState_ThreadHead" title="PyInterpreterState_ThreadHead"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_ThreadHead()</span></code></a> y <a class="reference internal" href="../c-api/init.html#c.PyThreadState_Next" title="PyThreadState_Next"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Next()</span></code></a> permiten recorrer todos los estados de los hilos de un intérprete dado.  (Contribución de David Beazley)</p></li>
<li><p>La interfaz a nivel de C para el recolector de basura ha sido cambiada para facilitar la escritura de tipos de extensión que soporten la recolección de basura y para depurar los malos usos de las funciones. Varias funciones tienen una semántica ligeramente diferente, por lo que hubo que cambiar el nombre de un montón de funciones.  Las extensiones que utilizan la antigua API seguirán compilando pero <em>no</em> participarán en la recolección de basura, por lo que actualizarlas para la 2.2 debería considerarse de alta prioridad.</p>
<p>Para actualizar un módulo de extensión a la nueva API, realice los siguientes pasos:</p>
</li>
<li><p>Cambia el nombre de <code class="xref c c-func docutils literal notranslate"><span class="pre">Py_TPFLAGS_GC()</span></code> a <code class="xref c c-func docutils literal notranslate"><span class="pre">PyTPFLAGS_HAVE_GC()</span></code>.</p></li>
<li><dl class="simple">
<dt>Utilice <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_New" title="PyObject_GC_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_New()</span></code></a> o <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_NewVar" title="PyObject_GC_NewVar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_NewVar()</span></code></a> para asignar</dt><dd><p>objetos, y <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_Del" title="PyObject_GC_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Del()</span></code></a> para desocuparlos.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Cambiar el nombre de <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Init()</span></code> a <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_Track" title="PyObject_GC_Track"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Track()</span></code></a> y</dt><dd><p><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Fini()</span></code> a <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_UnTrack" title="PyObject_GC_UnTrack"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_UnTrack()</span></code></a>.</p>
</dd>
</dl>
</li>
<li><p>Eliminar <code class="xref c c-func docutils literal notranslate"><span class="pre">PyGC_HEAD_SIZE()</span></code> del cálculo del tamaño de los objetos.</p></li>
<li><p>Eliminar las llamadas a <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_AS_GC()</span></code> y <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_FROM_GC()</span></code>.</p></li>
<li><p>Se ha añadido una nueva secuencia de formato <code class="docutils literal notranslate"><span class="pre">et</span></code> a <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>; <code class="docutils literal notranslate"><span class="pre">et</span></code> toma tanto un parámetro como un nombre de codificación, y convierte el parámetro a la codificación dada si el parámetro resulta ser una cadena Unicode, o lo deja solo si es una cadena de 8 bits, asumiendo que ya está en la codificación deseada.  Esto difiere del carácter de formato <code class="docutils literal notranslate"><span class="pre">es</span></code>, que asume que las cadenas de 8 bits están en la codificación ASCII por defecto de Python y las convierte a la nueva codificación especificada. (Contribuido por M.-A. Lemburg, y utilizado para el soporte de MBCS en Windows descrito en la siguiente sección)</p></li>
<li><p>Se ha agregado una función de análisis de argumentos diferente, <a class="reference internal" href="../c-api/arg.html#c.PyArg_UnpackTuple" title="PyArg_UnpackTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_UnpackTuple()</span></code></a>, que es más simple y presumiblemente más rápida. En lugar de especificar una cadena de formato, la persona que llama simplemente proporciona el número mínimo y máximo de argumentos esperados y un conjunto de punteros a las variables <span class="c-expr sig sig-inline c"><a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> que se completarán con los valores de los argumentos.</p></li>
<li><p>Dos nuevos indicadores <a class="reference internal" href="../c-api/structures.html#METH_NOARGS" title="METH_NOARGS"><code class="xref py py-const docutils literal notranslate"><span class="pre">METH_NOARGS</span></code></a> y <a class="reference internal" href="../c-api/structures.html#METH_O" title="METH_O"><code class="xref py py-const docutils literal notranslate"><span class="pre">METH_O</span></code></a> están disponibles en las tablas de definición de métodos para simplificar la implementación de métodos sin argumentos o con un único argumento no tipado. Llamar a estos métodos es más eficiente que llamar a un método correspondiente que utilice <a class="reference internal" href="../c-api/structures.html#METH_VARARGS" title="METH_VARARGS"><code class="xref py py-const docutils literal notranslate"><span class="pre">METH_VARARGS</span></code></a>.  Además, el antiguo estilo <code class="xref py py-const docutils literal notranslate"><span class="pre">METH_OLDARGS</span></code> de escribir métodos en C está oficialmente en desuso.</p></li>
<li><p>Se han añadido dos nuevas funciones de envoltura, <a class="reference internal" href="../c-api/conversion.html#c.PyOS_snprintf" title="PyOS_snprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_snprintf()</span></code></a> y <a class="reference internal" href="../c-api/conversion.html#c.PyOS_vsnprintf" title="PyOS_vsnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_vsnprintf()</span></code></a> para proporcionar implementaciones multiplataforma para las relativamente nuevas APIs de la biblioteca C <code class="xref c c-func docutils literal notranslate"><span class="pre">snprintf()</span></code> y <code class="xref c c-func docutils literal notranslate"><span class="pre">vsnprintf()</span></code>. A diferencia de las funciones estándar <code class="xref c c-func docutils literal notranslate"><span class="pre">sprintf()</span></code> y <code class="xref c c-func docutils literal notranslate"><span class="pre">vsprintf()</span></code>, las versiones de Python comprueban los límites del búfer utilizado para protegerse de los desbordamientos del mismo. (Contribución de M.-A. Lemburg.)</p></li>
<li><p>La función <a class="reference internal" href="../c-api/tuple.html#c._PyTuple_Resize" title="_PyTuple_Resize"><code class="xref c c-func docutils literal notranslate"><span class="pre">_PyTuple_Resize()</span></code></a> ha perdido un parámetro que no se utilizaba, por lo que ahora toma 2 parámetros en lugar de 3. El tercer argumento nunca se utilizaba, y puede descartarse simplemente al portar el código de versiones anteriores a Python 2.2.</p></li>
</ul>
</section>
<section id="other-changes-and-fixes">
<h2>Otros cambios y correcciones<a class="headerlink" href="#other-changes-and-fixes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Como es habitual, hubo un montón de otras mejoras y correcciones de errores repartidas por todo el árbol de fuentes.  Una búsqueda en los registros de cambios de CVS revela que se aplicaron 527 parches y se corrigieron 683 errores entre Python 2.1 y 2.2; en 2.2.1 se aplicaron 139 parches y se corrigieron 143 errores; en 2.2.2 se aplicaron 106 parches y se corrigieron 82 errores.  Es probable que estas cifras estén subestimadas.</p>
<p>Algunos de los cambios más notables son:</p>
<ul>
<li><p>El código del puerto MacOS para Python, mantenido por Jack Jansen, se mantiene ahora en el árbol CVS principal de Python, y se han realizado muchos cambios para soportar MacOS X.</p>
<p>El cambio más significativo es la capacidad de construir Python como un marco de trabajo, que se activa proporcionando la opción <code class="xref std std-option docutils literal notranslate"><span class="pre">--enable-framework</span></code> al script de configuración cuando se compila Python.  Según Jack Jansen, «Esto instala una instalación autónoma de Python más el «pegamento» del framework de OS X en <code class="file docutils literal notranslate"><span class="pre">/Library/Frameworks/Python.framework</span></code> (o en otra ubicación de su elección). Por ahora hay poco beneficio inmediato añadido a esto (en realidad, existe la desventaja de que tienes que cambiar tu PATH para poder encontrar Python), pero es la base para crear una aplicación Python completa, portar el IDE de MacPython, posiblemente usar Python como un lenguaje de scripting estándar de OSA y mucho más.»</p>
<p>La mayoría de los módulos de la caja de herramientas de MacPython, que interactúan con las APIs de MacOS como ventanas, QuickTime, scripts, etc. han sido portados a OS X, pero se han dejado comentados en <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code>.  Las personas que quieran experimentar con estos módulos pueden descomentarlos manualmente.</p>
</li>
<li><p>Los argumentos de palabras clave pasados a funciones incorporadas que no los aceptan ahora provocan una excepción <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>, con el mensaje «<em>function</em> no acepta argumentos de palabras clave».</p></li>
<li><p>Las referencias débiles, añadidas en Python 2.1 como un módulo de extensión, son ahora parte del núcleo porque se utilizan en la implementación de clases de nuevo estilo.  Por lo tanto, la excepción <a class="reference internal" href="../library/exceptions.html#ReferenceError" title="ReferenceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ReferenceError</span></code></a> se ha movido del módulo <a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weakref</span></code></a> para convertirse en una excepción incorporada.</p></li>
<li><p>Un nuevo script, <code class="file docutils literal notranslate"><span class="pre">Tools/scripts/cleanfuture.py</span></code> de Tim Peters, elimina automáticamente las sentencias <code class="docutils literal notranslate"><span class="pre">__future__</span></code> obsoletas del código fuente de Python.</p></li>
<li><p>Se ha añadido un argumento adicional <em>flags</em> a la función incorporada <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a>, por lo que el comportamiento de las sentencias <code class="docutils literal notranslate"><span class="pre">__future__</span></code> puede ahora observarse correctamente en shells simulados, como los presentados por IDLE y otros entornos de desarrollo.  Esto se describe en <span class="target" id="index-68"></span><a class="pep reference external" href="https://peps.python.org/pep-0264/"><strong>PEP 264</strong></a>. (Contribución de Michael Hudson)</p></li>
<li><p>La nueva licencia introducida con Python 1.6 no era compatible con la GPL.  Esto se ha solucionado con algunos cambios textuales menores en la licencia 2.2, de modo que ahora es legal volver a incrustar Python dentro de un programa con licencia GPL.  Tenga en cuenta que Python en sí mismo no es GPL, sino que está bajo una licencia que es esencialmente equivalente a la licencia BSD, igual que siempre.  Los cambios en la licencia también se aplicaron a las versiones 2.0.1 y 2.1.1 de Python.</p></li>
<li><p>Cuando se presenta un nombre de archivo Unicode en Windows, Python ahora lo convertirá en una cadena codificada en MBCS, como la que utilizan las APIs de archivos de Microsoft.  Como las APIs de archivos utilizan explícitamente MBCS, la elección de Python de ASCII como codificación por defecto resulta ser una molestia.  En Unix, se utiliza el juego de caracteres de la localización si <code class="docutils literal notranslate"><span class="pre">locale.nl_langinfo(CODESET)</span></code> está disponible.  (El soporte de Windows fue contribuido por Mark Hammond con la ayuda de Marc-André Lemburg. El soporte para Unix fue añadido por Martin von Löwis)</p></li>
<li><p>La compatibilidad con archivos de gran tamaño ya está activada en Windows.  (Contribución de Tim Peters.)</p></li>
<li><p>El script <code class="file docutils literal notranslate"><span class="pre">Tools/scripts/ftpmirror.py</span></code> ahora analiza un archivo <code class="file docutils literal notranslate"><span class="pre">.netrc</span></code>, si tiene uno. (Contribución de Mike Romberg)</p></li>
<li><p>Algunas características del objeto retornado por la función <code class="xref py py-func docutils literal notranslate"><span class="pre">xrange()</span></code> están ahora obsoletas, y provocan advertencias cuando se accede a ellas; desaparecerán en Python 2.3. Los objetos <code class="xref py py-class docutils literal notranslate"><span class="pre">xrange</span></code> intentaban fingir que eran tipos de secuencia completos soportando el troceado, la multiplicación de secuencias y el operador <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a>, pero estas características se utilizaban raramente y, por lo tanto, tenían errores.  El método <code class="xref py py-meth docutils literal notranslate"><span class="pre">tolist()</span></code> y los atributos <code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code> y <code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code> también han quedado obsoletos.  A nivel de C, el cuarto argumento de la función <code class="xref c c-func docutils literal notranslate"><span class="pre">PyRange_New()</span></code>, <code class="docutils literal notranslate"><span class="pre">repeat</span></code>, también ha quedado obsoleto.</p></li>
<li><p>Hubo un montón de parches para la implementación del diccionario, sobre todo para arreglar posibles vertidos del núcleo si un diccionario contiene objetos que cambian furtivamente su valor hash, o mutan el diccionario que contienen. Durante un tiempo python-dev cayó en un suave ritmo de Michael Hudson encontrando un caso que volcaba el núcleo, Tim Peters corrigiendo el error, Michael encontrando otro caso, y así sucesivamente.</p></li>
<li><p>En Windows, Python puede ahora compilarse con Borland C gracias a una serie de parches aportados por Stephen Hansen, aunque el resultado aún no es totalmente funcional.  (Pero esto <em>es</em> un progreso…)</p></li>
<li><p>Otra mejora de Windows: Wise Solutions ofreció generosamente a PythonLabs el uso de su sistema InstallerMaster 8.1.  Los anteriores instaladores de PythonLabs para Windows utilizaban Wise 5.0a, que estaba empezando a mostrar su edad.  (Empaquetado por Tim Peters)</p></li>
<li><p>Los archivos que terminan en <code class="docutils literal notranslate"><span class="pre">.pyw</span></code> pueden importarse ahora en Windows. <code class="docutils literal notranslate"><span class="pre">.pyw</span></code> es algo exclusivo de Windows, que se utiliza para indicar que un script debe ejecutarse utilizando PYTHONW.EXE en lugar de PYTHON.EXE para evitar que aparezca una consola DOS para mostrar la salida.  Este parche hace posible la importación de tales scripts, en caso de que también se puedan utilizar como módulos.  (Implementado por David Bolen)</p></li>
<li><p>En las plataformas en las que Python utiliza la función C <code class="xref c c-func docutils literal notranslate"><span class="pre">dlopen()</span></code> para cargar módulos de extensión, ahora es posible establecer las banderas utilizadas por <code class="xref c c-func docutils literal notranslate"><span class="pre">dlopen()</span></code> utilizando las funciones <a class="reference internal" href="../library/sys.html#sys.getdlopenflags" title="sys.getdlopenflags"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getdlopenflags()</span></code></a> y <a class="reference internal" href="../library/sys.html#sys.setdlopenflags" title="sys.setdlopenflags"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setdlopenflags()</span></code></a>. (Contribución de Bram Stolk.)</p></li>
<li><p>La función incorporada <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> ya no admite 3 argumentos cuando se suministran números de punto flotante. <code class="docutils literal notranslate"><span class="pre">pow(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code> retorna <code class="docutils literal notranslate"><span class="pre">(x**y)</span> <span class="pre">%</span> <span class="pre">z</span></code>, pero esto nunca es útil para números de punto flotante, y el resultado final varía de forma impredecible dependiendo de la plataforma.  Una llamada como <code class="docutils literal notranslate"><span class="pre">pow(2.0,</span> <span class="pre">8.0,</span> <span class="pre">7.0)</span></code> lanzará ahora una excepción <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p></li>
</ul>
</section>
<section id="acknowledgements">
<h2>Agradecimientos<a class="headerlink" href="#acknowledgements" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El autor desea agradecer a las siguientes personas sus sugerencias, correcciones y ayuda en varios borradores de este artículo: Fred Bremmer, Keith Briggs, Andrew Dalke, Fred L. Drake, Jr, Carel Fellinger, David Goodger, Mark Hammond, Stephen Hansen, Michael Hudson, Jack Jansen, Marc-André Lemburg, Martin von Löwis, Fredrik Lundh, Michael McLay, Nick Mathewson, Paul Moore, Gustavo Niemeyer, Don O’Donnell, Joonas Paalasma, Tim Peters, Jens Quade, Tom Reinhardt, Neil Schemenauer, Guido van Rossum, Greg Ward, Edward Welbourne.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">Qué hay de nuevo en Python 2.2</a><ul>
<li><a class="reference internal" href="#introduction">Introducción</a></li>
<li><a class="reference internal" href="#peps-252-and-253-type-and-class-changes">PEPs 252 y 253: Cambios de tipo y clase</a><ul>
<li><a class="reference internal" href="#old-and-new-classes">Clases antiguas y nuevas</a></li>
<li><a class="reference internal" href="#descriptors">Descriptores</a></li>
<li><a class="reference internal" href="#multiple-inheritance-the-diamond-rule">Herencia múltiple: la regla del diamante</a></li>
<li><a class="reference internal" href="#attribute-access">Acceso a atributos</a></li>
<li><a class="reference internal" href="#related-links">Enlaces relacionados</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-234-iterators">PEP 234: Iteradores</a></li>
<li><a class="reference internal" href="#pep-255-simple-generators">PEP 255: Generadores simples</a></li>
<li><a class="reference internal" href="#pep-237-unifying-long-integers-and-integers">PEP 237: Unificación de enteros largos y enteros</a></li>
<li><a class="reference internal" href="#pep-238-changing-the-division-operator">PEP 238: Cambio del operador de división</a></li>
<li><a class="reference internal" href="#unicode-changes">Cambios en Unicode</a></li>
<li><a class="reference internal" href="#pep-227-nested-scopes">PEP 227: Ámbitos anidados</a></li>
<li><a class="reference internal" href="#new-and-improved-modules">Módulos nuevos y mejorados</a></li>
<li><a class="reference internal" href="#interpreter-changes-and-fixes">Cambios y correcciones en el intérprete</a></li>
<li><a class="reference internal" href="#other-changes-and-fixes">Otros cambios y correcciones</a></li>
<li><a class="reference internal" href="#acknowledgements">Agradecimientos</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="2.3.html"
                          title="capítulo anterior">Qué hay de nuevo en Python 2.3</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="2.1.html"
                          title="próximo capítulo">Qué hay de nuevo en Python 2.1</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/whatsnew/2.2.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="2.1.html" title="Qué hay de nuevo en Python 2.1"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="2.3.html" title="Qué hay de nuevo en Python 2.3"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Qué hay de nuevo en Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Qué hay de nuevo en Python 2.2</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 23, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>