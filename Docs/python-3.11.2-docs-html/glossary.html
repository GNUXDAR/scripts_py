
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="Glosario" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/glossary.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content=">>>, El prompt en el shell interactivo de Python por omisión. Frecuentemente vistos en ejemplos de código que pueden ser ejecutados interactivamente en el intérprete.,,..., Puede referirse a:- El p..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content=">>>, El prompt en el shell interactivo de Python por omisión. Frecuentemente vistos en ejemplos de código que pueden ser ejecutados interactivamente en el intérprete.,,..., Puede referirse a:- El p..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>Glosario &#8212; documentación de Python - 3.11.2</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/pydoctheme.css?digest=2d3badd06fe70b34b68db01f99471ce1624ffe4a" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/translations.js"></script>
    
    <script src="_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.11.2"
          href="_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="about.html" />
    <link rel="index" title="Índice" href="genindex.html" />
    <link rel="search" title="Búsqueda" href="search.html" />
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="next" title="Acerca de estos documentos" href="about.html" />
    <link rel="prev" title="«¿Por qué está Python instalado en mi ordenador?» FAQ" href="faq/installed.html" />
    <link rel="canonical" href="https://docs.python.org/3/glossary.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="_static/py.svg" />
            <script type="text/javascript" src="_static/copybutton.js"></script>
            <script type="text/javascript" src="_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="faq/installed.html"
                          title="capítulo anterior">«¿Por qué está Python instalado en mi ordenador?» FAQ</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="about.html"
                          title="próximo capítulo">Acerca de estos documentos</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/glossary.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="about.html" title="Acerca de estos documentos"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="faq/installed.html" title="«¿Por qué está Python instalado en mi ordenador?» FAQ"
             accesskey="P">anterior</a> |</li>

          <li><img src="_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="index.html">3.11.2 Documentation</a> &#187;
    </li>

        <li class="nav-item nav-item-this"><a href="">Glosario</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="glossary">
<span id="id1"></span><h1>Glosario<a class="headerlink" href="#glossary" title="Enlazar permanentemente con este título">¶</a></h1>
<dl class="glossary">
<dt id="term-0"><code class="docutils literal notranslate"><span class="pre">&gt;&gt;&gt;</span></code><a class="headerlink" href="#term-0" title="Permalink to this term">¶</a></dt><dd><p>El prompt en el shell interactivo de Python por omisión. Frecuentemente vistos en ejemplos de código que pueden ser ejecutados interactivamente en el intérprete.</p>
</dd>
<dt id="term-..."><code class="docutils literal notranslate"><span class="pre">...</span></code><a class="headerlink" href="#term-..." title="Permalink to this term">¶</a></dt><dd><p>Puede referirse a:</p>
<ul class="simple">
<li><p>El prompt en el shell interactivo de Python por omisión cuando se ingresa código para un bloque indentado de código, y cuando se encuentra entre dos delimitadores que emparejan (paréntesis, corchetes, llaves o comillas triples), o después de especificar un decorador.</p></li>
<li><p>La constante incorporada <a class="reference internal" href="library/constants.html#Ellipsis" title="Ellipsis"><code class="xref py py-const docutils literal notranslate"><span class="pre">Ellipsis</span></code></a>.</p></li>
</ul>
</dd>
<dt id="term-2to3">2to3<a class="headerlink" href="#term-2to3" title="Permalink to this term">¶</a></dt><dd><p>Una herramienta que intenta convertir código de Python 2.x a Python 3.x arreglando la mayoría de las incompatibilidades que pueden ser detectadas analizando el código y recorriendo el árbol de análisis sintáctico.</p>
<p>2to3 está disponible en la biblioteca estándar como <a class="reference internal" href="library/2to3.html#module-lib2to3" title="lib2to3: The 2to3 library"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lib2to3</span></code></a>; un punto de entrada independiente es provisto como <code class="file docutils literal notranslate"><span class="pre">Tools/scripts/2to3</span></code>.  Vea <a class="reference internal" href="library/2to3.html#to3-reference"><span class="std std-ref">2to3 — Traducción automática de código de Python 2 a 3</span></a>.</p>
</dd>
<dt id="term-abstract-base-class">clase base abstracta<a class="headerlink" href="#term-abstract-base-class" title="Permalink to this term">¶</a></dt><dd><p>Las clases base abstractas (ABC, por sus siglas en inglés <cite>Abstract Base Class</cite>) complementan al <a class="reference internal" href="#term-duck-typing"><span class="xref std std-term">duck-typing</span></a> brindando un forma de definir interfaces con técnicas como <a class="reference internal" href="library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> que serían confusas o sutilmente erróneas (por ejemplo con <a class="reference internal" href="reference/datamodel.html#special-lookup"><span class="std std-ref">magic methods</span></a>). Las ABC introduce subclases virtuales, las cuales son clases que no heredan desde una clase pero aún así son reconocidas por <a class="reference internal" href="library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> y <a class="reference internal" href="library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>; vea la documentación del módulo <a class="reference internal" href="library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a>. Python viene con muchas ABC incorporadas para las estructuras de datos( en el módulo <a class="reference internal" href="library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a>), números (en el módulo <a class="reference internal" href="library/numbers.html#module-numbers" title="numbers: Numeric abstract base classes (Complex, Real, Integral, etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">numbers</span></code></a> ) , flujos de datos (en el módulo <a class="reference internal" href="library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> ) , buscadores y cargadores de importaciones (en el módulo <a class="reference internal" href="library/importlib.html#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> ) . Puede crear sus propios ABCs con el módulo <a class="reference internal" href="library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a>.</p>
</dd>
<dt id="term-annotation">anotación<a class="headerlink" href="#term-annotation" title="Permalink to this term">¶</a></dt><dd><p>Una etiqueta asociada a una variable, atributo de clase, parámetro de función o valor de retorno, usado por convención como un <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">type hint</span></a>.</p>
<p>Las anotaciones de variables no pueden ser accedidas en tiempo de ejecución, pero las anotaciones de variables globales, atributos de clase, y funciones son almacenadas en el atributo especial <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> de módulos, clases y funciones, respectivamente.</p>
<p>Consulte <a class="reference internal" href="#term-variable-annotation"><span class="xref std std-term">variable annotation</span></a>, <a class="reference internal" href="#term-function-annotation"><span class="xref std std-term">function annotation</span></a>, <span class="target" id="index-74"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> y <span class="target" id="index-75"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a>, que describen esta funcionalidad. Consulte también <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">Prácticas recomendadas para las anotaciones</span></a> para conocer las mejores prácticas sobre cómo trabajar con anotaciones.</p>
</dd>
<dt id="term-argument">argumento<a class="headerlink" href="#term-argument" title="Permalink to this term">¶</a></dt><dd><p>Un valor pasado a una <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a> (o <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a>) cuando se llama a la función. Hay dos clases de argumentos:</p>
<ul>
<li><p><em class="dfn">argumento nombrado</em>: es un argumento precedido por un identificador (por ejemplo, <code class="docutils literal notranslate"><span class="pre">nombre=</span></code>) en una llamada a una función o pasado como valor en un diccionario precedido por <code class="docutils literal notranslate"><span class="pre">**</span></code>. Por ejemplo <code class="docutils literal notranslate"><span class="pre">3</span></code> y <code class="docutils literal notranslate"><span class="pre">5</span></code> son argumentos nombrados en las llamadas a <a class="reference internal" href="library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">complex</span><span class="p">(</span><span class="n">real</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">imag</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">complex</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;real&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;imag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
</pre></div>
</div>
</li>
<li><p><em class="dfn">argumento posicional</em> son aquellos que no son nombrados. Los argumentos posicionales deben aparecer al principio de una lista de argumentos o ser pasados como elementos de un <a class="reference internal" href="#term-iterable"><span class="xref std std-term">iterable</span></a> precedido por <code class="docutils literal notranslate"><span class="pre">*</span></code>. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">3</span></code> y <code class="docutils literal notranslate"><span class="pre">5</span></code> son argumentos posicionales en las siguientes llamadas:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">complex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="nb">complex</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ul>
<p>Los argumentos son asignados a las variables locales en el cuerpo de la función. Vea en la sección <a class="reference internal" href="reference/expressions.html#calls"><span class="std std-ref">Invocaciones</span></a> las reglas que rigen estas asignaciones. Sintácticamente, cualquier expresión puede ser usada para representar un argumento; el valor evaluado es asignado a la variable local.</p>
<p>Vea también el <a class="reference internal" href="#term-parameter"><span class="xref std std-term">parameter</span></a> en el glosario, la pregunta frecuente <a class="reference internal" href="faq/programming.html#faq-argument-vs-parameter"><span class="std std-ref">la diferencia entre argumentos y parámetros</span></a>, y <span class="target" id="index-76"></span><a class="pep reference external" href="https://peps.python.org/pep-0362/"><strong>PEP 362</strong></a>.</p>
</dd>
<dt id="term-asynchronous-context-manager">administrador asincrónico de contexto<a class="headerlink" href="#term-asynchronous-context-manager" title="Permalink to this term">¶</a></dt><dd><p>Un objeto que controla el entorno visible en un sentencia <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> al definir los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__aenter__()</span></code> <code class="xref py py-meth docutils literal notranslate"><span class="pre">__aexit__()</span></code>.   Introducido por <span class="target" id="index-77"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-asynchronous-generator">generador asincrónico<a class="headerlink" href="#term-asynchronous-generator" title="Permalink to this term">¶</a></dt><dd><p>Una función que retorna un <a class="reference internal" href="#term-asynchronous-generator-iterator"><span class="xref std std-term">asynchronous generator iterator</span></a>. Es similar a una función corrutina definida con <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> excepto que contiene expresiones <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> para producir series de variables usadas en un ciclo <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>.</p>
<p>Usualmente se refiere a una función generadora asincrónica, pero puede referirse a un <em>iterador generador asincrónico</em> en ciertos contextos. En aquellos casos en los que el significado no está claro, usar los términos completos evita la ambigüedad.</p>
<p>Una función generadora asincrónica puede contener expresiones <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> así como sentencias <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>, y <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a>.</p>
</dd>
<dt id="term-asynchronous-generator-iterator">iterador generador asincrónico<a class="headerlink" href="#term-asynchronous-generator-iterator" title="Permalink to this term">¶</a></dt><dd><p>Un objeto creado por una función <a class="reference internal" href="#term-asynchronous-generator"><span class="xref std std-term">asynchronous generator</span></a>.</p>
<p>Este es un <a class="reference internal" href="#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> el cual cuando es llamado usa el método  <code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code> retornando un objeto a la espera (<em>awaitable</em>) el cual ejecutará el cuerpo de la función generadora asincrónica hasta la siguiente expresión <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>.</p>
<p>Cada <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> suspende temporalmente el procesamiento, recordando el estado local de ejecución (incluyendo a las variables locales y las sentencias <cite>try</cite> pendientes). Cuando el <em>iterador del generador asincrónico</em> vuelve efectivamente con otro objeto a la espera (<em>awaitable</em>) retornado por el método  <code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code>, retoma donde lo dejó. Vea <span class="target" id="index-78"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> y <span class="target" id="index-79"></span><a class="pep reference external" href="https://peps.python.org/pep-0525/"><strong>PEP 525</strong></a>.</p>
</dd>
<dt id="term-asynchronous-iterable">iterable asincrónico<a class="headerlink" href="#term-asynchronous-iterable" title="Permalink to this term">¶</a></dt><dd><p>Un objeto, que puede ser usado en una sentencia <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>. Debe retornar un <a class="reference internal" href="#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> de su método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code>. Introducido por <span class="target" id="index-80"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-asynchronous-iterator">iterador asincrónico<a class="headerlink" href="#term-asynchronous-iterator" title="Permalink to this term">¶</a></dt><dd><p>Un objeto que implementa los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code>. <code class="docutils literal notranslate"><span class="pre">__anext__</span></code> debe retornar un objeto <a class="reference internal" href="#term-awaitable"><span class="xref std std-term">awaitable</span></a>. <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> resuelve los esperables retornados por un método de iterador asincrónico <code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code> hasta que lanza una excepción <a class="reference internal" href="library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a>. Introducido por <span class="target" id="index-81"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-attribute">atributo<a class="headerlink" href="#term-attribute" title="Permalink to this term">¶</a></dt><dd><p>A value associated with an object which is usually referenced by name
using dotted expressions.
For example, if an object <em>o</em> has an attribute
<em>a</em> it would be referenced as <em>o.a</em>.</p>
<p>It is possible to give an object an attribute whose name is not an
identifier as defined by <a class="reference internal" href="reference/lexical_analysis.html#identifiers"><span class="std std-ref">Identificadores y palabras clave</span></a>, for example using
<a class="reference internal" href="library/functions.html#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a>, if the object allows it.
Such an attribute will not be accessible using a dotted expression,
and would instead need to be retrieved with <a class="reference internal" href="library/functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a>.</p>
</dd>
<dt id="term-awaitable">a la espera<a class="headerlink" href="#term-awaitable" title="Permalink to this term">¶</a></dt><dd><p>Es un objeto a la espera (<em>awaitable</em>) que puede ser usado en una expresión <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>. Puede ser una <a class="reference internal" href="#term-coroutine"><span class="xref std std-term">coroutine</span></a> o un objeto con un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code>. Vea también <span class="target" id="index-82"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-BDFL">BDFL<a class="headerlink" href="#term-BDFL" title="Permalink to this term">¶</a></dt><dd><p>Sigla de <em>Benevolent Dictator For Life</em>, benevolente dictador vitalicio, es decir <a class="reference external" href="https://gvanrossum.github.io/">Guido van Rossum</a>, el creador de Python.</p>
</dd>
<dt id="term-binary-file">archivo binario<a class="headerlink" href="#term-binary-file" title="Permalink to this term">¶</a></dt><dd><p>Un <a class="reference internal" href="#term-file-object"><span class="xref std std-term">file object</span></a> capaz de leer y escribir <a class="reference internal" href="#term-bytes-like-object"><span class="xref std std-term">objetos tipo binarios</span></a>. Ejemplos de archivos binarios son los abiertos en modo binario (<code class="docutils literal notranslate"><span class="pre">'rb'</span></code>, <code class="docutils literal notranslate"><span class="pre">'wb'</span></code> o <code class="docutils literal notranslate"><span class="pre">'rb+'</span></code>), <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin.buffer</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout.buffer</span></code>, e instancias de <a class="reference internal" href="library/io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BytesIO</span></code></a> y de <a class="reference internal" href="library/gzip.html#gzip.GzipFile" title="gzip.GzipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">gzip.GzipFile</span></code></a>.</p>
<p>Vea también <a class="reference internal" href="#term-text-file"><span class="xref std std-term">text file</span></a> para un objeto archivo capaz de leer y escribir objetos <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p>
</dd>
<dt id="term-borrowed-reference">referencia prestada<a class="headerlink" href="#term-borrowed-reference" title="Permalink to this term">¶</a></dt><dd><p>En la API C de Python, una referencia prestada es una referencia a un objeto. No modifica el recuento de referencias de objetos. Se convierte en un puntero colgante si se destruye el objeto. Por ejemplo, una recolección de basura puede eliminar el último <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">strong reference</span></a> del objeto y así destruirlo.</p>
<p>Se recomienda llamar a <a class="reference internal" href="c-api/refcounting.html#c.Py_INCREF" title="Py_INCREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_INCREF()</span></code></a> en la <a class="reference internal" href="#term-borrowed-reference"><span class="xref std std-term">referencia prestada</span></a> para convertirla en una <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">referencia fuerte</span></a> in situ, excepto cuando el objeto no se puede destruir antes del último uso de la referencia prestada. La función <a class="reference internal" href="c-api/refcounting.html#c.Py_NewRef" title="Py_NewRef"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewRef()</span></code></a> se puede utilizar para crear una nueva <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">referencia fuerte</span></a>.</p>
</dd>
<dt id="term-bytes-like-object">objetos tipo binarios<a class="headerlink" href="#term-bytes-like-object" title="Permalink to this term">¶</a></dt><dd><p>Un objeto que soporta <a class="reference internal" href="c-api/buffer.html#bufferobjects"><span class="std std-ref">Protocolo búfer</span></a>  y puede exportar un búfer C-<a class="reference internal" href="#term-contiguous"><span class="xref std std-term">contiguous</span></a>. Esto incluye todas los objetos <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>, y <a class="reference internal" href="library/array.html#array.array" title="array.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">array.array</span></code></a>, así como muchos objetos comunes <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>. Los objetos tipo binarios pueden ser usados para varias operaciones que usan datos binarios; éstas incluyen compresión, salvar a archivos binarios, y enviarlos a través de un socket.</p>
<p>Algunas operaciones necesitan que los datos binarios sean mutables. La documentación frecuentemente se refiere a éstos como «objetos tipo binario de lectura y escritura». Ejemplos de objetos de búfer mutables incluyen a <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> y <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> de la <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>. Otras operaciones que requieren datos binarios almacenados en objetos inmutables («objetos tipo binario de sólo lectura»); ejemplos de éstos incluyen <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> y <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> del objeto <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
</dd>
<dt id="term-bytecode">bytecode<a class="headerlink" href="#term-bytecode" title="Permalink to this term">¶</a></dt><dd><p>El código fuente Python es compilado en <em>bytecode</em>, la representación interna de un programa python en el intérprete CPython. El <em>bytecode</em> también es guardado en caché en los archivos <cite>.pyc</cite> de tal forma que ejecutar el mismo archivo es más fácil la segunda vez (la recompilación desde el código fuente a <em>bytecode</em> puede ser evitada). Este «lenguaje intermedio» deberá corren en una <a class="reference internal" href="#term-virtual-machine"><span class="xref std std-term">virtual machine</span></a> que ejecute el código de máquina correspondiente a cada <em>bytecode</em>. Note que los <em>bytecodes</em> no tienen como requisito trabajar en las diversas máquina virtuales de Python, ni de ser estable entre versiones Python.</p>
<p>Una lista de las instrucciones en <em>bytecode</em> está disponible en la documentación de <a class="reference internal" href="library/dis.html#bytecodes"><span class="std std-ref">el módulo dis</span></a>.</p>
</dd>
<dt id="term-callable">callable<a class="headerlink" href="#term-callable" title="Permalink to this term">¶</a></dt><dd><p>A callable is an object that can be called, possibly with a set
of arguments (see <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>), with the following syntax:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">callable</span><span class="p">(</span><span class="n">argument1</span><span class="p">,</span> <span class="n">argument2</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>A <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a>, and by extension a <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a>, is a callable.
An instance of a class that implements the <a class="reference internal" href="reference/datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a>
method is also a callable.</p>
</dd>
<dt id="term-callback">retrollamada<a class="headerlink" href="#term-callback" title="Permalink to this term">¶</a></dt><dd><p>Una función de subrutina que se pasa como un argumento para ejecutarse en algún momento en el futuro.</p>
</dd>
<dt id="term-class">clase<a class="headerlink" href="#term-class" title="Permalink to this term">¶</a></dt><dd><p>Una plantilla para crear objetos definidos por el usuario. Las definiciones de clase normalmente contienen definiciones de métodos que operan una instancia de la clase.</p>
</dd>
<dt id="term-class-variable">variable de clase<a class="headerlink" href="#term-class-variable" title="Permalink to this term">¶</a></dt><dd><p>Una variable definida en una clase y prevista para ser modificada sólo a nivel de clase (es decir, no en una instancia de la clase).</p>
</dd>
<dt id="term-complex-number">número complejo<a class="headerlink" href="#term-complex-number" title="Permalink to this term">¶</a></dt><dd><p>Una extensión del sistema familiar de número reales en el cual los números son expresados como la suma de una parte real y una parte imaginaria.  Los números imaginarios son múltiplos de la unidad imaginaria (la raíz cuadrada de <code class="docutils literal notranslate"><span class="pre">-1</span></code>), usualmente escrita como <code class="docutils literal notranslate"><span class="pre">i</span></code> en matemáticas o <code class="docutils literal notranslate"><span class="pre">j</span></code> en ingeniería.  Python tiene soporte incorporado para números complejos, los cuales son escritos con la notación mencionada al final.; la parte imaginaria es escrita con un sufijo <code class="docutils literal notranslate"><span class="pre">j</span></code>, por ejemplo, <code class="docutils literal notranslate"><span class="pre">3+1j</span></code>.  Para tener acceso a los equivalentes complejos del módulo <a class="reference internal" href="library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> module, use <a class="reference internal" href="library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code></a>.  El uso de números complejos es matemática bastante avanzada.  Si no le parecen necesarios, puede ignorarlos sin inconvenientes.</p>
</dd>
<dt id="term-context-manager">administrador de contextos<a class="headerlink" href="#term-context-manager" title="Permalink to this term">¶</a></dt><dd><p>Un objeto que controla el entorno en la sentencia <a class="reference internal" href="reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> definiendo los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code>. Vea <span class="target" id="index-83"></span><a class="pep reference external" href="https://peps.python.org/pep-0343/"><strong>PEP 343</strong></a>.</p>
</dd>
<dt id="term-context-variable">variable de contexto<a class="headerlink" href="#term-context-variable" title="Permalink to this term">¶</a></dt><dd><p>Una variable que puede tener diferentes valores dependiendo del contexto. Esto es similar a un almacenamiento de hilo local <em>Thread-Local Storage</em> en el cual cada hilo de ejecución puede tener valores diferentes para una variable. Sin embargo, con las variables de contexto, podría haber varios contextos en un hilo de ejecución y el uso principal de las variables de contexto es mantener registro de las variables en tareas concurrentes asíncronas. Vea <a class="reference internal" href="library/contextvars.html#module-contextvars" title="contextvars: Context Variables"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a>.</p>
</dd>
<dt id="term-contiguous">contiguo<a class="headerlink" href="#term-contiguous" title="Permalink to this term">¶</a></dt><dd><p id="index-10">Un búfer es considerado contiguo con precisión si es <em>C-contiguo</em> o <em>Fortran contiguo</em>. Los búferes cero dimensionales con C y Fortran contiguos. En los arreglos unidimensionales, los ítems deben ser dispuestos en memoria uno siguiente al otro, ordenados por índices que comienzan en cero. En arreglos unidimensionales C-contiguos, el último índice varía más velozmente en el orden de las direcciones de memoria. Sin embargo, en arreglos Fortran contiguos, el primer índice vería más rápidamente.</p>
</dd>
<dt id="term-coroutine">corrutina<a class="headerlink" href="#term-coroutine" title="Permalink to this term">¶</a></dt><dd><p>Las corrutinas son una forma más generalizadas de las subrutinas. A las subrutinas se ingresa por un punto y se sale por otro punto. Las corrutinas pueden se iniciadas, finalizadas y reanudadas en muchos puntos diferentes. Pueden ser implementadas con la sentencia <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a>. Vea además <span class="target" id="index-84"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-coroutine-function">función corrutina<a class="headerlink" href="#term-coroutine-function" title="Permalink to this term">¶</a></dt><dd><p>Un función que retorna un objeto  <a class="reference internal" href="#term-coroutine"><span class="xref std std-term">coroutine</span></a> . Una función corrutina puede ser definida con la sentencia <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a>, y puede contener las palabras claves <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>, <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>, y <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a>. Las mismas son introducidas en <span class="target" id="index-85"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt id="term-CPython">CPython<a class="headerlink" href="#term-CPython" title="Permalink to this term">¶</a></dt><dd><p>La implementación canónica del lenguaje de programación Python, como se distribuye en <a class="reference external" href="https://www.python.org">python.org</a>. El término «CPython» es usado cuando es necesario distinguir esta implementación de otras como <em>Jython</em> o <em>IronPython</em>.</p>
</dd>
<dt id="term-decorator">decorador<a class="headerlink" href="#term-decorator" title="Permalink to this term">¶</a></dt><dd><p>Una función que retorna otra función, usualmente aplicada como una función de transformación empleando la sintaxis <code class="docutils literal notranslate"><span class="pre">&#64;envoltorio</span></code>. Ejemplos comunes de decoradores son  <a class="reference internal" href="library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> y <a class="reference internal" href="library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a>.</p>
<p>La sintaxis del decorador es meramente azúcar sintáctico, las definiciones de las siguientes dos funciones son semánticamente equivalentes:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>El mismo concepto existe para clases, pero son menos usadas. Vea la documentación de <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">function definitions</span></a> y <a class="reference internal" href="reference/compound_stmts.html#class"><span class="std std-ref">class definitions</span></a> para mayor detalle sobre decoradores.</p>
</dd>
<dt id="term-descriptor">descriptor<a class="headerlink" href="#term-descriptor" title="Permalink to this term">¶</a></dt><dd><p>Cualquier objeto que define los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code>, o <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code>.   Cuando un atributo de clase es un descriptor, su conducta enlazada especial es disparada durante la búsqueda del atributo. Normalmente, usando <em>a.b</em> para consultar, establecer o borrar un atributo busca el objeto llamado <em>b</em> en el diccionario de clase de <em>a</em>, pero si <em>b</em> es un descriptor, el respectivo método descriptor es llamado.  Entender descriptores es clave para lograr una comprensión profunda de Python porque son la base de muchas de las capacidades incluyendo funciones, métodos, propiedades, métodos de clase, métodos estáticos, y referencia a súper clases.</p>
<p>Para obtener más información sobre los métodos de los descriptores, consulte <a class="reference internal" href="reference/datamodel.html#descriptors"><span class="std std-ref">Implementando descriptores</span></a> o <a class="reference internal" href="howto/descriptor.html#descriptorhowto"><span class="std std-ref">Guía práctica de uso de los descriptores</span></a>.</p>
</dd>
<dt id="term-dictionary">diccionario<a class="headerlink" href="#term-dictionary" title="Permalink to this term">¶</a></dt><dd><p>Un arreglo asociativo, con claves arbitrarias que son asociadas a valores. Las claves pueden ser cualquier objeto con los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code> . Son llamadas hash en Perl.</p>
</dd>
<dt id="term-dictionary-comprehension">comprensión de diccionarios<a class="headerlink" href="#term-dictionary-comprehension" title="Permalink to this term">¶</a></dt><dd><p>Una forma compacta de procesar todos o parte de los elementos en un iterable y retornar un diccionario con los resultados. <code class="docutils literal notranslate"><span class="pre">results</span> <span class="pre">=</span> <span class="pre">{n:</span> <span class="pre">n</span> <span class="pre">**</span> <span class="pre">2</span> <span class="pre">for</span> <span class="pre">n</span> <span class="pre">in</span> <span class="pre">range(10)}</span></code> genera un diccionario que contiene la clave <code class="docutils literal notranslate"><span class="pre">n</span></code> asignada al valor <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">**</span> <span class="pre">2</span></code>. Ver <a class="reference internal" href="reference/expressions.html#comprehensions"><span class="std std-ref">Despliegues para listas, conjuntos y diccionarios</span></a>.</p>
</dd>
<dt id="term-dictionary-view">vista de diccionario<a class="headerlink" href="#term-dictionary-view" title="Permalink to this term">¶</a></dt><dd><p>Los objetos retornados por los métodos  <a class="reference internal" href="library/stdtypes.html#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.keys()</span></code></a>, <a class="reference internal" href="library/stdtypes.html#dict.values" title="dict.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.values()</span></code></a>, y <a class="reference internal" href="library/stdtypes.html#dict.items" title="dict.items"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.items()</span></code></a> son llamados vistas de diccionarios. Proveen una vista dinámica de las entradas de un diccionario, lo que significa que cuando el diccionario cambia, la vista refleja éstos cambios. Para forzar a la vista de diccionario a convertirse en una lista completa, use <code class="docutils literal notranslate"><span class="pre">list(dictview)</span></code>.  Vea <a class="reference internal" href="library/stdtypes.html#dict-views"><span class="std std-ref">Objetos tipos vista de diccionario</span></a>.</p>
</dd>
<dt id="term-docstring">docstring<a class="headerlink" href="#term-docstring" title="Permalink to this term">¶</a></dt><dd><p>Una cadena de caracteres literal que aparece como la primera expresión en una clase, función o módulo. Aunque es ignorada cuando se ejecuta, es reconocida por el compilador y puesta en el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> de la clase, función o módulo comprendida.  Como está disponible mediante introspección, es el lugar canónico para ubicar la documentación del objeto.</p>
</dd>
<dt id="term-duck-typing">tipado de pato<a class="headerlink" href="#term-duck-typing" title="Permalink to this term">¶</a></dt><dd><p>Un estilo de programación que no revisa el tipo del objeto para determinar si tiene la interfaz correcta; en vez de ello, el método o atributo es simplemente llamado o usado («Si se ve como un pato y grazna como un pato, debe ser un pato»).  Enfatizando las interfaces en vez de hacerlo con los tipos específicos, un código bien diseñado pues tener mayor flexibilidad permitiendo la sustitución polimórfica.  El tipado de pato <em>duck-typing</em> evita usar pruebas llamando a <a class="reference internal" href="library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> o <a class="reference internal" href="library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a>.  (Nota: si embargo, el tipado de pato puede ser complementado con <a class="reference internal" href="#term-abstract-base-class"><span class="xref std std-term">abstract base classes</span></a>. En su lugar, generalmente pregunta con <a class="reference internal" href="library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> o <a class="reference internal" href="#term-EAFP"><span class="xref std std-term">EAFP</span></a>.</p>
</dd>
<dt id="term-EAFP">EAFP<a class="headerlink" href="#term-EAFP" title="Permalink to this term">¶</a></dt><dd><p>Del inglés <em>Easier to ask for forgiveness than permission</em>, es más fácil pedir perdón que pedir permiso.  Este estilo de codificación común en Python asume la existencia de claves o atributos válidos y atrapa las excepciones si esta suposición resulta falsa.  Este estilo rápido y limpio está caracterizado por muchas sentencias <a class="reference internal" href="reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> y <a class="reference internal" href="reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a>.  Esta técnica contrasta con estilo <a class="reference internal" href="#term-LBYL"><span class="xref std std-term">LBYL</span></a> usual en otros lenguajes como C.</p>
</dd>
<dt id="term-expression">expresión<a class="headerlink" href="#term-expression" title="Permalink to this term">¶</a></dt><dd><p>Una construcción sintáctica que puede ser evaluada, hasta dar un valor.  En otras palabras, una expresión es una acumulación de elementos de expresión tales como literales, nombres, accesos a atributos, operadores o llamadas a funciones, todos ellos retornando valor.  A diferencia de otros lenguajes, no toda la sintaxis del lenguaje son expresiones. También hay <a class="reference internal" href="#term-statement"><span class="xref std std-term">statement</span></a>s que no pueden ser usadas como expresiones, como la <a class="reference internal" href="reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a>.  Las asignaciones también son sentencias, no expresiones.</p>
</dd>
<dt id="term-extension-module">módulo de extensión<a class="headerlink" href="#term-extension-module" title="Permalink to this term">¶</a></dt><dd><p>Un módulo escrito en C o C++, usando la API para C de Python para interactuar con el núcleo y el código del usuario.</p>
</dd>
<dt id="term-f-string">f-string<a class="headerlink" href="#term-f-string" title="Permalink to this term">¶</a></dt><dd><p>Son llamadas <em>f-strings</em> las cadenas literales que usan el prefijo <code class="docutils literal notranslate"><span class="pre">'f'</span></code> o <code class="docutils literal notranslate"><span class="pre">'F'</span></code>, que es una abreviatura para  <a class="reference internal" href="reference/lexical_analysis.html#f-strings"><span class="std std-ref">formatted string literals</span></a>.  Vea también <span class="target" id="index-86"></span><a class="pep reference external" href="https://peps.python.org/pep-0498/"><strong>PEP 498</strong></a>.</p>
</dd>
<dt id="term-file-object">objeto archivo<a class="headerlink" href="#term-file-object" title="Permalink to this term">¶</a></dt><dd><p>Un objeto que expone una API orientada a archivos (con métodos como <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> o <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code>) al objeto subyacente.  Dependiendo de la forma en la que fue creado, un objeto archivo, puede mediar el acceso a un archivo real en el disco u otro tipo de dispositivo de almacenamiento o de comunicación (por ejemplo, entrada/salida estándar, búfer de memoria, sockets, pipes, etc.).  Los objetos archivo son también denominados <em class="dfn">objetos tipo archivo</em> o <em class="dfn">flujos</em>.</p>
<p>Existen tres categorías de objetos archivo: crudos <em>raw</em> <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">archivos binarios</span></a>, con búfer <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">archivos binarios</span></a> y <a class="reference internal" href="#term-text-file"><span class="xref std std-term">archivos de texto</span></a>.  Sus interfaces son definidas en el módulo <a class="reference internal" href="library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a>.  La forma canónica de crear objetos archivo es usando la función <a class="reference internal" href="library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>.</p>
</dd>
<dt id="term-file-like-object">objetos tipo archivo<a class="headerlink" href="#term-file-like-object" title="Permalink to this term">¶</a></dt><dd><p>Un sinónimo de <a class="reference internal" href="#term-file-object"><span class="xref std std-term">file object</span></a>.</p>
</dd>
<dt id="term-filesystem-encoding-and-error-handler">codificación del sistema de archivos y manejador de errores<a class="headerlink" href="#term-filesystem-encoding-and-error-handler" title="Permalink to this term">¶</a></dt><dd><p>Controlador de errores y codificación utilizado por Python para decodificar bytes del sistema operativo y codificar Unicode en el sistema operativo.</p>
<p>La codificación del sistema de archivos debe garantizar la decodificación exitosa de todos los bytes por debajo de 128. Si la codificación del sistema de archivos no proporciona esta garantía, las funciones de API pueden lanzar <a class="reference internal" href="library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>.</p>
<p>Las funciones <a class="reference internal" href="library/sys.html#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencoding()</span></code></a> y <a class="reference internal" href="library/sys.html#sys.getfilesystemencodeerrors" title="sys.getfilesystemencodeerrors"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencodeerrors()</span></code></a> se pueden utilizar para obtener la codificación del sistema de archivos y el controlador de errores.</p>
<p>La <a class="reference internal" href="#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">codificación del sistema de archivos y el manejador de errores</span></a> se configuran al inicio de Python mediante la función <code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_Read()</span></code>: consulte los miembros <a class="reference internal" href="c-api/init_config.html#c.PyConfig.filesystem_encoding" title="PyConfig.filesystem_encoding"><code class="xref c c-member docutils literal notranslate"><span class="pre">filesystem_encoding</span></code></a> y <a class="reference internal" href="c-api/init_config.html#c.PyConfig.filesystem_errors" title="PyConfig.filesystem_errors"><code class="xref c c-member docutils literal notranslate"><span class="pre">filesystem_errors</span></code></a> de <a class="reference internal" href="c-api/init_config.html#c.PyConfig" title="PyConfig"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyConfig</span></code></a>.</p>
<p>See also the <a class="reference internal" href="#term-locale-encoding"><span class="xref std std-term">locale encoding</span></a>.</p>
</dd>
<dt id="term-finder">buscador<a class="headerlink" href="#term-finder" title="Permalink to this term">¶</a></dt><dd><p>Un objeto que trata de encontrar el <a class="reference internal" href="#term-loader"><span class="xref std std-term">loader</span></a> para el módulo que está siendo importado.</p>
<p>Desde la versión 3.3 de Python, existen dos tipos de buscadores: <a class="reference internal" href="#term-meta-path-finder"><span class="xref std std-term">meta buscadores de ruta</span></a> para usar con <a class="reference internal" href="library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>, y <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">buscadores de entradas de rutas</span></a> para usar con  <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>.</p>
<p>Vea <span class="target" id="index-87"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a>, <span class="target" id="index-88"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> y <span class="target" id="index-89"></span><a class="pep reference external" href="https://peps.python.org/pep-0451/"><strong>PEP 451</strong></a> para mayores detalles.</p>
</dd>
<dt id="term-floor-division">división entera<a class="headerlink" href="#term-floor-division" title="Permalink to this term">¶</a></dt><dd><p>Una división matemática que se redondea hacia el entero menor más cercano.  El operador de la división entera es <code class="docutils literal notranslate"><span class="pre">//</span></code>.  Por ejemplo, la expresión <code class="docutils literal notranslate"><span class="pre">11</span> <span class="pre">//</span> <span class="pre">4</span></code> evalúa <code class="docutils literal notranslate"><span class="pre">2</span></code> a diferencia del <code class="docutils literal notranslate"><span class="pre">2.75</span></code> retornado por la verdadera división de números flotantes.  Note que <code class="docutils literal notranslate"><span class="pre">(-11)</span> <span class="pre">//</span> <span class="pre">4</span></code> es <code class="docutils literal notranslate"><span class="pre">-3</span></code> porque es <code class="docutils literal notranslate"><span class="pre">-2.75</span></code> redondeado <em>para abajo</em>. Ver <span class="target" id="index-90"></span><a class="pep reference external" href="https://peps.python.org/pep-0238/"><strong>PEP 238</strong></a>.</p>
</dd>
<dt id="term-function">función<a class="headerlink" href="#term-function" title="Permalink to this term">¶</a></dt><dd><p>Una serie de sentencias que retornan un valor al que las llama.  También se le puede pasar cero o más <a class="reference internal" href="#term-argument"><span class="xref std std-term">argumentos</span></a> los cuales pueden ser usados en la ejecución de la misma. Vea también <a class="reference internal" href="#term-parameter"><span class="xref std std-term">parameter</span></a>, <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a>, y la sección <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">Definiciones de funciones</span></a>.</p>
</dd>
<dt id="term-function-annotation">anotación de función<a class="headerlink" href="#term-function-annotation" title="Permalink to this term">¶</a></dt><dd><p>Una <a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotation</span></a> del parámetro de una función o un valor de retorno.</p>
<p>Las anotaciones de funciones son usadas frecuentemente para <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">indicadores de tipo</span></a>, por ejemplo, se espera que una función tome dos argumentos de clase <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>  y también se espera que retorne dos valores <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sum_two_numbers</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
   <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>La sintaxis de las anotaciones de funciones son explicadas en la sección <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">Definiciones de funciones</span></a>.</p>
<p>Consulte <a class="reference internal" href="#term-variable-annotation"><span class="xref std std-term">variable annotation</span></a> y <span class="target" id="index-91"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>, que describen esta funcionalidad. Consulte también <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">Prácticas recomendadas para las anotaciones</span></a> para conocer las mejores prácticas sobre cómo trabajar con anotaciones.</p>
</dd>
<dt id="term-__future__">__future__<a class="headerlink" href="#term-__future__" title="Permalink to this term">¶</a></dt><dd><p>Un <a class="reference internal" href="reference/simple_stmts.html#future"><span class="std std-ref">future statement</span></a>, <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">&lt;feature&gt;</span></code>, indica al compilador que compile el módulo actual utilizando una sintaxis o semántica que se convertirá en estándar en una versión futura de Python. El módulo <a class="reference internal" href="library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a> documenta los posibles valores de <em>feature</em>. Al importar este módulo y evaluar sus variables, puede ver cuándo se agregó por primera vez una nueva característica al lenguaje y cuándo se convertirá (o se convirtió) en la predeterminada:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">__future__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__future__</span><span class="o">.</span><span class="n">division</span>
<span class="go">_Feature((2, 2, 0, &#39;alpha&#39;, 2), (3, 0, 0, &#39;alpha&#39;, 0), 8192)</span>
</pre></div>
</div>
</dd>
<dt id="term-garbage-collection">recolección de basura<a class="headerlink" href="#term-garbage-collection" title="Permalink to this term">¶</a></dt><dd><p>El proceso de liberar la memoria de lo que ya no está en uso.  Python realiza recolección de basura (<em>garbage collection</em>) llevando la cuenta de las referencias, y el recogedor de basura cíclico es capaz de detectar y romper las referencias cíclicas.  El recogedor de basura puede ser controlado mediante el módulo <a class="reference internal" href="library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> .</p>
</dd>
<dt id="index-19"><span id="term-generator"></span>generador<a class="headerlink" href="#index-19" title="Permalink to this term">¶</a></dt><dd><p>Una función que retorna un <a class="reference internal" href="#term-generator-iterator"><span class="xref std std-term">generator iterator</span></a>.  Luce como una función normal excepto que contiene la expresión <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> para producir series de valores utilizables en un bucle <em>for</em> o que pueden ser obtenidas una por una con la función <a class="reference internal" href="library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a>.</p>
<p>Usualmente se refiere a una función generadora, pero puede referirse a un <em>iterador generador</em> en ciertos contextos.  En aquellos casos en los que el significado no está claro, usar los términos completos  evita la ambigüedad.</p>
</dd>
<dt id="term-generator-iterator">iterador generador<a class="headerlink" href="#term-generator-iterator" title="Permalink to this term">¶</a></dt><dd><p>Un objeto creado por una función <a class="reference internal" href="#term-generator"><span class="xref std std-term">generator</span></a>.</p>
<p>Cada <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> suspende temporalmente el procesamiento, recordando el estado de ejecución local (incluyendo las variables locales y las sentencias <em>try</em> pendientes).  Cuando el «iterador generado» vuelve, retoma donde ha dejado, a diferencia de lo que ocurre con las funciones que comienzan nuevamente con cada invocación.</p>
</dd>
<dt id="index-20"><span id="term-generator-expression"></span>expresión generadora<a class="headerlink" href="#index-20" title="Permalink to this term">¶</a></dt><dd><p>Una expresión que retorna un iterador.  Luce como una expresión normal seguida por la cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> definiendo así una variable de bucle, un rango y una cláusula opcional <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code>.  La expresión combinada genera valores para la función contenedora:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>         <span class="c1"># sum of squares 0, 1, 4, ... 81</span>
<span class="go">285</span>
</pre></div>
</div>
</dd>
<dt id="term-generic-function">función genérica<a class="headerlink" href="#term-generic-function" title="Permalink to this term">¶</a></dt><dd><p>Una función compuesta de muchas funciones que implementan la misma operación para diferentes tipos. Qué implementación deberá ser usada durante la llamada a la misma es determinado por el algoritmo de despacho.</p>
<p>Vea también la entrada de glosario <a class="reference internal" href="#term-single-dispatch"><span class="xref std std-term">single dispatch</span></a>, el decorador <a class="reference internal" href="library/functools.html#functools.singledispatch" title="functools.singledispatch"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.singledispatch()</span></code></a>, y <span class="target" id="index-92"></span><a class="pep reference external" href="https://peps.python.org/pep-0443/"><strong>PEP 443</strong></a>.</p>
</dd>
<dt id="term-generic-type">tipos genéricos<a class="headerlink" href="#term-generic-type" title="Permalink to this term">¶</a></dt><dd><p>A <a class="reference internal" href="#term-type"><span class="xref std std-term">type</span></a> that can be parameterized; typically a
<a class="reference internal" href="reference/datamodel.html#sequence-types"><span class="std std-ref">container class</span></a> such as <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> or
<a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>. Used for <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">type hints</span></a> and
<a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotations</span></a>.</p>
<p>For more details, see <a class="reference internal" href="library/stdtypes.html#types-genericalias"><span class="std std-ref">generic alias types</span></a>,
<span class="target" id="index-22"></span><a class="pep reference external" href="https://peps.python.org/pep-0483/"><strong>PEP 483</strong></a>, <span class="target" id="index-23"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>, <span class="target" id="index-24"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a>, and the <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> module.</p>
</dd>
<dt id="term-GIL">GIL<a class="headerlink" href="#term-GIL" title="Permalink to this term">¶</a></dt><dd><p>Vea <a class="reference internal" href="#term-global-interpreter-lock"><span class="xref std std-term">global interpreter lock</span></a>.</p>
</dd>
<dt id="term-global-interpreter-lock">bloqueo global del intérprete<a class="headerlink" href="#term-global-interpreter-lock" title="Permalink to this term">¶</a></dt><dd><p>Mecanismo empleado por el intérprete <a class="reference internal" href="#term-CPython"><span class="xref std std-term">CPython</span></a> para asegurar que sólo un hilo ejecute el  <a class="reference internal" href="#term-bytecode"><span class="xref std std-term">bytecode</span></a> Python por vez. Esto simplifica la implementación de CPython haciendo que el modelo de objetos (incluyendo algunos críticos como <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>) están implícitamente a salvo de acceso concurrente.  Bloqueando el intérprete completo se simplifica hacerlo multi-hilos, a costa de mucho del paralelismo ofrecido por las máquinas con múltiples procesadores.</p>
<p>However, some extension modules, either standard or third-party,
are designed so as to release the GIL when doing computationally intensive
tasks such as compression or hashing.  Also, the GIL is always released
when doing I/O.</p>
<p>Esfuerzos previos hechos para crear un intérprete «sin hilos» (uno que bloquee los datos compartidos con una granularidad mucho más fina) no han sido exitosos debido a que el rendimiento sufrió para el caso más común de un solo procesador. Se cree que superar este problema de rendimiento haría la implementación mucho más compleja y por tanto, más costosa de mantener.</p>
</dd>
<dt id="term-hash-based-pyc">hash-based pyc<a class="headerlink" href="#term-hash-based-pyc" title="Permalink to this term">¶</a></dt><dd><p>Un archivo cache de <em>bytecode</em> que usa el <em>hash</em> en vez de usar el tiempo de la última modificación del archivo fuente correspondiente para determinar su validez. Vea <a class="reference internal" href="reference/import.html#pyc-invalidation"><span class="std std-ref">Invalidación del código de bytes en caché</span></a>.</p>
</dd>
<dt id="term-hashable">hashable<a class="headerlink" href="#term-hashable" title="Permalink to this term">¶</a></dt><dd><p>Un objeto es <em>hashable</em> si tiene un valor de hash que nunca cambiará durante su tiempo de vida (necesita un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> ), y puede ser comparado con otro objeto (necesita el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code> ).  Los objetos hashables que se comparan iguales deben tener el mismo número hash.</p>
<p>Ser <em>hashable</em> hace a un objeto utilizable como clave de un diccionario y miembro de un set, porque éstas estructuras de datos usan los valores de hash internamente.</p>
<p>La mayoría de los objetos inmutables incorporados en Python son <em>hashables</em>; los contenedores mutables (como las listas o los diccionarios) no lo son; los contenedores inmutables (como tuplas y conjuntos <em>frozensets</em>) son <em>hashables</em> si sus elementos son <em>hashables</em> .  Los objetos que son instancias de clases definidas por el usuario son <em>hashables</em> por defecto.  Todos se comparan como desiguales (excepto consigo mismos), y su valor de hash está derivado de su función <a class="reference internal" href="library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a>.</p>
</dd>
<dt id="term-IDLE">IDLE<a class="headerlink" href="#term-IDLE" title="Permalink to this term">¶</a></dt><dd><p>An Integrated Development and Learning Environment for Python.
<a class="reference internal" href="library/idle.html#idle"><span class="std std-ref">IDLE</span></a> is a basic editor and interpreter environment
which ships with the standard distribution of Python.</p>
</dd>
<dt id="term-immutable">inmutable<a class="headerlink" href="#term-immutable" title="Permalink to this term">¶</a></dt><dd><p>Un objeto con un valor fijo.  Los objetos inmutables son números, cadenas y tuplas.  Éstos objetos no pueden ser alterados.  Un nuevo objeto debe ser creado si un valor diferente ha de ser guardado.  Juegan un rol importante en lugares donde es necesario un valor de hash constante, por ejemplo como claves de un diccionario.</p>
</dd>
<dt id="term-import-path">ruta de importación<a class="headerlink" href="#term-import-path" title="Permalink to this term">¶</a></dt><dd><p>Una lista de las ubicaciones (o <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">entradas de ruta</span></a>) que son revisadas por <a class="reference internal" href="#term-path-based-finder"><span class="xref std std-term">path based finder</span></a> al importar módulos. Durante la importación, ésta lista de localizaciones usualmente viene de <a class="reference internal" href="library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>, pero para los subpaquetes también puede incluir al atributo <code class="docutils literal notranslate"><span class="pre">__path__</span></code> del paquete padre.</p>
</dd>
<dt id="term-importing">importar<a class="headerlink" href="#term-importing" title="Permalink to this term">¶</a></dt><dd><p>El proceso mediante el cual el código Python dentro de un módulo se hace alcanzable desde otro código Python en otro módulo.</p>
</dd>
<dt id="term-importer">importador<a class="headerlink" href="#term-importer" title="Permalink to this term">¶</a></dt><dd><p>Un objeto que buscan y lee un módulo; un objeto que es tanto <a class="reference internal" href="#term-finder"><span class="xref std std-term">finder</span></a> como <a class="reference internal" href="#term-loader"><span class="xref std std-term">loader</span></a>.</p>
</dd>
<dt id="term-interactive">interactivo<a class="headerlink" href="#term-interactive" title="Permalink to this term">¶</a></dt><dd><p>Python tiene un intérprete interactivo, lo que significa que puede ingresar sentencias y expresiones en el prompt del intérprete, ejecutarlos de inmediato y ver sus resultados.  Sólo ejecute <code class="docutils literal notranslate"><span class="pre">python</span></code> sin argumentos (podría seleccionarlo desde el menú principal de su computadora). Es una forma muy potente de probar nuevas ideas o inspeccionar módulos y paquetes (recuerde  <code class="docutils literal notranslate"><span class="pre">help(x)</span></code>).</p>
</dd>
<dt id="term-interpreted">interpretado<a class="headerlink" href="#term-interpreted" title="Permalink to this term">¶</a></dt><dd><p>Python es un lenguaje interpretado, a diferencia de uno compilado, a pesar de que la distinción puede ser difusa debido al compilador a <em>bytecode</em>.  Esto significa que los archivos fuente pueden ser corridos directamente, sin crear explícitamente un ejecutable que es corrido luego. Los lenguajes interpretados típicamente tienen ciclos de desarrollo y depuración más cortos que los compilados, sin embargo sus programas suelen correr más lentamente.  Vea también  <a class="reference internal" href="#term-interactive"><span class="xref std std-term">interactive</span></a>.</p>
</dd>
<dt id="term-interpreter-shutdown">apagado del intérprete<a class="headerlink" href="#term-interpreter-shutdown" title="Permalink to this term">¶</a></dt><dd><p>Cuando se le solicita apagarse, el intérprete Python ingresa a un fase especial en la cual gradualmente libera todos los recursos reservados, como módulos y varias estructuras internas críticas.  También hace varias llamadas al <a class="reference internal" href="#term-garbage-collection"><span class="xref std std-term">recolector de basura</span></a>.  Esto puede disparar la ejecución de código de destructores definidos por el usuario o <em>weakref callbacks</em>. El código ejecutado durante la fase de apagado puede encontrar varias excepciones debido a que los recursos que necesita pueden no funcionar más (ejemplos comunes son los módulos de bibliotecas o los artefactos de advertencias <em>warnings machinery</em>)</p>
<p>La principal razón para el apagado del intérpreter es que el módulo <code class="docutils literal notranslate"><span class="pre">__main__</span></code> o el script que estaba corriendo termine su ejecución.</p>
</dd>
<dt id="term-iterable">iterable<a class="headerlink" href="#term-iterable" title="Permalink to this term">¶</a></dt><dd><p>An object capable of returning its members one at a time. Examples of
iterables include all sequence types (such as <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>,
and <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>) and some non-sequence types like <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>,
<a class="reference internal" href="#term-file-object"><span class="xref std std-term">file objects</span></a>, and objects of any classes you define
with an <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> method or with a <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code> method
that implements <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a> semantics.</p>
<p>Los iterables pueden ser usados en el bucle <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> y en muchos otros sitios donde una secuencia es necesaria (<a class="reference internal" href="library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a>, <a class="reference internal" href="library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a>, …).  Cuando un objeto iterable es pasado como argumento a la función incorporada <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a>, retorna un iterador para el objeto.  Este iterador pasa así el conjunto de valores.  Cuando se usan iterables, normalmente no es necesario llamar a la función <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> o tratar con los objetos iteradores usted mismo.  La sentencia <code class="docutils literal notranslate"><span class="pre">for</span></code> lo hace automáticamente por usted, creando un variable temporal sin nombre para mantener el iterador mientras dura el bucle.  Vea también <a class="reference internal" href="#term-iterator"><span class="xref std std-term">iterator</span></a>, <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a>, y <a class="reference internal" href="#term-generator"><span class="xref std std-term">generator</span></a>.</p>
</dd>
<dt id="term-iterator">iterador<a class="headerlink" href="#term-iterator" title="Permalink to this term">¶</a></dt><dd><p>Un objeto que representa un flujo de datos.  Llamadas repetidas al método  <a class="reference internal" href="library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> del iterador (o al pasar la función incorporada <a class="reference internal" href="library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a>) retorna ítems sucesivos del flujo.  Cuando no hay más datos disponibles, una excepción <a class="reference internal" href="library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> es disparada.  En este momento, el objeto iterador está exhausto y cualquier llamada posterior al método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code> sólo dispara otra vez <a class="reference internal" href="library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>.  Los iteradores necesitan tener un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> que retorna el objeto iterador mismo así cada iterador es también un iterable y puede ser usado en casi todos los lugares donde los iterables son aceptados.  Una excepción importante es el código que intenta múltiples pases de iteración.  Un objeto contenedor (como la <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>) produce un nuevo iterador cada vez que pasa a una función <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> o se usa en un bucle  <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>.  Intentar ésto con un iterador simplemente retornaría el mismo objeto iterador exhausto usado en previas iteraciones, haciéndolo aparecer como un contenedor vacío.</p>
<p>Puede encontrar más información en <a class="reference internal" href="library/stdtypes.html#typeiter"><span class="std std-ref">Tipos de iteradores</span></a>.</p>
<div class="impl-detail compound">
<p><strong>Detalles de implementación de CPython:</strong> CPython does not consistently apply the requirement that an iterator
define <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code>.</p>
</div>
</dd>
<dt id="term-key-function">función clave<a class="headerlink" href="#term-key-function" title="Permalink to this term">¶</a></dt><dd><p>Una función clave o una función de colación es un invocable que retorna un valor usado para el ordenamiento o clasificación.  Por ejemplo, <a class="reference internal" href="library/locale.html#locale.strxfrm" title="locale.strxfrm"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.strxfrm()</span></code></a> es usada para producir claves de ordenamiento que se adaptan a las convenciones específicas de ordenamiento de un <em>locale</em>.</p>
<p>Cierta cantidad de herramientas de Python aceptan funciones clave para controlar como los elementos son ordenados o agrupados. Incluyendo a  <a class="reference internal" href="library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a>, <a class="reference internal" href="library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.merge" title="heapq.merge"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.merge()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.nsmallest" title="heapq.nsmallest"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.nsmallest()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.nlargest" title="heapq.nlargest"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.nlargest()</span></code></a>, y <a class="reference internal" href="library/itertools.html#itertools.groupby" title="itertools.groupby"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.groupby()</span></code></a>.</p>
<p>There are several ways to create a key function.  For example. the
<a class="reference internal" href="library/stdtypes.html#str.lower" title="str.lower"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.lower()</span></code></a> method can serve as a key function for case insensitive
sorts.  Alternatively, a key function can be built from a
<a class="reference internal" href="reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> expression such as <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">r:</span> <span class="pre">(r[0],</span> <span class="pre">r[2])</span></code>.  Also,
<a class="reference internal" href="library/operator.html#operator.attrgetter" title="operator.attrgetter"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.attrgetter()</span></code></a>, <a class="reference internal" href="library/operator.html#operator.itemgetter" title="operator.itemgetter"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.itemgetter()</span></code></a>, and
<a class="reference internal" href="library/operator.html#operator.methodcaller" title="operator.methodcaller"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.methodcaller()</span></code></a> are three key function constructors.  See the <a class="reference internal" href="howto/sorting.html#sortinghowto"><span class="std std-ref">Sorting HOW TO</span></a> for examples of how to create and use key functions.</p>
</dd>
<dt id="term-keyword-argument">argumento nombrado<a class="headerlink" href="#term-keyword-argument" title="Permalink to this term">¶</a></dt><dd><p>Vea <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>.</p>
</dd>
<dt id="term-lambda">lambda<a class="headerlink" href="#term-lambda" title="Permalink to this term">¶</a></dt><dd><p>Una función anónima de una línea consistente en un sola <a class="reference internal" href="#term-expression"><span class="xref std std-term">expression</span></a> que es evaluada cuando la función es llamada.  La sintaxis para crear una función lambda es <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">[parameters]:</span> <span class="pre">expression</span></code></p>
</dd>
<dt id="term-LBYL">LBYL<a class="headerlink" href="#term-LBYL" title="Permalink to this term">¶</a></dt><dd><p>Del inglés <em>Look before you leap</em>, «mira antes de saltar».  Es un estilo de codificación que prueba explícitamente las condiciones previas antes de hacer llamadas o búsquedas.  Este estilo contrasta con la manera <a class="reference internal" href="#term-EAFP"><span class="xref std std-term">EAFP</span></a> y está caracterizado por la presencia de muchas sentencias <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>.</p>
<p>En entornos multi-hilos, el método LBYL tiene el riesgo de introducir condiciones de carrera entre los hilos que están «mirando» y los que están «saltando».  Por ejemplo, el código, <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">key</span> <span class="pre">in</span> <span class="pre">mapping:</span> <span class="pre">return</span> <span class="pre">mapping[key]</span></code>  puede fallar si otro hilo remueve <em>key</em> de <em>mapping</em> después del test, pero antes de retornar el valor.  Este problema puede ser resuelto usando bloqueos o empleando el método EAFP.</p>
</dd>
<dt id="term-locale-encoding">codificación de la configuración regional<a class="headerlink" href="#term-locale-encoding" title="Permalink to this term">¶</a></dt><dd><p>On Unix, it is the encoding of the LC_CTYPE locale. It can be set with
<a class="reference internal" href="library/locale.html#locale.setlocale" title="locale.setlocale"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.setlocale(locale.LC_CTYPE,</span> <span class="pre">new_locale)</span></code></a>.</p>
<p>On Windows, it is the ANSI code page (ex: <code class="docutils literal notranslate"><span class="pre">&quot;cp1252&quot;</span></code>).</p>
<p>On Android and VxWorks, Python uses <code class="docutils literal notranslate"><span class="pre">&quot;utf-8&quot;</span></code> as the locale encoding.</p>
<p><code class="docutils literal notranslate"><span class="pre">locale.getencoding()</span></code> can be used to get the locale encoding.</p>
<p>See also the <a class="reference internal" href="#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem encoding and error handler</span></a>.</p>
</dd>
<dt id="term-list">lista<a class="headerlink" href="#term-list" title="Permalink to this term">¶</a></dt><dd><p>Es una <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a> Python incorporada.  A pesar de su nombre es más similar a un arreglo en otros lenguajes que a una lista enlazada porque el acceso a los elementos es O(1).</p>
</dd>
<dt id="term-list-comprehension">comprensión de listas<a class="headerlink" href="#term-list-comprehension" title="Permalink to this term">¶</a></dt><dd><p>Una forma compacta de procesar todos o parte de los elementos en una secuencia y retornar una lista como resultado.  <code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">['{:#04x}'.format(x)</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(256)</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0]</span></code> genera una lista de cadenas conteniendo números hexadecimales (0x..) entre 0 y 255. La cláusula <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> es opcional.  Si es omitida, todos los elementos en <code class="docutils literal notranslate"><span class="pre">range(256)</span></code> son procesados.</p>
</dd>
<dt id="term-loader">cargador<a class="headerlink" href="#term-loader" title="Permalink to this term">¶</a></dt><dd><p>Un objeto que carga un módulo. Debe definir el método llamado <code class="xref py py-meth docutils literal notranslate"><span class="pre">load_module()</span></code>.  Un cargador es normalmente retornados por un  <a class="reference internal" href="#term-finder"><span class="xref std std-term">finder</span></a>. Vea <span class="target" id="index-93"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> para detalles y <a class="reference internal" href="library/importlib.html#importlib.abc.Loader" title="importlib.abc.Loader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.Loader</span></code></a> para una <a class="reference internal" href="#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a>.</p>
</dd>
<dt id="term-magic-method">método mágico<a class="headerlink" href="#term-magic-method" title="Permalink to this term">¶</a></dt><dd><p id="index-26">Una manera informal de llamar a un <a class="reference internal" href="#term-special-method"><span class="xref std std-term">special method</span></a>.</p>
</dd>
<dt id="term-mapping">mapeado<a class="headerlink" href="#term-mapping" title="Permalink to this term">¶</a></dt><dd><p>A container object that supports arbitrary key lookups and implements the
methods specified in the <a class="reference internal" href="library/collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a> or
<a class="reference internal" href="library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a>
<a class="reference internal" href="library/collections.abc.html#collections-abstract-base-classes"><span class="std std-ref">abstract base classes</span></a>.  Examples
include <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>, <a class="reference internal" href="library/collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a>,
<a class="reference internal" href="library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> and <a class="reference internal" href="library/collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a>.</p>
</dd>
<dt id="term-meta-path-finder">meta buscadores de ruta<a class="headerlink" href="#term-meta-path-finder" title="Permalink to this term">¶</a></dt><dd><p>Un <a class="reference internal" href="#term-finder"><span class="xref std std-term">finder</span></a> retornado por una búsqueda de <a class="reference internal" href="library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>.  Los meta buscadores de ruta están relacionados a <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">buscadores de entradas de rutas</span></a>, pero son algo diferente.</p>
<p>Vea en <a class="reference internal" href="library/importlib.html#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> los métodos que los meta buscadores de ruta implementan.</p>
</dd>
<dt id="term-metaclass">metaclase<a class="headerlink" href="#term-metaclass" title="Permalink to this term">¶</a></dt><dd><p>La clase de una clase.  Las definiciones de clases crean nombres de clase, un diccionario de clase, y una lista de clases base.  Las metaclases son responsables de tomar estos tres argumentos y crear la clase.  La mayoría de los objetos de un lenguaje de programación orientado a objetos provienen de una implementación por defecto.  Lo que hace a Python especial que es posible crear metaclases a medida.  La mayoría de los usuario nunca necesitarán esta herramienta, pero cuando la necesidad surge, las metaclases pueden brindar soluciones poderosas y elegantes.  Han sido usadas para <em>loggear</em> acceso de atributos, agregar seguridad a hilos, rastrear la creación de objetos, implementar <em>singletons</em>, y muchas otras tareas.</p>
<p>Más información hallará en <a class="reference internal" href="reference/datamodel.html#metaclasses"><span class="std std-ref">Metaclases</span></a>.</p>
</dd>
<dt id="term-method">método<a class="headerlink" href="#term-method" title="Permalink to this term">¶</a></dt><dd><p>Una función que es definida dentro del cuerpo de una clase.  Si es llamada como un atributo de una instancia de otra clase, el método tomará el objeto instanciado como su primer <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a> (el cual es usualmente denominado <cite>self</cite>). Vea <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a> y <a class="reference internal" href="#term-nested-scope"><span class="xref std std-term">nested scope</span></a>.</p>
</dd>
<dt id="term-method-resolution-order">orden de resolución de métodos<a class="headerlink" href="#term-method-resolution-order" title="Permalink to this term">¶</a></dt><dd><p>Orden de resolución de métodos es el orden en el cual una clase base es buscada por un miembro durante la búsqueda. Mire en <a class="reference external" href="https://www.python.org/download/releases/2.3/mro/">The Python 2.3 Method Resolution Order</a> los detalles del algoritmo usado por el intérprete Python desde la versión 2.3.</p>
</dd>
<dt id="term-module">módulo<a class="headerlink" href="#term-module" title="Permalink to this term">¶</a></dt><dd><p>Un objeto que sirve como unidad de organización del código Python.  Los módulos tienen espacios de nombres conteniendo objetos Python arbitrarios.  Los módulos son cargados en Python por el proceso de <a class="reference internal" href="#term-importing"><span class="xref std std-term">importing</span></a>.</p>
<p>Vea también <a class="reference internal" href="#term-package"><span class="xref std std-term">package</span></a>.</p>
</dd>
<dt id="term-module-spec">especificador de módulo<a class="headerlink" href="#term-module-spec" title="Permalink to this term">¶</a></dt><dd><p>Un espacio de nombres que contiene la información relacionada a la importación usada al leer un módulo.  Una instancia de  <a class="reference internal" href="library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.ModuleSpec</span></code></a>.</p>
</dd>
<dt id="term-MRO">MRO<a class="headerlink" href="#term-MRO" title="Permalink to this term">¶</a></dt><dd><p>Vea <a class="reference internal" href="#term-method-resolution-order"><span class="xref std std-term">method resolution order</span></a>.</p>
</dd>
<dt id="term-mutable">mutable<a class="headerlink" href="#term-mutable" title="Permalink to this term">¶</a></dt><dd><p>Los objetos mutables pueden cambiar su valor pero mantener su <a class="reference internal" href="library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a>.  Vea también <a class="reference internal" href="#term-immutable"><span class="xref std std-term">immutable</span></a>.</p>
</dd>
<dt id="term-named-tuple">tupla nombrada<a class="headerlink" href="#term-named-tuple" title="Permalink to this term">¶</a></dt><dd><p>La denominación «tupla nombrada» se aplica a cualquier tipo o clase que hereda de una tupla y cuyos elementos indexables son también accesibles usando atributos nombrados. Este tipo o clase puede tener además otras capacidades.</p>
<p>Varios tipos incorporados son tuplas nombradas, incluyendo los valores retornados por <a class="reference internal" href="library/time.html#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.localtime()</span></code></a> y <a class="reference internal" href="library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a>.  Otro ejemplo es <a class="reference internal" href="library/sys.html#sys.float_info" title="sys.float_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.float_info</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>                   <span class="c1"># indexed access</span>
<span class="go">1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max_exp</span>              <span class="c1"># named field access</span>
<span class="go">1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>   <span class="c1"># kind of tuple</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Algunas tuplas nombradas con tipos incorporados (como en los ejemplo precedentes). También puede ser creada con una definición regular de clase que hereda de la clase  <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> y que define campos nombrados.  Una clase como esta puede ser hechas personalizadamente o puede ser creada con la función factoría <a class="reference internal" href="library/collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a>.  Esta última técnica automáticamente brinda métodos adicionales que pueden no estar presentes en las tuplas nombradas personalizadas o incorporadas.</p>
</dd>
<dt id="term-namespace">espacio de nombres<a class="headerlink" href="#term-namespace" title="Permalink to this term">¶</a></dt><dd><p>El lugar donde la variable es almacenada.  Los espacios de nombres son implementados como diccionarios.  Hay espacio de nombre local, global, e incorporado así como espacios de nombres anidados en objetos (en métodos).  Los espacios de nombres soportan modularidad previniendo conflictos de nombramiento.  Por ejemplo, las funciones <a class="reference internal" href="library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">builtins.open</span></code></a> y <a class="reference internal" href="library/os.html#os.open" title="os.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.open()</span></code></a> se distinguen por su espacio de nombres.  Los espacios de nombres también ayuda a la legibilidad y mantenibilidad dejando claro qué módulo implementa una función.  Por ejemplo, escribiendo <a class="reference internal" href="library/random.html#random.seed" title="random.seed"><code class="xref py py-func docutils literal notranslate"><span class="pre">random.seed()</span></code></a> o <a class="reference internal" href="library/itertools.html#itertools.islice" title="itertools.islice"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.islice()</span></code></a> queda claro que éstas funciones están implementadas en los módulos <a class="reference internal" href="library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a> y <a class="reference internal" href="library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal notranslate"><span class="pre">itertools</span></code></a>, respectivamente.</p>
</dd>
<dt id="term-namespace-package">paquete de espacios de nombres<a class="headerlink" href="#term-namespace-package" title="Permalink to this term">¶</a></dt><dd><p>Un <span class="target" id="index-94"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> <a class="reference internal" href="#term-package"><span class="xref std std-term">package</span></a> que sirve sólo para contener subpaquetes.  Los paquetes de espacios de nombres pueden no tener representación física, y específicamente se diferencian de los <a class="reference internal" href="#term-regular-package"><span class="xref std std-term">regular package</span></a> porque no tienen un archivo <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>.</p>
<p>Vea también <a class="reference internal" href="#term-module"><span class="xref std std-term">module</span></a>.</p>
</dd>
<dt id="term-nested-scope">alcances anidados<a class="headerlink" href="#term-nested-scope" title="Permalink to this term">¶</a></dt><dd><p>La habilidad de referirse a una variable dentro de una definición encerrada.  Por ejemplo, una función definida dentro de otra función puede referir a variables en la función externa.  Note que los alcances anidados por defecto sólo funcionan para referencia y no para asignación.  Las variables locales leen y escriben sólo en el alcance más interno.  De manera semejante, las variables globales pueden leer y escribir en el espacio de nombres global.  Con <a class="reference internal" href="reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> se puede escribir en alcances exteriores.</p>
</dd>
<dt id="term-new-style-class">clase de nuevo estilo<a class="headerlink" href="#term-new-style-class" title="Permalink to this term">¶</a></dt><dd><p>Vieja denominación usada para el estilo de clases ahora empleado en todos los objetos de clase.  En versiones más tempranas de Python, sólo las nuevas clases podían usar capacidades nuevas y versátiles de Python como <a class="reference internal" href="reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a>, descriptores, propiedades, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code>, métodos de clase y métodos estáticos.</p>
</dd>
<dt id="term-object">objeto<a class="headerlink" href="#term-object" title="Permalink to this term">¶</a></dt><dd><p>Cualquier dato con estado (atributo o valor) y comportamiento definido (métodos).  También es la más básica clase base para cualquier <a class="reference internal" href="#term-new-style-class"><span class="xref std std-term">new-style class</span></a>.</p>
</dd>
<dt id="term-package">paquete<a class="headerlink" href="#term-package" title="Permalink to this term">¶</a></dt><dd><p>A Python <a class="reference internal" href="#term-module"><span class="xref std std-term">module</span></a> which can contain submodules or recursively,
subpackages.  Technically, a package is a Python module with a
<code class="docutils literal notranslate"><span class="pre">__path__</span></code> attribute.</p>
<p>Vea también <a class="reference internal" href="#term-regular-package"><span class="xref std std-term">regular package</span></a> y <a class="reference internal" href="#term-namespace-package"><span class="xref std std-term">namespace package</span></a>.</p>
</dd>
<dt id="term-parameter">parámetro<a class="headerlink" href="#term-parameter" title="Permalink to this term">¶</a></dt><dd><p>Una entidad nombrada en una definición de una <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a> (o método) que especifica un <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a> (o en algunos casos, varios argumentos) que la función puede aceptar.  Existen cinco tipos de argumentos:</p>
<ul>
<li><p><em class="dfn">posicional o nombrado</em>: especifica un argumento que puede ser pasado tanto como <a class="reference internal" href="#term-argument"><span class="xref std std-term">posicional</span></a> o como <a class="reference internal" href="#term-argument"><span class="xref std std-term">nombrado</span></a>.  Este es el tipo por defecto de parámetro, como <em>foo</em> y <em>bar</em> en el siguiente ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<ul id="positional-only-parameter">
<li><p><em class="dfn">sólo posicional</em>: especifica un argumento que puede ser pasado sólo por posición.  Los parámetros sólo posicionales pueden ser definidos incluyendo un carácter <code class="docutils literal notranslate"><span class="pre">/</span></code> en la lista de parámetros de la función después de ellos, como <em>posonly1</em> y <em>posonly2</em> en el ejemplo que sigue:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">posonly1</span><span class="p">,</span> <span class="n">posonly2</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">positional_or_keyword</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<ul id="keyword-only-parameter">
<li><p><em class="dfn">sólo nombrado</em>: especifica un argumento que sólo puede ser pasado por nombre.  Los parámetros sólo por nombre pueden ser definidos incluyendo un parámetro posicional de una sola variable o un simple <code class="docutils literal notranslate"><span class="pre">*`</span></code> antes de ellos en la lista de parámetros en la definición de la función, como <em>kw_only1</em> y <em>kw_only2</em> en el ejemplo siguiente:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">kw_only1</span><span class="p">,</span> <span class="n">kw_only2</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p><em class="dfn">variable posicional</em>: especifica una secuencia arbitraria de argumentos posicionales que pueden ser brindados (además de cualquier argumento posicional aceptado por otros parámetros).  Este parámetro puede ser definido anteponiendo al nombre del parámetro <code class="docutils literal notranslate"><span class="pre">*</span></code>, como a <em>args</em> en el siguiente ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p><em class="dfn">variable nombrado</em>: especifica que arbitrariamente muchos argumentos nombrados pueden ser brindados (además de cualquier argumento nombrado ya aceptado por cualquier otro parámetro).  Este parámetro puede ser definido anteponiendo al nombre del parámetro con <code class="docutils literal notranslate"><span class="pre">**</span></code>, como <em>kwargs</em> en el ejemplo precedente.</p></li>
</ul>
<p>Los parámetros puede especificar tanto argumentos opcionales como requeridos, así como valores por defecto para algunos argumentos opcionales.</p>
<p>Vea también el glosario de <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>, la pregunta respondida en <a class="reference internal" href="faq/programming.html#faq-argument-vs-parameter"><span class="std std-ref">la diferencia entre argumentos y parámetros</span></a>, la clase <a class="reference internal" href="library/inspect.html#inspect.Parameter" title="inspect.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">inspect.Parameter</span></code></a>, la sección <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">Definiciones de funciones</span></a> , y <span class="target" id="index-95"></span><a class="pep reference external" href="https://peps.python.org/pep-0362/"><strong>PEP 362</strong></a>.</p>
</dd>
<dt id="term-path-entry">entrada de ruta<a class="headerlink" href="#term-path-entry" title="Permalink to this term">¶</a></dt><dd><p>Una ubicación única en el <a class="reference internal" href="#term-import-path"><span class="xref std std-term">import path</span></a> que el <a class="reference internal" href="#term-path-based-finder"><span class="xref std std-term">path based finder</span></a> consulta para encontrar los módulos a importar.</p>
</dd>
<dt id="term-path-entry-finder">buscador de entradas de ruta<a class="headerlink" href="#term-path-entry-finder" title="Permalink to this term">¶</a></dt><dd><p>Un <a class="reference internal" href="#term-finder"><span class="xref std std-term">finder</span></a> retornado por un invocable en <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> (esto es, un <a class="reference internal" href="#term-path-entry-hook"><span class="xref std std-term">path entry hook</span></a>) que sabe cómo localizar módulos dada una <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">path entry</span></a>.</p>
<p>Vea en <a class="reference internal" href="library/importlib.html#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder</span></code></a> los métodos que los buscadores de entradas de ruta implementan.</p>
</dd>
<dt id="term-path-entry-hook">gancho a entrada de ruta<a class="headerlink" href="#term-path-entry-hook" title="Permalink to this term">¶</a></dt><dd><p>Un invocable en la lista <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hook</span></code> que retorna un <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a> si éste sabe cómo encontrar módulos en un <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">path entry</span></a> específico.</p>
</dd>
<dt id="term-path-based-finder">buscador basado en ruta<a class="headerlink" href="#term-path-based-finder" title="Permalink to this term">¶</a></dt><dd><p>Uno de los <a class="reference internal" href="#term-meta-path-finder"><span class="xref std std-term">meta buscadores de ruta</span></a> por defecto que busca un <a class="reference internal" href="#term-import-path"><span class="xref std std-term">import path</span></a> para los módulos.</p>
</dd>
<dt id="term-path-like-object">objeto tipo ruta<a class="headerlink" href="#term-path-like-object" title="Permalink to this term">¶</a></dt><dd><p>Un objeto que representa una ruta del sistema de archivos. Un objeto tipo ruta puede ser tanto una <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> como un <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> representando una ruta, o un objeto que implementa el protocolo <a class="reference internal" href="library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a>. Un objeto que soporta el protocolo  <a class="reference internal" href="library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> puede ser convertido a ruta del sistema de archivo de clase <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> o <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> usando la función <a class="reference internal" href="library/os.html#os.fspath" title="os.fspath"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fspath()</span></code></a>; <a class="reference internal" href="library/os.html#os.fsdecode" title="os.fsdecode"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fsdecode()</span></code></a> <a class="reference internal" href="library/os.html#os.fsencode" title="os.fsencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fsencode()</span></code></a> pueden emplearse para garantizar que retorne respectivamente <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> o <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. Introducido por <span class="target" id="index-96"></span><a class="pep reference external" href="https://peps.python.org/pep-0519/"><strong>PEP 519</strong></a>.</p>
</dd>
<dt id="term-PEP">PEP<a class="headerlink" href="#term-PEP" title="Permalink to this term">¶</a></dt><dd><p>Propuesta de mejora de Python, del inglés <em>Python Enhancement Proposal</em>. Un PEP es un documento de diseño que brinda información a la comunidad Python, o describe una nueva capacidad para Python, sus procesos o entorno. Los PEPs deberían dar una especificación técnica concisa y una fundamentación para las capacidades propuestas.</p>
<p>Los PEPs tienen como propósito ser los mecanismos primarios para proponer nuevas y mayores capacidad, para recoger la opinión de la comunidad sobre un tema, y para documentar las decisiones de diseño que se han hecho en Python. El autor del PEP es el responsable de lograr consenso con la comunidad y documentar las opiniones disidentes.</p>
<p>Vea <span class="target" id="index-97"></span><a class="pep reference external" href="https://peps.python.org/pep-0001/"><strong>PEP 1</strong></a>.</p>
</dd>
<dt id="term-portion">porción<a class="headerlink" href="#term-portion" title="Permalink to this term">¶</a></dt><dd><p>Un conjunto de archivos en un único directorio (posiblemente guardo en un archivo comprimido <em>zip</em>) que contribuye a un espacio de nombres de paquete, como está definido en <span class="target" id="index-98"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a>.</p>
</dd>
<dt id="term-positional-argument">argumento posicional<a class="headerlink" href="#term-positional-argument" title="Permalink to this term">¶</a></dt><dd><p>Vea <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>.</p>
</dd>
<dt id="term-provisional-API">API provisional<a class="headerlink" href="#term-provisional-API" title="Permalink to this term">¶</a></dt><dd><p>Una API provisoria es aquella que deliberadamente fue excluida de las garantías de compatibilidad hacia atrás de la biblioteca estándar.  Aunque no se esperan cambios fundamentales en dichas interfaces, como están marcadas como provisionales, los cambios incompatibles hacia atrás (incluso remover la misma interfaz) podrían ocurrir si los desarrolladores principales lo estiman.  Estos cambios no se hacen gratuitamente – solo ocurrirán si fallas fundamentales y serias son descubiertas que no fueron vistas antes de la inclusión de la API.</p>
<p>Incluso para APIs provisorias, los cambios incompatibles hacia atrás son vistos como una «solución de último recurso» - se intentará todo para encontrar una solución compatible hacia atrás para los problemas identificados.</p>
<p>Este proceso permite que la biblioteca estándar continúe evolucionando con el tiempo, sin bloquearse por errores de diseño problemáticos por períodos extensos de tiempo. Vea <span class="target" id="index-99"></span><a class="pep reference external" href="https://peps.python.org/pep-0411/"><strong>PEP 411</strong></a> para más detalles.</p>
</dd>
<dt id="term-provisional-package">paquete provisorio<a class="headerlink" href="#term-provisional-package" title="Permalink to this term">¶</a></dt><dd><p>Vea <a class="reference internal" href="#term-provisional-API"><span class="xref std std-term">provisional API</span></a>.</p>
</dd>
<dt id="term-Python-3000">Python 3000<a class="headerlink" href="#term-Python-3000" title="Permalink to this term">¶</a></dt><dd><p>Apodo para la fecha de lanzamiento de Python 3.x (acuñada en un tiempo cuando llegar a la versión 3 era algo distante en el futuro.)  También se lo abrevió como <em>Py3k</em>.</p>
</dd>
<dt id="term-Pythonic">Pythónico<a class="headerlink" href="#term-Pythonic" title="Permalink to this term">¶</a></dt><dd><p>Una idea o pieza de código que sigue ajustadamente la convenciones idiomáticas comunes del lenguaje Python, en vez de implementar código usando conceptos comunes a otros lenguajes.  Por ejemplo, una convención común en Python es hacer bucles sobre todos los elementos de un iterable con la sentencia <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>.  Muchos otros lenguajes no tienen este tipo de construcción, así que los que no están familiarizados con Python podrían usar contadores numéricos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">food</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">food</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>En contraste, un método Pythónico más limpio:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">piece</span> <span class="ow">in</span> <span class="n">food</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">piece</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt id="term-qualified-name">nombre calificado<a class="headerlink" href="#term-qualified-name" title="Permalink to this term">¶</a></dt><dd><p>Un nombre con puntos mostrando la ruta desde el alcance global del módulo a la clase, función o método definido en dicho módulo, como se define en <span class="target" id="index-100"></span><a class="pep reference external" href="https://peps.python.org/pep-3155/"><strong>PEP 3155</strong></a>.  Para las funciones o clases de más alto nivel, el nombre calificado es el igual al nombre del objeto:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">class</span> <span class="nc">D</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">def</span> <span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>            <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C.D&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">meth</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C.D.meth&#39;</span>
</pre></div>
</div>
<p>Cuando es usado para referirse a los módulos, <em>nombre completamente calificado</em> significa la ruta con puntos completo al módulo, incluyendo cualquier paquete padre, por ejemplo, <code class="docutils literal notranslate"><span class="pre">email.mime.text</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">email.mime.text</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">email</span><span class="o">.</span><span class="n">mime</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;email.mime.text&#39;</span>
</pre></div>
</div>
</dd>
<dt id="term-reference-count">contador de referencias<a class="headerlink" href="#term-reference-count" title="Permalink to this term">¶</a></dt><dd><p>The number of references to an object.  When the reference count of an
object drops to zero, it is deallocated.  Reference counting is
generally not visible to Python code, but it is a key element of the
<a class="reference internal" href="#term-CPython"><span class="xref std std-term">CPython</span></a> implementation.  Programmers can call the
<a class="reference internal" href="library/sys.html#sys.getrefcount" title="sys.getrefcount"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getrefcount()</span></code></a> function to return the
reference count for a particular object.</p>
</dd>
<dt id="term-regular-package">paquete regular<a class="headerlink" href="#term-regular-package" title="Permalink to this term">¶</a></dt><dd><p>Un  <a class="reference internal" href="#term-package"><span class="xref std std-term">package</span></a> tradicional, como aquellos con un directorio conteniendo el archivo <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>.</p>
<p>Vea también <a class="reference internal" href="#term-namespace-package"><span class="xref std std-term">namespace package</span></a>.</p>
</dd>
<dt id="term-__slots__">__slots__<a class="headerlink" href="#term-__slots__" title="Permalink to this term">¶</a></dt><dd><p>Es una declaración dentro de una clase que ahorra memoria predeclarando espacio para las atributos de la instancia y eliminando diccionarios de la instancia.  Aunque es popular, esta técnica es algo dificultosa de lograr correctamente y es mejor reservarla para los casos raros en los que existen grandes cantidades de instancias en aplicaciones con uso crítico de memoria.</p>
</dd>
<dt id="term-sequence">secuencia<a class="headerlink" href="#term-sequence" title="Permalink to this term">¶</a></dt><dd><p>Un <a class="reference internal" href="#term-iterable"><span class="xref std std-term">iterable</span></a> que logra un acceso eficiente a los elementos usando índices enteros a través del método especial <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code> y que define un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code> que retorna la longitud de la secuencia. Algunas de las secuencias incorporadas son <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, y <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. Observe que <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> también soporta <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code>, pero es considerada un mapeo más que una secuencia porque las búsquedas son por claves arbitraria <a class="reference internal" href="#term-immutable"><span class="xref std std-term">immutable</span></a> y no por enteros.</p>
<p>La clase abstracta base <a class="reference internal" href="library/collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> define una interfaz mucho más rica que va más allá de sólo <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code>, agregando <code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code>, y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code>. Los tipos que implementan esta interfaz expandida pueden ser registrados explícitamente usando <code class="xref py py-func docutils literal notranslate"><span class="pre">register()</span></code>.</p>
</dd>
<dt id="term-set-comprehension">comprensión de conjuntos<a class="headerlink" href="#term-set-comprehension" title="Permalink to this term">¶</a></dt><dd><p>Una forma compacta de procesar todos o parte de los elementos en un iterable y retornar un conjunto con los resultados. <code class="docutils literal notranslate"><span class="pre">results</span> <span class="pre">=</span> <span class="pre">{c</span> <span class="pre">for</span> <span class="pre">c</span> <span class="pre">in</span> <span class="pre">'abracadabra'</span> <span class="pre">if</span> <span class="pre">c</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">'abc'}</span></code> genera el conjunto de cadenas <code class="docutils literal notranslate"><span class="pre">{'r',</span> <span class="pre">'d'}</span></code>. Ver <a class="reference internal" href="reference/expressions.html#comprehensions"><span class="std std-ref">Despliegues para listas, conjuntos y diccionarios</span></a>.</p>
</dd>
<dt id="term-single-dispatch">despacho único<a class="headerlink" href="#term-single-dispatch" title="Permalink to this term">¶</a></dt><dd><p>Una forma de despacho de una <a class="reference internal" href="#term-generic-function"><span class="xref std std-term">generic function</span></a> donde la implementación es elegida a partir del tipo de un sólo argumento.</p>
</dd>
<dt id="term-slice">rebanada<a class="headerlink" href="#term-slice" title="Permalink to this term">¶</a></dt><dd><p>Un objeto que contiene una porción de una <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a>.  Una rebanada es creada usando la notación de suscripto, <code class="docutils literal notranslate"><span class="pre">[]</span></code> con dos puntos entre los números cuando se ponen varios, como en <code class="docutils literal notranslate"><span class="pre">nombre_variable[1:3:5]</span></code>.  La notación con corchete (suscrito) usa internamente objetos <a class="reference internal" href="library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a>.</p>
</dd>
<dt id="term-special-method">método especial<a class="headerlink" href="#term-special-method" title="Permalink to this term">¶</a></dt><dd><p id="index-34">Un método que es llamado implícitamente por Python cuando ejecuta ciertas operaciones en un tipo, como la adición.  Estos métodos tienen nombres que comienzan y terminan con doble barra baja.  Los métodos especiales están documentados en <a class="reference internal" href="reference/datamodel.html#specialnames"><span class="std std-ref">Nombres especiales de método</span></a>.</p>
</dd>
<dt id="term-statement">sentencia<a class="headerlink" href="#term-statement" title="Permalink to this term">¶</a></dt><dd><p>Una sentencia es parte de un conjunto (un «bloque» de código).  Una sentencia tanto es una <a class="reference internal" href="#term-expression"><span class="xref std std-term">expression</span></a>  como alguna de las varias sintaxis usando una palabra clave, como <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>, <a class="reference internal" href="reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> o <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>.</p>
</dd>
<dt id="term-strong-reference">referencia fuerte<a class="headerlink" href="#term-strong-reference" title="Permalink to this term">¶</a></dt><dd><p>En la API C de Python, una referencia fuerte es una referencia a un objeto que incrementa el recuento de referencias del objeto cuando se crea y disminuye el recuento de referencias del objeto cuando se elimina.</p>
<p>La función <a class="reference internal" href="c-api/refcounting.html#c.Py_NewRef" title="Py_NewRef"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewRef()</span></code></a> se puede utilizar para crear una referencia fuerte a un objeto. Por lo general, se debe llamar a la función <a class="reference internal" href="c-api/refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DECREF()</span></code></a> en la referencia fuerte antes de salir del alcance de la referencia fuerte, para evitar filtrar una referencia.</p>
<p>Consulte también <a class="reference internal" href="#term-borrowed-reference"><span class="xref std std-term">borrowed reference</span></a>.</p>
</dd>
<dt id="term-text-encoding">codificación de texto<a class="headerlink" href="#term-text-encoding" title="Permalink to this term">¶</a></dt><dd><p>A string in Python is a sequence of Unicode code points (in range
<code class="docutils literal notranslate"><span class="pre">U+0000</span></code>–<code class="docutils literal notranslate"><span class="pre">U+10FFFF</span></code>). To store or transfer a string, it needs to be
serialized as a sequence of bytes.</p>
<p>Serializing a string into a sequence of bytes is known as «encoding», and
recreating the string from the sequence of bytes is known as «decoding».</p>
<p>There are a variety of different text serialization
<a class="reference internal" href="library/codecs.html#standard-encodings"><span class="std std-ref">codecs</span></a>, which are collectively referred to as
«text encodings».</p>
</dd>
<dt id="term-text-file">archivo de texto<a class="headerlink" href="#term-text-file" title="Permalink to this term">¶</a></dt><dd><p>Un <a class="reference internal" href="#term-file-object"><span class="xref std std-term">file object</span></a> capaz de leer y escribir objetos <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>. Frecuentemente, un archivo de texto también accede a un flujo de datos binario y maneja automáticamente el <a class="reference internal" href="#term-text-encoding"><span class="xref std std-term">text encoding</span></a>. Ejemplos de archivos de texto que son abiertos en modo texto (<code class="docutils literal notranslate"><span class="pre">'r'</span></code> o <code class="docutils literal notranslate"><span class="pre">'w'</span></code>), <a class="reference internal" href="library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin</span></code></a>, <a class="reference internal" href="library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a>, y las instancias de <a class="reference internal" href="library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a>.</p>
<p>Vea también <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">binary file</span></a> por objeto de archivos capaces de leer y escribir <a class="reference internal" href="#term-bytes-like-object"><span class="xref std std-term">objeto tipo binario</span></a>.</p>
</dd>
<dt id="term-triple-quoted-string">cadena con triple comilla<a class="headerlink" href="#term-triple-quoted-string" title="Permalink to this term">¶</a></dt><dd><p>Una cadena que está enmarcada por tres instancias de comillas (») o apostrofes (“).  Aunque no brindan ninguna funcionalidad que no está disponible usando cadenas con comillas simple, son útiles por varias razones.  Permiten incluir comillas simples o dobles sin escapar dentro de las cadenas y pueden abarcar múltiples líneas sin el uso de caracteres de continuación, haciéndolas particularmente útiles para escribir docstrings.</p>
</dd>
<dt id="term-type">tipo<a class="headerlink" href="#term-type" title="Permalink to this term">¶</a></dt><dd><p>El tipo de un objeto Python determina qué tipo de objeto es; cada objeto tiene un tipo.  El tipo de un objeto puede ser accedido por su atributo <a class="reference internal" href="library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> o puede ser conseguido usando <code class="docutils literal notranslate"><span class="pre">type(obj)</span></code>.</p>
</dd>
<dt id="term-type-alias">alias de tipos<a class="headerlink" href="#term-type-alias" title="Permalink to this term">¶</a></dt><dd><p>Un sinónimo para un tipo, creado al asignar un tipo a un identificador.</p>
<p>Los alias de tipos son útiles para simplificar los <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">indicadores de tipo</span></a>. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">remove_gray_shades</span><span class="p">(</span>
        <span class="n">colors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>podría ser más legible así:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Color</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">remove_gray_shades</span><span class="p">(</span><span class="n">colors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Color</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Color</span><span class="p">]:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Vea <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> y <span class="target" id="index-101"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>, que describen esta funcionalidad.</p>
</dd>
<dt id="term-type-hint">indicador de tipo<a class="headerlink" href="#term-type-hint" title="Permalink to this term">¶</a></dt><dd><p>Una  <a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotation</span></a> que especifica el tipo esperado para una variable, un atributo de clase, un parámetro para una función o un valor de retorno.</p>
<p>Los indicadores de tipo son opcionales y no son obligados por Python pero son útiles para las herramientas de análisis de tipos estático, y ayuda a las IDE en el completado del código y la refactorización.</p>
<p>Los indicadores de tipo de las variables globales, atributos de clase, y funciones, no de variables locales, pueden ser accedidos usando <a class="reference internal" href="library/typing.html#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.get_type_hints()</span></code></a>.</p>
<p>Vea <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> y <span class="target" id="index-102"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>, que describen esta funcionalidad.</p>
</dd>
<dt id="term-universal-newlines">saltos de líneas universales<a class="headerlink" href="#term-universal-newlines" title="Permalink to this term">¶</a></dt><dd><p>Una manera de interpretar flujos de texto en la cual son reconocidos como finales de línea todas siguientes formas: la convención de Unix para fin de línea <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>, la convención de Windows <code class="docutils literal notranslate"><span class="pre">'\r\n'</span></code>, y la vieja convención de Macintosh <code class="docutils literal notranslate"><span class="pre">'\r'</span></code>.  Vea <span class="target" id="index-103"></span><a class="pep reference external" href="https://peps.python.org/pep-0278/"><strong>PEP 278</strong></a> y <span class="target" id="index-104"></span><a class="pep reference external" href="https://peps.python.org/pep-3116/"><strong>PEP 3116</strong></a>, además de <a class="reference internal" href="library/stdtypes.html#bytes.splitlines" title="bytes.splitlines"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes.splitlines()</span></code></a> para usos adicionales.</p>
</dd>
<dt id="term-variable-annotation">anotación de variable<a class="headerlink" href="#term-variable-annotation" title="Permalink to this term">¶</a></dt><dd><p>Una <a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotation</span></a> de una variable o un atributo de clase.</p>
<p>Cuando se anota una variable o un atributo de clase, la asignación es opcional:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">field</span><span class="p">:</span> <span class="s1">&#39;annotation&#39;</span>
</pre></div>
</div>
<p>Las anotaciones de variables son frecuentemente usadas para <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">type hints</span></a>: por ejemplo, se espera que esta variable tenga valores de clase <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>La sintaxis de la anotación de variables está explicada en la sección <a class="reference internal" href="reference/simple_stmts.html#annassign"><span class="std std-ref">Declaraciones de asignación anotadas</span></a>.</p>
<p>Consulte <a class="reference internal" href="#term-function-annotation"><span class="xref std std-term">function annotation</span></a>, <span class="target" id="index-105"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> y <span class="target" id="index-106"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a>, que describen esta funcionalidad. Consulte también <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">Prácticas recomendadas para las anotaciones</span></a> para conocer las mejores prácticas sobre cómo trabajar con anotaciones.</p>
</dd>
<dt id="term-virtual-environment">entorno virtual<a class="headerlink" href="#term-virtual-environment" title="Permalink to this term">¶</a></dt><dd><p>Un entorno cooperativamente aislado de ejecución que permite a los usuarios de Python y a las aplicaciones instalar y actualizar paquetes de distribución de Python sin interferir con el comportamiento de otras aplicaciones de Python en el mismo sistema.</p>
<p>Vea también <a class="reference internal" href="library/venv.html#module-venv" title="venv: Creation of virtual environments."><code class="xref py py-mod docutils literal notranslate"><span class="pre">venv</span></code></a>.</p>
</dd>
<dt id="term-virtual-machine">máquina virtual<a class="headerlink" href="#term-virtual-machine" title="Permalink to this term">¶</a></dt><dd><p>Una computadora definida enteramente por software.  La máquina virtual de Python ejecuta el <a class="reference internal" href="#term-bytecode"><span class="xref std std-term">bytecode</span></a> generado por el compilador de <em>bytecode</em>.</p>
</dd>
<dt id="term-Zen-of-Python">Zen de Python<a class="headerlink" href="#term-Zen-of-Python" title="Permalink to this term">¶</a></dt><dd><p>Un listado de los principios de diseño y la filosofía de Python que son útiles para entender y usar el lenguaje.  El listado puede encontrarse ingresando  «<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">this</span></code>» en la consola interactiva.</p>
</dd>
</dl>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="faq/installed.html"
                          title="capítulo anterior">«¿Por qué está Python instalado en mi ordenador?» FAQ</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="about.html"
                          title="próximo capítulo">Acerca de estos documentos</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/glossary.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="about.html" title="Acerca de estos documentos"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="faq/installed.html" title="«¿Por qué está Python instalado en mi ordenador?» FAQ"
             >anterior</a> |</li>

          <li><img src="_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="index.html">3.11.2 Documentation</a> &#187;
    </li>

        <li class="nav-item nav-item-this"><a href="">Glosario</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 23, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>