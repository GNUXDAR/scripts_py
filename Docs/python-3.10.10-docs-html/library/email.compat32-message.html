
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>email.message.Message: Representar un mensaje de correo electrónico usando la API compat32 &#8212; documentación de Python - 3.10.10</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.10.10"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="email.mime: Creación de correo electrónico y objetos MIME desde cero" href="email.mime.html" />
    <link rel="prev" title="email: Ejemplos" href="email.examples.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/email.compat32-message.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h4>Tema anterior</h4>
  <p class="topless"><a href="email.examples.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code>: Ejemplos</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="email.mime.html"
                        title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.mime</span></code>: Creación de correo electrónico y objetos MIME desde cero</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/email.compat32-message.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="email.mime.html" title="email.mime: Creación de correo electrónico y objetos MIME desde cero"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="email.examples.html" title="email: Ejemplos"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La Biblioteca Estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="netdata.html" >Manejo de Datos de Internet</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="email.html" accesskey="U"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> — Un paquete de manejo de correo electrónico y MIME</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.message.Message</span></code>: Representar un mensaje de correo electrónico usando la API <code class="xref py py-data docutils literal notranslate"><span class="pre">compat32</span></code></a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="email-message-message-representing-an-email-message-using-the-compat32-api">
<span id="compat32-message"></span><h1><a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.message.Message</span></code></a>: Representar un mensaje de correo electrónico usando la API <a class="reference internal" href="email.policy.html#email.policy.compat32" title="email.policy.compat32"><code class="xref py py-data docutils literal notranslate"><span class="pre">compat32</span></code></a><a class="headerlink" href="#email-message-message-representing-an-email-message-using-the-compat32-api" title="Enlazar permanentemente con este título">¶</a></h1>
<p>La clase <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> es muy similar a la clase <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>, sin los métodos añadidos por esa clase y con el comportamiento predeterminado de algunos otros métodos siendo ligeramente diferente. También documentamos aquí algunos métodos que, aun siendo soportados por <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>, no están recomendados a no ser que estés lidiando con código heredado.</p>
<p>Por lo demás, la filosofía y estructura de las dos clases es la misma.</p>
<p>Este documento describe el comportamiento bajo la política por defecto (para <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a>) <a class="reference internal" href="email.policy.html#email.policy.Compat32" title="email.policy.Compat32"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Compat32</span></code></a>. Si vas a usar otra política, deberías estar usando la clase <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> en su lugar.</p>
<p>Un mensaje de correo electrónico consta de <em>headers</em> y <em>payload</em>. Los encabezados deben ser nombres y valores de estilo <span class="target" id="index-24"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5322.html"><strong>RFC 5322</strong></a>, donde el nombre del campo y el valor están separados por dos puntos. Los dos puntos no forman parte del nombre del campo ni del valor del campo. La carga útil puede ser un mensaje de texto simple, un objeto binario o una secuencia estructurada de submensajes, cada uno con su propio conjunto de encabezados y su propia carga útil. El último tipo de carga útil se indica mediante el mensaje que tiene un tipo MIME como <em class="mimetype">multipart/*</em> o <em class="mimetype">message/rfc822</em>.</p>
<p>El modelo conceptual proporcionado por un objeto <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> es el de un diccionario ordenado de encabezados con métodos adicionales para acceder a información especializada de los encabezados, para acceder a la carga, para generar una versión serializada del mensaje y para recorrer recursivamente el árbol del objeto. Ten en cuenta que son soportados encabezados duplicados pero deben ser usados métodos especiales para acceder a ellos.</p>
<p>El pseudodiccionario <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> es indexado por los nombres de encabezados, los cuales deben ser valores ASCII. Los valores del diccionario son cadenas que se supone que contienen sólo caracteres ASCII; hay algún manejo especial para la entrada no ASCII, pero esta no siempre produce los resultados correctos. Los encabezados son almacenados y retornados preservando mayúsculas y minúsculas, pero los nombres de campos son emparejados sin distinción entre mayúsculas y minúsculas. También puede haber sólo un encabezado de envoltura, también conocido como el encabezado <em>Unix-From</em> o el encabezado <code class="docutils literal notranslate"><span class="pre">From_</span></code>. La carga (<em>payload</em>) es una cadena o bytes, en el caso de objetos de mensajes simples, o una lista de objetos <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a>, para contenedores de documentos MIME (ej. <em class="mimetype">multipart/*</em> y <em class="mimetype">message/rfc822</em>).</p>
<p>Aquí están los métodos de la clase <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a>:</p>
<dl class="py class">
<dt id="email.message.Message">
<em class="property">class </em><code class="sig-prename descclassname">email.message.</code><code class="sig-name descname">Message</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">policy</span><span class="o">=</span><span class="default_value">compat32</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si se especifica <em>policy</em> (debe ser una instancia de una clase <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a>) utiliza las reglas que especifica para actualizar y serializar la representación del mensaje. Si no se define <em>policy</em>, utiliza la política <a class="reference internal" href="email.policy.html#email.policy.Compat32" title="email.policy.Compat32"><code class="xref py py-class docutils literal notranslate"><span class="pre">compat32</span></code></a>, la cual mantiene compatibilidad con la versión de Python 3.2 del paquete email. Para más información consulta la documentación de <a class="reference internal" href="email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>El argumento de palabra clave <em>policy</em> fue añadido.</p>
</div>
<dl class="py method">
<dt id="email.message.Message.as_string">
<code class="sig-name descname">as_string</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">unixfrom</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">maxheaderlen</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">policy</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.as_string" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el mensaje completo aplanado como una cadena. Cuando el parámetro opcional <em>unixfrom</em> es verdadero, el encabezado de envoltura se incluye en la cadena retornada. <em>unixfrom</em> es por defecto <code class="docutils literal notranslate"><span class="pre">False</span></code>. Por razones de compatibilidad con versiones anteriores, <em>maxheaderlen</em> es <code class="docutils literal notranslate"><span class="pre">0</span></code> por defecto, por lo que si quieres un valor diferente debes debes sobreescribirlo explícitamente (el valor especificado por <em>max_line_length</em> en la política será ignorado por este método). El argumento <em>policy</em> puede ser usado para sobrescribir la política por defecto obtenida de la instancia del mensaje. Esto puede ser usado para controlar algo del formato producido por el método, ya que la <em>policy</em> especificada puede ser pasada al <code class="docutils literal notranslate"><span class="pre">Generator</span></code>.</p>
<p>Aplanar el mensaje puede desencadenar cambios en <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> si por defecto necesita ser rellenado para completar la transformación a una cadena (por ejemplo, límites MIME pueden ser generados o modificados).</p>
<p>Note that this method is provided as a convenience and may not always
format the message the way you want.  For example, by default it does
not do the mangling of lines that begin with <code class="docutils literal notranslate"><span class="pre">From</span></code> that is
required by the Unix mbox format.  For more flexibility, instantiate a
<a class="reference internal" href="email.generator.html#email.generator.Generator" title="email.generator.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> instance and use its
<a class="reference internal" href="email.generator.html#email.generator.Generator.flatten" title="email.generator.Generator.flatten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flatten()</span></code></a> method directly.  For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="kn">from</span> <span class="nn">email.generator</span> <span class="kn">import</span> <span class="n">Generator</span>
<span class="n">fp</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">Generator</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">mangle_from_</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">maxheaderlen</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="n">text</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
</pre></div>
</div>
<p>Si el objeto de mensaje contiene datos binarios que no están codificados de acuerdo a los estándares RFC, los datos no compatibles serán reemplazados por puntos de código Unicode de «carácter desconocido». (Consulta también <a class="reference internal" href="#email.message.Message.as_bytes" title="email.message.Message.as_bytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_bytes()</span></code></a> y <a class="reference internal" href="email.generator.html#email.generator.BytesGenerator" title="email.generator.BytesGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">BytesGenerator</span></code></a>.)</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>el argumento de palabra clave <em>policy</em> fue añadido.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.__str__">
<code class="sig-name descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.__str__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Equivalente a <a class="reference internal" href="#email.message.Message.as_string" title="email.message.Message.as_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_string()</span></code></a>. Permite a <code class="docutils literal notranslate"><span class="pre">str(msg)</span></code> producir una cadena conteniendo el mensaje formateado.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.as_bytes">
<code class="sig-name descname">as_bytes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">unixfrom</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">policy</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.as_bytes" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el mensaje completo aplanado como un objeto de bytes. Cuando el argumento opcional <em>unixfrom</em> es verdadero, el encabezado de envoltura se incluye en la cadena retornada. <em>unixfrom</em> es por defecto <code class="docutils literal notranslate"><span class="pre">False</span></code>. El argumento <em>policy</em> puede ser usado para sobrescribir la política por defecto obtenida desde la instancia del mensaje. Esto puede ser usado para controlar algo del formato producido por el método, ya que el <em>policy</em> especificado será pasado al <code class="docutils literal notranslate"><span class="pre">BytesGenerator</span></code>.</p>
<p>Aplanar el mensaje puede desencadenar cambios en <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> si por defecto necesita ser rellenado para completar la transformación a una cadena (por ejemplo, límites MIME pueden ser generados o modificados).</p>
<p>Note that this method is provided as a convenience and may not always
format the message the way you want.  For example, by default it does
not do the mangling of lines that begin with <code class="docutils literal notranslate"><span class="pre">From</span></code> that is
required by the Unix mbox format.  For more flexibility, instantiate a
<a class="reference internal" href="email.generator.html#email.generator.BytesGenerator" title="email.generator.BytesGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">BytesGenerator</span></code></a> instance and use its
<a class="reference internal" href="email.generator.html#email.generator.BytesGenerator.flatten" title="email.generator.BytesGenerator.flatten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">flatten()</span></code></a> method directly.
For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">BytesIO</span>
<span class="kn">from</span> <span class="nn">email.generator</span> <span class="kn">import</span> <span class="n">BytesGenerator</span>
<span class="n">fp</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">()</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">BytesGenerator</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">mangle_from_</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">maxheaderlen</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="n">text</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.__bytes__">
<code class="sig-name descname">__bytes__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.__bytes__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Equivalente a <a class="reference internal" href="#email.message.Message.as_bytes" title="email.message.Message.as_bytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_bytes()</span></code></a>. Permite a <code class="docutils literal notranslate"><span class="pre">bytes(msg)</span></code> producir un objeto de bytes conteniendo el mensaje formateado.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.is_multipart">
<code class="sig-name descname">is_multipart</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.is_multipart" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si la carga del mensaje es una lista de objetos heredados de <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a>, si no retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>. Cuando <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>, la carga debe ser un objeto de cadena (el cual puede ser una carga CTE codificada en binario). (Ten en cuenta que <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> retornando <code class="docutils literal notranslate"><span class="pre">True</span></code> no significa necesariamente que «msg.get_content_maintype() == “multipart”» retornará <code class="docutils literal notranslate"><span class="pre">True</span></code>. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">is_multipart</span></code> retornará <code class="docutils literal notranslate"><span class="pre">True</span></code> cuando el <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> es de tipo <code class="docutils literal notranslate"><span class="pre">message/rfc822</span></code>.)</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.set_unixfrom">
<code class="sig-name descname">set_unixfrom</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">unixfrom</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.set_unixfrom" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece el mensaje del encabezado de envoltura a <em>unixfrom</em>, el cual debe ser una cadena.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.get_unixfrom">
<code class="sig-name descname">get_unixfrom</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_unixfrom" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el mensaje del encabezado de envoltura. Por defecto a <code class="docutils literal notranslate"><span class="pre">None</span></code> si el encabezado de envoltura nunca fue definido.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.attach">
<code class="sig-name descname">attach</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">payload</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.attach" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Añade el <em>payload</em> dado a la carga actual, la cual debe ser <code class="docutils literal notranslate"><span class="pre">None</span></code> o una lista de objetos <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> antes de la invocación. Después de la invocación, la carga siempre será una lista de objetos <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a>. Si quieres definir la carga a un objeto escalar (ej. una cadena), usa <a class="reference internal" href="#email.message.Message.set_payload" title="email.message.Message.set_payload"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_payload()</span></code></a> en su lugar.</p>
<p>Este es un método heredado. En la clase <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> su funcionalidad es remplazada por <a class="reference internal" href="email.message.html#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a> y los métodos relacionados <code class="docutils literal notranslate"><span class="pre">make</span></code> y <code class="docutils literal notranslate"><span class="pre">add</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.get_payload">
<code class="sig-name descname">get_payload</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">decode</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_payload" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la carga (<em>payload</em>) actual, la cual será una lista de objetos <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> cuando <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> es <code class="docutils literal notranslate"><span class="pre">True</span></code>, o una cadena cuando <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> es <code class="docutils literal notranslate"><span class="pre">False</span></code>. Si la carga es una lista y mutas el objeto de lista, modificarás la carga del mensaje.</p>
<p>Con el argumento opcional <em>i</em>, <a class="reference internal" href="#email.message.Message.get_payload" title="email.message.Message.get_payload"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_payload()</span></code></a> retornará el elemento número <em>i</em> de la carga (<em>payload</em>), contando desde cero, si <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> es <code class="docutils literal notranslate"><span class="pre">True</span></code>. Un <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> será generado si <em>i</em> es menor que 0 ó mayor o igual que el número de elementos en la carga. Si la carga es una cadena (ej. <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> es <code class="docutils literal notranslate"><span class="pre">False</span></code>) y se define <em>i</em>, se genera un <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<p>El argumento opcional <em>decode</em> es un indicador que determina si una carga debería ser decodificada o no, de acuerdo al encabezado <em class="mailheader">Content-Transfer-Encoding</em>. Cuando es <code class="docutils literal notranslate"><span class="pre">True</span></code> y el mensaje no es multiparte, la carga será decodificada si el valor de su encabezado es <code class="docutils literal notranslate"><span class="pre">quoted-printable</span></code> o <code class="docutils literal notranslate"><span class="pre">base64</span></code>. Si se usa alguna otra codificación o falta el encabezado <em class="mailheader">Content-Transfer-Encoding</em>, la carga es retornada tal cual (sin decodificar). En todos los casos el valor retornado son datos binarios. Si el mensaje es multiparte y el indicador <em>decode</em> es <code class="docutils literal notranslate"><span class="pre">True</span></code>, entonces se retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>. Si la carga es base64 y no fue perfectamente formada (falta relleno, tiene caracteres fuera del alfabeto base64), entonces un defecto apropiado será añadido a la propiedad defect del mensaje (<code class="xref py py-class docutils literal notranslate"><span class="pre">InvalidBase64PaddingDefect</span></code> o <code class="xref py py-class docutils literal notranslate"><span class="pre">InvalidBase64CharactersDefect</span></code>, respectivamente).</p>
<p>Cuando <em>decode</em> es <code class="docutils literal notranslate"><span class="pre">False</span></code> (por defecto) el cuerpo es retornado como una cadena sin decodificar el <em class="mailheader">Content-Transfer-Encoding</em>. Sin embargo, para un <em class="mailheader">Content-Transfer-Encoding</em> de 8bit, se realiza un intento para decodificar los bytes originales usando el <code class="docutils literal notranslate"><span class="pre">charset</span></code> especificado por el encabezado <em class="mailheader">Content-Type</em>, usando el manejador de error <code class="docutils literal notranslate"><span class="pre">replace</span></code>. Si ningún <code class="docutils literal notranslate"><span class="pre">charset</span></code> es especificado o si el <code class="docutils literal notranslate"><span class="pre">charset</span></code> dado no es reconocido por el paquete email, el cuerpo es decodificado usando el conjunto de caracteres ASCII por defecto.</p>
<p>Este es un método heredado. En la clase <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> su funcionalidad es remplazada por <a class="reference internal" href="email.message.html#email.message.EmailMessage.get_content" title="email.message.EmailMessage.get_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content()</span></code></a> y <a class="reference internal" href="email.message.html#email.message.EmailMessage.iter_parts" title="email.message.EmailMessage.iter_parts"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iter_parts()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.set_payload">
<code class="sig-name descname">set_payload</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">payload</span></em>, <em class="sig-param"><span class="n">charset</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.set_payload" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Define la carga completa del objeto mensaje a <em>payload</em>. Es responsabilidad del cliente asegurar invariantes de carga. El argumento opcional <em>charset</em> define el conjunto de caracteres por defecto del mensaje; consulta <a class="reference internal" href="#email.message.Message.set_charset" title="email.message.Message.set_charset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_charset()</span></code></a> para más detalles.</p>
<p>Este es un método heredado. En la clase <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> su funcionalidad es remplazada por <a class="reference internal" href="email.message.html#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.set_charset">
<code class="sig-name descname">set_charset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">charset</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.set_charset" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Define el junto de caracteres de la carga a <em>charset</em>, el cual puede ser tanto una instancia <a class="reference internal" href="email.charset.html#email.charset.Charset" title="email.charset.Charset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Charset</span></code></a> (ver <a class="reference internal" href="email.charset.html#module-email.charset" title="email.charset: Character Sets"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.charset</span></code></a>), una cadena denominando un conjunto de caracteres, o <code class="docutils literal notranslate"><span class="pre">None</span></code>. Si es una cadena, será convertida a una instancia <a class="reference internal" href="email.charset.html#email.charset.Charset" title="email.charset.Charset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Charset</span></code></a>. Si <em>charset</em> es <code class="docutils literal notranslate"><span class="pre">None</span></code>, el parámetro <code class="docutils literal notranslate"><span class="pre">charset</span></code> será eliminado del encabezado <em class="mailheader">Content-Type</em> (el mensaje no será modificado de otra manera). Cualquier otro valor lanzará un <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<p>Si no hay un encabezado existente <em class="mailheader">MIME-Version</em>, será añadido uno. Si no hay un encabezado existente <em class="mailheader">Content-Type</em>, será añadido uno con valor <em class="mimetype">text/plain</em>. Tanto como si el encabezado <em class="mailheader">Content-Type</em> existe actualmente como si no, su parámetro <code class="docutils literal notranslate"><span class="pre">charset</span></code> será establecido a <em>charset.output_charset</em>. Si <em>charset.input_charset</em> y <em>charset.output_charset</em> difieren, la carga será recodificada al <em>output_charset</em>. Si no hay un encabezado existente <em class="mailheader">Content-Transfer-Encoding</em>, entonces la carga será codificada por transferencia, si es necesario, usando el <a class="reference internal" href="email.charset.html#email.charset.Charset" title="email.charset.Charset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Charset</span></code></a> especificado y un encabezado con el valor apropiado será añadido. Si ya existe un encabezado <em class="mailheader">Content-Transfer-Encoding</em>, la carga se asume que ya está correctamente codificada usando ese <em class="mailheader">Content-Transfer-Encoding</em> y no es modificada.</p>
<p>Este es un método heredado. En la clase <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> su funcionalidad es remplazada por el parámetro <em>charset</em> del método <code class="xref py py-meth docutils literal notranslate"><span class="pre">email.emailmessage.EmailMessage.set_content()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.get_charset">
<code class="sig-name descname">get_charset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_charset" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la instancia <a class="reference internal" href="email.charset.html#email.charset.Charset" title="email.charset.Charset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Charset</span></code></a> asociada con la carga del mensaje.</p>
<p>Este es un método heredado. En la clase <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> siempre retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<p>Los siguientes métodos implementan una interfaz parecida a un mapeo para acceder a los encabezados <span class="target" id="index-25"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2822.html"><strong>RFC 2822</strong></a> del mensaje. Ten en cuenta que hay algunas diferencias semánticas entre esos métodos y una interfaz de mapeo normal (ej. diccionario). Por ejemplo, en un diccionario no hay claves duplicadas, pero aquí pueden haber encabezados de mensaje duplicados. También, en diccionarios no hay un orden garantizado de las claves retornadas por <a class="reference internal" href="#email.message.Message.keys" title="email.message.Message.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code></a>, pero en un objeto <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a>, los encabezados siempre son retornados en el orden que aparecieron en el mensaje original, o en el que fueron añadidos al mensaje más tarde. Cualquier encabezado eliminado y vuelto a adicionar siempre es añadido al final de la lista de encabezados.</p>
<p>Esas diferencias semánticas son intencionales y están sesgadas hacia la máxima comodidad.</p>
<p>Ten en cuenta que en todos los casos, cualquier encabezado de envoltura presente en el mensaje no está incluido en la interfaz de mapeo.</p>
<p>In a model generated from bytes, any header values that (in contravention of
the RFCs) contain non-ASCII bytes will, when retrieved through this
interface, be represented as <a class="reference internal" href="email.header.html#email.header.Header" title="email.header.Header"><code class="xref py py-class docutils literal notranslate"><span class="pre">Header</span></code></a> objects with
a charset of <code class="docutils literal notranslate"><span class="pre">unknown-8bit</span></code>.</p>
<dl class="py method">
<dt id="email.message.Message.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.__len__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el número total de encabezados, incluyendo duplicados.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.__contains__">
<code class="sig-name descname">__contains__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.__contains__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si el objeto mensaje tiene un campo llamado <em>name</em>. La concordancia se realiza sin distinguir mayúsculas de minúsculas y <em>name</em> no debería incluir el caracter de doble punto final. Usado para el operador <code class="docutils literal notranslate"><span class="pre">in</span></code>, ej:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="s1">&#39;message-id&#39;</span> <span class="ow">in</span> <span class="n">myMessage</span><span class="p">:</span>
   <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Message-ID:&#39;</span><span class="p">,</span> <span class="n">myMessage</span><span class="p">[</span><span class="s1">&#39;message-id&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.__getitem__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el valor del campo del encabezado nombrado. <em>name</em> no debe incluir el separador de campo de doble punto. Si falta un encabezado, se retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>; nunca se genera un error <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>.</p>
<p>Ten en cuenta que si el campo nombrado aparece más de una vez en los encabezados del mensaje, no se define cuales serán exactamente aquellos valores de campos retornados. Usa el método <a class="reference internal" href="#email.message.Message.get_all" title="email.message.Message.get_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_all()</span></code></a> para obtener los valores de todos los encabezados nombrados existentes.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.__setitem__">
<code class="sig-name descname">__setitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">val</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.__setitem__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Añade un encabezado al mensaje con el nombre de campo <em>name</em> y el valor <em>val</em>. El campo es añadido al final de los campos existentes del mensaje.</p>
<p>Ten en cuenta que esto no sobreescribe ni elimina ningún encabezado existente con el mismo nombre. Si quieres asegurar que el nuevo encabezado es el único presente en el mensaje con el nombre de campo <em>name</em>, elimina el campo primero, ej:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">del</span> <span class="n">msg</span><span class="p">[</span><span class="s1">&#39;subject&#39;</span><span class="p">]</span>
<span class="n">msg</span><span class="p">[</span><span class="s1">&#39;subject&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Python roolz!&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.__delitem__">
<code class="sig-name descname">__delitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.__delitem__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Elimina todas las ocurrencias de un campo con el nombre <em>name</em> de los encabezados del mensaje. No se genera ninguna excepción si el encabezado nombrado no está presente en los encabezados.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.keys">
<code class="sig-name descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.keys" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una lista de todos los nombres de campos de encabezados del mensaje.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.values">
<code class="sig-name descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.values" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una lista de todos los valores de campos del mensaje.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.items">
<code class="sig-name descname">items</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.items" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una lista de tuplas de dos elementos conteniendo todos los campos y valores de encabezados del mensaje.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.get">
<code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">failobj</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el valor del campo de encabezado nombrado. Esto es idéntico a <a class="reference internal" href="#email.message.Message.__getitem__" title="email.message.Message.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> excepto que el argumento <em>failobj</em> es retornado si falta el encabezado nombrado (por defecto a <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<p>Aquí hay algunos métodos útiles adicionales:</p>
<dl class="py method">
<dt id="email.message.Message.get_all">
<code class="sig-name descname">get_all</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">failobj</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_all" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una lista de todos los valores para el campo denominado <em>name</em>. Si no hay tales encabezados nombrados en el mensaje, retorna <em>failobj</em> (por defecto <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.add_header">
<code class="sig-name descname">add_header</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">_name</span></em>, <em class="sig-param"><span class="n">_value</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">_params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.add_header" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Configuración de encabezado extendida. Este método es similar a <a class="reference internal" href="#email.message.Message.__setitem__" title="email.message.Message.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a> excepto que pueden ser provistos parámetros adicionales de encabezado como argumentos de palabra clave. <em>_name</em> es el campo de encabezado a añadir y <em>_value</em> es el valor <em>primario</em> para el encabezado.</p>
<p>Para cada elemento en el diccionario de argumentos de palabra clave <em>_params</em>, la clave se toma como el nombre del parámetro con guiones bajos convertidos a guiones medios (ya que los guiones medios son ilegales como identificadores en Python). Normalmente, el parámetro será añadido como  <code class="docutils literal notranslate"><span class="pre">key=&quot;value&quot;</span></code> a no ser que el valor sea <code class="docutils literal notranslate"><span class="pre">None</span></code>, en cuyo caso sólo la clave será añadida. Si el valor contiene caracteres no ASCII, puede ser especificado como una tupla de tres elementos en el formato <code class="docutils literal notranslate"><span class="pre">(CHARSET,</span> <span class="pre">LANGUAGE,</span> <span class="pre">VALUE)</span></code>, donde <code class="docutils literal notranslate"><span class="pre">CHARSET</span></code> es una cadena que nombra el conjunto de caracteres a ser usado al codificar el valor, <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code> puede normalmente ser definido a <code class="docutils literal notranslate"><span class="pre">None</span></code> o una cadena vacía (ver <span class="target" id="index-26"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2231.html"><strong>RFC 2231</strong></a> para otras posibilidades) y <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> es la cadena del valor conteniendo puntos de caracteres no ASCII. Si no se pasa una tupla de tres elementos y el valor contiene caracteres no ASCII, se codifica automáticamente en formato <span class="target" id="index-27"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2231.html"><strong>RFC 2231</strong></a> usando <code class="docutils literal notranslate"><span class="pre">CHARSET</span></code> como <code class="docutils literal notranslate"><span class="pre">utf-8</span></code> y <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code> como <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Aquí hay un ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">msg</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;Content-Disposition&#39;</span><span class="p">,</span> <span class="s1">&#39;attachment&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;bud.gif&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Esto añadirá un encabezado que se verá como</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Content</span><span class="o">-</span><span class="n">Disposition</span><span class="p">:</span> <span class="n">attachment</span><span class="p">;</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;bud.gif&quot;</span>
</pre></div>
</div>
<p>Un ejemplo con caracteres no ASCII:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">msg</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;Content-Disposition&#39;</span><span class="p">,</span> <span class="s1">&#39;attachment&#39;</span><span class="p">,</span>
               <span class="n">filename</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;iso-8859-1&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;Fußballer.ppt&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Lo que produce</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Content</span><span class="o">-</span><span class="n">Disposition</span><span class="p">:</span> <span class="n">attachment</span><span class="p">;</span> <span class="n">filename</span><span class="o">*=</span><span class="s2">&quot;iso-8859-1&#39;&#39;Fu%DFballer.ppt&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.replace_header">
<code class="sig-name descname">replace_header</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">_name</span></em>, <em class="sig-param"><span class="n">_value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.replace_header" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Reemplaza un encabezado. Reemplaza el primer encabezado encontrado en el mensaje que concuerda con <em>_name</em>, conservando el orden del encabezado y el nombre del campo. Si no se encuentra ningún encabezado que concuerde, se genera un error <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.get_content_type">
<code class="sig-name descname">get_content_type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_content_type" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el tipo de contenido del mensaje. La cadena retornada se fuerza a letras minúsculas de la forma <em class="mimetype">maintype/subtype</em>. Si no hay ningún encabezado <em class="mailheader">Content-Type</em> en el mensaje será retornado el tipo por defecto como es dado por <a class="reference internal" href="#email.message.Message.get_default_type" title="email.message.Message.get_default_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_default_type()</span></code></a>. Dado que según <span class="target" id="index-28"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2045.html"><strong>RFC 2045</strong></a>, los mensajes tienen siempre un tipo predeterminado, <a class="reference internal" href="#email.message.Message.get_content_type" title="email.message.Message.get_content_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content_type()</span></code></a> siempre retornará un valor.</p>
<p><span class="target" id="index-29"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2045.html"><strong>RFC 2045</strong></a> define el tipo predeterminado del mensaje a <em class="mimetype">text/plain</em> a no ser que aparezca dentro de un contenedor <em class="mimetype">multipart/digest</em>, en cuyo caso sería <em class="mimetype">message/rfc822</em>. Si el encabezado <em class="mailheader">Content-Type</em> tiene una especificación de tipo inválido, <span class="target" id="index-30"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2045.html"><strong>RFC 2045</strong></a> ordena que el tipo por defecto sea <em class="mimetype">text/plain</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.get_content_maintype">
<code class="sig-name descname">get_content_maintype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_content_maintype" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el tipo de contenido principal del mensaje. Esta es la parte <em class="mimetype">maintype</em> de la cadena retornada por <a class="reference internal" href="#email.message.Message.get_content_type" title="email.message.Message.get_content_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content_type()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.get_content_subtype">
<code class="sig-name descname">get_content_subtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_content_subtype" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el tipo del subcontenido del mensaje. Esta es la parte <em class="mimetype">subtype</em> de la cadena retornada por <a class="reference internal" href="#email.message.Message.get_content_type" title="email.message.Message.get_content_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content_type()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.get_default_type">
<code class="sig-name descname">get_default_type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_default_type" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el tipo del contenido por defecto. La mayoría de mensajes tienen un tipo de contenido por defecto de <em class="mimetype">text/plain</em>, excepto para mensajes que son subpartes de contenedores <em class="mimetype">multipart/digest</em>. Tales subpartes tienen como tipo de contenido predeterminado <em class="mimetype">message/rfc822</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.set_default_type">
<code class="sig-name descname">set_default_type</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ctype</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.set_default_type" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece el tipo de contenido por defecto. <em>ctype</em> debería ser <em class="mimetype">text/plain</em> o <em class="mimetype">message/rfc822</em>, aunque esto no es obligatorio. El tipo de contenido predeterminado no se almacena en el encabezado <em class="mailheader">Content-Type</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.get_params">
<code class="sig-name descname">get_params</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">failobj</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">header</span><span class="o">=</span><span class="default_value">'content-type'</span></em>, <em class="sig-param"><span class="n">unquote</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_params" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna los parámetros del <em class="mailheader">Content-Type</em> del mensaje como una lista. Los elementos de la lista retornada son tuplas de dos elementos de pares clave/valor, tal y como son partidas por el signo <code class="docutils literal notranslate"><span class="pre">'='</span></code>. El lado izquierdo del <code class="docutils literal notranslate"><span class="pre">'='</span></code> es la clave, mientras el lado derecho es el valor. Si no hay signo <code class="docutils literal notranslate"><span class="pre">'='</span></code> en el parámetro, el valor es la cadena vacía, en caso contrario el valor es como se describe en <a class="reference internal" href="#email.message.Message.get_param" title="email.message.Message.get_param"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_param()</span></code></a> y no está citado si el parámetro opcional <em>unquote</em> es <code class="docutils literal notranslate"><span class="pre">True</span></code> (por defecto).</p>
<p>El parámetro opcional <em>failobj</em> es el objeto a retornar si no hay encabezado <em class="mailheader">Content-Type</em>. El parámetro opcional <em>header</em> es el encabezado a buscar en lugar de <em class="mailheader">Content-Type</em>.</p>
<p>Este es un método heredado. En la clase <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> su funcionalidad es remplazada por la propiedad <em>params</em> de los objetos individuales de encabezado retornados por los métodos de acceso del encabezado.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.get_param">
<code class="sig-name descname">get_param</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">param</span></em>, <em class="sig-param"><span class="n">failobj</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">header</span><span class="o">=</span><span class="default_value">'content-type'</span></em>, <em class="sig-param"><span class="n">unquote</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_param" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el valor del parámetro <em>param</em> del encabezado <em class="mailheader">Content-Type</em> como una cadena. Si el mensaje no tiene encabezado <em class="mailheader">Content-Type</em> o si no existe tal parámetro, entonces se retorna <em>failobj</em> (por defecto es <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
<p>El parámetro opcional <em>header</em>, si es definido, especifica el encabezado del mensaje a usar en lugar de <em class="mailheader">Content-Type</em>.</p>
<p>Las claves de parámetros siempre son comparadas distinguiendo entre mayúsculas y minúsculas. El valor de retorno puede ser una cadena, una tupla de 3 elementos si el parámetro fue codificado según <span class="target" id="index-31"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2231.html"><strong>RFC 2231</strong></a>. Cuando es una tupla de 3 elementos, los elementos del valor tienen la forma <code class="docutils literal notranslate"><span class="pre">(CHARSET,</span> <span class="pre">LANGUAGE,</span> <span class="pre">VALUE)</span></code>. Ten en cuenta que <code class="docutils literal notranslate"><span class="pre">CHARSET</span></code> y <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code> pueden ser <code class="docutils literal notranslate"><span class="pre">None</span></code>, en cuyo caso debes considerar <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> como codificado en el conjunto de caracteres <code class="docutils literal notranslate"><span class="pre">us-ascii</span></code>. Generalmente puedes ignorar <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code>.</p>
<p>Si a tu aplicación no le importa si el parámetro fue codificado según <span class="target" id="index-32"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2231.html"><strong>RFC 2231</strong></a>, puedes contraer el valor del parámetro invocando <a class="reference internal" href="email.utils.html#email.utils.collapse_rfc2231_value" title="email.utils.collapse_rfc2231_value"><code class="xref py py-func docutils literal notranslate"><span class="pre">email.utils.collapse_rfc2231_value()</span></code></a>, pasando el valor de retorno desde <a class="reference internal" href="#email.message.Message.get_param" title="email.message.Message.get_param"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_param()</span></code></a>. Esto retornará una cadena Unicode convenientemente decodificada cuando el valor es una tupla o la cadena original sin entrecomillar si no lo es. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">rawparam</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">get_param</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="n">param</span> <span class="o">=</span> <span class="n">email</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">collapse_rfc2231_value</span><span class="p">(</span><span class="n">rawparam</span><span class="p">)</span>
</pre></div>
</div>
<p>En cualquier caso, el valor del parámetro (tanto la cadena retornada o el elemento <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> en la tupla de 3 elementos) siempre está sin entrecomillar, a no ser que <em>unquote</em> está establecido a <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>Este es un método heredado. En la clase <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> su funcionalidad es remplazada por la propiedad <em>params</em> de los objetos individuales de encabezado retornados por los métodos de acceso del encabezado.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.set_param">
<code class="sig-name descname">set_param</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">param</span></em>, <em class="sig-param"><span class="n">value</span></em>, <em class="sig-param"><span class="n">header</span><span class="o">=</span><span class="default_value">'Content-Type'</span></em>, <em class="sig-param"><span class="n">requote</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">charset</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">language</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">replace</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.set_param" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece un parámetro en el encabezado <em class="mailheader">Content-Type</em>. Si el parámetro ya existe en el encabezado, su valor será remplazado con <em>value</em>. Si el encabezado <em class="mailheader">Content-Type</em> no ha sido definido todavía para este mensaje, será establecido a <em class="mimetype">text/plain</em> y el nuevo valor del parámetro será añadido según <span class="target" id="index-33"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2045.html"><strong>RFC 2045</strong></a>.</p>
<p>El parámetro opcional <em>header</em> especifica una alternativa a <em class="mailheader">Content-Type</em> y todos los parámetros serán entrecomillados si es necesario a no ser que el parámetro opcional <em>requote</em> sea <code class="docutils literal notranslate"><span class="pre">False</span></code> (por defecto es <code class="docutils literal notranslate"><span class="pre">True</span></code>).</p>
<p>Si se especifica el parámetro opcional <em>charset</em>, el parámetro será codificado de acuerdo a <span class="target" id="index-34"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2231.html"><strong>RFC 2231</strong></a>. El parámetro opcional <em>language</em> especifica el lenguaje RFC 2231, por defecto una cadena vacía. Tanto <em>charset</em> como <em>language</em> deberían ser cadenas.</p>
<p>Si <em>replace</em> es <code class="docutils literal notranslate"><span class="pre">False</span></code> (por defecto) el encabezado será movido al final de la lista de encabezados. Si <em>replace</em> es <code class="docutils literal notranslate"><span class="pre">True</span></code>, el encabezado será actualizado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>el parámetro de palabra clave <code class="docutils literal notranslate"><span class="pre">replace</span></code> fue añadido.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.del_param">
<code class="sig-name descname">del_param</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">param</span></em>, <em class="sig-param"><span class="n">header</span><span class="o">=</span><span class="default_value">'content-type'</span></em>, <em class="sig-param"><span class="n">requote</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.del_param" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Elimina el parámetro dado completamente del encabezado <em class="mailheader">Content-Type</em>. El encabezado será reescrito en sí mismo sin el parámetro o su valor. Todos los valores serán entrecomillados si es necesario a no ser que <em>requote</em> sea <code class="docutils literal notranslate"><span class="pre">False</span></code> (por defecto es <code class="docutils literal notranslate"><span class="pre">True</span></code>). El parámetro opcional <em>header</em> especifica una alternativa a <em class="mailheader">Content-Type</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.set_type">
<code class="sig-name descname">set_type</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">type</span></em>, <em class="sig-param"><span class="n">header</span><span class="o">=</span><span class="default_value">'Content-Type'</span></em>, <em class="sig-param"><span class="n">requote</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.set_type" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece el tipo y subtipo principal para el encabezado <em class="mailheader">Content-Type</em>. <em>type</em> debe ser una cadena de la forma <em class="mimetype">maintype/subtype</em>, si no será generado un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
<p>Este método remplaza el encabezado <em class="mailheader">Content-Type</em>, manteniendo todos los parámetros en su lugar. Si <em>requote</em> es <code class="docutils literal notranslate"><span class="pre">False</span></code>, este dejará el encabezado existente tal como está, en caso contrario los parámetros serán entrecomillados (por defecto).</p>
<p>Un encabezado alternativo puede ser especificado en el argumento <em>header</em>. Cuando el encabezado <em class="mailheader">Content-Type</em> es definido, un encabezado <em class="mailheader">MIME-Version</em> también es añadido.</p>
<p>Este es un método heredado. En la clase <code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> su funcionalidad es remplazada por los métodos <code class="docutils literal notranslate"><span class="pre">make_</span></code> y <code class="docutils literal notranslate"><span class="pre">add_</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.get_filename">
<code class="sig-name descname">get_filename</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">failobj</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_filename" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el valor del parámetro <code class="docutils literal notranslate"><span class="pre">filename</span></code> del encabezado <em class="mailheader">Content-Disposition</em> del mensaje. Si el encabezado no tiene un parámetro <code class="docutils literal notranslate"><span class="pre">filename</span></code>, este método recurre a buscar el parámetro <code class="docutils literal notranslate"><span class="pre">name</span></code> en el encabezado <em class="mailheader">Content-Type</em>. Si tampoco se encuentra o falta el encabezado, entonces retorna <em>failobj</em>. La cadena retornada siempre será sin entrecomillar según <a class="reference internal" href="email.utils.html#email.utils.unquote" title="email.utils.unquote"><code class="xref py py-func docutils literal notranslate"><span class="pre">email.utils.unquote()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.get_boundary">
<code class="sig-name descname">get_boundary</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">failobj</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_boundary" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el valor del parámetro <code class="docutils literal notranslate"><span class="pre">boundary</span></code> del encabezado <em class="mailheader">Content-Type</em> del mensaje o <em>failobj</em> tanto si falta el encabezado como si no tiene parámetro <code class="docutils literal notranslate"><span class="pre">boundary</span></code>. La cadena retornada siempre será sin entrecomillar según <a class="reference internal" href="email.utils.html#email.utils.unquote" title="email.utils.unquote"><code class="xref py py-func docutils literal notranslate"><span class="pre">email.utils.unquote()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.set_boundary">
<code class="sig-name descname">set_boundary</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">boundary</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.set_boundary" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece el parámetro <code class="docutils literal notranslate"><span class="pre">boundary</span></code> del encabezado <em class="mailheader">Content-Type</em> a <em>boundary</em>. <a class="reference internal" href="#email.message.Message.set_boundary" title="email.message.Message.set_boundary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_boundary()</span></code></a> siempre entrecomillará <em>boundary</em> si es necesario. Se genera <a class="reference internal" href="email.errors.html#email.errors.HeaderParseError" title="email.errors.HeaderParseError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HeaderParseError</span></code></a> si el objeto de mensaje no tiene encabezado <em class="mailheader">Content-Type</em>.</p>
<p>Ten en cuenta que usar este método es sutilmente diferente a borrar el antiguo encabezado <em class="mailheader">Content-Type</em> y añadir uno nuevo con el nuevo límite mediante <a class="reference internal" href="#email.message.Message.add_header" title="email.message.Message.add_header"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_header()</span></code></a> porque <a class="reference internal" href="#email.message.Message.set_boundary" title="email.message.Message.set_boundary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_boundary()</span></code></a> preserva el orden del encabezado <em class="mailheader">Content-Type</em> en la lista de encabezados. Sin embargo, no conserva ninguna línea de continuación que pueden haber estado presentes en el encabezado original <em class="mailheader">Content-Type</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.get_content_charset">
<code class="sig-name descname">get_content_charset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">failobj</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_content_charset" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el parámetro <code class="docutils literal notranslate"><span class="pre">charset</span></code> del encabezado <em class="mailheader">Content-Type</em>, forzado a letras minúsculas. Si no hay un encabezado <em class="mailheader">Content-Type</em> o si ese encabezado no tiene parámetro <code class="docutils literal notranslate"><span class="pre">charset</span></code>, se retorna <em>failobj</em>.</p>
<p>Ten en cuenta que este método difiere de <a class="reference internal" href="#email.message.Message.get_charset" title="email.message.Message.get_charset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_charset()</span></code></a>, el cual retorna la instancia <a class="reference internal" href="email.charset.html#email.charset.Charset" title="email.charset.Charset"><code class="xref py py-class docutils literal notranslate"><span class="pre">Charset</span></code></a> para la codificación por defecto del cuerpo del mensaje.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.get_charsets">
<code class="sig-name descname">get_charsets</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">failobj</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_charsets" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una lista conteniendo los nombres de los conjuntos de caracteres en el mensaje. Si el mensaje es <em class="mimetype">multipart</em>, entonces la lista contendrá un elemento para cada subparte en la carga (<em>payload</em>), en caso contrario será una lista de un elemento.</p>
<p>Cada elemento en la lista será una cadena la cual es el valor del parámetro <code class="docutils literal notranslate"><span class="pre">charset</span></code> en el encabezado <em class="mailheader">Content-Type</em> para la subparte representada. Sin embargo, si la subparte no tiene encabezado <em class="mailheader">Content-Type</em>, no tiene parámetro <code class="docutils literal notranslate"><span class="pre">charset</span></code> o no es del tipo MIME <em class="mimetype">text</em> principal, entonces ese elemento en la lista retornada será <em>failobj</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.get_content_disposition">
<code class="sig-name descname">get_content_disposition</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_content_disposition" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el valor en minúsculas (sin parámetros) del encabezado del mensaje <em class="mailheader">Content-Disposition</em> si tiene uno o <code class="docutils literal notranslate"><span class="pre">None</span></code>. Los valores posibles para este método son <em>inline</em>, <em>attachment</em> o <code class="docutils literal notranslate"><span class="pre">None</span></code> si el mensaje sigue el <span class="target" id="index-35"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2183.html"><strong>RFC 2183</strong></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="email.message.Message.walk">
<code class="sig-name descname">walk</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.walk" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El método <a class="reference internal" href="#email.message.Message.walk" title="email.message.Message.walk"><code class="xref py py-meth docutils literal notranslate"><span class="pre">walk()</span></code></a> es un generador de todo propósito el cual puede ser usado para iterar sobre todas las partes y subpartes de árbol de objeto de mensaje, en orden de recorrido de profundidad primero. Siempre usarás típicamente <a class="reference internal" href="#email.message.Message.walk" title="email.message.Message.walk"><code class="xref py py-meth docutils literal notranslate"><span class="pre">walk()</span></code></a> como iterador en un bucle <code class="docutils literal notranslate"><span class="pre">for</span></code>; cada iteración retorna la siguiente subparte.</p>
<p>Aquí hay un ejemplo que imprime el tipo MIME de cada parte de una estructura de mensaje multiparte:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">msg</span><span class="o">.</span><span class="n">walk</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">get_content_type</span><span class="p">())</span>
<span class="go">multipart/report</span>
<span class="go">text/plain</span>
<span class="go">message/delivery-status</span>
<span class="go">text/plain</span>
<span class="go">text/plain</span>
<span class="go">message/rfc822</span>
<span class="go">text/plain</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">walk</span></code> itera sobre las subpartes de cualquier parte donde <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> retorna <code class="docutils literal notranslate"><span class="pre">True</span></code>, aunque <code class="docutils literal notranslate"><span class="pre">msg.get_content_maintype()</span> <span class="pre">==</span> <span class="pre">'multipart'</span></code> puede retornar <code class="docutils literal notranslate"><span class="pre">False</span></code>. Vemos esto en nuestro ejemplo haciendo uso de la función de ayuda de depuración <code class="docutils literal notranslate"><span class="pre">_structure</span></code>:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">msg</span><span class="o">.</span><span class="n">walk</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">get_content_maintype</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;multipart&#39;</span><span class="p">,</span>
<span class="gp">... </span>          <span class="n">part</span><span class="o">.</span><span class="n">is_multipart</span><span class="p">())</span>
<span class="go">True True</span>
<span class="go">False False</span>
<span class="go">False True</span>
<span class="go">False False</span>
<span class="go">False False</span>
<span class="go">False True</span>
<span class="go">False False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_structure</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="go">multipart/report</span>
<span class="go">    text/plain</span>
<span class="go">    message/delivery-status</span>
<span class="go">        text/plain</span>
<span class="go">        text/plain</span>
<span class="go">    message/rfc822</span>
<span class="go">        text/plain</span>
</pre></div>
</div>
<p>Aquí las partes de <code class="docutils literal notranslate"><span class="pre">message``no</span> <span class="pre">son</span> <span class="pre">``multiparts</span></code>, pero contienen subpartes. <code class="docutils literal notranslate"><span class="pre">is_multipart()</span></code> retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> y <code class="docutils literal notranslate"><span class="pre">walk</span></code> desciende a las subpartes.</p>
</dd></dl>

<p>Los objetos <a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> pueden contener opcionalmente dos atributos de instancia, los cuales pueden ser usados al generar el texto plano de un mensaje MIME.</p>
<dl class="py attribute">
<dt id="email.message.Message.preamble">
<code class="sig-name descname">preamble</code><a class="headerlink" href="#email.message.Message.preamble" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El formato de un documento MIME permite algo de texto entre la línea en blanco que sigue a los encabezados y la primera cadena límite multiparte. Normalmente, este texto nunca es visible en un lector de correo compatible con MIME porque queda fuera de la armadura MIME estándar. Sin embargo, viendo el texto del mensaje en crudo o viendo el mensaje en un lector no compatible con MIME, este texto puede volverse visible.</p>
<p>El atributo <em>preamble</em> contiene este texto de refuerzo adicional para documentos MIME. Cuando el <a class="reference internal" href="email.parser.html#email.parser.Parser" title="email.parser.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parser</span></code></a> descubre algo de texto después de los encabezados pero antes de la primera cadena límite, asigna este texto al atributo <em>preamble</em> del mensaje. Cuando el <a class="reference internal" href="email.generator.html#email.generator.Generator" title="email.generator.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> está escribiendo la representación de texto sin formato de un mensaje MIME y puede encontrar el mensaje como un atributo <em>preamble</em>, escribirá este texto en el área entre los encabezados y el primer límite. Consulta <a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.parser</span></code></a> y <a class="reference internal" href="email.generator.html#module-email.generator" title="email.generator: Generate flat text email messages from a message structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.generator</span></code></a> para más detalles.</p>
<p>Ten en cuenta que si el objeto de mensaje no tiene preámbulo, el atributo <em>preamble</em> será <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="email.message.Message.epilogue">
<code class="sig-name descname">epilogue</code><a class="headerlink" href="#email.message.Message.epilogue" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El atributo <em>epilogue</em> actúa de la misma manera que el atributo <em>preamble</em>, excepto que contiene texto que aparece entre el último límite y el fin del mensaje.</p>
<p>No necesitas establecer el epílogo de la cadena vacía en orden para el <a class="reference internal" href="email.generator.html#email.generator.Generator" title="email.generator.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> para imprimir una nueva línea al final del archivo.</p>
</dd></dl>

<dl class="py attribute">
<dt id="email.message.Message.defects">
<code class="sig-name descname">defects</code><a class="headerlink" href="#email.message.Message.defects" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El atributo <em>defects</em> contiene una lista de todos los problemas encontrados al analizar este mensaje. Consulta <a class="reference internal" href="email.errors.html#module-email.errors" title="email.errors: The exception classes used by the email package."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.errors</span></code></a> para una descripción detallada de los posibles defectos de análisis.</p>
</dd></dl>

</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Tema anterior</h4>
  <p class="topless"><a href="email.examples.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code>: Ejemplos</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="email.mime.html"
                        title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.mime</span></code>: Creación de correo electrónico y objetos MIME desde cero</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/email.compat32-message.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="email.mime.html" title="email.mime: Creación de correo electrónico y objetos MIME desde cero"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="email.examples.html" title="email: Ejemplos"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La Biblioteca Estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="netdata.html" >Manejo de Datos de Internet</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="email.html" ><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code> — Un paquete de manejo de correo electrónico y MIME</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.message.Message</span></code>: Representar un mensaje de correo electrónico usando la API <code class="xref py py-data docutils literal notranslate"><span class="pre">compat32</span></code></a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 27, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>