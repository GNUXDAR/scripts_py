
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>dataclasses — Clases de datos &#8212; documentación de Python - 3.10.10</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.10.10"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="contextlib — Utilidades para declaraciones de contexto with" href="contextlib.html" />
    <link rel="prev" title="warnings — Control de advertencias" href="warnings.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/dataclasses.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dataclasses</span></code> — Clases de datos</a><ul>
<li><a class="reference internal" href="#module-contents">Contenidos del módulo</a></li>
<li><a class="reference internal" href="#post-init-processing">Procesamiento posterior a la inicialización</a></li>
<li><a class="reference internal" href="#class-variables">Variables de clase</a></li>
<li><a class="reference internal" href="#init-only-variables">Variable de solo inicialización</a></li>
<li><a class="reference internal" href="#frozen-instances">Instancias congeladas</a></li>
<li><a class="reference internal" href="#inheritance">Herencia</a></li>
<li><a class="reference internal" href="#re-ordering-of-keyword-only-parameters-in-init">Reordenar los parámetros de solo palabras clave en <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a></li>
<li><a class="reference internal" href="#default-factory-functions">Funciones fábrica por defecto</a></li>
<li><a class="reference internal" href="#mutable-default-values">Valores por defecto mutables</a></li>
<li><a class="reference internal" href="#descriptor-typed-fields">Descriptor-typed fields</a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="warnings.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code> — Control de advertencias</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="contextlib.html"
                        title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code> — Utilidades para declaraciones de contexto <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/dataclasses.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="contextlib.html" title="contextlib — Utilidades para declaraciones de contexto with"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="warnings.html" title="warnings — Control de advertencias"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La Biblioteca Estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="python.html" accesskey="U">Servicios en tiempo de ejecución de Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">dataclasses</span></code> — Clases de datos</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-dataclasses">
<span id="dataclasses-data-classes"></span><h1><a class="reference internal" href="#module-dataclasses" title="dataclasses: Generate special methods on user-defined classes."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dataclasses</span></code></a> — Clases de datos<a class="headerlink" href="#module-dataclasses" title="Enlazar permanentemente con este título">¶</a></h1>
<p><strong>Código fuente:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/dataclasses.py">Lib/dataclasses.py</a></p>
<hr class="docutils" />
<p>Este módulo provee un decorador y funciones para añadir <a class="reference internal" href="../glossary.html#term-special-method"><span class="xref std std-term">métodos especiales</span></a> automáticamente, como <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code> por ejemplo, a clases definidas por el usuario. Fue originalmente descrito en <span class="target" id="index-5"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0557"><strong>PEP 557</strong></a>.</p>
<p>Las variables miembro a utilizar en estos métodos generados son definidas teniendo en cuenta anotaciones de tipo <span class="target" id="index-6"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a>. Por ejemplo, en este código:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">InventoryItem</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class for keeping track of an item in inventory.&quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">unit_price</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">quantity_on_hand</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">total_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit_price</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantity_on_hand</span>
</pre></div>
</div>
<p>Añadirá, además de otros métodos, un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> con la siguiente estructura:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">unit_price</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">quantity_on_hand</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">unit_price</span> <span class="o">=</span> <span class="n">unit_price</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">quantity_on_hand</span> <span class="o">=</span> <span class="n">quantity_on_hand</span>
</pre></div>
</div>
<p>Es importante observar que este método es añadido a la clase automáticamente; está implícito en la definición de <code class="docutils literal notranslate"><span class="pre">InventoryItem</span></code> implementada arriba.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
<section id="module-contents">
<h2>Contenidos del módulo<a class="headerlink" href="#module-contents" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="py function">
<dt id="dataclasses.dataclass">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">dataclasses.</code><code class="sig-name descname">dataclass</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">init</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">repr</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">eq</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">unsafe_hash</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">frozen</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">match_args</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">kw_only</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">slots</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dataclasses.dataclass" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta función es un <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> utilizado para añadir a las clases <a class="reference internal" href="../glossary.html#term-special-method"><span class="xref std std-term">los métodos especiales</span></a> generados, como se describe a continuación.</p>
<p>El decorador <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> examina la clase para encontrar <code class="docutils literal notranslate"><span class="pre">fields</span></code>. Un <code class="docutils literal notranslate"><span class="pre">field</span></code> (“campo”) se define como una variable de clase que tiene una <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">anotación de variable</span></a>. A excepción de los dos casos descritos debajo, nada en <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> examina el tipo especificado en la anotación de variable.</p>
<p>El orden de los campos en los métodos generados es el mismo en el que se encuentran en la definición de la clase.</p>
<p>El decorador <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> añade varios métodos «<em>dunder</em>» (abreviación de <em>double underline</em>) a la clase, descritos a continuación. Si alguno de los métodos añadidos ya existe en la definición de la clase, el comportamiento dependerá del parámetro, como se documenta abajo. El decorador retorna la misma clase con la que es llamado, no crea una nueva.</p>
<p>Si <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> es llamado como un simple decorador sin parámetros, actúa con los valores por defecto documentados aquí. Específicamente, los siguientes tres usos de <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> son equivalentes:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="o">...</span>

<span class="nd">@dataclass</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="o">...</span>

<span class="nd">@dataclass</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">repr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">eq</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unsafe_hash</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">frozen</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
           <span class="n">match_args</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kw_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">slots</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
   <span class="o">...</span>
</pre></div>
</div>
<p>Los parámetros de <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> son:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">init</span></code>: Si es verdadero (valor por defecto), el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> será generado.</p>
<p>Si la clase ya define <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code>, este parámetro es ignorado.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">repr</span></code>: Si es verdadero (valor por defecto), el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code> es generado. La cadena de representación generada tendrá el nombre de la clase junto al nombre y la representación de cada uno de sus campos, en el mismo orden en el que están definidos en la clase. Es posible indicar que ciertos campos no sean incluidos en la representación. Por ejemplo: <code class="docutils literal notranslate"><span class="pre">InventoryItem(name='widget',</span> <span class="pre">unit_price=3.0,</span> <span class="pre">quantity_on_hand=10)</span></code>.</p>
<p>Si la clase ya define <code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code>, este parámetro es ignorado.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">eq</span></code>: Si es verdadero (por defecto), el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code> es generado. Este método compara entre instancias de la clase representando cada una de ellas mediante una tupla, siendo los elementos de la misma los campos de la clase ubicados en el mismo orden en el que fueron definidos (dos tuplas son iguales si, y sólo si, sus campos son iguales).</p>
<p>Si la clase ya define <code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code>, este parámetro es ignorado.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">order</span></code>: Si es verdadero (<code class="docutils literal notranslate"><span class="pre">False</span></code> es el valor por defecto), los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code> serán generados. Estos métodos comparan la clase como si fuera una tupla con sus campos, en orden. Ambas instancias en la comparación deben ser del mismo tipo. Si <code class="docutils literal notranslate"><span class="pre">order</span></code> es verdadero y <code class="docutils literal notranslate"><span class="pre">eq</span></code> falso, se lanza una excepción <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
<p>Si la clase ya define <code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code> o <code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code>, se lanza una excepción <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">unsafe_hash</span></code>: Si es <code class="docutils literal notranslate"><span class="pre">False</span></code> (por defecto), se genera el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> de acuerdo a los valores de <code class="docutils literal notranslate"><span class="pre">eq</span></code> y <code class="docutils literal notranslate"><span class="pre">frozen</span></code> definidos.</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> es utilizado por la función incorporada <a class="reference internal" href="functions.html#hash" title="hash"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hash()</span></code></a> y cuando los objetos definidos por la clase son añadidos a colecciones hash, como por ejemplo diccionarios y conjuntos. Definir el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> en una clase implica que sus instancias son inmutables. La mutabilidad es una propiedad compleja, ya que depende de cómo el programador utilice el objeto, la existencia y comportamiento de <code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code> y del valor asignado a las flags <code class="docutils literal notranslate"><span class="pre">eq</span></code> y <code class="docutils literal notranslate"><span class="pre">frozen</span></code> en el decorador <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a>.</p>
<p>Por defecto, <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> no añade de forma implícita el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> a menos que sea seguro hacerlo. Tampoco añade o cambia un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> previamente definido de forma explícita. Definir el atributo de clase <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> tiene un significado específico en Python, descrito en la documentación dedicada a <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code>.</p>
<p>Si <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> no está definido explícitamente, o si está configurado como <code class="docutils literal notranslate"><span class="pre">None</span></code>, entonces <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> <em>puede</em> agregar un método implícito <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code>. Aunque no se recomienda, puede forzar un <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> a crear un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> con <code class="docutils literal notranslate"><span class="pre">unsafe_hash=True</span></code>. Este podría ser el caso si su clase es lógicamente inmutable pero, no obstante, puede mutar. Este es un caso de uso especializado y debe considerarse detenidamente.</p>
<p>A continuación se explican las reglas que se aplican en la creación implícita del método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code>. Observar que no es compatible definir explícitamente un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> en su clase de datos y al mismo tiempo asignar <code class="docutils literal notranslate"><span class="pre">unsafe_hash=True</span></code>; esto lanza una excepción <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<p>Si <code class="docutils literal notranslate"><span class="pre">eq</span></code> y <code class="docutils literal notranslate"><span class="pre">frozen</span></code> son ambos verdaderos, <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> genera por defecto un método <a class="reference internal" href="functions.html#hash" title="hash"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hash()</span></code></a> por ti. En el caso que <code class="docutils literal notranslate"><span class="pre">eq</span></code> sea verdadero y <code class="docutils literal notranslate"><span class="pre">frozen</span></code> falso, a <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> se le asigna <code class="docutils literal notranslate"><span class="pre">None</span></code>, en consecuencia será <em>unhashable</em> (lo cual es deseable, ya que es mutable). Si <code class="docutils literal notranslate"><span class="pre">eq</span></code> es falso, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> permanece sin cambios, por lo que en este caso se hará uso del método <a class="reference internal" href="functions.html#hash" title="hash"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hash()</span></code></a> heredado de la superclase (lo que implica que si la superclase es <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>, se aplicará el <em>hashing</em> basado en el id de los objetos).</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">frozen</span></code>: Si es verdadero (el valor por defecto es <code class="docutils literal notranslate"><span class="pre">False</span></code>), cualquier intento de asignación a un campo de la clase lanza una excepción. Esto emula el comportamiento de las instancias congeladas (<em>frozen</em>) de sólo lectura. Si <code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code> o <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delattr__()</span></code> son definidos en la clase, se lanzará una excepción <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>. Esto es ampliado más abajo.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">match_args</span></code>: si es verdadero (el valor predeterminado es <code class="docutils literal notranslate"><span class="pre">True</span></code>), la tupla <code class="docutils literal notranslate"><span class="pre">__match_args__</span></code> se creará a partir de la lista de parámetros para el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> generado (incluso si no se genera <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code>, consulte más arriba). Si es falso, o si <code class="docutils literal notranslate"><span class="pre">__match_args__</span></code> ya está definido en la clase, no se generará <code class="docutils literal notranslate"><span class="pre">__match_args__</span></code>.</p></li>
</ul>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</div></blockquote>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">kw_only</span></code>: si es verdadero (el valor predeterminado es <code class="docutils literal notranslate"><span class="pre">False</span></code>), todos los campos se marcarán solo como palabra clave. Si un campo está marcado como solo de palabra clave, el único efecto es que el parámetro <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> generado a partir de un campo de solo palabra clave debe especificarse con una palabra clave cuando se llama a <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code>. No hay ningún efecto sobre ningún otro aspecto de las clases de datos. Consulte la entrada del glosario <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parameter</span></a> para obtener más detalles. Consulte también la sección <a class="reference internal" href="#dataclasses.KW_ONLY" title="dataclasses.KW_ONLY"><code class="xref py py-const docutils literal notranslate"><span class="pre">KW_ONLY</span></code></a>.</p></li>
</ul>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</div></blockquote>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">slots</span></code>: si es verdadero (el valor predeterminado es <code class="docutils literal notranslate"><span class="pre">False</span></code>), se generará el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code> y se devolverá una nueva clase en lugar de la original. Si <code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code> ya está definido en la clase, se genera <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p></li>
</ul>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</div></blockquote>
<p>Los <code class="docutils literal notranslate"><span class="pre">fields</span></code> pueden especificar un valor por defecto opcionalmente, simplemente usando la sintaxis normal de Python:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">int</span>       <span class="c1"># &#39;a&#39; has no default value</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># assign a default value for &#39;b&#39;</span>
</pre></div>
</div>
<p>En este ejemplo, tanto <code class="docutils literal notranslate"><span class="pre">a</span></code> como <code class="docutils literal notranslate"><span class="pre">b</span></code> serán incluidos en el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> agregado, el cual será definido como sigue:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
</pre></div>
</div>
<p>Si, en la definición de una clase, a un campo con valor por defecto le sigue un campo sin valor por defecto será lanzada una excepción <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>. Esto se aplica también a la implementación de una clase única o como resultado de herencia de clases.</p>
</dd></dl>

<dl class="py function">
<dt id="dataclasses.field">
<code class="sig-prename descclassname">dataclasses.</code><code class="sig-name descname">field</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">MISSING</span></em>, <em class="sig-param"><span class="n">default_factory</span><span class="o">=</span><span class="default_value">MISSING</span></em>, <em class="sig-param"><span class="n">init</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">repr</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">hash</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">compare</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">metadata</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kw_only</span><span class="o">=</span><span class="default_value">MISSING</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dataclasses.field" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Para casos de uso común, estas funcionalidades son suficientes. Sin embargo, existen otras características de las clases de datos que requieren información adicional en ciertos campos. Para satisfacer esta necesidad, es posible reemplazar cualquier valor por defecto de un campo mediante una llamada a la función <a class="reference internal" href="#dataclasses.field" title="dataclasses.field"><code class="xref py py-func docutils literal notranslate"><span class="pre">field()</span></code></a>. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">mylist</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="n">c</span><span class="o">.</span><span class="n">mylist</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>Como se muestra arriba, el valor <a class="reference internal" href="#dataclasses.MISSING" title="dataclasses.MISSING"><code class="xref py py-const docutils literal notranslate"><span class="pre">MISSING</span></code></a> es un objeto centinela que se usa para detectar si el usuario proporciona algunos parámetros. Este centinela se utiliza porque <code class="docutils literal notranslate"><span class="pre">None</span></code> es un valor válido para algunos parámetros con un significado distinto. Ningún código debe utilizar directamente el valor <a class="reference internal" href="#dataclasses.MISSING" title="dataclasses.MISSING"><code class="xref py py-const docutils literal notranslate"><span class="pre">MISSING</span></code></a>.</p>
<p>Los parámetros de <a class="reference internal" href="#dataclasses.field" title="dataclasses.field"><code class="xref py py-func docutils literal notranslate"><span class="pre">field()</span></code></a> son:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">default</span></code>: Si es provisto, este será el valor por defecto para este campo. Es necesario que sea definido ya que la propia llamada a <a class="reference internal" href="#dataclasses.field" title="dataclasses.field"><code class="xref py py-meth docutils literal notranslate"><span class="pre">field()</span></code></a> reemplaza la posición normal del valor por defecto.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">default_factory</span></code>: Si es provisto, debe ser un objeto invocable sin argumentos, el cual será llamado cuando el valor por defecto de este campo sea necesario. Además de otros propósitos, puede ser utilizado para especificar campos con valores por defecto mutables, como se explica a continuación. Especificar tanto <code class="docutils literal notranslate"><span class="pre">default</span></code> como <code class="docutils literal notranslate"><span class="pre">default_factory</span></code> resulta en un error.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">init</span></code>: Si es verdadero (por defecto), este campo es incluido como parámetro del método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> generado.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">repr</span></code>: Si es verdadero (por defecto), este campo es incluido en la cadena de caracteres que retorna el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code> generado.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hash</span></code>: Su valor puede ser de tipo booleano o <code class="docutils literal notranslate"><span class="pre">None</span></code>. Si es verdadero, este campo es incluido en el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> generado. Si es <code class="docutils literal notranslate"><span class="pre">None</span></code> (por defecto), utiliza el valor de <code class="docutils literal notranslate"><span class="pre">compare</span></code>: normalmente éste es el comportamiento esperado. Un campo debería ser considerado para el <em>hash</em> si es compatible con operaciones de comparación. Está desaconsejado establecer este valor en algo que no sea <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Una posible razón para definir <code class="docutils literal notranslate"><span class="pre">hash=False</span></code> y <code class="docutils literal notranslate"><span class="pre">compare=True</span></code> podría ser el caso en el que computar el valor <em>hash</em> para dicho campo es costoso pero el campo es necesario para los métodos de comparación, siempre que existan otros campos que contribuyen al valor hash del tipo. Incluso si un campo se excluye del hash, se seguirá utilizando a la hora de comparar.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">compare</span></code>: Si es verdadero (por defecto), este campo es incluido en los métodos de comparación generados (<code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code> y otros).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">metadata</span></code>: Puede ser un mapeo o <em>None</em>. <em>None</em> es tratado como un diccionario vacío. Este valor es envuelto en <a class="reference internal" href="types.html#types.MappingProxyType" title="types.MappingProxyType"><code class="xref py py-func docutils literal notranslate"><span class="pre">MappingProxyType()</span></code></a> para que sea de sólo lectura y visible en el objeto <a class="reference internal" href="#dataclasses.Field" title="dataclasses.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a>. No es utilizado por las clases de datos, mas bien es provisto como un mecanismo de extensión de terceros. Varios terceros pueden tener su propia clave para utilizar como espacio de nombres en <em>metadata</em>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">kw_only</span></code>: si es verdadero, este campo se marcará como solo palabra clave. Se utiliza cuando se calculan los parámetros del método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> generado.</p></li>
</ul>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</div></blockquote>
<p>Si el valor por defecto de un campo es especificado por una llamada a <a class="reference internal" href="#dataclasses.field" title="dataclasses.field"><code class="xref py py-func docutils literal notranslate"><span class="pre">field()</span></code></a>, los atributos de clase para este campo serán reemplazados por los especificados en el valor <code class="docutils literal notranslate"><span class="pre">default</span></code>. Si el valor de <code class="docutils literal notranslate"><span class="pre">default</span></code> no es provisto, el atributo de clase será eliminado. La idea es que, después que la ejecución del decorador <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a>, todos los atributos de la clase contengan los valores por defecto de cada campo, como si fueran definidos uno por uno. Por ejemplo, luego de:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="nb">repr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="nb">repr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">t</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span>
</pre></div>
</div>
<p>El atributo de clase <code class="docutils literal notranslate"><span class="pre">C.z</span></code> será <code class="docutils literal notranslate"><span class="pre">10</span></code>, el atributo de clase <code class="docutils literal notranslate"><span class="pre">C.t</span></code> será <code class="docutils literal notranslate"><span class="pre">20</span></code> y los atributos de clase <code class="docutils literal notranslate"><span class="pre">C.x</span></code> y <code class="docutils literal notranslate"><span class="pre">C.y</span></code> no serán definidos.</p>
</dd></dl>

<dl class="py class">
<dt id="dataclasses.Field">
<em class="property">class </em><code class="sig-prename descclassname">dataclasses.</code><code class="sig-name descname">Field</code><a class="headerlink" href="#dataclasses.Field" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Los objetos <a class="reference internal" href="#dataclasses.Field" title="dataclasses.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> describen cada campo definido. Estos objetos son creados internamente y son retornados por el método <a class="reference internal" href="#dataclasses.fields" title="dataclasses.fields"><code class="xref py py-func docutils literal notranslate"><span class="pre">fields()</span></code></a> definido en este módulo (explicado más abajo). Los usuarios no deben instanciar un objeto <a class="reference internal" href="#dataclasses.Field" title="dataclasses.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> directamente. Sus atributos documentados son:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>: El nombre del campo.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code>: El tipo del campo.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">default</span></code>, <code class="docutils literal notranslate"><span class="pre">default_factory</span></code>, <code class="docutils literal notranslate"><span class="pre">init</span></code>, <code class="docutils literal notranslate"><span class="pre">repr</span></code>, <code class="docutils literal notranslate"><span class="pre">hash</span></code>, <code class="docutils literal notranslate"><span class="pre">compare</span></code> y <code class="docutils literal notranslate"><span class="pre">metadata</span></code> tienen los mismos valores y significados respecto a la declaración de <a class="reference internal" href="#dataclasses.field" title="dataclasses.field"><code class="xref py py-func docutils literal notranslate"><span class="pre">field()</span></code></a> (ver arriba).</p></li>
</ul>
</div></blockquote>
<p>Pueden existir otros atributos, pero son privados y no deberían ser considerados ni depender de ellos.</p>
</dd></dl>

<dl class="py function">
<dt id="dataclasses.fields">
<code class="sig-prename descclassname">dataclasses.</code><code class="sig-name descname">fields</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">class_or_instance</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dataclasses.fields" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una tupla de objetos <a class="reference internal" href="#dataclasses.Field" title="dataclasses.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> que definen los campos para esta clase de datos. Acepta tanto una clase de datos como una instancia de esta. Lanza una excepción <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> si se le pasa cualquier otro objeto. No retorna pseudocampos, que son <code class="docutils literal notranslate"><span class="pre">ClassVar</span></code> o <code class="docutils literal notranslate"><span class="pre">InitVar</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="dataclasses.asdict">
<code class="sig-prename descclassname">dataclasses.</code><code class="sig-name descname">asdict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">dict_factory</span><span class="o">=</span><span class="default_value">dict</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dataclasses.asdict" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Converts the dataclass <code class="docutils literal notranslate"><span class="pre">obj</span></code> to a dict (by using the
factory function <code class="docutils literal notranslate"><span class="pre">dict_factory</span></code>).  Each dataclass is converted
to a dict of its fields, as <code class="docutils literal notranslate"><span class="pre">name:</span> <span class="pre">value</span></code> pairs.  dataclasses, dicts,
lists, and tuples are recursed into.  Other objects are copied with
<a class="reference internal" href="copy.html#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a>.</p>
<p>Example of using <a class="reference internal" href="#dataclasses.asdict" title="dataclasses.asdict"><code class="xref py py-func docutils literal notranslate"><span class="pre">asdict()</span></code></a> on nested dataclasses:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
     <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
     <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
     <span class="n">mylist</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Point</span><span class="p">]</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">asdict</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">}</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">([</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">Point</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="k">assert</span> <span class="n">asdict</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;mylist&#39;</span><span class="p">:</span> <span class="p">[{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}]}</span>
</pre></div>
</div>
<p>To create a shallow copy, the following workaround may be used:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">dict</span><span class="p">((</span><span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">))</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
</pre></div>
</div>
<p><a class="reference internal" href="#dataclasses.asdict" title="dataclasses.asdict"><code class="xref py py-func docutils literal notranslate"><span class="pre">asdict()</span></code></a> raises <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> if <code class="docutils literal notranslate"><span class="pre">obj</span></code> is not a dataclass
instance.</p>
</dd></dl>

<dl class="py function">
<dt id="dataclasses.astuple">
<code class="sig-prename descclassname">dataclasses.</code><code class="sig-name descname">astuple</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">tuple_factory</span><span class="o">=</span><span class="default_value">tuple</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dataclasses.astuple" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Converts the dataclass <code class="docutils literal notranslate"><span class="pre">obj</span></code> to a tuple (by using the
factory function <code class="docutils literal notranslate"><span class="pre">tuple_factory</span></code>).  Each dataclass is converted
to a tuple of its field values.  dataclasses, dicts, lists, and
tuples are recursed into. Other objects are copied with
<a class="reference internal" href="copy.html#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a>.</p>
<p>Continuando con el ejemplo anterior:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">astuple</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">astuple</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],)</span>
</pre></div>
</div>
<p>To create a shallow copy, the following workaround may be used:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">fields</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
</pre></div>
</div>
<p><a class="reference internal" href="#dataclasses.astuple" title="dataclasses.astuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">astuple()</span></code></a> raises <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> if <code class="docutils literal notranslate"><span class="pre">obj</span></code> is not a dataclass
instance.</p>
</dd></dl>

<dl class="py function">
<dt id="dataclasses.make_dataclass">
<code class="sig-prename descclassname">dataclasses.</code><code class="sig-name descname">make_dataclass</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cls_name</span></em>, <em class="sig-param"><span class="n">fields</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">bases</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">namespace</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">init</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">repr</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">eq</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">unsafe_hash</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">frozen</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">match_args</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">kw_only</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">slots</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dataclasses.make_dataclass" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea una nueva clase de datos con el nombre <code class="docutils literal notranslate"><span class="pre">cls_name</span></code>, con los campos definidos en <code class="docutils literal notranslate"><span class="pre">fields</span></code>, con las clases base dadas en <code class="docutils literal notranslate"><span class="pre">bases</span></code> e inicializada con el espacio de nombres dado en <code class="docutils literal notranslate"><span class="pre">namespace</span></code>. <code class="docutils literal notranslate"><span class="pre">fields</span></code> es un iterable que cumple con una de estas formas: <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">type)</span></code> o <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">type,</span> <span class="pre">Field)</span></code>. Si solo <code class="docutils literal notranslate"><span class="pre">name</span></code> es proporcionado, <code class="docutils literal notranslate"><span class="pre">typing.Any</span></code> es usado para <code class="docutils literal notranslate"><span class="pre">type</span></code>. Los valores <code class="docutils literal notranslate"><span class="pre">init</span></code>, <code class="docutils literal notranslate"><span class="pre">repr</span></code>, <code class="docutils literal notranslate"><span class="pre">eq</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span></code>, <code class="docutils literal notranslate"><span class="pre">unsafe_hash</span></code> y <code class="docutils literal notranslate"><span class="pre">frozen</span></code> tienen el mismo significado que en la función <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a>.</p>
<p>Esta función no es estrictamente necesaria debido a que cualquier mecanismo de Python para crear una nueva clase con <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> puede usar la función <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> para convertir esa clase en una clase de datos. Esta función se proporciona simplemente por comodidad. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">C</span> <span class="o">=</span> <span class="n">make_dataclass</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span>
                   <span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
                     <span class="s1">&#39;y&#39;</span><span class="p">,</span>
                    <span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">))],</span>
                   <span class="n">namespace</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;add_one&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">})</span>
</pre></div>
</div>
<p>Es equivalente a:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="s1">&#39;typing.Any&#39;</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="k">def</span> <span class="nf">add_one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dataclasses.replace">
<code class="sig-prename descclassname">dataclasses.</code><code class="sig-name descname">replace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="o">/</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">changes</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dataclasses.replace" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Creates a new object of the same type as <code class="docutils literal notranslate"><span class="pre">obj</span></code>, replacing
fields with values from <code class="docutils literal notranslate"><span class="pre">changes</span></code>.  If <code class="docutils literal notranslate"><span class="pre">obj</span></code> is not a Data
Class, raises <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.  If values in <code class="docutils literal notranslate"><span class="pre">changes</span></code> do not
specify fields, raises <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<p>El objeto recién retornado es creado llamando al método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> de la clase de datos. Esto asegura que <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code>, si existe, también será llamado.</p>
<p>Las variables de solo inicialización sin valores predeterminados, si existen, deben especificarse en la llamada a <a class="reference internal" href="#dataclasses.replace" title="dataclasses.replace"><code class="xref py py-func docutils literal notranslate"><span class="pre">replace()</span></code></a> para que puedan pasarse a <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code>.</p>
<p>Es un error que <code class="docutils literal notranslate"><span class="pre">changes</span></code> contenga cualquier campo que esté definido como <code class="docutils literal notranslate"><span class="pre">init=False</span></code>. Una excepción <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> se lanzará en este caso.</p>
<p>Tenga en cuenta cómo funcionan los campos <code class="docutils literal notranslate"><span class="pre">init=False</span></code> durante una llamada a <a class="reference internal" href="#dataclasses.replace" title="dataclasses.replace"><code class="xref py py-func docutils literal notranslate"><span class="pre">replace()</span></code></a>. No se copian del objeto de origen, sino que, de inicializarse, lo hacen en <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code>. Se espera que los campos <code class="docutils literal notranslate"><span class="pre">init=False</span></code> se utilicen en contadas ocasiones y con prudencia. Si se utilizan, podría ser conveniente tener constructores de clase alternativos, o quizás un método personalizado <code class="docutils literal notranslate"><span class="pre">replace()</span></code> (o con un nombre similar) que maneje la copia de instancias.</p>
</dd></dl>

<dl class="py function">
<dt id="dataclasses.is_dataclass">
<code class="sig-prename descclassname">dataclasses.</code><code class="sig-name descname">is_dataclass</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dataclasses.is_dataclass" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si su parámetro es una clase de datos o una instancia de una, en caso contrario retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>Si se necesita conocer si una clase es una instancia de <em>dataclass</em> (y no una clase de datos en si misma), se debe agregar una verificación adicional para <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">isinstance(obj,</span> <span class="pre">type)</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_dataclass_instance</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">is_dataclass</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py data">
<dt id="dataclasses.MISSING">
<code class="sig-prename descclassname">dataclasses.</code><code class="sig-name descname">MISSING</code><a class="headerlink" href="#dataclasses.MISSING" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un valor centinela que significa que falta un default o default_factory.</p>
</dd></dl>

<dl class="py data">
<dt id="dataclasses.KW_ONLY">
<code class="sig-prename descclassname">dataclasses.</code><code class="sig-name descname">KW_ONLY</code><a class="headerlink" href="#dataclasses.KW_ONLY" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un valor centinela utilizado como anotación de tipo. Cualquier campo después de un pseudocampo con el tipo de <a class="reference internal" href="#dataclasses.KW_ONLY" title="dataclasses.KW_ONLY"><code class="xref py py-const docutils literal notranslate"><span class="pre">KW_ONLY</span></code></a> se marca como campos de solo palabras clave. Tenga en cuenta que, de lo contrario, un pseudocampo de tipo <a class="reference internal" href="#dataclasses.KW_ONLY" title="dataclasses.KW_ONLY"><code class="xref py py-const docutils literal notranslate"><span class="pre">KW_ONLY</span></code></a> se ignora por completo. Esto incluye el nombre de dicho campo. Por convención, se utiliza un nombre de <code class="docutils literal notranslate"><span class="pre">_</span></code> para un campo <a class="reference internal" href="#dataclasses.KW_ONLY" title="dataclasses.KW_ONLY"><code class="xref py py-const docutils literal notranslate"><span class="pre">KW_ONLY</span></code></a>. Los campos de solo palabras clave significan parámetros <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> que deben especificarse como palabras clave cuando se crea una instancia de la clase.</p>
<p>En este ejemplo, los campos <code class="docutils literal notranslate"><span class="pre">y</span></code> y <code class="docutils literal notranslate"><span class="pre">z</span></code> se marcarán como campos de solo palabras clave:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
  <span class="n">x</span><span class="p">:</span> <span class="nb">float</span>
  <span class="n">_</span><span class="p">:</span> <span class="n">KW_ONLY</span>
  <span class="n">y</span><span class="p">:</span> <span class="nb">float</span>
  <span class="n">z</span><span class="p">:</span> <span class="nb">float</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
<p>En una sola clase de datos, es un error especificar más de un campo cuyo tipo es <a class="reference internal" href="#dataclasses.KW_ONLY" title="dataclasses.KW_ONLY"><code class="xref py py-const docutils literal notranslate"><span class="pre">KW_ONLY</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</dd></dl>

<dl class="py exception">
<dt id="dataclasses.FrozenInstanceError">
<em class="property">exception </em><code class="sig-prename descclassname">dataclasses.</code><code class="sig-name descname">FrozenInstanceError</code><a class="headerlink" href="#dataclasses.FrozenInstanceError" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Se genera cuando se llama a un <code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code> o <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delattr__()</span></code> definido implícitamente en una clase de datos que se definió con <code class="docutils literal notranslate"><span class="pre">frozen=True</span></code>. Es una subclase de <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>.</p>
</dd></dl>

</section>
<section id="post-init-processing">
<h2>Procesamiento posterior a la inicialización<a class="headerlink" href="#post-init-processing" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El código del método generado <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> llamará a un método llamado <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code>, si <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code> está definido en la clase. Normalmente se llamará como <code class="docutils literal notranslate"><span class="pre">self.__post_init__()</span></code>. Sin embargo, si se define algún campo <code class="docutils literal notranslate"><span class="pre">InitVar</span></code>, también se pasarán a <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code> en el orden en que se definieron en la clase. Si no se genera el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code>, entonces <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code> no se llamará automáticamente.</p>
<p>Entre otros usos, esto permite inicializar valores de campo que dependen de uno o más campos. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">c</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span>
</pre></div>
</div>
<p>El método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> generado por <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> no llama a los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> de la clase base. Si la clase base tiene un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> que debe llamarse, es común llamar a este método en un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Rectangle</span><span class="p">:</span>
    <span class="n">height</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">width</span><span class="p">:</span> <span class="nb">float</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Square</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">):</span>
    <span class="n">side</span><span class="p">:</span> <span class="nb">float</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">side</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">side</span><span class="p">)</span>
</pre></div>
</div>
<p>Sin embargo, tenga en cuenta que, en general, no es necesario llamar a los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> generados por la clase de datos, ya que la clase de datos derivada se encargará de inicializar todos los campos de cualquier clase base que sea una clase de datos en sí.</p>
<p>Consulta la sección sobre variables de solo inicialización que hay a continuación para conocer las posibles formas de pasar parámetros a <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code>. También vea la advertencia sobre cómo <a class="reference internal" href="#dataclasses.replace" title="dataclasses.replace"><code class="xref py py-func docutils literal notranslate"><span class="pre">replace()</span></code></a> maneja los campos <code class="docutils literal notranslate"><span class="pre">init</span> <span class="pre">=</span> <span class="pre">False</span></code>.</p>
</section>
<section id="class-variables">
<h2>Variables de clase<a class="headerlink" href="#class-variables" title="Enlazar permanentemente con este título">¶</a></h2>
<p>One of the few places where <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> actually inspects the type
of a field is to determine if a field is a class variable as defined
in <span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a>.  It does this by checking if the type of the field is
<code class="docutils literal notranslate"><span class="pre">typing.ClassVar</span></code>.  If a field is a <code class="docutils literal notranslate"><span class="pre">ClassVar</span></code>, it is excluded
from consideration as a field and is ignored by the dataclass
mechanisms.  Such <code class="docutils literal notranslate"><span class="pre">ClassVar</span></code> pseudo-fields are not returned by the
module-level <a class="reference internal" href="#dataclasses.fields" title="dataclasses.fields"><code class="xref py py-func docutils literal notranslate"><span class="pre">fields()</span></code></a> function.</p>
</section>
<section id="init-only-variables">
<h2>Variable de solo inicialización<a class="headerlink" href="#init-only-variables" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Another place where <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> inspects a type annotation is to
determine if a field is an init-only variable.  It does this by seeing
if the type of a field is of type <code class="docutils literal notranslate"><span class="pre">dataclasses.InitVar</span></code>.  If a field
is an <code class="docutils literal notranslate"><span class="pre">InitVar</span></code>, it is considered a pseudo-field called an init-only
field.  As it is not a true field, it is not returned by the
module-level <a class="reference internal" href="#dataclasses.fields" title="dataclasses.fields"><code class="xref py py-func docutils literal notranslate"><span class="pre">fields()</span></code></a> function.  Init-only fields are added as
parameters to the generated <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> method, and are passed to
the optional <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code> method.  They are not otherwise used
by dataclasses.</p>
<p>Por ejemplo, supongamos que se va a inicializar un campo desde una base de datos, de no proporcionarse un valor al crear la clase:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">i</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">j</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">database</span><span class="p">:</span> <span class="n">InitVar</span><span class="p">[</span><span class="n">DatabaseType</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">database</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">j</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">database</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">j</span> <span class="o">=</span> <span class="n">database</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="s1">&#39;j&#39;</span><span class="p">)</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">database</span><span class="o">=</span><span class="n">my_database</span><span class="p">)</span>
</pre></div>
</div>
<p>En este caso, <a class="reference internal" href="#dataclasses.fields" title="dataclasses.fields"><code class="xref py py-func docutils literal notranslate"><span class="pre">fields()</span></code></a> retornará objetos <a class="reference internal" href="#dataclasses.Field" title="dataclasses.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a> para <code class="docutils literal notranslate"><span class="pre">i</span></code> y <code class="docutils literal notranslate"><span class="pre">j</span></code>, pero no para <code class="docutils literal notranslate"><span class="pre">database</span></code>.</p>
</section>
<section id="frozen-instances">
<h2>Instancias congeladas<a class="headerlink" href="#frozen-instances" title="Enlazar permanentemente con este título">¶</a></h2>
<p>No es posible crear objetos verdaderamente inmutables en Python. Sin embargo, se puede emular la inmutabilidad pasando <code class="docutils literal notranslate"><span class="pre">frozen=True</span></code> al decorador <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dataclass()</span></code></a>. En este caso, las clases de datos añadirán los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delattr__()</span></code> a la clase. Estos métodos lanzarán una excepción <a class="reference internal" href="#dataclasses.FrozenInstanceError" title="dataclasses.FrozenInstanceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FrozenInstanceError</span></code></a> cuando sean llamados.</p>
<p>Hay una pequeña penalización de rendimiento cuando se usa <code class="docutils literal notranslate"><span class="pre">frozen=True</span></code>, esto se debe a que <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> no puede usar una asignación simple para inicializar campos, viéndose obligado a usar <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__setattr__()</span></code></a>.</p>
</section>
<section id="inheritance">
<h2>Herencia<a class="headerlink" href="#inheritance" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Cuando la clase de datos está siendo creada por el decorador <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dataclass()</span></code></a>, revisa todas las clases base de la clase en el MRO invertido (es decir, comenzando en <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>) y, para cada clase de datos que encuentra, agrega los campos de esa clase base a un mapeo ordenado. Después de agregar todos los campos de la clase base, agrega sus propios campos al mapeo. Todos los métodos generados utilizarán este mapeo ordenado calculado combinando los campos. Como los campos están en orden de inserción, las clases derivadas anulan las clases base. Un ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Base</span><span class="p">:</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="mf">15.0</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">15</span>
</pre></div>
</div>
<p>La lista final de campos es, en orden, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">z</span></code>. El tipo final de <code class="docutils literal notranslate"><span class="pre">x</span></code> es <code class="docutils literal notranslate"><span class="pre">int</span></code>, como se especifica en la clase <code class="docutils literal notranslate"><span class="pre">C</span></code>.</p>
<p>El método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> generado para <code class="docutils literal notranslate"><span class="pre">C</span></code> se verá como:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
</pre></div>
</div>
</section>
<section id="re-ordering-of-keyword-only-parameters-in-init">
<h2>Reordenar los parámetros de solo palabras clave en <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code><a class="headerlink" href="#re-ordering-of-keyword-only-parameters-in-init" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Una vez que se calculan los parámetros necesarios para <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code>, todos los parámetros de solo palabras clave se mueven después de todos los parámetros normales (no solo de palabras clave). Este es un requisito de cómo se implementan los parámetros de solo palabras clave en Python: deben ir después de los parámetros que no son solo de palabras clave.</p>
<p>En este ejemplo, <code class="docutils literal notranslate"><span class="pre">Base.y</span></code>, <code class="docutils literal notranslate"><span class="pre">Base.w</span></code> y <code class="docutils literal notranslate"><span class="pre">D.t</span></code> son campos de solo palabras clave, y <code class="docutils literal notranslate"><span class="pre">Base.x</span></code> y <code class="docutils literal notranslate"><span class="pre">D.z</span></code> son campos regulares:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Base</span><span class="p">:</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="mf">15.0</span>
    <span class="n">_</span><span class="p">:</span> <span class="n">KW_ONLY</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">w</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">t</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">kw_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>El método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> generado para <code class="docutils literal notranslate"><span class="pre">C</span></code> se verá como:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="mf">15.0</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
</pre></div>
</div>
<p>Tenga en cuenta que los parámetros se han reordenado a partir de cómo aparecen en la lista de campos: los parámetros derivados de los campos regulares son seguidos por los parámetros derivados de los campos de solo palabras clave.</p>
<p>El orden relativo de los parámetros de solo palabras clave se mantiene en la lista de parámetros <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> reordenada.</p>
</section>
<section id="default-factory-functions">
<h2>Funciones fábrica por defecto<a class="headerlink" href="#default-factory-functions" title="Enlazar permanentemente con este título">¶</a></h2>
<blockquote>
<div><p>Si un <a class="reference internal" href="#dataclasses.field" title="dataclasses.field"><code class="xref py py-func docutils literal notranslate"><span class="pre">field()</span></code></a> especifica una <code class="docutils literal notranslate"><span class="pre">default_factory</span></code>, se llama sin argumentos cuando se necesita un valor predeterminado para el campo. Por ejemplo, para crear una nueva instancia de una lista, debe usarse:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">mylist</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
</pre></div>
</div>
<p>Si un campo está excluido de <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> (usando <code class="docutils literal notranslate"><span class="pre">init</span> <span class="pre">=</span> <span class="pre">False</span></code>) y el campo también especifica <code class="docutils literal notranslate"><span class="pre">default_factory</span></code>, entonces la función de fábrica predeterminada siempre se llamará desde la función generada <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code>. Esto sucede porque no existe otra forma de darle al campo un valor inicial.</p>
</div></blockquote>
</section>
<section id="mutable-default-values">
<h2>Valores por defecto mutables<a class="headerlink" href="#mutable-default-values" title="Enlazar permanentemente con este título">¶</a></h2>
<blockquote>
<div><p>Python almacena los valores miembros por defecto en atributos de clase. Considera este ejemplo, sin usar clases de datos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

<span class="n">o1</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="n">o2</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="n">o1</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">o2</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">o1</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">o1</span><span class="o">.</span><span class="n">x</span> <span class="ow">is</span> <span class="n">o2</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
<p>Tenga en cuenta que, tal como cabe esperar, las dos instancias de la clase <code class="docutils literal notranslate"><span class="pre">C</span></code> comparten la misma variable de clase <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>Usando clases de datos, <em>si</em> este código fuera válido:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">D</span><span class="p">:</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">element</span>
</pre></div>
</div>
<p>generaría un código similar a:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">D</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">element</span>

<span class="k">assert</span> <span class="n">D</span><span class="p">()</span><span class="o">.</span><span class="n">x</span> <span class="ow">is</span> <span class="n">D</span><span class="p">()</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
<p>Esto tiene el mismo problema que el ejemplo original usando la clase <code class="docutils literal notranslate"><span class="pre">C</span></code>. Es decir, dos instancias de la clase <code class="docutils literal notranslate"><span class="pre">D</span></code> que no especifican un valor para <code class="docutils literal notranslate"><span class="pre">x</span></code> al crear una instancia de clase compartirán la misma copia de <code class="docutils literal notranslate"><span class="pre">x</span></code>. Debido a que las clases de datos solo usan la creación normal de clases de Python, también comparten este comportamiento. No existe una forma general de que las clases de datos detecten esta condición. En cambio, el decorador <a class="reference internal" href="#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass()</span></code></a> lanzará un <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> si detecta un parámetro predeterminado de tipo <code class="docutils literal notranslate"><span class="pre">list</span></code>, <code class="docutils literal notranslate"><span class="pre">dict</span></code> o <code class="docutils literal notranslate"><span class="pre">set</span></code>. Esta es una solución parcial, pero protege contra muchos errores comunes.</p>
<p>Usar las funciones fábrica por defecto es una forma de crear nuevas instancias de tipos mutables como valores por defecto para campos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">D</span><span class="p">:</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">D</span><span class="p">()</span><span class="o">.</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">D</span><span class="p">()</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="descriptor-typed-fields">
<h2>Descriptor-typed fields<a class="headerlink" href="#descriptor-typed-fields" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Fields that are assigned <a class="reference internal" href="../reference/datamodel.html#descriptors"><span class="std std-ref">descriptor objects</span></a> as their
default value have the following special behaviors:</p>
<ul class="simple">
<li><p>The value for the field passed to the dataclass’s <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method is
passed to the descriptor’s <code class="docutils literal notranslate"><span class="pre">__set__</span></code> method rather than overwriting the
descriptor object.</p></li>
<li><p>Similarly, when getting or setting the field, the descriptor’s
<code class="docutils literal notranslate"><span class="pre">__get__</span></code> or <code class="docutils literal notranslate"><span class="pre">__set__</span></code> method is called rather than returning or
overwriting the descriptor object.</p></li>
<li><p>To determine whether a field contains a default value, <code class="docutils literal notranslate"><span class="pre">dataclasses</span></code>
will call the descriptor’s <code class="docutils literal notranslate"><span class="pre">__get__</span></code> method using its class access
form (i.e. <code class="docutils literal notranslate"><span class="pre">descriptor.__get__(obj=None,</span> <span class="pre">type=cls)</span></code>.  If the
descriptor returns a value in this case, it will be used as the
field’s default. On the other hand, if the descriptor raises
<a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> in this situation, no default value will be
provided for the field.</p></li>
</ul>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">IntConversionDescriptor</span><span class="p">:</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">default</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_default</span> <span class="o">=</span> <span class="n">default</span>

  <span class="k">def</span> <span class="nf">__set_name__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">name</span>

  <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default</span>

    <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">InventoryItem</span><span class="p">:</span>
  <span class="n">quantity_on_hand</span><span class="p">:</span> <span class="n">IntConversionDescriptor</span> <span class="o">=</span> <span class="n">IntConversionDescriptor</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="n">i</span> <span class="o">=</span> <span class="n">InventoryItem</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">quantity_on_hand</span><span class="p">)</span>   <span class="c1"># 100</span>
<span class="n">i</span><span class="o">.</span><span class="n">quantity_on_hand</span> <span class="o">=</span> <span class="mf">2.5</span>    <span class="c1"># calls __set__ with 2.5</span>
<span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">quantity_on_hand</span><span class="p">)</span>   <span class="c1"># 2</span>
</pre></div>
</div>
<p>Note that if a field is annotated with a descriptor type, but is not assigned
a descriptor object as its default value, the field will act like a normal
field.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dataclasses</span></code> — Clases de datos</a><ul>
<li><a class="reference internal" href="#module-contents">Contenidos del módulo</a></li>
<li><a class="reference internal" href="#post-init-processing">Procesamiento posterior a la inicialización</a></li>
<li><a class="reference internal" href="#class-variables">Variables de clase</a></li>
<li><a class="reference internal" href="#init-only-variables">Variable de solo inicialización</a></li>
<li><a class="reference internal" href="#frozen-instances">Instancias congeladas</a></li>
<li><a class="reference internal" href="#inheritance">Herencia</a></li>
<li><a class="reference internal" href="#re-ordering-of-keyword-only-parameters-in-init">Reordenar los parámetros de solo palabras clave en <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a></li>
<li><a class="reference internal" href="#default-factory-functions">Funciones fábrica por defecto</a></li>
<li><a class="reference internal" href="#mutable-default-values">Valores por defecto mutables</a></li>
<li><a class="reference internal" href="#descriptor-typed-fields">Descriptor-typed fields</a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="warnings.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code> — Control de advertencias</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="contextlib.html"
                        title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code> — Utilidades para declaraciones de contexto <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/dataclasses.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="contextlib.html" title="contextlib — Utilidades para declaraciones de contexto with"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="warnings.html" title="warnings — Control de advertencias"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La Biblioteca Estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="python.html" >Servicios en tiempo de ejecución de Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">dataclasses</span></code> — Clases de datos</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 27, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>