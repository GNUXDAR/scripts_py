
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="6. Expresiones" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/reference/expressions.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Este capítulo explica el significado de los elementos de expresiones en Python. Notas de Sintaxis: En este y los siguientes capítulos será usada notación BNF extendida para describir sintaxis, no a..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Este capítulo explica el significado de los elementos de expresiones en Python. Notas de Sintaxis: En este y los siguientes capítulos será usada notación BNF extendida para describir sintaxis, no a..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>6. Expresiones &#8212; documentación de Python - 3.11.2</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=2d3badd06fe70b34b68db01f99471ce1624ffe4a" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.11.2"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="7. Declaraciones simples" href="simple_stmts.html" />
    <link rel="prev" title="5. El sistema de importación" href="import.html" />
    <link rel="canonical" href="https://docs.python.org/3/reference/expressions.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">6. Expresiones</a><ul>
<li><a class="reference internal" href="#arithmetic-conversions">6.1. Conversiones aritméticas</a></li>
<li><a class="reference internal" href="#atoms">6.2. Átomos</a><ul>
<li><a class="reference internal" href="#atom-identifiers">6.2.1. Identificadores (Nombres)</a></li>
<li><a class="reference internal" href="#literals">6.2.2. Literales</a></li>
<li><a class="reference internal" href="#parenthesized-forms">6.2.3. Formas entre paréntesis</a></li>
<li><a class="reference internal" href="#displays-for-lists-sets-and-dictionaries">6.2.4. Despliegues para listas, conjuntos y diccionarios</a></li>
<li><a class="reference internal" href="#list-displays">6.2.5. Despliegues de lista</a></li>
<li><a class="reference internal" href="#set-displays">6.2.6. Despliegues de conjuntos</a></li>
<li><a class="reference internal" href="#dictionary-displays">6.2.7. Despliegues de diccionario</a></li>
<li><a class="reference internal" href="#generator-expressions">6.2.8. Expresiones de generador</a></li>
<li><a class="reference internal" href="#yield-expressions">6.2.9. Expresiones yield</a><ul>
<li><a class="reference internal" href="#generator-iterator-methods">6.2.9.1. Métodos generador-iterador</a></li>
<li><a class="reference internal" href="#examples">6.2.9.2. Ejemplos</a></li>
<li><a class="reference internal" href="#asynchronous-generator-functions">6.2.9.3. Funciones generadoras asincrónicas</a></li>
<li><a class="reference internal" href="#asynchronous-generator-iterator-methods">6.2.9.4. Métodos asincrónicos de generador-iterador</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#primaries">6.3. Primarios</a><ul>
<li><a class="reference internal" href="#attribute-references">6.3.1. Referencias de atributos</a></li>
<li><a class="reference internal" href="#subscriptions">6.3.2. Suscripciones</a></li>
<li><a class="reference internal" href="#slicings">6.3.3. Segmentos</a></li>
<li><a class="reference internal" href="#calls">6.3.4. Invocaciones</a></li>
</ul>
</li>
<li><a class="reference internal" href="#await-expression">6.4. Expresión await</a></li>
<li><a class="reference internal" href="#the-power-operator">6.5. El operador de potencia</a></li>
<li><a class="reference internal" href="#unary-arithmetic-and-bitwise-operations">6.6. Aritmética unaria y operaciones bit a bit</a></li>
<li><a class="reference internal" href="#binary-arithmetic-operations">6.7. Operaciones aritméticas binarias</a></li>
<li><a class="reference internal" href="#shifting-operations">6.8. Operaciones de desplazamiento</a></li>
<li><a class="reference internal" href="#binary-bitwise-operations">6.9. Operaciones bit a bit binarias</a></li>
<li><a class="reference internal" href="#comparisons">6.10. Comparaciones</a><ul>
<li><a class="reference internal" href="#value-comparisons">6.10.1. Comparaciones de valor</a></li>
<li><a class="reference internal" href="#membership-test-operations">6.10.2. Operaciones de prueba de membresía</a></li>
<li><a class="reference internal" href="#is-not">6.10.3. Comparaciones de identidad</a></li>
</ul>
</li>
<li><a class="reference internal" href="#boolean-operations">6.11. Operaciones booleanas</a></li>
<li><a class="reference internal" href="#assignment-expressions">6.12. Expresiones de asignación</a></li>
<li><a class="reference internal" href="#conditional-expressions">6.13. Expresiones condicionales</a></li>
<li><a class="reference internal" href="#lambda">6.14. Lambdas</a></li>
<li><a class="reference internal" href="#expression-lists">6.15. Listas de expresiones</a></li>
<li><a class="reference internal" href="#evaluation-order">6.16. Orden de evaluación</a></li>
<li><a class="reference internal" href="#operator-precedence">6.17. Prioridad de operador</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="import.html"
                          title="capítulo anterior"><span class="section-number">5. </span>El sistema de importación</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="simple_stmts.html"
                          title="próximo capítulo"><span class="section-number">7. </span>Declaraciones simples</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/reference/expressions.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="7. Declaraciones simples"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="import.html" title="5. El sistema de importación"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Referencia del Lenguaje Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">6. </span>Expresiones</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="expressions">
<span id="id1"></span><h1><span class="section-number">6. </span>Expresiones<a class="headerlink" href="#expressions" title="Enlazar permanentemente con este título">¶</a></h1>
<p id="index-0">Este capítulo explica el significado de los elementos de expresiones en Python.</p>
<p><strong>Notas de Sintaxis:</strong> En este y los siguientes capítulos será usada notación BNF extendida para describir sintaxis, no análisis léxico. Cuando (una alternativa de) una regla de sintaxis tiene la forma</p>
<pre>
<strong id="grammar-token-python-grammar-name"><span id="grammar-token-name"></span>name</strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">othername</span></code>
</pre>
<p>y no han sido dadas semánticas, las semánticas de esta forma de <code class="docutils literal notranslate"><span class="pre">name</span></code> son las mismas que para <code class="docutils literal notranslate"><span class="pre">othername</span></code>.</p>
<section id="arithmetic-conversions">
<span id="conversions"></span><h2><span class="section-number">6.1. </span>Conversiones aritméticas<a class="headerlink" href="#arithmetic-conversions" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-1">Cuando una descripción de un operador aritmético a continuación usa la frase «los argumentos numéricos son convertidos a un tipo común», esto significa que la implementación de operador para tipos incorporados funciona de la siguiente forma:</p>
<ul class="simple">
<li><p>Si cualquiera de los argumentos es un número complejo, el otro es convertido a complejo;</p></li>
<li><p>de otra forma, si cualquier de los argumentos es un número de punto flotante, el otro es convertido a punto flotante;</p></li>
<li><p>de otra forma, ambos deben ser enteros y no se necesita conversión.</p></li>
</ul>
<p>Algunas reglas adicionales aplican para ciertos operadores (ej., una cadena de caracteres como argumento a la izquierda del operador “%”). Las extensiones deben definir su comportamiento de conversión.</p>
</section>
<section id="atoms">
<span id="id2"></span><h2><span class="section-number">6.2. </span>Átomos<a class="headerlink" href="#atoms" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-2">Los átomos son los elementos más básicos de las expresiones. Los átomos más simples son identificadores o literales. Las formas encerradas en paréntesis, corchetes o llaves son también sintácticamente categorizadas como átomos. La sintaxis para átomos es:</p>
<pre>
<strong id="grammar-token-python-grammar-atom"><span id="grammar-token-atom"></span>atom     </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-literal"><code class="xref docutils literal notranslate"><span class="pre">literal</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-enclosure"><code class="xref docutils literal notranslate"><span class="pre">enclosure</span></code></a>
<strong id="grammar-token-python-grammar-enclosure"><span id="grammar-token-enclosure"></span>enclosure</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-parenth_form"><code class="xref docutils literal notranslate"><span class="pre">parenth_form</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-list_display"><code class="xref docutils literal notranslate"><span class="pre">list_display</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-dict_display"><code class="xref docutils literal notranslate"><span class="pre">dict_display</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-set_display"><code class="xref docutils literal notranslate"><span class="pre">set_display</span></code></a>
               | <a class="reference internal" href="#grammar-token-python-grammar-generator_expression"><code class="xref docutils literal notranslate"><span class="pre">generator_expression</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-yield_atom"><code class="xref docutils literal notranslate"><span class="pre">yield_atom</span></code></a>
</pre>
<section id="atom-identifiers">
<span id="identifiers-names"></span><h3><span class="section-number">6.2.1. </span>Identificadores (Nombres)<a class="headerlink" href="#atom-identifiers" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-3">Un identificador encontrándose como un átomo es un nombre. Vea la sección <a class="reference internal" href="lexical_analysis.html#identifiers"><span class="std std-ref">Identificadores y palabras clave</span></a> para la definición léxica y la sección <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">Nombres y vínculos</span></a> para documentación de nombrar y vincular.</p>
<p id="index-4">Cuando el nombre es vinculado a un objeto, la evaluación del átomo produce ese objeto. Cuando un nombre no es vinculado, un intento de evaluarlo genera una excepción <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a>.</p>
<span class="target" id="private-name-mangling"></span><p id="index-5"><strong>Alteración de nombre privado:</strong> Cuando un identificador que ocurre textualmente en una definición de clase comienza con dos o más caracteres de guión bajo y no termina en dos o más guiones bajos, es considerado un <em class="dfn">private name</em> de esa clase. Los nombres privados son transformados a una forma más larga antes de que sea generado código para ellos. La transformación inserta el nombre de clase, con los guiones bajos iniciales eliminados y un solo guión bajo insertado, delante del nombre. Por ejemplo, el identificador <code class="docutils literal notranslate"><span class="pre">__spam</span></code> que se encuentra en una clase denominada <code class="docutils literal notranslate"><span class="pre">Ham</span></code> será transformado a <code class="docutils literal notranslate"><span class="pre">_Ham__spam</span></code>. Esta transformación es independiente del contexto sintáctico en el cual es usado el identificador. Si el nombre transformado es extremadamente largo (más largo que 255 caracteres), puede ocurrir el truncamiento definido por la implementación. Si el nombre de clase consiste únicamente de guiones bajos, no se realiza transformación.</p>
</section>
<section id="literals">
<span id="atom-literals"></span><h3><span class="section-number">6.2.2. </span>Literales<a class="headerlink" href="#literals" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-6">Python soporta literales de cadenas de caracteres y bytes y varios literales numéricos:</p>
<pre>
<strong id="grammar-token-python-grammar-literal"><span id="grammar-token-literal"></span>literal</strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-stringliteral"><code class="xref docutils literal notranslate"><span class="pre">stringliteral</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-bytesliteral"><code class="xref docutils literal notranslate"><span class="pre">bytesliteral</span></code></a>
             | <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-integer"><code class="xref docutils literal notranslate"><span class="pre">integer</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-floatnumber"><code class="xref docutils literal notranslate"><span class="pre">floatnumber</span></code></a> | <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-imagnumber"><code class="xref docutils literal notranslate"><span class="pre">imagnumber</span></code></a>
</pre>
<p>La evaluación de un literal produce un objeto del tipo dado (cadena de caracteres, bytes, entero, número de punto flotante, número complejo) con el valor dado. El valor puede ser aproximado en el caso de literales de número de punto flotante e imaginarios (complejos). Vea la sección <a class="reference internal" href="lexical_analysis.html#literals"><span class="std std-ref">Literales</span></a> para más detalles.</p>
<p id="index-7">Todos los literales corresponden a tipos de datos inmutables y, por lo tanto, la identidad del objeto es menos importante que su valor. Múltiples evaluaciones de literales con el mismo valor (ya sea la misma ocurrencia en el texto del programa o una ocurrencia diferente) pueden obtener el mismo objeto o un objeto diferente con el mismo valor.</p>
</section>
<section id="parenthesized-forms">
<span id="parenthesized"></span><h3><span class="section-number">6.2.3. </span>Formas entre paréntesis<a class="headerlink" href="#parenthesized-forms" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-8">Una forma entre paréntesis es una lista de expresiones opcionales encerradas entre paréntesis:</p>
<pre>
<strong id="grammar-token-python-grammar-parenth_form"><span id="grammar-token-parenth-form"></span>parenth_form</strong> ::=  &quot;(&quot; [<a class="reference internal" href="#grammar-token-python-grammar-starred_expression"><code class="xref docutils literal notranslate"><span class="pre">starred_expression</span></code></a>] &quot;)&quot;
</pre>
<p>Una expresión entre paréntesis produce lo que la lista de expresión produce: si la lista contiene al menos una coma, produce una tupla; en caso contrario, produce la única expresión que que forma la lista de expresiones.</p>
<p id="index-9">Un par de paréntesis vacío producen un objeto de tupla vacío. Debido a que las tuplas son inmutables, se aplican las mismas reglas que aplican para literales (ej., dos ocurrencias de una tupla vacía puede o no producir el mismo objeto).</p>
<p id="index-10">Note that tuples are not formed by the parentheses, but rather by use of the
comma.  The exception is the empty tuple, for which parentheses <em>are</em>
required — allowing unparenthesized «nothing» in expressions would cause
ambiguities and allow common typos to pass uncaught.</p>
</section>
<section id="displays-for-lists-sets-and-dictionaries">
<span id="comprehensions"></span><h3><span class="section-number">6.2.4. </span>Despliegues para listas, conjuntos y diccionarios<a class="headerlink" href="#displays-for-lists-sets-and-dictionaries" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-11">Para construir una lista, un conjunto o un diccionario, Python provee sintaxis especial denominada «despliegue», cada una de ellas en dos sabores:</p>
<ul class="simple">
<li><p>los contenidos del contenedor son listados explícitamente o</p></li>
<li><p>son calculados mediante un conjunto de instrucciones de bucle y filtrado, denominadas una <em class="dfn">comprehension</em>.</p></li>
</ul>
<p id="index-12">Los elementos comunes de sintaxis para las comprensiones son:</p>
<pre>
<strong id="grammar-token-python-grammar-comprehension"><span id="grammar-token-comprehension"></span>comprehension</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-assignment_expression"><code class="xref docutils literal notranslate"><span class="pre">assignment_expression</span></code></a> <a class="reference internal" href="#grammar-token-python-grammar-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a>
<strong id="grammar-token-python-grammar-comp_for"><span id="grammar-token-comp-for"></span>comp_for     </strong> ::=  [&quot;async&quot;] &quot;for&quot; <a class="reference internal" href="simple_stmts.html#grammar-token-python-grammar-target_list"><code class="xref docutils literal notranslate"><span class="pre">target_list</span></code></a> &quot;in&quot; <a class="reference internal" href="#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> [<a class="reference internal" href="#grammar-token-python-grammar-comp_iter"><code class="xref docutils literal notranslate"><span class="pre">comp_iter</span></code></a>]
<strong id="grammar-token-python-grammar-comp_iter"><span id="grammar-token-comp-iter"></span>comp_iter    </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-comp_if"><code class="xref docutils literal notranslate"><span class="pre">comp_if</span></code></a>
<strong id="grammar-token-python-grammar-comp_if"><span id="grammar-token-comp-if"></span>comp_if      </strong> ::=  &quot;if&quot; <a class="reference internal" href="#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> [<a class="reference internal" href="#grammar-token-python-grammar-comp_iter"><code class="xref docutils literal notranslate"><span class="pre">comp_iter</span></code></a>]
</pre>
<p>La comprensión consiste en una única expresión seguida por al menos una cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> y cero o más cláusulas <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> o <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code>. En este caso, los elementos del nuevo contenedor son aquellos que serían producidos mediante considerar cada una de las cláusulas <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> o <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> un bloque, anidado de izquierda a derecha y evaluando la expresión para producir un elemento cada vez que se alcanza el bloque más interno.</p>
<p>Sin embargo, aparte de la expresión iterable en la cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> más a la izquierda, la comprensión es ejecutada en un alcance separado implícitamente anidado. Esto asegura que los nombres asignados a en la lista objetiva no se «filtren» en el alcance adjunto.</p>
<p>La expresión iterable en la cláusula más a la izquierda <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> es evaluada directamente en el alcance anidado y luego pasada como un argumento al alcance implícitamente anidado. Subsecuentes cláusulas <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> y cualquier condición de filtro en la cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> más a la izquierda no pueden ser evaluadas en el alcance adjunto ya que pueden depender de los valores obtenidos del iterable de más a la izquierda. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">[x*y</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(10)</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">range(x,</span> <span class="pre">x+10)]</span></code>.</p>
<p>Para asegurar que la comprensión siempre resulta en un contenedor del tipo apropiado, las expresiones <code class="docutils literal notranslate"><span class="pre">yield</span></code> y <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> están prohibidas en el alcance implícitamente anidado.</p>
<p id="index-13">Since Python 3.6, in an <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> function, an <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code>
clause may be used to iterate over a <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a>.
A comprehension in an <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> function may consist of either a
<code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> or <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> clause following the leading
expression, may contain additional <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> or <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code>
clauses, and may also use <a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> expressions.
If a comprehension contains either <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> clauses or
<code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code> expressions or other asynchronous comprehensions it is called
an <em class="dfn">asynchronous comprehension</em>.  An asynchronous comprehension may
suspend the execution of the coroutine function in which it appears.
See also <span class="target" id="index-14"></span><a class="pep reference external" href="https://peps.python.org/pep-0530/"><strong>PEP 530</strong></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6: </span>Fueron introducidas las comprensiones asincrónicas.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Prohibidas <code class="docutils literal notranslate"><span class="pre">yield</span></code> y <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> en el alcance implícitamente anidado.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Asynchronous comprehensions are now allowed inside comprehensions in
asynchronous functions. Outer comprehensions implicitly become
asynchronous.</p>
</div>
</section>
<section id="list-displays">
<span id="lists"></span><h3><span class="section-number">6.2.5. </span>Despliegues de lista<a class="headerlink" href="#list-displays" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-15">Un despliegue de lista es una serie de expresiones posiblemente vacía encerrada entre corchetes:</p>
<pre>
<strong id="grammar-token-python-grammar-list_display"><span id="grammar-token-list-display"></span>list_display</strong> ::=  &quot;[&quot; [<a class="reference internal" href="#grammar-token-python-grammar-starred_list"><code class="xref docutils literal notranslate"><span class="pre">starred_list</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-comprehension"><code class="xref docutils literal notranslate"><span class="pre">comprehension</span></code></a>] &quot;]&quot;
</pre>
<p>Un despliegue de lista produce un nuevo objeto lista, el contenido se especifica por una lista de expresiones o una comprensión. Cuando se proporciona una lista de expresiones, sus elementos son evaluados desde la izquierda a la derecha y colocados en el objeto lista en ese orden. Cuando se proporciona una comprensión, la lista es construida desde los elementos resultantes de la comprensión.</p>
</section>
<section id="set-displays">
<span id="set"></span><h3><span class="section-number">6.2.6. </span>Despliegues de conjuntos<a class="headerlink" href="#set-displays" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-16">Un despliegue de conjunto se denota mediante llaves y se distinguen de los despliegues de diccionarios por la ausencia de caracteres de doble punto separando claves y valores:</p>
<pre>
<strong id="grammar-token-python-grammar-set_display"><span id="grammar-token-set-display"></span>set_display</strong> ::=  &quot;{&quot; (<a class="reference internal" href="#grammar-token-python-grammar-starred_list"><code class="xref docutils literal notranslate"><span class="pre">starred_list</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-comprehension"><code class="xref docutils literal notranslate"><span class="pre">comprehension</span></code></a>) &quot;}&quot;
</pre>
<p>Un despliegue de conjunto produce un nuevo objeto conjunto mutable, el contenido se especifica mediante una secuencia de expresiones o una comprensión. Cuando se proporciona una lista de expresiones separadas por comas, sus elementos son evaluados desde la izquierda a la derecha y añadidos al objeto de conjunto. Cuando se proporciona una comprensión, el conjunto es construido de los elementos resultantes de la comprensión.</p>
<p>Un conjunto vacío no puede ser construido con <code class="docutils literal notranslate"><span class="pre">{}</span></code>; este literal construye un diccionario vacío.</p>
</section>
<section id="dictionary-displays">
<span id="dict"></span><h3><span class="section-number">6.2.7. </span>Despliegues de diccionario<a class="headerlink" href="#dictionary-displays" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-17">Un despliegue de diccionario es una serie posiblemente vacía de pares clave/datos encerrados entre llaves:</p>
<pre>
<strong id="grammar-token-python-grammar-dict_display"><span id="grammar-token-dict-display"></span>dict_display      </strong> ::=  &quot;{&quot; [<a class="reference internal" href="#grammar-token-python-grammar-key_datum_list"><code class="xref docutils literal notranslate"><span class="pre">key_datum_list</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-dict_comprehension"><code class="xref docutils literal notranslate"><span class="pre">dict_comprehension</span></code></a>] &quot;}&quot;
<strong id="grammar-token-python-grammar-key_datum_list"><span id="grammar-token-key-datum-list"></span>key_datum_list    </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-key_datum"><code class="xref docutils literal notranslate"><span class="pre">key_datum</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-key_datum"><code class="xref docutils literal notranslate"><span class="pre">key_datum</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-python-grammar-key_datum"><span id="grammar-token-key-datum"></span>key_datum         </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | &quot;**&quot; <a class="reference internal" href="#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a>
<strong id="grammar-token-python-grammar-dict_comprehension"><span id="grammar-token-dict-comprehension"></span>dict_comprehension</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-python-grammar-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a>
</pre>
<p>Un despliegue de diccionario produce un nuevo objeto diccionario.</p>
<p>Si es dada una secuencia separada por comas de pares clave/datos, son evaluadas desde la izquierda a la derecha para definir las entradas del diccionario: cada objeto clave es usado como una clave dentro del diccionario para almacenar el dato correspondiente. Esto significa que puedes especificar la misma clave múltiples veces en la lista clave/datos y el valor final del diccionario para esa clave será la última dada.</p>
<p id="index-18">Un doble asterisco <code class="docutils literal notranslate"><span class="pre">**</span></code> denota <em class="dfn">dictionary unpacking</em>. Su operando debe ser un <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a>. Cada elemento de mapeo es añadido al nuevo diccionario. Valores más tardíos remplazan los valores ya establecidos para los pares clave/dato y para los desempaquetados de diccionario anteriores.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5: </span>Desempaquetar en despliegues de diccionarios, originalmente propuesto por <span class="target" id="index-110"></span><a class="pep reference external" href="https://peps.python.org/pep-0448/"><strong>PEP 448</strong></a>.</p>
</div>
<p>Una comprensión de diccionario, en contraste a las compresiones de lista y conjunto, necesita dos expresiones separadas con un caracter de doble punto seguido por las cláusulas usuales «for» e «if». Cuando la comprensión se ejecuta, los elementos resultantes clave y valor son insertados en el nuevo diccionario en el orden que son producidos.</p>
<p id="index-20">Las restricciones de los tipos de los valores de clave son listados anteriormente en la sección <a class="reference internal" href="datamodel.html#types"><span class="std std-ref">Jerarquía de tipos estándar</span></a>. (Para resumir, el tipo de la clave debe ser <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>, el cual excluye todos los objetos mutables.) No se detectan choques entre claves duplicadas; el último dato (textualmente el más a la derecha en el despliegue) almacenado para una clave dada prevalece.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Antes de Python 3.8, en las comprensiones de diccionarios, el orden de evaluación de clave y valor no fue bien definido. En CPython, el valor fue evaluado antes de la clave. A partir de 3.8, la clave es evaluada antes que el valor, como fue propuesto por <span class="target" id="index-111"></span><a class="pep reference external" href="https://peps.python.org/pep-0572/"><strong>PEP 572</strong></a>.</p>
</div>
</section>
<section id="generator-expressions">
<span id="genexpr"></span><h3><span class="section-number">6.2.8. </span>Expresiones de generador<a class="headerlink" href="#generator-expressions" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-22">Una expresión de generador es una notación compacta de generador en paréntesis:</p>
<pre>
<strong id="grammar-token-python-grammar-generator_expression"><span id="grammar-token-generator-expression"></span>generator_expression</strong> ::=  &quot;(&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> <a class="reference internal" href="#grammar-token-python-grammar-comp_for"><code class="xref docutils literal notranslate"><span class="pre">comp_for</span></code></a> &quot;)&quot;
</pre>
<p>Una expresión de generador produce un nuevo objeto generador. Su sintaxis es la misma que para las comprensiones, excepto que es encerrado en paréntesis en lugar de corchetes o llaves.</p>
<p>Las variables usadas en la expresión de generador son evaluadas perezosamente cuando se ejecuta el método <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> para el objeto generador (de la misma forma que los generadores normales). Sin embargo, la expresión iterable en la cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> más a la izquierda es inmediatamente evaluada, de forma que un error producido por ella será emitido en el punto en el que se define la expresión de generador, en lugar de en el punto donde se obtiene el primer valor. Subsecuentes cláusulas <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> y cualquier condición en la cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> más a la izquierda no pueden ser evaluadas en el alcance adjunto, ya que puede depender de los valores obtenidos por el iterable de más a la izquierda. Por ejemplo: <code class="docutils literal notranslate"><span class="pre">(x*y</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(10)</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">range(x,</span> <span class="pre">x+10))</span></code>.</p>
<p>Los paréntesis pueden ser omitidos en ejecuciones con un solo argumento. Vea la sección <a class="reference internal" href="#calls"><span class="std std-ref">Invocaciones</span></a> para más detalles.</p>
<p>Para evitar interferir con la operación esperada de la expresión misma del generador, las expresiones <code class="docutils literal notranslate"><span class="pre">yield</span></code> y <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> están prohibidas en el generador definido implícitamente.</p>
<p>Si una expresión de generador contiene cláusulas <code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> o expresiones <a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>, se ejecuta una <em class="dfn">asynchronous generator expression</em>. Una expresión de generador asincrónica retorna un nuevo objeto de generador asincrónico, el cual es un iterador asincrónico (ver <a class="reference internal" href="datamodel.html#async-iterators"><span class="std std-ref">Iteradores asíncronos</span></a>).</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6: </span>Las expresiones de generador asincrónico fueron introducidas.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Antes de Python 3.7, las expresiones de generador asincrónico podrían aparecer sólo en corrutinas <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a>. Desde 3.7, cualquier función puede usar expresiones de generador asincrónico.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Prohibidas <code class="docutils literal notranslate"><span class="pre">yield</span></code> y <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> en el alcance implícitamente anidado.</p>
</div>
</section>
<section id="yield-expressions">
<span id="yieldexpr"></span><h3><span class="section-number">6.2.9. </span>Expresiones yield<a class="headerlink" href="#yield-expressions" title="Enlazar permanentemente con este título">¶</a></h3>
<pre id="index-23">
<strong id="grammar-token-python-grammar-yield_atom"><span id="grammar-token-yield-atom"></span>yield_atom      </strong> ::=  &quot;(&quot; <a class="reference internal" href="#grammar-token-python-grammar-yield_expression"><code class="xref docutils literal notranslate"><span class="pre">yield_expression</span></code></a> &quot;)&quot;
<strong id="grammar-token-python-grammar-yield_expression"><span id="grammar-token-yield-expression"></span>yield_expression</strong> ::=  &quot;yield&quot; [<a class="reference internal" href="#grammar-token-python-grammar-expression_list"><code class="xref docutils literal notranslate"><span class="pre">expression_list</span></code></a> | &quot;from&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>]
</pre>
<p>The yield expression is used when defining a <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a> function
or an <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">asynchronous generator</span></a> function and
thus can only be used in the body of a function definition.  Using a yield
expression in a function’s body causes that function to be a generator function,
and using it in an <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> function’s body causes that
coroutine function to be an asynchronous generator function. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>  <span class="c1"># defines a generator function</span>
    <span class="k">yield</span> <span class="mi">123</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">agen</span><span class="p">():</span> <span class="c1"># defines an asynchronous generator function</span>
    <span class="k">yield</span> <span class="mi">123</span>
</pre></div>
</div>
<p>Debido a sus efectos secundarios sobre el alcance contenedor, las expresiones <code class="docutils literal notranslate"><span class="pre">yield</span></code> no están permitidas como parte de los alcances implícitamente definidos usados para implementar comprensiones y expresiones de generador.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Expresiones yield prohibidas en los ámbitos anidados implícitamente utilizados para implementar comprensiones y expresiones de generador.</p>
</div>
<p>Las funciones generadoras son descritas a continuación, mientras que las funciones generadoras asincrónicas son descritas separadamente en la sección <a class="reference internal" href="#asynchronous-generator-functions"><span class="std std-ref">Funciones generadoras asincrónicas</span></a>.</p>
<p>When a generator function is called, it returns an iterator known as a
generator.  That generator then controls the execution of the generator
function.  The execution starts when one of the generator’s methods is called.
At that time, the execution proceeds to the first yield expression, where it is
suspended again, returning the value of <a class="reference internal" href="#grammar-token-python-grammar-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a>
to the generator’s caller,
or <code class="docutils literal notranslate"><span class="pre">None</span></code> if <a class="reference internal" href="#grammar-token-python-grammar-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> is omitted.
By suspended, we mean that all local state is
retained, including the current bindings of local variables, the instruction
pointer, the internal evaluation stack, and the state of any exception handling.
When the execution is resumed by calling one of the generator’s methods, the
function can proceed exactly as if the yield expression were just another
external call.  The value of the yield expression after resuming depends on the
method which resumed the execution.  If <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> is used
(typically via either a <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> or the <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> builtin) then the
result is <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>.  Otherwise, if <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> is used, then
the result will be the value passed in to that method.</p>
<p id="index-24">Todo este hace a las funciones generadores similar a las corrutinas; producen múltiples veces, tienen más de un punto de entrada y su ejecución puede ser suspendida. La única diferencia es que una función generadora no puede controlar si la ejecución debe continuar después de producir; el control siempre es transferido al invocador del generador.</p>
<p>Las expresiones yield están permitidas en cualquier lugar en un constructo <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>. Si el generador no es reanudado antes de finalizar (alcanzando un recuento de referencia cero o colectando basura), el método generador-iterador <a class="reference internal" href="#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> será invocado, permitiendo la ejecución de cualquier cláusula <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> pendiente.</p>
<p id="index-25">Cuando se usa <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code>, la expresión proporcionada debe ser iterable. Los valores producidos al iterar ese iterable se pasan directamente al llamador de los métodos del generador actual. Cualquier valor pasado con <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> y cualquier excepción pasada con <a class="reference internal" href="#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> se pasan al iterador subyacente si tiene los métodos apropiados. Si este no es el caso, entonces <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> lanzará <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> o <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>, mientras que <a class="reference internal" href="#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> solo lanzará la excepción pasada inmediatamente.</p>
<p>Cuando el iterador subyacente está completo, el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> de la instancia <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> generada se convierte en el valor de la expresión yield. Puede ser establecido explícitamente al generar <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> o automáticamente cuando el subiterador es un generador (retornando un valor del subgenerador).</p>
<blockquote>
<div><div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Añadido <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> para delegar el control de flujo a un subiterador.</p>
</div>
</div></blockquote>
<p>Los paréntesis pueden ser omitidos cuando la expresión yield es la única expresión en el lado derecho de una sentencia de asignación.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-112"></span><a class="pep reference external" href="https://peps.python.org/pep-0255/"><strong>PEP 255</strong></a> - Generadores Simples</dt><dd><p>La propuesta para añadir generadores y la sentencia <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> a Python.</p>
</dd>
<dt><span class="target" id="index-113"></span><a class="pep reference external" href="https://peps.python.org/pep-0342/"><strong>PEP 342</strong></a> - Corrutinas mediante Generadores Mejorados</dt><dd><p>La propuesta para mejorar la API y la sintaxis de generadores, haciéndolos utilizables como corrutinas simples.</p>
</dd>
<dt><span class="target" id="index-114"></span><a class="pep reference external" href="https://peps.python.org/pep-0380/"><strong>PEP 380</strong></a> - Sintaxis para Delegar a un Subgenerador</dt><dd><p>The proposal to introduce the <code class="xref std std-token docutils literal notranslate"><span class="pre">yield_from</span></code> syntax,
making delegation to subgenerators easy.</p>
</dd>
<dt><span class="target" id="index-115"></span><a class="pep reference external" href="https://peps.python.org/pep-0525/"><strong>PEP 525</strong></a>- Generadores Asincrónicos</dt><dd><p>La propuesta que expandió <span class="target" id="index-116"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> añadiendo capacidades de generador a las funciones corrutina.</p>
</dd>
</dl>
</div>
<section id="generator-iterator-methods">
<span id="generator-methods"></span><span id="index-31"></span><h4><span class="section-number">6.2.9.1. </span>Métodos generador-iterador<a class="headerlink" href="#generator-iterator-methods" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Esta subsección describe los métodos de un generador iterador. Estos pueden ser usados para controlar la ejecución de una función generadora.</p>
<p>Tenga en cuenta que invocar cualquiera de los métodos de generador siguientes cuando el generador está todavía en ejecución genera una excepción <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
<span class="target" id="index-32"></span><dl class="py method">
<dt class="sig sig-object py" id="generator.__next__">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">__next__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.__next__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Starts the execution of a generator function or resumes it at the last
executed yield expression.  When a generator function is resumed with a
<a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> method, the current yield expression always
evaluates to <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>.  The execution then continues to the next yield
expression, where the generator is suspended again, and the value of the
<a class="reference internal" href="#grammar-token-python-grammar-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> is returned to <a class="reference internal" href="#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a>”s
caller.  If the generator exits without yielding another value, a
<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> exception is raised.</p>
<p>Este método es normalmente invocado implícitamente, por ejemplo, por un bucle <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> o por la función incorporada <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="generator.send">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">send</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#generator.send" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Reanuda la ejecución y «envía» un valor dentro de la función generadora. El argumento <em>value</em> se convierte en el resultado de la expresión yield actual. El método <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> retorna el siguiente valor producido por el generador o genera <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> si el generador termina sin producir otro valor. Cuando se ejecuta <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> para comenzar el generador, debe ser invocado con <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> como el argumento, debido a que no hay expresión yield que pueda recibir el valor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="generator.throw">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">throw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#generator.throw" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">throw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">traceback</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Raises an exception at the point where the generator was paused,
and returns the next value yielded by the generator function.  If the generator
exits without yielding another value, a <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> exception is
raised.  If the generator function does not catch the passed-in exception, or
raises a different exception, then that exception propagates to the caller.</p>
<p>In typical use, this is called with a single exception instance similar to the
way the <a class="reference internal" href="simple_stmts.html#raise"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a> keyword is used.</p>
<p>For backwards compatibility, however, the second signature is
supported, following a convention from older versions of Python.
The <em>type</em> argument should be an exception class, and <em>value</em>
should be an exception instance. If the <em>value</em> is not provided, the
<em>type</em> constructor is called to get an instance. If <em>traceback</em>
is provided, it is set on the exception, otherwise any existing
<code class="xref py py-attr docutils literal notranslate"><span class="pre">__traceback__</span></code> attribute stored in <em>value</em> may
be cleared.</p>
</dd></dl>

<span class="target" id="index-33"></span><dl class="py method">
<dt class="sig sig-object py" id="generator.close">
<span class="sig-prename descclassname"><span class="pre">generator.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#generator.close" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Genera <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> en el punto donde la función generadora fue pausada. Si la función generadora termina sin errores, está ya cerrada o genera <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> (sin cazar la excepción), close retorna a su invocador. Si el generador produce un valor, se genera un <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>. Si el generador genera cualquier otra excepción, es propagado al invocador. <a class="reference internal" href="#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> no hace nada si el generador ya fue terminado debido a una excepción o una salida normal.</p>
</dd></dl>

</section>
<section id="examples">
<span id="index-34"></span><h4><span class="section-number">6.2.9.2. </span>Ejemplos<a class="headerlink" href="#examples" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Aquí hay un ejemplo simple que demuestra el comportamiento de generadores y funciones generadoras:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">echo</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Execution starts when &#39;next()&#39; is called for the first time.&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">... </span>            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">value</span> <span class="o">=</span> <span class="n">e</span>
<span class="gp">... </span>    <span class="k">finally</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Don&#39;t forget to clean up when &#39;close()&#39; is called.&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span> <span class="o">=</span> <span class="n">echo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
<span class="go">Execution starts when &#39;next()&#39; is called for the first time.</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">generator</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="s2">&quot;spam&quot;</span><span class="p">)</span>
<span class="go">TypeError(&#39;spam&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">generator</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="go">Don&#39;t forget to clean up when &#39;close()&#39; is called.</span>
</pre></div>
</div>
<p>Para ejemplos usando <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>, ver <a class="reference internal" href="../whatsnew/3.3.html#pep-380"><span class="std std-ref">PEP 380: Sintaxis para delegar en un subgenerador</span></a> en «Qué es nuevo en Python.»</p>
</section>
<section id="asynchronous-generator-functions">
<span id="id3"></span><h4><span class="section-number">6.2.9.3. </span>Funciones generadoras asincrónicas<a class="headerlink" href="#asynchronous-generator-functions" title="Enlazar permanentemente con este título">¶</a></h4>
<p>La presencia de una expresión yield en una función o método definido usando <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> adicionalmente define la función como una función <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">asynchronous generator</span></a>.</p>
<p>Cuando se invoca una función generadora asincrónica, retorna un iterador asincrónico conocido como un objeto generador asincrónico. Este objeto entonces controla la ejecución de la función generadora. Un objeto generador asincrónico se usa típicamente en una sentencia <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> en una función corrutina análogamente a como sería usado un objeto generador en una sentencia <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>.</p>
<p>Calling one of the asynchronous generator’s methods returns an <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a>
object, and the execution starts when this object is awaited on. At that time,
the execution proceeds to the first yield expression, where it is suspended
again, returning the value of <a class="reference internal" href="#grammar-token-python-grammar-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> to the
awaiting coroutine. As with a generator, suspension means that all local state
is retained, including the current bindings of local variables, the instruction
pointer, the internal evaluation stack, and the state of any exception handling.
When the execution is resumed by awaiting on the next object returned by the
asynchronous generator’s methods, the function can proceed exactly as if the
yield expression were just another external call. The value of the yield
expression after resuming depends on the method which resumed the execution.  If
<a class="reference internal" href="#agen.__anext__" title="agen.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> is used then the result is <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>. Otherwise, if
<a class="reference internal" href="#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asend()</span></code></a> is used, then the result will be the value passed in to that
method.</p>
<p>Si un generador asincrónico sale temprano por <a class="reference internal" href="simple_stmts.html#break"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">break</span></code></a>, la tarea de la persona que llama se cancela u otras excepciones, el código de limpieza asíncrono del generador se ejecutará y posiblemente lanzará excepciones o accederá a variables de contexto en un contexto inesperado, tal vez después de la vida útil de las tareas de las que depende, o durante el cierre del ciclo de eventos cuando se llama al gancho de recolección de basura del generador asíncrono. Para evitar esto, la persona que llama debe cerrar explícitamente el generador asíncrono llamando al método <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> para finalizar el generador y finalmente desconectarlo del bucle de eventos.</p>
<p>En una función generadora asincrónica, las expresiones yield están permitidas en cualquier lugar de un constructo <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>. Sin embargo, si un generador asincrónico no es reanudado antes de finalizar (alcanzando un contador de referencia cero o recogiendo basura), entonces una expresión yield dentro de un constructo <code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code> podría fallar al ejecutar cláusulas <a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> pendientes. En este caso, es responsabilidad del bucle de eventos o del planificador ejecutando el generador asincrónico invocar el método <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> del generador-iterador asincrónico y ejecutar el objeto corrutina resultante, permitiendo así la ejecución de cualquier cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> pendiente.</p>
<p>Para encargarse de la finalización tras la finalización del ciclo de eventos, un ciclo de eventos debe definir una función <em>finalizer</em> que tome un generador-iterador asíncrono y presumiblemente llame a <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> y ejecute la rutina. Este <em>finalizer</em> se puede registrar llamando a <a class="reference internal" href="../library/sys.html#sys.set_asyncgen_hooks" title="sys.set_asyncgen_hooks"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.set_asyncgen_hooks()</span></code></a>. Cuando se itera por primera vez, un generador-iterador asíncrono almacenará el <em>finalizer</em> registrado para ser llamado al finalizar. Para obtener un ejemplo de referencia de un método <em>finalizer</em>, consulte la implementación de <code class="docutils literal notranslate"><span class="pre">asyncio.Loop.shutdown_asyncgens</span></code> en <a class="reference external" href="https://github.com/python/cpython/tree/3.11/Lib/asyncio/base_events.py">Lib/asyncio/base_events.py</a>.</p>
<p>La expresión <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">&lt;expr&gt;</span></code> es un error de sintaxis cuando es usada en una función generadora asincrónica.</p>
</section>
<section id="asynchronous-generator-iterator-methods">
<span id="asynchronous-generator-methods"></span><span id="index-35"></span><h4><span class="section-number">6.2.9.4. </span>Métodos asincrónicos de generador-iterador<a class="headerlink" href="#asynchronous-generator-iterator-methods" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Esta subsección describe los métodos de un generador iterador asincrónico, los cuales son usados para controlar la ejecución de una función generadora.</p>
<span class="target" id="index-36"></span><dl class="py method">
<dt class="sig sig-object py" id="agen.__anext__">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">__anext__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agen.__anext__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Returns an awaitable which when run starts to execute the asynchronous
generator or resumes it at the last executed yield expression.  When an
asynchronous generator function is resumed with an <a class="reference internal" href="#agen.__anext__" title="agen.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a>
method, the current yield expression always evaluates to <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> in the
returned awaitable, which when run will continue to the next yield
expression. The value of the <a class="reference internal" href="#grammar-token-python-grammar-expression_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression_list</span></code></a> of the
yield expression is the value of the <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> exception raised by
the completing coroutine.  If the asynchronous generator exits without
yielding another value, the awaitable instead raises a
<a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> exception, signalling that the asynchronous
iteration has completed.</p>
<p>Este método es invocado normalmente de forma implícita por un bucle <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="agen.asend">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">asend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#agen.asend" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un esperable el cual cuando corre reanuda la ejecución del generador asincrónico. Como el método <a class="reference internal" href="#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> para un generador, este «envía» un valor a la función generadora asincrónica y el argumento <em>value</em> se convierte en el resultado de la expresión yield actual. El esperable retornado por el método <a class="reference internal" href="#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asend()</span></code></a> retornará el siguiente valor producido por el generador como el valor de la <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> generada o genera <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> si el generador asincrónico termina sin producir otro valor. Cuando se invoca <a class="reference internal" href="#agen.asend" title="agen.asend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asend()</span></code></a> para empezar el generador asincrónico, debe ser invocado con <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> como argumento, porque no hay expresión yield que pueda recibir el valor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="agen.athrow">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">athrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">traceback</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#agen.athrow" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un esperable que genera una excepción de tipo <code class="docutils literal notranslate"><span class="pre">type</span></code> en el punto donde el generador asincrónico fue pausado y retorna el siguiente valor producido por la función generadora como el valor de la excepción <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> generada. Si el generador asincrónico termina sin producir otro valor, el esperable genera una excepción <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a>. Si la función generadora no caza la excepción pasada o genera una excepción diferente, entonces cuando se ejecuta el esperable esa excepción se propaga al invocador del esperable.</p>
</dd></dl>

<span class="target" id="index-37"></span><dl class="py method">
<dt class="sig sig-object py" id="agen.aclose">
<em class="property"><span class="pre">coroutine</span> </em><span class="sig-prename descclassname"><span class="pre">agen.</span></span><span class="sig-name descname"><span class="pre">aclose</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#agen.aclose" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un esperable que cuando corre lanza un <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> a la función generadora asincrónica en el punto donde fue pausada. Si la función generadora asincrónica termina exitosamente, ya está cerrada o genera  <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> (sin cazar la excepción), el esperable retornado lanzará una excepción <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>. Otros esperables retornados por subsecuentes invocaciones al generador asincrónico lanzarán una excepción <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a>. Si el generador asincrónico produce un valor, el esperable genera un <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>. Si el generador asincrónico genera cualquier otra excepción, esta es propagada al invocador del esperable. Si el generador asincrónico ha terminado debido a una excepción o una terminación normal, entonces futuras invocaciones a <a class="reference internal" href="#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> retornarán un esperable que no hace nada.</p>
</dd></dl>

</section>
</section>
</section>
<section id="primaries">
<span id="id4"></span><h2><span class="section-number">6.3. </span>Primarios<a class="headerlink" href="#primaries" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-38">Los primarios representan las operaciones más fuertemente ligadas al lenguaje. Su sintaxis es:</p>
<pre>
<strong id="grammar-token-python-grammar-primary"><span id="grammar-token-primary"></span>primary</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-atom"><code class="xref docutils literal notranslate"><span class="pre">atom</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-attributeref"><code class="xref docutils literal notranslate"><span class="pre">attributeref</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-subscription"><code class="xref docutils literal notranslate"><span class="pre">subscription</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-slicing"><code class="xref docutils literal notranslate"><span class="pre">slicing</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-call"><code class="xref docutils literal notranslate"><span class="pre">call</span></code></a>
</pre>
<section id="attribute-references">
<span id="id5"></span><h3><span class="section-number">6.3.1. </span>Referencias de atributos<a class="headerlink" href="#attribute-references" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-39">Una referencia de atributo es un primario seguido de un punto y un nombre:</p>
<pre>
<strong id="grammar-token-python-grammar-attributeref"><span id="grammar-token-attributeref"></span>attributeref</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;.&quot; <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a>
</pre>
<p id="index-40">El primario debe evaluar a un objeto de un tipo que soporte referencias de atributos, lo cual la mayoría de los objetos soportan. Luego se le pide a este objeto que produzca el atributo cuyo nombre es el identificador. Esta producción puede ser personalizada sobrescribiendo el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code>. Si este atributo no es esperable, se genera la excepción <code class="xref py py-exc docutils literal notranslate"><span class="pre">AtributeError</span></code>. De otra forma, el tipo y el valor del objeto producido es determinado por el objeto. Múltiples evaluaciones la misma referencia de atributo pueden producir diferentes objetos.</p>
</section>
<section id="subscriptions">
<span id="id6"></span><h3><span class="section-number">6.3.2. </span>Suscripciones<a class="headerlink" href="#subscriptions" title="Enlazar permanentemente con este título">¶</a></h3>
<span class="target" id="index-41"></span><p id="index-42">The subscription of an instance of a <a class="reference internal" href="datamodel.html#sequence-types"><span class="std std-ref">container class</span></a>
will generally select an element from the container. The subscription of a
<a class="reference internal" href="../glossary.html#term-generic-type"><span class="xref std std-term">generic class</span></a> will generally return a
<a class="reference internal" href="../library/stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias</span></a> object.</p>
<pre>
<strong id="grammar-token-python-grammar-subscription"><span id="grammar-token-subscription"></span>subscription</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression_list"><code class="xref docutils literal notranslate"><span class="pre">expression_list</span></code></a> &quot;]&quot;
</pre>
<p>When an object is subscripted, the interpreter will evaluate the primary and
the expression list.</p>
<p>The primary must evaluate to an object that supports subscription. An object
may support subscription through defining one or both of
<a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> and <a class="reference internal" href="datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>. When the
primary is subscripted, the evaluated result of the expression list will be
passed to one of these methods. For more details on when <code class="docutils literal notranslate"><span class="pre">__class_getitem__</span></code>
is called instead of <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>, see <a class="reference internal" href="datamodel.html#classgetitem-versus-getitem"><span class="std std-ref">__class_getitem__ versus __getitem__</span></a>.</p>
<p>If the expression list contains at least one comma, it will evaluate to a
<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> containing the items of the expression list. Otherwise, the
expression list will evaluate to the value of the list’s sole member.</p>
<p>For built-in objects, there are two types of objects that support subscription
via <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>:</p>
<ol class="arabic simple">
<li><p>Mappings. If the primary is a <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a>, the expression list must
evaluate to an object whose value is one of the keys of the mapping, and the
subscription selects the value in the mapping that corresponds to that key.
An example of a builtin mapping class is the <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> class.</p></li>
<li><p>Sequences. If the primary is a <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequence</span></a>, the expression list must
evaluate to an <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> or a <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> (as discussed in the
following section). Examples of builtin sequence classes include the
<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> and <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> classes.</p></li>
</ol>
<p>The formal syntax makes no special provision for negative indices in
<a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequences</span></a>. However, built-in sequences all provide a <a class="reference internal" href="datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>
method that interprets negative indices by adding the length of the sequence
to the index so that, for example, <code class="docutils literal notranslate"><span class="pre">x[-1]</span></code> selects the last item of <code class="docutils literal notranslate"><span class="pre">x</span></code>. The
resulting value must be a nonnegative integer less than the number of items in
the sequence, and the subscription selects the item whose index is that value
(counting from zero). Since the support for negative indices and slicing
occurs in the object’s <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code> method, subclasses overriding
this method will need to explicitly add that support.</p>
<p id="index-43">A <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">string</span></code></a> is a special kind of sequence whose items are
<em>characters</em>. A character is not a separate data type but a
string of exactly one character.</p>
</section>
<section id="slicings">
<span id="id7"></span><h3><span class="section-number">6.3.3. </span>Segmentos<a class="headerlink" href="#slicings" title="Enlazar permanentemente con este título">¶</a></h3>
<span class="target" id="index-44"></span><p id="index-45">Un segmento selecciona un rango de elementos en una objeto secuencia (ej., una cadena de caracteres, tupla o lista). Los segmentos pueden ser usados como expresiones o como objetivos en asignaciones o sentencias <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a>. La sintaxis para un segmento:</p>
<pre>
<strong id="grammar-token-python-grammar-slicing"><span id="grammar-token-slicing"></span>slicing     </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-python-grammar-slice_list"><code class="xref docutils literal notranslate"><span class="pre">slice_list</span></code></a> &quot;]&quot;
<strong id="grammar-token-python-grammar-slice_list"><span id="grammar-token-slice-list"></span>slice_list  </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-slice_item"><code class="xref docutils literal notranslate"><span class="pre">slice_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-slice_item"><code class="xref docutils literal notranslate"><span class="pre">slice_item</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-python-grammar-slice_item"><span id="grammar-token-slice-item"></span>slice_item  </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-proper_slice"><code class="xref docutils literal notranslate"><span class="pre">proper_slice</span></code></a>
<strong id="grammar-token-python-grammar-proper_slice"><span id="grammar-token-proper-slice"></span>proper_slice</strong> ::=  [<a class="reference internal" href="#grammar-token-python-grammar-lower_bound"><code class="xref docutils literal notranslate"><span class="pre">lower_bound</span></code></a>] &quot;:&quot; [<a class="reference internal" href="#grammar-token-python-grammar-upper_bound"><code class="xref docutils literal notranslate"><span class="pre">upper_bound</span></code></a>] [ &quot;:&quot; [<a class="reference internal" href="#grammar-token-python-grammar-stride"><code class="xref docutils literal notranslate"><span class="pre">stride</span></code></a>] ]
<strong id="grammar-token-python-grammar-lower_bound"><span id="grammar-token-lower-bound"></span>lower_bound </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-python-grammar-upper_bound"><span id="grammar-token-upper-bound"></span>upper_bound </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-python-grammar-stride"><span id="grammar-token-stride"></span>stride      </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p>Hay ambigüedad en la sintaxis formal aquí: todo lo que parezca una expresión de lista también parece una segmento de lista, así que cualquier subscripción puede ser interpretada como un segmento. En lugar de complicar aún más la sintaxis, esta es desambiguada definiendo que en este caso la interpretación como una subscripción toma prioridad sobre la interpretación como un segmento (este es el caso si el segmento de lista no contiene un segmento adecuado).</p>
<p id="index-46">Las semánticas para un segmento son las siguientes. El primario es indexado (usando el mismo método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code> de una subscripción normal) con una clave que se construye del segmento de lista, tal como sigue. Si el segmento de lista contiene al menos una coma, la clave es una tupla que contiene la conversión de los elementos del segmento; de otra forma, la conversión del segmento de lista solitario es la clave. La conversión de un elemento de segmento que es una expresión es esa expresión. La conversión de un segmento apropiado es un objeto segmento (ver sección <a class="reference internal" href="datamodel.html#types"><span class="std std-ref">Jerarquía de tipos estándar</span></a>) cuyos atributos <code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code> y <code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code> son los valores de las expresiones dadas como límite inferior, límite superior y paso, respectivamente, substituyendo <code class="docutils literal notranslate"><span class="pre">None</span></code> para las expresiones faltantes.</p>
</section>
<section id="calls">
<span id="index-47"></span><span id="id8"></span><h3><span class="section-number">6.3.4. </span>Invocaciones<a class="headerlink" href="#calls" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Una invocación invoca un objeto invocable (ej., una <a class="reference internal" href="../glossary.html#term-function"><span class="xref std std-term">function</span></a>) con una serie posiblemente vacía de <a class="reference internal" href="../glossary.html#term-argument"><span class="xref std std-term">argumentos</span></a>:</p>
<pre>
<strong id="grammar-token-python-grammar-call"><span id="grammar-token-call"></span>call                </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a> &quot;(&quot; [<a class="reference internal" href="#grammar-token-python-grammar-argument_list"><code class="xref docutils literal notranslate"><span class="pre">argument_list</span></code></a> [&quot;,&quot;] | <a class="reference internal" href="#grammar-token-python-grammar-comprehension"><code class="xref docutils literal notranslate"><span class="pre">comprehension</span></code></a>] &quot;)&quot;
<strong id="grammar-token-python-grammar-argument_list"><span id="grammar-token-argument-list"></span>argument_list       </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-positional_arguments"><code class="xref docutils literal notranslate"><span class="pre">positional_arguments</span></code></a> [&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-starred_and_keywords"><code class="xref docutils literal notranslate"><span class="pre">starred_and_keywords</span></code></a>]
                            [&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-keywords_arguments"><code class="xref docutils literal notranslate"><span class="pre">keywords_arguments</span></code></a>]
                          | <a class="reference internal" href="#grammar-token-python-grammar-starred_and_keywords"><code class="xref docutils literal notranslate"><span class="pre">starred_and_keywords</span></code></a> [&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-keywords_arguments"><code class="xref docutils literal notranslate"><span class="pre">keywords_arguments</span></code></a>]
                          | <a class="reference internal" href="#grammar-token-python-grammar-keywords_arguments"><code class="xref docutils literal notranslate"><span class="pre">keywords_arguments</span></code></a>
<strong id="grammar-token-python-grammar-positional_arguments"><span id="grammar-token-positional-arguments"></span>positional_arguments</strong> ::=  positional_item (&quot;,&quot; positional_item)*
<strong id="grammar-token-python-grammar-positional_item"><span id="grammar-token-positional-item"></span>positional_item     </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-assignment_expression"><code class="xref docutils literal notranslate"><span class="pre">assignment_expression</span></code></a> | &quot;*&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
<strong id="grammar-token-python-grammar-starred_and_keywords"><span id="grammar-token-starred-and-keywords"></span>starred_and_keywords</strong> ::=  (&quot;*&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a>)
                          (&quot;,&quot; &quot;*&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | &quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a>)*
<strong id="grammar-token-python-grammar-keywords_arguments"><span id="grammar-token-keywords-arguments"></span>keywords_arguments  </strong> ::=  (<a class="reference internal" href="#grammar-token-python-grammar-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a> | &quot;**&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>)
                          (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-keyword_item"><code class="xref docutils literal notranslate"><span class="pre">keyword_item</span></code></a> | &quot;,&quot; &quot;**&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>)*
<strong id="grammar-token-python-grammar-keyword_item"><span id="grammar-token-keyword-item"></span>keyword_item        </strong> ::=  <a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> &quot;=&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p>Una coma final opcional puede estar presente después de los argumentos posicionales y de palabra clave pero no afecta a las semánticas.</p>
<p id="index-48">La clave primaria debe evaluar a un objeto invocable (funciones definidas por el usuario, funciones incorporadas, métodos de objetos incorporados, métodos de instancias de clases y todos los objetos que tienen un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code> son invocables). Todas las expresiones de argumento son evaluadas antes de que la invocación sea intentada. Por favor, refiera a la sección <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">Definiciones de funciones</span></a> para la sintaxis formal de listas de <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parameter</span></a>.</p>
<p>If keyword arguments are present, they are first converted to positional
arguments, as follows.  First, a list of unfilled slots is created for the
formal parameters.  If there are N positional arguments, they are placed in the
first N slots.  Next, for each keyword argument, the identifier is used to
determine the corresponding slot (if the identifier is the same as the first
formal parameter name, the first slot is used, and so on).  If the slot is
already filled, a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> exception is raised. Otherwise, the
argument is placed in the slot, filling it (even if the expression is
<code class="docutils literal notranslate"><span class="pre">None</span></code>, it fills the slot).  When all arguments have been processed, the slots
that are still unfilled are filled with the corresponding default value from the
function definition.  (Default values are calculated, once, when the function is
defined; thus, a mutable object such as a list or dictionary used as default
value will be shared by all calls that don’t specify an argument value for the
corresponding slot; this should usually be avoided.)  If there are any unfilled
slots for which no default value is specified, a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> exception is
raised.  Otherwise, the list of filled slots is used as the argument list for
the call.</p>
<div class="impl-detail compound">
<p><strong>Detalles de implementación de CPython:</strong> Una implementación puede proveer funciones incorporadas cuyos argumentos posicionales no tienen nombres, incluso si son «nombrados» a efectos de documentación y los cuales por consiguiente no pueden ser suplidos por palabras clave. En CPython, este es el caso para funciones implementadas en C que usan <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> para analizar sus argumentos.</p>
</div>
<p>Si hay más argumentos posicionales que ranuras formales de parámetros, se genera una excepción <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>, a no ser que un parámetro formal usando la sintaxis <code class="docutils literal notranslate"><span class="pre">*identifier</span></code> se encuentre presente; en este caso, ese parámetro formal recibe una tupla conteniendo los argumentos posicionales sobrantes (o una tupla vacía su no hay argumentos posicionales sobrantes).</p>
<p>Si un argumento de palabra clave no corresponde a un nombre de parámetro formal, se genera una excepción <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>, a no ser que un parámetro formal usando la sintaxis <code class="docutils literal notranslate"><span class="pre">**identifier</span></code> esté presente; en este caso, ese parámetro formal recibe un diccionario que contiene los argumentos de palabra clave sobrantes (usando las palabras clave como claves y los valores de argumento como sus valores correspondientes), o un (nuevo) diccionario vacío si no hay argumentos de palabra clave sobrantes.</p>
<p id="index-49">Si la sintaxis <code class="docutils literal notranslate"><span class="pre">*expression</span></code> aparece en la invocación de función, <code class="docutils literal notranslate"><span class="pre">expression</span></code> debe evaluar a un <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a>. Elementos de esos iterables son tratados como si fueran argumentos posicionales adicionales. Para la invocación <code class="docutils literal notranslate"><span class="pre">f(x1,</span> <span class="pre">x2,</span> <span class="pre">*y,</span> <span class="pre">x3,</span> <span class="pre">x4)</span></code>, si <em>y</em> evalúa a una secuencia <em>y1</em>, …, <em>yM</em>, equivale a una invocación con M+4 argumentos posicionales <em>x1</em>, <em>x2</em>, <em>y1</em>, …, <em>yM</em>, <em>x3</em>, <em>x4</em>.</p>
<p>Una consecuencia de esto es que aunque la sintaxis <code class="docutils literal notranslate"><span class="pre">*expression</span></code> puede aparecer <em>después</em> de argumentos de palabra clave explícitos, es procesada <em>antes</em> de los argumentos de palabra clave (y cualquiera de los argumentos <code class="docutils literal notranslate"><span class="pre">*expression</span></code> – ver abajo). Así que:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">2 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">f() got multiple values for keyword argument &#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="go">1 2</span>
</pre></div>
</div>
<p>It is unusual for both keyword arguments and the <code class="docutils literal notranslate"><span class="pre">*expression</span></code> syntax to be
used in the same call, so in practice this confusion does not often arise.</p>
<p id="index-50">If the syntax <code class="docutils literal notranslate"><span class="pre">**expression</span></code> appears in the function call, <code class="docutils literal notranslate"><span class="pre">expression</span></code> must
evaluate to a <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a>, the contents of which are treated as
additional keyword arguments. If a parameter matching a key has already been
given a value (by an explicit keyword argument, or from another unpacking),
a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> exception is raised.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">**expression</span></code> is used, each key in this mapping must be
a string.
Each value from the mapping is assigned to the first formal parameter
eligible for keyword assignment whose name is equal to the key.
A key need not be a Python identifier (e.g. <code class="docutils literal notranslate"><span class="pre">&quot;max-temp</span> <span class="pre">°F&quot;</span></code> is acceptable,
although it will not match any formal parameter that could be declared).
If there is no match to a formal parameter
the key-value pair is collected by the <code class="docutils literal notranslate"><span class="pre">**</span></code> parameter, if there is one,
or if there is not, a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> exception is raised.</p>
<p>No pueden ser usados parámetros formales usando la sintaxis <code class="docutils literal notranslate"><span class="pre">*identifier</span></code> o <code class="docutils literal notranslate"><span class="pre">**identifier</span></code> como ranuras de argumentos posicionales o como nombres de argumentos de palabra clave.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Las invocaciones de función aceptan cualquier número de desempaquetados <code class="docutils literal notranslate"><span class="pre">*</span></code> y <code class="docutils literal notranslate"><span class="pre">**</span></code>, los argumentos posicionales pueden seguir a desempaquetados de iterable (<code class="docutils literal notranslate"><span class="pre">*</span></code>) y los argumentos de palabra clave pueden seguir a desempaquetados de diccionario (<code class="docutils literal notranslate"><span class="pre">*</span></code>). Originalmente propuesto por <span class="target" id="index-117"></span><a class="pep reference external" href="https://peps.python.org/pep-0448/"><strong>PEP 448</strong></a>.</p>
</div>
<p>Una invocación siempre retorna algún valor, posiblemente <code class="docutils literal notranslate"><span class="pre">None</span></code>, a no ser que genere una excepción. Cómo se calcula este valor depende del tipo del objeto invocable.</p>
<p>Si es—</p>
<dl>
<dt>una función definida por el usuario:</dt><dd><p id="index-52">Se ejecuta el bloque de código para la función, pasándole la lista de argumentos. Lo primero que hace el bloque de código es enlazar los parámetros formales a los argumentos; esto es descrito en la sección <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">Definiciones de funciones</span></a>. Cuando el bloque de código ejecuta una sentencia <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a>, esto especifica el valor de retorno de la invocación de función.</p>
</dd>
<dt>una función o método incorporado:</dt><dd><p id="index-53">El resultado depende del intérprete; ver <a class="reference internal" href="../library/functions.html#built-in-funcs"><span class="std std-ref">Funciones Built-in</span></a> para las descripciones de funciones y métodos incorporados.</p>
</dd>
<dt>un objeto de clase:</dt><dd><p id="index-54">Se retorna una nueva instancia de esa clase.</p>
</dd>
<dt>un método de una instancia de clase:</dt><dd><p id="index-55">Se invoca la función definida por el usuario correspondiente, con una lista de argumentos con un largo uno mayor que la lista de argumentos de la invocación: la instancia se convierte en el primer argumento.</p>
</dd>
<dt>una instancia de clase:</dt><dd><p id="index-56">La clase debe definir un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code>; el efecto es entonces el mismo que si ese método fuera invocado.</p>
</dd>
</dl>
</section>
</section>
<section id="await-expression">
<span id="await"></span><span id="index-57"></span><h2><span class="section-number">6.4. </span>Expresión await<a class="headerlink" href="#await-expression" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Suspende la ejecución de <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a> o un objeto <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a>. Puede ser usado sólo dentro de una <a class="reference internal" href="../glossary.html#term-coroutine-function"><span class="xref std std-term">coroutine function</span></a>.</p>
<pre>
<strong id="grammar-token-python-grammar-await_expr"><span id="grammar-token-await-expr"></span>await_expr</strong> ::=  &quot;await&quot; <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a>
</pre>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
</section>
<section id="the-power-operator">
<span id="power"></span><h2><span class="section-number">6.5. </span>El operador de potencia<a class="headerlink" href="#the-power-operator" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-58">El operador de potencia se vincula más estrechamente que los operadores unarios a su izquierda; se vincula con menos fuerza que los operadores unarios a su derecha. La sintaxis es:</p>
<pre>
<strong id="grammar-token-python-grammar-power"><span id="grammar-token-power"></span>power</strong> ::=  (<a class="reference internal" href="#grammar-token-python-grammar-await_expr"><code class="xref docutils literal notranslate"><span class="pre">await_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-primary"><code class="xref docutils literal notranslate"><span class="pre">primary</span></code></a>) [&quot;**&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a>]
</pre>
<p>Por lo tanto, en una secuencia sin paréntesis de operadores unarios y de potencia, los operadores son evaluados desde la derecha a la izquierda (este no se constriñe al orden de evaluación para los operandos): <code class="docutils literal notranslate"><span class="pre">-1**2</span></code> resulta en <code class="docutils literal notranslate"><span class="pre">-1</span></code>.</p>
<p>El operador de potencia tiene las mismas semánticas que la función incorporada <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> cuando se invoca con dos argumentos: este produce su argumento de la izquierda elevado a la potencia de su argumento de la derecha. Los argumentos numéricos se convierten primero en un tipo común y el resultado es de ese tipo.</p>
<p>Para operandos int, el resultado tiene el mismo tipo que los operandos a no ser que el segundo argumento sea negativo; en ese caso, todos los argumentos son convertidos a float y se entrega un resultado float. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">10**2</span></code> retorna <code class="docutils literal notranslate"><span class="pre">100</span></code>, pero <code class="docutils literal notranslate"><span class="pre">10**-2</span></code> retorna <code class="docutils literal notranslate"><span class="pre">0.01</span></code>.</p>
<p>Elevar <code class="docutils literal notranslate"><span class="pre">0.0</span></code> a una potencia negativa resulta en un <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a>. Elevar un número negativo a una potencia fraccional resulta en un número <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>. (En versiones anteriores se genera un <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.)</p>
<p>Esta operación se puede personalizar mediante el método especial <code class="xref py py-meth docutils literal notranslate"><span class="pre">__pow__()</span></code>.</p>
</section>
<section id="unary-arithmetic-and-bitwise-operations">
<span id="unary"></span><h2><span class="section-number">6.6. </span>Aritmética unaria y operaciones bit a bit<a class="headerlink" href="#unary-arithmetic-and-bitwise-operations" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-59">Toda la aritmética unaria y las operaciones bit a bit tienen la misma prioridad:</p>
<pre>
<strong id="grammar-token-python-grammar-u_expr"><span id="grammar-token-u-expr"></span>u_expr</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-power"><code class="xref docutils literal notranslate"><span class="pre">power</span></code></a> | &quot;-&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | &quot;+&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | &quot;~&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a>
</pre>
<p id="index-60">El operador unario <code class="docutils literal notranslate"><span class="pre">-</span></code> (menos) produce la negación de su argumento numérico; la operación se puede anular con el método especial <code class="xref py py-meth docutils literal notranslate"><span class="pre">__neg__()</span></code>.</p>
<p id="index-61">El operador unario <code class="docutils literal notranslate"><span class="pre">+</span></code> (más) produce su argumento numérico sin cambios; la operación se puede anular con el método especial <code class="xref py py-meth docutils literal notranslate"><span class="pre">__pos__()</span></code>.</p>
<p id="index-62">El operador unario <code class="docutils literal notranslate"><span class="pre">~</span></code> (invertir) produce la inversión bit a bit de su argumento entero. La inversión bit a bit de <code class="docutils literal notranslate"><span class="pre">x</span></code> se define como <code class="docutils literal notranslate"><span class="pre">-(x+1)</span></code>. Solo se aplica a números enteros o a objetos personalizados que anulan el método especial <code class="xref py py-meth docutils literal notranslate"><span class="pre">__invert__()</span></code>.</p>
<p id="index-63">En todos los tres casos, si el argumento no tiene el tipo apropiado, se genera una excepción <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
</section>
<section id="binary-arithmetic-operations">
<span id="binary"></span><h2><span class="section-number">6.7. </span>Operaciones aritméticas binarias<a class="headerlink" href="#binary-arithmetic-operations" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-64">Las operaciones aritméticas binarias tienen los niveles convencionales de prioridad. Tenga en cuenta que algunas de esas operaciones también aplican a ciertos tipos no numéricos. Aparte del operador de potencia, hay sólo dos niveles, uno para operadores multiplicativos y uno para aditivos:</p>
<pre>
<strong id="grammar-token-python-grammar-m_expr"><span id="grammar-token-m-expr"></span>m_expr</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;*&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;&#64;&quot; <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> |
            <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;//&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;/&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a> |
            <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> &quot;%&quot; <a class="reference internal" href="#grammar-token-python-grammar-u_expr"><code class="xref docutils literal notranslate"><span class="pre">u_expr</span></code></a>
<strong id="grammar-token-python-grammar-a_expr"><span id="grammar-token-a-expr"></span>a_expr</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a> &quot;+&quot; <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a> &quot;-&quot; <a class="reference internal" href="#grammar-token-python-grammar-m_expr"><code class="xref docutils literal notranslate"><span class="pre">m_expr</span></code></a>
</pre>
<p id="index-65">El operador <code class="docutils literal notranslate"><span class="pre">*</span></code> (multiplicación) produce el producto de sus argumentos. Los argumentos pueden ser ambos números, o un argumento debe ser un entero y el otro debe ser una secuencia. En el primer caso, los números se convierten a un tipo común y luego son multiplicados. En el segundo caso, se realiza una repetición de secuencia; un factor de repetición negativo produce una secuencia vacía.</p>
<p>Esta operación se puede personalizar utilizando los métodos especiales <code class="xref py py-meth docutils literal notranslate"><span class="pre">__mul__()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__rmul__()</span></code>.</p>
<p id="index-66">El operador <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> (en) está destinado a ser usado para multiplicación de matrices. Ningún tipo incorporado en Python implementa este operador.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
<p id="index-67">Los operadores <code class="docutils literal notranslate"><span class="pre">/</span></code> (división) y <code class="docutils literal notranslate"><span class="pre">//</span></code> (división de redondeo) producen el cociente de sus argumentos. Los argumentos numéricos son primero convertidos a un tipo común. La división de enteros producen un número de punto flotante, mientras que la división redondeada de enteros resulta en un entero; el resultado es aquel de una división matemática con la función “floor” aplicada al resultado. Dividir entre 0 genera la excepción <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a>.</p>
<p>Esta operación se puede personalizar utilizando los métodos especiales <code class="xref py py-meth docutils literal notranslate"><span class="pre">__truediv__()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__floordiv__()</span></code>.</p>
<p id="index-68">El operador <code class="docutils literal notranslate"><span class="pre">%</span></code> (módulo) produce el resto de la división del primer argumento entre el segundo. Los argumentos numéricos son primero convertidos a un tipo común. Un argumento a la derecha cero genera la excepción <a class="reference internal" href="../library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code></a>. Los argumentos pueden ser números de punto flotante, ej., <code class="docutils literal notranslate"><span class="pre">3.14%0.7</span></code> es igual a <code class="docutils literal notranslate"><span class="pre">0.34</span></code> (ya que <code class="docutils literal notranslate"><span class="pre">3.14</span></code> es igual a <code class="docutils literal notranslate"><span class="pre">4*0.7</span> <span class="pre">+</span> <span class="pre">0.34</span></code>.) El operador módulo siempre produce un resultado con el mismo signo que su segundo operando (o cero); el valor absoluto del resultado es estrictamente más pequeño que el valor absoluto del segundo operando <a class="footnote-reference brackets" href="#id17" id="id9">1</a>.</p>
<p>Los operadores de división de redondeo y módulo están conectados por la siguiente identidad: <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">(x//y)*y</span> <span class="pre">+</span> <span class="pre">(x%y)</span></code>. La división de redondeo y el módulo también están conectadas por la función incorporada <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>: <code class="docutils literal notranslate"><span class="pre">divmod(x,</span> <span class="pre">y)</span> <span class="pre">==</span> <span class="pre">(x//y,</span> <span class="pre">x%y)</span></code>. <a class="footnote-reference brackets" href="#id18" id="id10">2</a>.</p>
<p>Adicionalmente a realizar la operación módulo en números, el operador <code class="docutils literal notranslate"><span class="pre">%</span></code> también está sobrecargado por objetos cadena de caracteres para realizar formateo de cadenas al estilo antiguo (también conocido como interpolación). La sintaxis para el formateo de cadenas está descrita en la Referencia de la Biblioteca de Python, sección <a class="reference internal" href="../library/stdtypes.html#old-string-formatting"><span class="std std-ref">Formateo de cadenas al estilo *printf*</span></a>.</p>
<p>La operación <em>modulo</em> se puede personalizar utilizando el método especial <code class="xref py py-meth docutils literal notranslate"><span class="pre">__mod__()</span></code>.</p>
<p>El operador de división de redondeo, el operador módulo y la función <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a> no están definidas para números complejos. En su lugar, convierta a un número de punto flotante usando la función <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a> si es apropiado.</p>
<p id="index-69">El operador <code class="docutils literal notranslate"><span class="pre">+</span></code> (adición) produce la suma de sus argumentos. Los argumentos deben ser ambos números o ambos secuencias del mismo tipo. En el primer caso, los números son convertidos a un tipo común y luego sumados. En el segundo caso, las secuencias son concatenadas.</p>
<p>Esta operación se puede personalizar utilizando los métodos especiales <code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__radd__()</span></code>.</p>
<p id="index-70">El operador <code class="docutils literal notranslate"><span class="pre">-</span></code> (resta) produce la diferencia de sus argumentos. Los argumentos numéricos son primero convertidos a un tipo común.</p>
<p>Esta operación se puede personalizar mediante el método especial <code class="xref py py-meth docutils literal notranslate"><span class="pre">__sub__()</span></code>.</p>
</section>
<section id="shifting-operations">
<span id="shifting"></span><h2><span class="section-number">6.8. </span>Operaciones de desplazamiento<a class="headerlink" href="#shifting-operations" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-71">Las operaciones de desplazamiento tienen menos prioridad que las operaciones aritméticas:</p>
<pre>
<strong id="grammar-token-python-grammar-shift_expr"><span id="grammar-token-shift-expr"></span>shift_expr</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-shift_expr"><code class="xref docutils literal notranslate"><span class="pre">shift_expr</span></code></a> (&quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot;) <a class="reference internal" href="#grammar-token-python-grammar-a_expr"><code class="xref docutils literal notranslate"><span class="pre">a_expr</span></code></a>
</pre>
<p>Estos operadores aceptan enteros como argumentos. Ellos desplazan el primer argumento a la izquierda o derecha el número de dígitos dados por el segundo argumento.</p>
<p>Esta operación se puede personalizar utilizando los métodos especiales <code class="xref py py-meth docutils literal notranslate"><span class="pre">__lshift__()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__rshift__()</span></code>.</p>
<p id="index-72">Un desplazamiento de <em>n</em> bits hacia la derecha está definido como una división de redondeo entre <code class="docutils literal notranslate"><span class="pre">pow(2,n)</span></code>. Un desplazamiento de <em>n</em> bits hacia la izquierda está definido como una multiplicación por <code class="docutils literal notranslate"><span class="pre">pow(2,n)</span></code>.</p>
</section>
<section id="binary-bitwise-operations">
<span id="bitwise"></span><h2><span class="section-number">6.9. </span>Operaciones bit a bit binarias<a class="headerlink" href="#binary-bitwise-operations" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-73">Cada una de las tres operaciones de bits binarias tienen diferente nivel de prioridad:</p>
<pre>
<strong id="grammar-token-python-grammar-and_expr"><span id="grammar-token-and-expr"></span>and_expr</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-shift_expr"><code class="xref docutils literal notranslate"><span class="pre">shift_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-and_expr"><code class="xref docutils literal notranslate"><span class="pre">and_expr</span></code></a> &quot;&amp;&quot; <a class="reference internal" href="#grammar-token-python-grammar-shift_expr"><code class="xref docutils literal notranslate"><span class="pre">shift_expr</span></code></a>
<strong id="grammar-token-python-grammar-xor_expr"><span id="grammar-token-xor-expr"></span>xor_expr</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-and_expr"><code class="xref docutils literal notranslate"><span class="pre">and_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-xor_expr"><code class="xref docutils literal notranslate"><span class="pre">xor_expr</span></code></a> &quot;^&quot; <a class="reference internal" href="#grammar-token-python-grammar-and_expr"><code class="xref docutils literal notranslate"><span class="pre">and_expr</span></code></a>
<strong id="grammar-token-python-grammar-or_expr"><span id="grammar-token-or-expr"></span>or_expr </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-xor_expr"><code class="xref docutils literal notranslate"><span class="pre">xor_expr</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a> &quot;|&quot; <a class="reference internal" href="#grammar-token-python-grammar-xor_expr"><code class="xref docutils literal notranslate"><span class="pre">xor_expr</span></code></a>
</pre>
<p id="index-74">El operador <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> produce el AND bit a bit de sus argumentos, que deben ser números enteros o uno de ellos debe ser un objeto personalizado que anule los métodos especiales <code class="xref py py-meth docutils literal notranslate"><span class="pre">__and__()</span></code> o <code class="xref py py-meth docutils literal notranslate"><span class="pre">__rand__()</span></code>.</p>
<p id="index-75">El operador <code class="docutils literal notranslate"><span class="pre">^</span></code> produce el XOR bit a bit (OR exclusivo) de sus argumentos, que deben ser números enteros o uno de ellos debe ser un objeto personalizado que anule los métodos especiales <code class="xref py py-meth docutils literal notranslate"><span class="pre">__xor__()</span></code> o <code class="xref py py-meth docutils literal notranslate"><span class="pre">__rxor__()</span></code>.</p>
<p id="index-76">El operador <code class="docutils literal notranslate"><span class="pre">|</span></code> produce el OR bit a bit (inclusive) de sus argumentos, que deben ser números enteros o uno de ellos debe ser un objeto personalizado que anule los métodos especiales <code class="xref py py-meth docutils literal notranslate"><span class="pre">__or__()</span></code> o <code class="xref py py-meth docutils literal notranslate"><span class="pre">__ror__()</span></code>.</p>
</section>
<section id="comparisons">
<span id="id11"></span><h2><span class="section-number">6.10. </span>Comparaciones<a class="headerlink" href="#comparisons" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-77">A diferencia de C, todas las operaciones de comparación en Python tienen la misma prioridad, la cual es menor que la de cualquier operación aritmética, de desplazamiento o bit a bit. También, a diferencia de C, expresiones como <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">c</span></code> tienen la interpretación convencional en matemáticas:</p>
<pre>
<strong id="grammar-token-python-grammar-comparison"><span id="grammar-token-comparison"></span>comparison   </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a> (<a class="reference internal" href="#grammar-token-python-grammar-comp_operator"><code class="xref docutils literal notranslate"><span class="pre">comp_operator</span></code></a> <a class="reference internal" href="#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a>)*
<strong id="grammar-token-python-grammar-comp_operator"><span id="grammar-token-comp-operator"></span>comp_operator</strong> ::=  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;==&quot; | &quot;&gt;=&quot; | &quot;&lt;=&quot; | &quot;!=&quot;
                   | &quot;is&quot; [&quot;not&quot;] | [&quot;not&quot;] &quot;in&quot;
</pre>
<p>Las comparaciones producen valores booleanos: <code class="docutils literal notranslate"><span class="pre">True</span></code> o <code class="docutils literal notranslate"><span class="pre">False</span></code>. Personalizado: dfn: los <cite>métodos de comparación enriquecidos</cite> pueden retornar valores no booleanos. En este caso, Python llamará a <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a> en dicho valor en contextos booleanos.</p>
<p id="index-78">Las comparaciones pueden ser encadenadas arbitrariamente, ej., <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code>, excepto que <code class="docutils literal notranslate"><span class="pre">y</span></code> es evaluado sólo una vez (pero en ambos casos <code class="docutils literal notranslate"><span class="pre">z</span></code> no es evaluado para nada cuando <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> se encuentra que es falso).</p>
<p>Formalmente, si <em>a</em>, <em>b</em>, <em>c</em>, …, <em>y</em>, <em>z</em> son expresiones y <em>op1</em>, <em>op2</em>, …, <em>opN</em> son operadores de comparación, entonces <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span> <span class="pre">...</span> <span class="pre">y</span> <span class="pre">opN</span> <span class="pre">z</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">and</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span> <span class="pre">and</span> <span class="pre">...</span> <span class="pre">y</span> <span class="pre">opN</span> <span class="pre">z</span></code>, excepto que cada expresión es evaluada como mucho una vez.</p>
<p>Tenga en cuenta que <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">op1</span> <span class="pre">b</span> <span class="pre">op2</span> <span class="pre">c</span></code> no implica ningún tipo de comparación entre <em>a</em> y <em>c</em>, por lo que, por ejemplo, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> es perfectamente legal (aunque quizás no es bonito).</p>
<section id="value-comparisons">
<span id="expressions-value-comparisons"></span><h3><span class="section-number">6.10.1. </span>Comparaciones de valor<a class="headerlink" href="#value-comparisons" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Los operadores <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, y <code class="docutils literal notranslate"><span class="pre">!=</span></code> comparan los valores de dos objetos. Los objetos no necesitan ser del mismo tipo.</p>
<p>El capítulo <a class="reference internal" href="datamodel.html#objects"><span class="std std-ref">Objetos, valores y tipos</span></a> afirma que los objetos tienen un valor (en adición al tipo e identidad). El valor de un objeto es una noción bastante abstracta en Python: Por ejemplo, no existe un método de acceso canónico para el valor de un objeto. Además, no se requiere que el valor de un objeto deba ser construido de una forma particular, ej. compuesto de todos sus atributos de datos. Los operadores de comparación implementan una noción particular de lo que es el valor de un objeto. Uno puede pensar en ellos definiendo el valor de un objeto indirectamente, mediante su implementación de comparación.</p>
<p>Debido a que todos los tipos son subtipos (directos o indirectos) de <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>, ellos heredan el comportamiento de comparación predeterminado desde <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>. Los tipos pueden personalizar su comportamiento de comparación implementando <em class="dfn">rich comparison methods</em> como <code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code>, descritos en <a class="reference internal" href="datamodel.html#customization"><span class="std std-ref">Personalización básica</span></a>.</p>
<p>El comportamiento predeterminado para comparación de igualdad (<code class="docutils literal notranslate"><span class="pre">==</span></code> y <code class="docutils literal notranslate"><span class="pre">!=</span></code>) se basa en la identidad de los objetos. Por lo tanto, la comparación de instancias con la misma identidad resulta en igualdad, y la comparación de igualdad de instancias con diferentes entidades resulta en desigualdad. Una motivación para este comportamiento predeterminado es el deseo de que todos los objetos sean reflexivos (ej. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> implica <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code>).</p>
<p>No se provee un orden de comparación por defecto (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, and <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>); un intento genera <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>. Una motivación para este comportamiento predeterminado es la falta de una invariante similar como para la igualdad.</p>
<p>El comportamiento de la comparación de igualdad predeterminado, que instancias con diferentes identidades siempre son desiguales, puede estar en contraste a que los tipos que necesitarán que tengan una definición sensata de valor de objeto e igualdad basada en el valor. Tales tipos necesitarán personalizar su comportamiento de comparación y, de hecho, un número de tipos incorporados lo han realizado.</p>
<p>La siguiente lista describe el comportamiento de comparación de los tipos incorporados más importantes.</p>
<ul>
<li><p>Números de tipos numéricos incorporadas (<a class="reference internal" href="../library/stdtypes.html#typesnumeric"><span class="std std-ref">Tipos numéricos — int, float, complex</span></a>) y tipos de la biblioteca estándar <a class="reference internal" href="../library/fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">fractions.Fraction</span></code></a> y <a class="reference internal" href="../library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">decimal.Decimal</span></code></a> pueden ser comparados consigo mismos y entre sus tipos, con la restricción de que números complejos no soportan orden de comparación. Dentro de los límites de los tipos involucrados, se comparan matemáticamente (algorítmicamente) correctos sin pérdida de precisión.</p>
<p>Los valores no-un-número <code class="docutils literal notranslate"><span class="pre">float('NaN')</span></code> y <code class="docutils literal notranslate"><span class="pre">decimal.Decimal('NaN')</span></code> son especiales. Cualquier comparación ordenada de un número a un no-un-número es falsa. Una implicación contraintuitiva es que los valores no-un-número son son iguales a sí mismos. Por ejemplo, si <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">float('NaN')</span></code>, <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">&lt;</span> <span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">3</span></code> y <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">x</span></code> son todos falso, mientras <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">x</span></code> es verdadero. Este comportamiento cumple con IEEE 754.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> y <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> son singletons. <span class="target" id="index-118"></span><a class="pep reference external" href="https://peps.python.org/pep-0008/"><strong>PEP 8</strong></a> avisa que las comparaciones para singletons deben ser realizadas siempre con <code class="docutils literal notranslate"><span class="pre">is</span></code> o <code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code>, nunca los operadores de igualdad.</p></li>
<li><p>Las secuencias binarias (instancias de <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> o <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>) pueden ser comparadas entre sí y con otros tipos. Ellas comparan lexicográficamente utilizando los valores numéricos de sus elementos.</p></li>
<li><p>Las cadenas de caracteres (instancias de <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) comparan lexicográficamente usando los puntos de códigos numéricos Unicode (el resultado de la función incorporada <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a>) o sus caracteres. <a class="footnote-reference brackets" href="#id19" id="id12">3</a></p>
<p>Las cadenas de caracteres y las secuencias binarias no pueden ser comparadas directamente.</p>
</li>
<li><p>Las secuencias (instancias de <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, o <a class="reference internal" href="../library/stdtypes.html#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a>) pueden ser comparadas sólo entre cada uno de sus tipos, con la restricción de que los rangos no soportan comparación de orden. Comparación de igualdad entre esos tipos resulta en desigualdad y la comparación de orden entre esos tipos genera <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<p>Las secuencias comparan lexicográficamente usando comparación de sus correspondientes elementos. Los contenedores incorporados asumen que los objetos idénticos son iguales a sí mismos. Eso les permite omitir las pruebas de igualdad para objetos idénticos para mejorar el rendimiento y mantener sus invariantes internos.</p>
<p>La comparación lexicográfica entre colecciones incorporadas funciona de la siguiente forma:</p>
<ul class="simple">
<li><p>Para que dos colecciones sean comparadas iguales, ellas deben ser del mismo tipo, tener el mismo largo, y cada para de elementos correspondientes deben comparar iguales (por ejemplo, <code class="docutils literal notranslate"><span class="pre">[1,2]</span> <span class="pre">==</span> <span class="pre">(1,2)</span></code> es falso debido a que el tipo no es el mismo).</p></li>
<li><p>Las colecciones que soportan comparación de orden son ordenadas igual que sus primeros elementos desiguales (por ejemplo, <code class="docutils literal notranslate"><span class="pre">[1,2,x]</span> <span class="pre">&lt;=</span> <span class="pre">[1,2,y]</span></code> tiene el mismo valor que <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code>). Si un elemento correspondiente no existe, la colección más corta es ordenada primero (por ejemplo, <code class="docutils literal notranslate"><span class="pre">[1,2]</span> <span class="pre">&lt;</span> <span class="pre">[1,2,3]</span></code> es verdadero).</p></li>
</ul>
</li>
<li><p>Mappings (instances of <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>) compare equal if and only if they have
equal <code class="docutils literal notranslate"><span class="pre">(key,</span> <span class="pre">value)</span></code> pairs. Equality comparison of the keys and values
enforces reflexivity.</p>
<p>Comparaciones de orden (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, and <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>) generan <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
</li>
<li><p>Conjuntos (instancias de <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> o <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>) pueden ser comparadas entre sí y entre sus tipos.</p>
<p>Ellas definen operadores de comparación de orden con la intención de comprobar subconjuntos y superconjuntos. Tales relaciones no definen ordenaciones completas (por ejemplo, los dos conjuntos <code class="docutils literal notranslate"><span class="pre">{1,2}</span></code> y <code class="docutils literal notranslate"><span class="pre">{2,3}</span></code> no son iguales, ni subconjuntos ni superconjuntos uno de otro). Acordemente, los conjuntos no son argumentos apropiados para funciones que dependen de ordenación completa (por ejemplo, <a class="reference internal" href="../library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="../library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a> y <a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a> producen resultados indefinidos dados una lista de conjuntos como entradas).</p>
<p>La comparación de conjuntos refuerza la reflexibilidad de sus elementos.</p>
</li>
<li><p>La mayoría de los otros tipos incorporados no tienen métodos de comparación implementados, por lo que ellos heredan el comportamiento de comparación predeterminado.</p></li>
</ul>
<p>Las clases definidas por el usuario que personalizan su comportamiento de comparación deben seguir algunas reglas de consistencia, si es posible:</p>
<ul>
<li><p>La comparación de igualdad debe ser reflexiva. En otras palabras, los objetos idénticos deben comparar iguales:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> implica <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code></p>
</div></blockquote>
</li>
<li><p>La comparación debe ser simétrica. En otras palabras, las siguientes expresiones deben tener el mismo resultado:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> y <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">==</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span></code> y <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">!=</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> y <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">x</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> y <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&gt;=</span> <span class="pre">x</span></code></p>
</div></blockquote>
</li>
<li><p>La comparación debe ser transitiva. Los siguientes ejemplos (no exhaustivos) ilustran esto:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&gt;</span> <span class="pre">z</span></code> implica <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">z</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> implica <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">z</span></code></p>
</div></blockquote>
</li>
<li><p>La comparación inversa debe resultar en la negación booleana. En otras palabras, las siguientes expresiones deben tener el mismo resultado:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> y <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">!=</span> <span class="pre">y</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> y <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">y</span></code> (para ordenación completa)</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">y</span></code> y <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code> (para ordenación completa)</p>
</div></blockquote>
<p>Las últimas dos expresiones aplican a colecciones completamente ordenadas (ej. a secuencias, pero no a conjuntos o mapeos). Vea también el decorador <a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal notranslate"><span class="pre">total_ordering()</span></code></a>.</p>
</li>
<li><p>La función <a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> debe ser consistente con la igualdad. Los objetos que son iguales deben tener el mismo valor de hash o ser marcados como inhashables.</p></li>
</ul>
<p>Python no fuerza a cumplir esas reglas de coherencia. De hecho, los valores no-un-número son u ejemplo para no seguir esas reglas.</p>
</section>
<section id="membership-test-operations">
<span id="membership-test-details"></span><span id="not-in"></span><span id="in"></span><h3><span class="section-number">6.10.2. </span>Operaciones de prueba de membresía<a class="headerlink" href="#membership-test-operations" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Los operadores <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> y <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a> comprueban membresía. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code> evalúa a <code class="docutils literal notranslate"><span class="pre">True</span></code> si <em>x</em> es un miembro de <em>s</em> y <code class="docutils literal notranslate"><span class="pre">False</span></code> en caso contrario. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">s</span></code> retorna la negación de <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code>. Todas las secuencias incorporadas y tipos conjuntos soportan esto, así como diccionarios, para los cuales <code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code> comprueba si un diccionario tiene una clave dada. Para tipos contenedores como list, tuple, set, frozenset, dict o collections.deque, la expresión <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">any(x</span> <span class="pre">is</span> <span class="pre">e</span> <span class="pre">or</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">e</span> <span class="pre">for</span> <span class="pre">e</span> <span class="pre">in</span> <span class="pre">y)</span></code>.</p>
<p>Para los tipos cadenas de caracteres y bytes, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> es <code class="docutils literal notranslate"><span class="pre">True</span></code> si y sólo si <em>x</em> es una subcadena de <em>y</em>. Una comprobación equivalente es <code class="docutils literal notranslate"><span class="pre">y.find(x)</span> <span class="pre">!=</span> <span class="pre">-1</span></code>. Las cadenas de caracteres vacías siempre son consideradas como subcadenas de cualquier otra cadena de caracteres, por lo que <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span> <span class="pre">in</span> <span class="pre">&quot;abc&quot;</span></code> retornará <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>Para clases definidas por el usuario las cuales definen el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si <code class="docutils literal notranslate"><span class="pre">y.__contains__(x)</span></code> retorna un valor verdadero y <code class="docutils literal notranslate"><span class="pre">False</span></code> si no.</p>
<p>Para clases definidas por el usuario las cuales no definen <code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code> pero definen <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> es <code class="docutils literal notranslate"><span class="pre">True</span></code> si algún valor <code class="docutils literal notranslate"><span class="pre">z</span></code>, para el cual la expresión <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">z</span> <span class="pre">or</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">z</span></code> es verdadera, es producido iterando sobre <code class="docutils literal notranslate"><span class="pre">y</span></code>. Si una excepción es generada durante la iteración, es como si <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> hubiera generado esa excepción.</p>
<p>Por último, se intenta el protocolo de iteración al estilo antiguo: si una clase define <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> es <code class="docutils literal notranslate"><span class="pre">True</span></code> si y sólo si hay un índice entero no negativo <em>i</em> tal que <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y[i]</span> <span class="pre">or</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">y[i]</span></code> y ningún entero menor genera la excepción <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>. (Si cualquier otra excepción es generada, es como si <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> hubiera generado esa excepción).</p>
<p id="index-80">El operador <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a> es definido para tener el valor de veracidad inverso de <a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a>.</p>
</section>
<section id="is-not">
<span id="is"></span><span id="index-81"></span><span id="identity-comparisons"></span><h3><span class="section-number">6.10.3. </span>Comparaciones de identidad<a class="headerlink" href="#is-not" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Los operadores <a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> y <a class="reference internal" href="#is-not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code></a> comprueban la identidad de un objeto. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> es verdadero si y sólo si <em>x</em> e <em>y</em> son el mismo objeto. La identidad de un Objeto se determina usando la función <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">id()</span></code></a>. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">y</span></code> produce el valor de veracidad inverso. <a class="footnote-reference brackets" href="#id20" id="id13">4</a></p>
</section>
</section>
<section id="boolean-operations">
<span id="not"></span><span id="or"></span><span id="and"></span><span id="booleans"></span><h2><span class="section-number">6.11. </span>Operaciones booleanas<a class="headerlink" href="#boolean-operations" title="Enlazar permanentemente con este título">¶</a></h2>
<pre id="index-82">
<strong id="grammar-token-python-grammar-or_test"><span id="grammar-token-or-test"></span>or_test </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-and_test"><code class="xref docutils literal notranslate"><span class="pre">and_test</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> &quot;or&quot; <a class="reference internal" href="#grammar-token-python-grammar-and_test"><code class="xref docutils literal notranslate"><span class="pre">and_test</span></code></a>
<strong id="grammar-token-python-grammar-and_test"><span id="grammar-token-and-test"></span>and_test</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-not_test"><code class="xref docutils literal notranslate"><span class="pre">not_test</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-and_test"><code class="xref docutils literal notranslate"><span class="pre">and_test</span></code></a> &quot;and&quot; <a class="reference internal" href="#grammar-token-python-grammar-not_test"><code class="xref docutils literal notranslate"><span class="pre">not_test</span></code></a>
<strong id="grammar-token-python-grammar-not_test"><span id="grammar-token-not-test"></span>not_test</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-comparison"><code class="xref docutils literal notranslate"><span class="pre">comparison</span></code></a> | &quot;not&quot; <a class="reference internal" href="#grammar-token-python-grammar-not_test"><code class="xref docutils literal notranslate"><span class="pre">not_test</span></code></a>
</pre>
<p>En el contexto de las operaciones booleanas y también cuando sentencias de control de flujo usan expresiones, los siguientes valores se interpretan como falsos: <code class="docutils literal notranslate"><span class="pre">False</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code>, ceros numéricos de todos los tipos y cadenas de caracteres y contenedores vacíos (incluyendo cadenas de caracteres, tuplas, diccionarios, conjuntos y conjuntos congelados). Todos los otros valores son interpretados como verdaderos. Los objetos definidos por el usuario pueden personalizar su valor de veracidad proveyendo un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code>.</p>
<p id="index-83">El operador <a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span></code></a> produce <code class="docutils literal notranslate"><span class="pre">True</span></code> si su argumento es falso, <code class="docutils literal notranslate"><span class="pre">False</span></code> si no.</p>
<p id="index-84">La expresión <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">and</span> <span class="pre">y</span></code> primero evalúa <em>x</em>; si <em>x</em> es falso, se retorna su valor; de otra forma, <em>y</em> es evaluado y se retorna el valor resultante.</p>
<p id="index-85">La expresión <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">or</span> <span class="pre">y</span></code> primero evalúa <em>x</em>; si <em>x</em> es verdadero, se retorna su valor; de otra forma, <em>y</em> es evaluado y se retorna el valor resultante.</p>
<p>Tenga en cuenta que ni <a class="reference internal" href="#and"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">and</span></code></a> ni <a class="reference internal" href="#or"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">or</span></code></a> restringen el valor y el tipo que retornan a <code class="docutils literal notranslate"><span class="pre">False</span></code> y <code class="docutils literal notranslate"><span class="pre">True</span></code>, sino retornan el último argumento evaluado. Esto es útil a veces, ej., si <code class="docutils literal notranslate"><span class="pre">s</span></code> es una cadena de caracteres que debe ser remplazada por un valor predeterminado si está vacía, la expresión <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">or</span> <span class="pre">'foo'</span></code> produce el valor deseado. Debido a que <a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span></code></a> tiene que crear un nuevo valor, retorna un valor booleano indiferentemente del tipo de su argumento (por ejemplo, <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">'foo'</span></code> produce <code class="docutils literal notranslate"><span class="pre">False</span></code> en lugar de <code class="docutils literal notranslate"><span class="pre">''</span></code>.)</p>
</section>
<section id="assignment-expressions">
<span id="index-86"></span><h2><span class="section-number">6.12. </span>Expresiones de asignación<a class="headerlink" href="#assignment-expressions" title="Enlazar permanentemente con este título">¶</a></h2>
<pre>
<strong id="grammar-token-python-grammar-assignment_expression"><span id="grammar-token-assignment-expression"></span>assignment_expression</strong> ::=  [<a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref docutils literal notranslate"><span class="pre">identifier</span></code></a> &quot;:=&quot;] <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p>An assignment expression (sometimes also called a «named expression» or
«walrus») assigns an <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression</span></code></a> to an
<a class="reference internal" href="lexical_analysis.html#grammar-token-python-grammar-identifier"><code class="xref std std-token docutils literal notranslate"><span class="pre">identifier</span></code></a>, while also returning the value of the
<a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref std std-token docutils literal notranslate"><span class="pre">expression</span></code></a>.</p>
<p>Un caso de uso común es cuando se manejan expresiones regulares coincidentes:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">matching</span> <span class="o">:=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">do_something</span><span class="p">(</span><span class="n">matching</span><span class="p">)</span>
</pre></div>
</div>
<p>O, al procesar un flujo de archivos en fragmentos:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">chunk</span> <span class="o">:=</span> <span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">9000</span><span class="p">):</span>
    <span class="n">process</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
</pre></div>
</div>
<p>Assignment expressions must be surrounded by parentheses when used
as sub-expressions in slicing, conditional, lambda,
keyword-argument, and comprehension-if expressions
and in <code class="docutils literal notranslate"><span class="pre">assert</span></code> and <code class="docutils literal notranslate"><span class="pre">with</span></code> statements.
In all other places where they can be used, parentheses are not required,
including in <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">while</span></code> statements.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8: </span>Vea <span class="target" id="index-119"></span><a class="pep reference external" href="https://peps.python.org/pep-0572/"><strong>PEP 572</strong></a> para más detalles sobre las expresiones de asignación.</p>
</div>
</section>
<section id="conditional-expressions">
<span id="if-expr"></span><h2><span class="section-number">6.13. </span>Expresiones condicionales<a class="headerlink" href="#conditional-expressions" title="Enlazar permanentemente con este título">¶</a></h2>
<pre id="index-88">
<strong id="grammar-token-python-grammar-conditional_expression"><span id="grammar-token-conditional-expression"></span>conditional_expression</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> [&quot;if&quot; <a class="reference internal" href="#grammar-token-python-grammar-or_test"><code class="xref docutils literal notranslate"><span class="pre">or_test</span></code></a> &quot;else&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>]
<strong id="grammar-token-python-grammar-expression"><span id="grammar-token-expression"></span>expression            </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-conditional_expression"><code class="xref docutils literal notranslate"><span class="pre">conditional_expression</span></code></a> | <a class="reference internal" href="#grammar-token-python-grammar-lambda_expr"><code class="xref docutils literal notranslate"><span class="pre">lambda_expr</span></code></a>
</pre>
<p>Las expresiones condicionales (a veces denominadas un «operador ternario») tienen la prioridad más baja que todas las operaciones de Python.</p>
<p>La expresión <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">if</span> <span class="pre">C</span> <span class="pre">else</span> <span class="pre">y</span></code> primero evalúa la condición, <em>C</em> en lugar de <em>x</em>. Si <em>C</em> es verdadero, <em>x</em> es evaluado y se retorna su valor; en caso contrario, <em>y</em> es evaluado y se retorna su valor.</p>
<p>Vea <span class="target" id="index-120"></span><a class="pep reference external" href="https://peps.python.org/pep-0308/"><strong>PEP 308</strong></a> para más detalles sobre expresiones condicionales.</p>
</section>
<section id="lambda">
<span id="lambdas"></span><span id="id14"></span><h2><span class="section-number">6.14. </span>Lambdas<a class="headerlink" href="#lambda" title="Enlazar permanentemente con este título">¶</a></h2>
<pre id="index-90">
<strong id="grammar-token-python-grammar-lambda_expr"><span id="grammar-token-lambda-expr"></span>lambda_expr</strong> ::=  &quot;lambda&quot; [<a class="reference internal" href="compound_stmts.html#grammar-token-python-grammar-parameter_list"><code class="xref docutils literal notranslate"><span class="pre">parameter_list</span></code></a>] &quot;:&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>
</pre>
<p>Las expresiones lambda (a veces denominadas formas lambda) son usadas para crear funciones anónimas. La expresión <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">parameters:</span> <span class="pre">expression</span></code> produce un objeto de función. El objeto sin nombre se comporta como un objeto función con:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def &lt;lambda&gt;(parameters):
    return expression
</pre></div>
</div>
<p>Vea la sección <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">Definiciones de funciones</span></a> para la sintaxis de listas de parámetros. Tenga en cuenta que las funciones creadas con expresiones lambda no pueden contener sentencias ni anotaciones.</p>
</section>
<section id="expression-lists">
<span id="exprlists"></span><h2><span class="section-number">6.15. </span>Listas de expresiones<a class="headerlink" href="#expression-lists" title="Enlazar permanentemente con este título">¶</a></h2>
<pre id="index-91">
<strong id="grammar-token-python-grammar-expression_list"><span id="grammar-token-expression-list"></span>expression_list   </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-python-grammar-starred_list"><span id="grammar-token-starred-list"></span>starred_list      </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-starred_item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-python-grammar-starred_item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a>)* [&quot;,&quot;]
<strong id="grammar-token-python-grammar-starred_expression"><span id="grammar-token-starred-expression"></span>starred_expression</strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-expression"><code class="xref docutils literal notranslate"><span class="pre">expression</span></code></a> | (<a class="reference internal" href="#grammar-token-python-grammar-starred_item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a> &quot;,&quot;)* [<a class="reference internal" href="#grammar-token-python-grammar-starred_item"><code class="xref docutils literal notranslate"><span class="pre">starred_item</span></code></a>]
<strong id="grammar-token-python-grammar-starred_item"><span id="grammar-token-starred-item"></span>starred_item      </strong> ::=  <a class="reference internal" href="#grammar-token-python-grammar-assignment_expression"><code class="xref docutils literal notranslate"><span class="pre">assignment_expression</span></code></a> | &quot;*&quot; <a class="reference internal" href="#grammar-token-python-grammar-or_expr"><code class="xref docutils literal notranslate"><span class="pre">or_expr</span></code></a>
</pre>
<p id="index-92">Excepto cuando son parte de un despliegue de lista o conjunto, una lista de expresión conteniendo al menos una coma produce una tupla. El largo de la tupla es el número de expresiones en la lista. Las expresiones son evaluadas de izquierda a derecha.</p>
<p id="index-93">Un asterisco <code class="docutils literal notranslate"><span class="pre">*</span></code> denota <em class="dfn">iterable unpacking</em>. Su operando deben ser un <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a>. El iterable es expandido en una secuencia de elementos, los cuales son incluidos en la nueva tupla, lista o conjunto en el lugar del desempaquetado.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5: </span>Desempaquetado iterable en listas de expresiones, originalmente propuesto por <span class="target" id="index-121"></span><a class="pep reference external" href="https://peps.python.org/pep-0488/"><strong>PEP 488</strong></a>.</p>
</div>
<p id="index-95">La coma final sólo es requerida para crear una tupla única (también denominada un <em>singleton</em>); es opcional en todos los otros casos. Una única expresión sin una coma final no crea una tupla, si no produce el valor de esa expresión. (Para crear una tupla vacía, usa un par de paréntesis vacío: <code class="docutils literal notranslate"><span class="pre">()</span></code>.)</p>
</section>
<section id="evaluation-order">
<span id="evalorder"></span><h2><span class="section-number">6.16. </span>Orden de evaluación<a class="headerlink" href="#evaluation-order" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-96">Python evalúa las expresiones de izquierda a derecha. Note que mientras se evalúa una asignación, la parte derecha es evaluada antes que la parte izquierda.</p>
<p>En las siguientes líneas, las expresiones serán evaluadas en el orden aritmético de sus sufijos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span>
<span class="p">(</span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span><span class="p">)</span>
<span class="p">{</span><span class="n">expr1</span><span class="p">:</span> <span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">:</span> <span class="n">expr4</span><span class="p">}</span>
<span class="n">expr1</span> <span class="o">+</span> <span class="n">expr2</span> <span class="o">*</span> <span class="p">(</span><span class="n">expr3</span> <span class="o">-</span> <span class="n">expr4</span><span class="p">)</span>
<span class="n">expr1</span><span class="p">(</span><span class="n">expr2</span><span class="p">,</span> <span class="n">expr3</span><span class="p">,</span> <span class="o">*</span><span class="n">expr4</span><span class="p">,</span> <span class="o">**</span><span class="n">expr5</span><span class="p">)</span>
<span class="n">expr3</span><span class="p">,</span> <span class="n">expr4</span> <span class="o">=</span> <span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span>
</pre></div>
</div>
</section>
<section id="operator-precedence">
<span id="operator-summary"></span><h2><span class="section-number">6.17. </span>Prioridad de operador<a class="headerlink" href="#operator-precedence" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-97">The following table summarizes the operator precedence in Python, from highest
precedence (most binding) to lowest precedence (least binding).  Operators in
the same box have the same precedence.  Unless the syntax is explicitly given,
operators are binary.  Operators in the same box group left to right (except for
exponentiation and conditional expressions, which group from right to left).</p>
<p>Tenga en cuenta que las comparaciones, comprobaciones de membresía y las comprobaciones de identidad tienen la misma prioridad y una característica de encadenado de izquierda a derecha como son descritas en la sección <a class="reference internal" href="#comparisons"><span class="std std-ref">Comparaciones</span></a>.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 56%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operador</p></th>
<th class="head"><p>Descripción</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">(expressions...)</span></code>,</p>
<p><code class="docutils literal notranslate"><span class="pre">[expressions...]</span></code>,
<code class="docutils literal notranslate"><span class="pre">{key:</span> <span class="pre">value...}</span></code>,
<code class="docutils literal notranslate"><span class="pre">{expressions...}</span></code></p>
</td>
<td><p>Expresión de enlace o entre paréntesis, despliegues de lista, diccionario y conjunto</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">x[index]</span></code>, <code class="docutils literal notranslate"><span class="pre">x[index:index]</span></code>,
<code class="docutils literal notranslate"><span class="pre">x(arguments...)</span></code>, <code class="docutils literal notranslate"><span class="pre">x.attribute</span></code></p></td>
<td><p>Subscripción, segmentación, invocación, referencia de atributo</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span> <span class="pre">x</span></code></a></p></td>
<td><p>Expresión await</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">**</span></code></p></td>
<td><p>Exponenciación <a class="footnote-reference brackets" href="#id21" id="id15">5</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">+x</span></code>, <code class="docutils literal notranslate"><span class="pre">-x</span></code>, <code class="docutils literal notranslate"><span class="pre">~x</span></code></p></td>
<td><p>NOT positivo, negativo, bit a bit</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code></p></td>
<td><p>Multiplicación, multiplicación de matrices, división, división de redondeo, resto <a class="footnote-reference brackets" href="#id22" id="id16">6</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
<td><p>Adición y sustracción</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code></p></td>
<td><p>Desplazamientos</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&amp;</span></code></p></td>
<td><p>AND bit a bit</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">^</span></code></p></td>
<td><p>XOR bit a bit</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">|</span></code></p></td>
<td><p>OR bit a bit</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a>, <a class="reference internal" href="#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a>,
<a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a>, <a class="reference internal" href="#is-not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code></a>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">==</span></code></p></td>
<td><p>Comparaciones, incluyendo comprobaciones de membresía y de identidad</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span></code></a></p></td>
<td><p>Booleano NOT</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#and"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">and</span></code></a></p></td>
<td><p>Booleano AND</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#or"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">or</span></code></a></p></td>
<td><p>Booleano OR</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#if-expr"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> – <code class="xref std std-keyword docutils literal notranslate"><span class="pre">else</span></code></p></td>
<td><p>Expresión condicional</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a></p></td>
<td><p>Expresión lambda</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">:=</span></code></p></td>
<td><p>Expresión de asignación</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Notas al pie</p>
<dl class="footnote brackets">
<dt class="label" id="id17"><span class="brackets"><a class="fn-backref" href="#id9">1</a></span></dt>
<dd><p>Mientras <code class="docutils literal notranslate"><span class="pre">abs(x%y)</span> <span class="pre">&lt;</span> <span class="pre">abs(y)</span></code> es matemáticamente verdadero, para números de punto flotante puede no ser verdadero numéricamente debido al redondeo. Por ejemplo, y asumiendo una plataforma en la cual un número de punto flotante de Python es un número de doble precisión IEEE 754, a fin de que <code class="docutils literal notranslate"><span class="pre">-1e-100</span> <span class="pre">%</span> <span class="pre">1e100</span></code> tenga el mismo signo que <code class="docutils literal notranslate"><span class="pre">1e100</span></code>, el resultado calculado es <code class="docutils literal notranslate"><span class="pre">-1e-100</span> <span class="pre">+</span> <span class="pre">1e100</span></code>, el cual es numéricamente exactamente igual a <code class="docutils literal notranslate"><span class="pre">1e100</span></code>. La función <a class="reference internal" href="../library/math.html#math.fmod" title="math.fmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.fmod()</span></code></a> retorna un resultado cuyo signo concuerda con el signo del primer argumento en su lugar, y por ello retorna <code class="docutils literal notranslate"><span class="pre">-1e-100</span></code> en este caso. La aproximación más apropiada depende de su aplicación.</p>
</dd>
<dt class="label" id="id18"><span class="brackets"><a class="fn-backref" href="#id10">2</a></span></dt>
<dd><p>Si x está muy cerca de un entero exacto múltiple de y, es posible para <code class="docutils literal notranslate"><span class="pre">x//y</span></code> que sea uno mayor que <code class="docutils literal notranslate"><span class="pre">(x-x%y)//y</span></code> debido al redondeo. En tales casos, Python retorna el último resultado, a fin de preservar que <code class="docutils literal notranslate"><span class="pre">divmod(x,y)[0]</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code> sea muy cercano a <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
<dt class="label" id="id19"><span class="brackets"><a class="fn-backref" href="#id12">3</a></span></dt>
<dd><p>El estándar Unicode distingue entre <em class="dfn">code points</em> (ej. U+0041) y <em class="dfn">abstract characters</em> (ej. «LETRA MAYÚSCULA LATINA A»). Mientras la mayoría de caracteres abstractos en Unicode sólo son representados usando un punto de código, hay un número de caracteres abstractos que pueden adicionalmente ser representados usado una secuencia de más de un punto de código. Por ejemplo, el caracter abstracto «LETRA MAYÚSCULA C LATINA CON CEDILLA» puede ser representado como un único <em class="dfn">precomposed character</em> en la posición de código U+00C7, o como una secuencia de un <em class="dfn">base character</em> en la posición de código U+0043 (LETRA MAYÚSCULA C LATINA), seguida de un <em class="dfn">combining character</em> en la posición de código U+0327 (CEDILLA COMBINADA).</p>
<p>Los operadores de comparación comparan en cadenas de caracteres al nivel de puntos de código Unicode. Esto puede ser contraintuitivo para humanos. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">&quot;\u00C7&quot;</span> <span class="pre">==</span> <span class="pre">&quot;\u0043\u0327&quot;</span></code> es <code class="docutils literal notranslate"><span class="pre">False</span></code>, incluso aunque ambas cadenas presenten el mismo caracter abstracto «LETRA MAYÚSCULA C LATINA CON CEDILLA».</p>
<p>Para comparar cadenas al nivel de caracteres abstractos (esto es, de una forma intuitiva para humanos), usa <a class="reference internal" href="../library/unicodedata.html#unicodedata.normalize" title="unicodedata.normalize"><code class="xref py py-func docutils literal notranslate"><span class="pre">unicodedata.normalize()</span></code></a>.</p>
</dd>
<dt class="label" id="id20"><span class="brackets"><a class="fn-backref" href="#id13">4</a></span></dt>
<dd><p>Debido a la recolección automática de basura, listas libres y a la naturaleza dinámica de los descriptores, puede notar un comportamiento aparentemente inusual en ciertos usos del operador <a class="reference internal" href="#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a>, como aquellos involucrando comparaciones entre métodos de instancia, o constantes. Compruebe su documentación para más información.</p>
</dd>
<dt class="label" id="id21"><span class="brackets"><a class="fn-backref" href="#id15">5</a></span></dt>
<dd><p>El operador de potencia <code class="docutils literal notranslate"><span class="pre">**</span></code> vincula con menos fuerza que un operador unario aritmético uno bit a bit en su derecha, esto significa que <code class="docutils literal notranslate"><span class="pre">2**-1</span></code> is <code class="docutils literal notranslate"><span class="pre">0.5</span></code>.</p>
</dd>
<dt class="label" id="id22"><span class="brackets"><a class="fn-backref" href="#id16">6</a></span></dt>
<dd><p>El operador <code class="docutils literal notranslate"><span class="pre">%</span></code> también es usado para formateo de cadenas; aplica la misma prioridad.</p>
</dd>
</dl>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">6. Expresiones</a><ul>
<li><a class="reference internal" href="#arithmetic-conversions">6.1. Conversiones aritméticas</a></li>
<li><a class="reference internal" href="#atoms">6.2. Átomos</a><ul>
<li><a class="reference internal" href="#atom-identifiers">6.2.1. Identificadores (Nombres)</a></li>
<li><a class="reference internal" href="#literals">6.2.2. Literales</a></li>
<li><a class="reference internal" href="#parenthesized-forms">6.2.3. Formas entre paréntesis</a></li>
<li><a class="reference internal" href="#displays-for-lists-sets-and-dictionaries">6.2.4. Despliegues para listas, conjuntos y diccionarios</a></li>
<li><a class="reference internal" href="#list-displays">6.2.5. Despliegues de lista</a></li>
<li><a class="reference internal" href="#set-displays">6.2.6. Despliegues de conjuntos</a></li>
<li><a class="reference internal" href="#dictionary-displays">6.2.7. Despliegues de diccionario</a></li>
<li><a class="reference internal" href="#generator-expressions">6.2.8. Expresiones de generador</a></li>
<li><a class="reference internal" href="#yield-expressions">6.2.9. Expresiones yield</a><ul>
<li><a class="reference internal" href="#generator-iterator-methods">6.2.9.1. Métodos generador-iterador</a></li>
<li><a class="reference internal" href="#examples">6.2.9.2. Ejemplos</a></li>
<li><a class="reference internal" href="#asynchronous-generator-functions">6.2.9.3. Funciones generadoras asincrónicas</a></li>
<li><a class="reference internal" href="#asynchronous-generator-iterator-methods">6.2.9.4. Métodos asincrónicos de generador-iterador</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#primaries">6.3. Primarios</a><ul>
<li><a class="reference internal" href="#attribute-references">6.3.1. Referencias de atributos</a></li>
<li><a class="reference internal" href="#subscriptions">6.3.2. Suscripciones</a></li>
<li><a class="reference internal" href="#slicings">6.3.3. Segmentos</a></li>
<li><a class="reference internal" href="#calls">6.3.4. Invocaciones</a></li>
</ul>
</li>
<li><a class="reference internal" href="#await-expression">6.4. Expresión await</a></li>
<li><a class="reference internal" href="#the-power-operator">6.5. El operador de potencia</a></li>
<li><a class="reference internal" href="#unary-arithmetic-and-bitwise-operations">6.6. Aritmética unaria y operaciones bit a bit</a></li>
<li><a class="reference internal" href="#binary-arithmetic-operations">6.7. Operaciones aritméticas binarias</a></li>
<li><a class="reference internal" href="#shifting-operations">6.8. Operaciones de desplazamiento</a></li>
<li><a class="reference internal" href="#binary-bitwise-operations">6.9. Operaciones bit a bit binarias</a></li>
<li><a class="reference internal" href="#comparisons">6.10. Comparaciones</a><ul>
<li><a class="reference internal" href="#value-comparisons">6.10.1. Comparaciones de valor</a></li>
<li><a class="reference internal" href="#membership-test-operations">6.10.2. Operaciones de prueba de membresía</a></li>
<li><a class="reference internal" href="#is-not">6.10.3. Comparaciones de identidad</a></li>
</ul>
</li>
<li><a class="reference internal" href="#boolean-operations">6.11. Operaciones booleanas</a></li>
<li><a class="reference internal" href="#assignment-expressions">6.12. Expresiones de asignación</a></li>
<li><a class="reference internal" href="#conditional-expressions">6.13. Expresiones condicionales</a></li>
<li><a class="reference internal" href="#lambda">6.14. Lambdas</a></li>
<li><a class="reference internal" href="#expression-lists">6.15. Listas de expresiones</a></li>
<li><a class="reference internal" href="#evaluation-order">6.16. Orden de evaluación</a></li>
<li><a class="reference internal" href="#operator-precedence">6.17. Prioridad de operador</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="import.html"
                          title="capítulo anterior"><span class="section-number">5. </span>El sistema de importación</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="simple_stmts.html"
                          title="próximo capítulo"><span class="section-number">7. </span>Declaraciones simples</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/reference/expressions.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="simple_stmts.html" title="7. Declaraciones simples"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="import.html" title="5. El sistema de importación"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Referencia del Lenguaje Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">6. </span>Expresiones</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 23, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>