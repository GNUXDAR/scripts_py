
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>3. Modelo de datos &#8212; documentación de Python - 3.10.10</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.10.10"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="4. Modelo de ejecución" href="executionmodel.html" />
    <link rel="prev" title="2. Análisis léxico" href="lexical_analysis.html" />
    <link rel="canonical" href="https://docs.python.org/3/reference/datamodel.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. Modelo de datos</a><ul>
<li><a class="reference internal" href="#objects-values-and-types">3.1. Objetos, valores y tipos</a></li>
<li><a class="reference internal" href="#the-standard-type-hierarchy">3.2. Jerarquía de tipos estándar</a></li>
<li><a class="reference internal" href="#special-method-names">3.3. Nombres especiales de método</a><ul>
<li><a class="reference internal" href="#basic-customization">3.3.1. Personalización básica</a></li>
<li><a class="reference internal" href="#customizing-attribute-access">3.3.2. Personalizando acceso a atributos</a><ul>
<li><a class="reference internal" href="#customizing-module-attribute-access">3.3.2.1. Personalizando acceso a atributos de módulo</a></li>
<li><a class="reference internal" href="#implementing-descriptors">3.3.2.2. Implementando Descriptores</a></li>
<li><a class="reference internal" href="#invoking-descriptors">3.3.2.3. Invocando Descriptores</a></li>
<li><a class="reference internal" href="#slots">3.3.2.4. __slots__</a><ul>
<li><a class="reference internal" href="#notes-on-using-slots">3.3.2.4.1. Notas sobre el uso de  <em>__slots__</em></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-class-creation">3.3.3. Personalización de creación de clases</a><ul>
<li><a class="reference internal" href="#metaclasses">3.3.3.1. Metaclases</a></li>
<li><a class="reference internal" href="#resolving-mro-entries">3.3.3.2. Resolviendo entradas de la Orden de Resolución de Métodos (MRU)</a></li>
<li><a class="reference internal" href="#determining-the-appropriate-metaclass">3.3.3.3. Determinando la metaclase adecuada</a></li>
<li><a class="reference internal" href="#preparing-the-class-namespace">3.3.3.4. Preparando el espacio de nombres de la clase</a></li>
<li><a class="reference internal" href="#executing-the-class-body">3.3.3.5. Ejecutando el cuerpo de la clase</a></li>
<li><a class="reference internal" href="#creating-the-class-object">3.3.3.6. Creando el objeto de clase</a></li>
<li><a class="reference internal" href="#uses-for-metaclasses">3.3.3.7. Usos para metaclases</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-instance-and-subclass-checks">3.3.4. Personalizando revisiones de instancia y subclase</a></li>
<li><a class="reference internal" href="#emulating-generic-types">3.3.5. Emulando tipos genéricos</a><ul>
<li><a class="reference internal" href="#the-purpose-of-class-getitem">3.3.5.1. The purpose of <em>__class_getitem__</em></a></li>
<li><a class="reference internal" href="#class-getitem-versus-getitem">3.3.5.2. <em>__class_getitem__</em> versus <em>__getitem__</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#emulating-callable-objects">3.3.6. Emulando objetos que se pueden llamar</a></li>
<li><a class="reference internal" href="#emulating-container-types">3.3.7. Emulando tipos de contenedores</a></li>
<li><a class="reference internal" href="#emulating-numeric-types">3.3.8. Emulando tipos numéricos</a></li>
<li><a class="reference internal" href="#with-statement-context-managers">3.3.9. Gestores de Contexto en la Declaración <em>with</em></a></li>
<li><a class="reference internal" href="#customizing-positional-arguments-in-class-pattern-matching">3.3.10. Personalización de argumentos posicionales en la coincidencia de patrones de clase</a></li>
<li><a class="reference internal" href="#special-method-lookup">3.3.11. Búsqueda de método especial</a></li>
</ul>
</li>
<li><a class="reference internal" href="#coroutines">3.4. Corrutinas</a><ul>
<li><a class="reference internal" href="#awaitable-objects">3.4.1. Objetos Esperables</a></li>
<li><a class="reference internal" href="#coroutine-objects">3.4.2. Objetos de Corrutina</a></li>
<li><a class="reference internal" href="#asynchronous-iterators">3.4.3. Iteradores asíncronos</a></li>
<li><a class="reference internal" href="#asynchronous-context-managers">3.4.4. Gestores de Contexto Asíncronos</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="lexical_analysis.html"
                        title="capítulo anterior"><span class="section-number">2. </span>Análisis léxico</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="executionmodel.html"
                        title="próximo capítulo"><span class="section-number">4. </span>Modelo de ejecución</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/reference/datamodel.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. Modelo de ejecución"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. Análisis léxico"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Referencia del Lenguaje Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">3. </span>Modelo de datos</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="data-model">
<span id="datamodel"></span><h1><span class="section-number">3. </span>Modelo de datos<a class="headerlink" href="#data-model" title="Enlazar permanentemente con este título">¶</a></h1>
<section id="objects-values-and-types">
<span id="objects"></span><h2><span class="section-number">3.1. </span>Objetos, valores y tipos<a class="headerlink" href="#objects-values-and-types" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-0"><em class="dfn">Objects</em> son la abstracción de Python para los datos. Todos los datos en un programa Python están representados por objetos o por relaciones entre objetos. (En cierto sentido y de conformidad con el modelo de Von Neumann de una «programa almacenado de computadora», el código también está representado por objetos.)</p>
<span class="target" id="index-1"></span><p>Cada objeto tiene una identidad, un tipo y un valor. La <em>identidad</em> de un objeto nunca cambia una vez que ha sido creado; puede pensar en ello como la dirección del objeto en la memoria. El operador “<a class="reference internal" href="expressions.html#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a>” compara la identidad de dos objetos; la función <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> retorna un número entero que representa su identidad.</p>
<div class="impl-detail compound">
<p><strong>Detalles de implementación de CPython:</strong> Para CPython, <code class="docutils literal notranslate"><span class="pre">id(x)</span></code> es la dirección de memoria donde se almacena <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</div>
<p>El tipo de un objeto determina las operaciones que admite el objeto (por ejemplo, «¿tiene una longitud?») y también define los posibles valores para los objetos de ese tipo. La función <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> retorna el tipo de un objeto (que es un objeto en sí mismo). Al igual que su identidad, también el <em class="dfn">type</em> de un objeto es inmutable. <a class="footnote-reference brackets" href="#id8" id="id1">1</a></p>
<p>El <em>valor</em> de algunos objetos puede cambiar. Se dice que los objetos cuyo valor puede cambiar son <em>mutables</em>; Los objetos cuyo valor no se puede modificar una vez que se crean se denominan <em>inmutables</em>. (El valor de un objeto contenedor inmutable que contiene una referencia a un objeto mutable puede cambiar cuando se cambia el valor de este último; sin embargo, el contenedor todavía se considera inmutable, porque la colección de objetos que contiene no se puede cambiar. Por lo tanto, la inmutabilidad no es estrictamente lo mismo que tener un valor inmutable, es más sutil). La mutabilidad de un objeto está determinada por su tipo; por ejemplo, los números, las cadenas de caracteres y las tuplas son inmutables, mientras que los diccionarios y las listas son mutables.</p>
<p id="index-2">Los objetos nunca se destruyen explícitamente; sin embargo, cuando se vuelven inalcanzables, se pueden recolectar basura. Se permite a una implementación posponer la recolección de basura u omitirla por completo; es una cuestión de calidad de la implementación cómo se implementa la recolección de basura, siempre que no se recolecten objetos que todavía sean accesibles.</p>
<div class="impl-detail compound">
<p><strong>Detalles de implementación de CPython:</strong> CPython actualmente utiliza un esquema de conteo de referencias con detección retardada (opcional) de basura enlazada cíclicamente, que recolecta la mayoría de los objetos tan pronto como se vuelven inalcanzables, pero no se garantiza que recolecte basura que contenga referencias circulares. Vea la documentación del módulo <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> para información sobre el control de la recolección de basura cíclica. Otras implementaciones actúan de manera diferente y CPython puede cambiar. No dependa de la finalización inmediata de los objetos cuando se vuelvan inalcanzables (por lo que siempre debe cerrar los archivos explícitamente).</p>
</div>
<p>Tenga en cuenta que el uso de las funciones de rastreo o depuración de la implementación puede mantener activos los objetos que normalmente serían coleccionables. También tenga en cuenta que la captura de una excepción con una sentencia “<a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>…<a class="reference internal" href="compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a>” puede mantener objetos activos.</p>
<p>Algunos objetos contienen referencias a recursos «externos» como archivos abiertos o ventanas.  Se entiende que estos recursos se liberan cuando el objeto es eliminado por el recolector de basura, pero como no se garantiza que la recolección de basura suceda, dichos objetos también proporcionan una forma explícita de liberar el recurso externo, generalmente un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code>. Se recomienda encarecidamente a los programas cerrar explícitamente dichos objetos. La declaración “<a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>…<a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a>” y la declaración “<a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>” proporcionan formas convenientes de hacer esto.</p>
<p id="index-3">Algunos objetos contienen referencias a otros objetos; estos se llaman <em>contenedores</em>. Ejemplos de contenedores son tuplas, listas y diccionarios. Las referencias son parte del valor de un contenedor. En la mayoría de los casos, cuando hablamos del valor de un contenedor, implicamos los valores, no las identidades de los objetos contenidos; sin embargo, cuando hablamos de la mutabilidad de un contenedor, solo se implican las identidades de los objetos contenidos inmediatamente. Entonces, si un contenedor inmutable (como una tupla) contiene una referencia a un objeto mutable, su valor cambia si se cambia ese objeto mutable.</p>
<p>Los tipos afectan a casi todos los aspectos del comportamiento del objeto. Incluso la importancia de la identidad del objeto se ve afectada en cierto sentido: para los tipos inmutables, las operaciones que calculan nuevos valores en realidad pueden retornar una referencia a cualquier objeto existente con el mismo tipo y valor, mientras que para los objetos mutables esto no está permitido. Por ejemplo, al hacer <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">1;</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">a</span></code> y <code class="docutils literal notranslate"><span class="pre">b</span></code> puede o no referirse al mismo objeto con el valor 1, dependiendo de la implementación, pero al hacer <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">[];</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code> y <code class="docutils literal notranslate"><span class="pre">d</span></code> se garantiza que se refieren a dos listas vacías diferentes, únicas y recién creadas. (Tenga en cuenta que <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></code> asigna el mismo objeto a ambos <code class="docutils literal notranslate"><span class="pre">c</span></code> y <code class="docutils literal notranslate"><span class="pre">d</span></code>.)</p>
</section>
<section id="the-standard-type-hierarchy">
<span id="types"></span><h2><span class="section-number">3.2. </span>Jerarquía de tipos estándar<a class="headerlink" href="#the-standard-type-hierarchy" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-4">A continuación se muestra una lista de los tipos integrados en Python. Los módulos de extensión (escritos en C, Java u otros lenguajes, dependiendo de la implementación) pueden definir tipos adicionales. Las versiones futuras de Python pueden agregar tipos a la jerarquía de tipos (por ejemplo, números racionales, matrices de enteros almacenados de manera eficiente, etc.), aunque tales adiciones a menudo se proporcionarán a través de la biblioteca estándar.</p>
<p id="index-5">Algunas de las descripciones de tipos a continuación contienen un párrafo que enumera “atributos especiales”. Estos son atributos que proporcionan acceso a la implementación y no están destinados para uso general. Su definición puede cambiar en el futuro.</p>
<dl>
<dt>None</dt><dd><p id="index-6">Este tipo tiene un solo valor. Hay un solo objeto con este valor. Se accede a este objeto a través del nombre incorporado <code class="docutils literal notranslate"><span class="pre">None</span></code>. Se utiliza para indicar la ausencia de un valor en muchas situaciones, por ejemplo, se retorna desde funciones que no retornan nada explícitamente. Su valor de verdad es falso.</p>
</dd>
<dt>NotImplemented</dt><dd><p id="index-7">Este tipo tiene un solo valor. Hay un solo objeto con este valor. Se accede a este objeto a través del nombre integrado <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code>. Los métodos numéricos y los métodos de comparación enriquecidos deben devolver este valor si no implementan la operación para los operandos proporcionados. (El intérprete intentará entonces la operación reflejada, o alguna otra alternativa, dependiendo del operador). No debe evaluarse en un contexto booleano.</p>
<p>Vea <a class="reference internal" href="../library/numbers.html#implementing-the-arithmetic-operations"><span class="std std-ref">Implementar operaciones aritméticas</span></a> para más detalles.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.9: </span>La evaluación de <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> en un contexto booleano está en desuso. Si bien actualmente se evalúa como verdadero, lanzará un <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>. Lanzará un <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> en una versión futura de Python.</p>
</div>
</dd>
<dt>Elipsis</dt><dd><p id="index-8">Este tipo tiene un solo valor. Hay un solo objeto con este valor. Se accede a este objeto a través del literal <code class="docutils literal notranslate"><span class="pre">...</span></code> o el nombre incorporado <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code>. Su valor de verdad es verdadero.</p>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Number" title="numbers.Number"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Number</span></code></a></dt><dd><p id="index-9">Estos son creados por literales numéricos y retornados como resultados por operadores aritméticos y funciones aritméticas integradas. Los objetos numéricos son inmutables; una vez creado su valor nunca cambia. Los números de Python están, por supuesto, fuertemente relacionados con los números matemáticos, pero están sujetos a las limitaciones de la representación numérica en las computadoras.</p>
<p>The string representations of the numeric classes, computed by
<a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> and <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a>, have the following
properties:</p>
<ul class="simple">
<li><p>Son literales numéricos válidos que, cuando se pasan a su constructor de clase, producen un objeto que tiene el valor del numérico original.</p></li>
<li><p>La representación está en base 10, cuando sea posible.</p></li>
<li><p>Los ceros iniciales, posiblemente excepto un solo cero antes de un punto decimal, no se muestran.</p></li>
<li><p>Los ceros finales, posiblemente excepto un solo cero después de un punto decimal, no se muestran.</p></li>
<li><p>Solo se muestra un signo cuando el número es negativo.</p></li>
</ul>
<p>Python distingue entre números enteros, números de coma flotante y números complejos:</p>
<dl>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Integral</span></code></a></dt><dd><p id="index-10">Estos representan elementos del conjunto matemático de números enteros (positivo y negativo).</p>
<p>Hay dos tipos de números enteros:</p>
<dl>
<dt>Enteros (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>)</dt><dd><p>Estos representan números en un rango ilimitado, sujetos solo a la memoria (virtual) disponible. Para las operaciones de desplazamiento y máscara, se asume una representación binaria, y los números negativos se representan en una variante del complemento de 2 que da la ilusión de una cadena de caracteres infinita de bits con signo que se extiende hacia la izquierda.</p>
</dd>
<dt>Booleanos (<a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>)</dt><dd><p id="index-11">Estos representan los valores de verdad Falso y Verdadero. Los dos objetos que representan los valores <code class="docutils literal notranslate"><span class="pre">False</span></code> y <code class="docutils literal notranslate"><span class="pre">True</span></code> son los únicos objetos booleanos. El tipo booleano es un subtipo del tipo entero y los valores booleanos se comportan como los valores 0 y 1 respectivamente, en casi todos los contextos, con la excepción de que cuando se convierten en una cadena de caracteres, las cadenas de caracteres <code class="docutils literal notranslate"><span class="pre">&quot;False&quot;</span></code> o <code class="docutils literal notranslate"><span class="pre">&quot;True&quot;</span></code> son retornadas respectivamente.</p>
</dd>
</dl>
<p id="index-12">Las reglas para la representación de enteros están destinadas a dar la interpretación más significativa de las operaciones de cambio y máscara que involucran enteros negativos.</p>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Real</span></code></a> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>)</dt><dd><p id="index-13">Estos representan números de punto flotante de precisión doble a nivel de máquina. Está a merced de la arquitectura de la máquina subyacente (y la implementación de C o Java) para el rango aceptado y el manejo del desbordamiento. Python no admite números de coma flotante de precisión simple; el ahorro en el uso del procesador y la memoria, que generalmente son la razón para usarlos, se ven reducidos por la sobrecarga del uso de objetos en Python, por lo que no hay razón para complicar el lenguaje con dos tipos de números de coma flotante.</p>
</dd>
<dt><a class="reference internal" href="../library/numbers.html#numbers.Complex" title="numbers.Complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Complex</span></code></a> (<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>)</dt><dd><p id="index-14">Estos representan números complejos como un par de números de coma flotante de precisión doble a nivel de máquina. Se aplican las mismas advertencias que para los números de coma flotante. Las partes reales e imaginarias de un número complejo <code class="docutils literal notranslate"><span class="pre">z</span></code> se pueden obtener a través de los atributos de solo lectura <code class="docutils literal notranslate"><span class="pre">z.real</span></code> y <code class="docutils literal notranslate"><span class="pre">z.imag</span></code>.</p>
</dd>
</dl>
</dd>
<dt>Secuencias</dt><dd><p id="index-15">Estos representan conjuntos ordenados finitos indexados por números no negativos. La función incorporada <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> retorna el número de elementos de una secuencia. Cuando la longitud de una secuencia es <em>n</em>, el conjunto de índices contiene los números 0, 1, …, <em>n</em>-1. El elemento <em>i</em> de la secuencia <em>a</em> se selecciona mediante <code class="docutils literal notranslate"><span class="pre">a[i]</span></code>.</p>
<p id="index-16">Las secuencias también admiten segmentación: <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code> selecciona todos los elementos con índice <em>k</em> de modo que <em>i</em> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <em>k</em> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <em>j</em>.  Cuando se usa como una expresión, un segmento es una secuencia del mismo tipo. Esto implica que el conjunto de índices se vuelve a enumerar para que comience en 0.</p>
<p>Algunas secuencias también admiten «segmentación extendida» con un tercer parámetro «paso» : <code class="docutils literal notranslate"><span class="pre">a[i:j:k]</span></code> selecciona todos los elementos de <em>a</em> con índice <em>x</em> donde <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">n*k</span></code>, <em>n</em> <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> <code class="docutils literal notranslate"><span class="pre">0</span></code> y <em>i</em> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <em>x</em> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <em>j</em>.</p>
<p>Las secuencias se distinguen según su mutabilidad:</p>
<dl>
<dt>Secuencias inmutables</dt><dd><p id="index-17">Un objeto de un tipo de secuencia inmutable no puede cambiar una vez que se crea. (Si el objeto contiene referencias a otros objetos, estos otros objetos pueden ser mutables y pueden cambiarse; sin embargo, la colección de objetos a los que hace referencia directamente un objeto inmutable no puede cambiar).</p>
<p>Los siguientes tipos son secuencias inmutables:</p>
<dl id="index-18">
<dt>Cadenas de caracteres</dt><dd><p id="index-19">A string is a sequence of values that represent Unicode code points.
All the code points in the range <code class="docutils literal notranslate"><span class="pre">U+0000</span> <span class="pre">-</span> <span class="pre">U+10FFFF</span></code> can be
represented in a string.  Python doesn’t have a <code class="xref c c-expr docutils literal notranslate"><span class="pre">char</span></code> type;
instead, every code point in the string is represented as a string
object with length <code class="docutils literal notranslate"><span class="pre">1</span></code>.  The built-in function <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a>
converts a code point from its string form to an integer in the
range <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">-</span> <span class="pre">10FFFF</span></code>; <a class="reference internal" href="../library/functions.html#chr" title="chr"><code class="xref py py-func docutils literal notranslate"><span class="pre">chr()</span></code></a> converts an integer in the range
<code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">-</span> <span class="pre">10FFFF</span></code> to the corresponding length <code class="docutils literal notranslate"><span class="pre">1</span></code> string object.
<a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> can be used to convert a <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> to
<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> using the given text encoding, and
<a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> can be used to achieve the opposite.</p>
</dd>
<dt>Tuplas</dt><dd><p id="index-20">Los elementos de una tupla son objetos arbitrarios de Python. Las tuplas de dos o más elementos están formadas por listas de expresiones separadas por comas. Se puede formar una tupla de un elemento (un “singleton”) al colocar una coma en una expresión (una expresión en sí misma no crea una tupla, ya que los paréntesis deben ser utilizables para agrupar expresiones). Una tupla vacía puede estar formada por un par de paréntesis vacío.</p>
</dd>
<dt>Bytes</dt><dd><p id="index-21">Un objeto de bytes es una colección inmutable. Los elementos son bytes de 8 bits, representados por enteros en el rango 0 &lt;= x &lt;256. Literales de bytes (como <code class="docutils literal notranslate"><span class="pre">b'abc'</span></code>) y el  constructor incorporado <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes()</span></code></a> se puede utilizar para crear objetos de bytes. Además, los objetos de bytes se pueden decodificar en cadenas de caracteres a través del método <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt>Secuencias mutables</dt><dd><p id="index-22">Las secuencias mutables se pueden cambiar después de su creación. Las anotaciones de suscripción y segmentación se pueden utilizar como el objetivo de asignaciones y declaraciones <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> (eliminar).</p>
<p>Actualmente hay dos tipos intrínsecos de secuencias mutable:</p>
<dl>
<dt>Listas</dt><dd><p id="index-23">Los elementos de una lista son objetos de Python arbitrarios.  Las listas se forman colocando una lista de expresiones separadas por comas entre corchetes. (Tome en cuenta que no hay casos especiales necesarios para formar listas de longitud 0 o 1.)</p>
</dd>
<dt>Colecciones de bytes</dt><dd><p id="index-24">Un objeto bytearray es una colección mutable. Son creados por el constructor incorporado <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytearray()</span></code></a>.  Además de ser mutables (y, por lo tanto, inquebrantable), las colecciones de bytes proporcionan la misma interfaz y funcionalidad que los objetos inmutables <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
</dd>
</dl>
<p id="index-25">El módulo de extensión <a class="reference internal" href="../library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> proporciona un ejemplo adicional de un tipo de secuencia mutable, al igual que el módulo <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt>Tipos de conjuntos</dt><dd><p id="index-26">Estos representan conjuntos finitos no ordenados de objetos únicos e inmutables. Como tal, no pueden ser indexados por ningún <em>subscript</em>. Sin embargo, pueden repetirse y la función incorporada <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> retorna el número de elementos en un conjunto. Los usos comunes de los conjuntos son pruebas rápidas de membresía, eliminación de duplicados de una secuencia y cálculo de operaciones matemáticas como intersección, unión, diferencia y diferencia simétrica.</p>
<p>Para elementos del conjunto, se aplican las mismas reglas de inmutabilidad que para las claves de diccionario. Tenga en cuenta que los tipos numéricos obedecen las reglas normales para la comparación numérica: si dos números se comparan igual (por ejemplo, <code class="docutils literal notranslate"><span class="pre">1</span></code> y <code class="docutils literal notranslate"><span class="pre">1.0</span></code>), solo uno de ellos puede estar contenido en un conjunto.</p>
<p>Actualmente hay dos tipos de conjuntos intrínsecos:</p>
<dl>
<dt>Conjuntos</dt><dd><p id="index-27">Estos representan un conjunto mutable. Son creados por el constructor incorporado <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-func docutils literal notranslate"><span class="pre">set()</span></code></a> y puede ser modificado posteriormente por varios métodos, como <code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code>.</p>
</dd>
<dt>Conjuntos congelados</dt><dd><p id="index-28">Estos representan un conjunto inmutable. Son creados por el  constructor incorporado <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-func docutils literal notranslate"><span class="pre">frozenset()</span></code></a>. Como un conjunto congelado es inmutable y <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>, se puede usar nuevamente como un elemento de otro conjunto o como una clave de un diccionario.</p>
</dd>
</dl>
</dd>
<dt>Mapeos</dt><dd><p id="index-29">Estos representan conjuntos finitos de objetos indexados por conjuntos de índices arbitrarios. La notación de subíndice <code class="docutils literal notranslate"><span class="pre">a[k]</span></code> selecciona el elemento indexado por <code class="docutils literal notranslate"><span class="pre">k</span></code> del mapeo <code class="docutils literal notranslate"><span class="pre">a</span></code>; esto se puede usar en expresiones y como el objetivo de asignaciones o declaraciones <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a>. La función incorporada <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> retorna el número de elementos en un mapeo.</p>
<p>Actualmente hay un único tipo de mapeo intrínseco:</p>
<dl>
<dt>Diccionarios</dt><dd><p id="index-30">Estos representan conjuntos finitos de objetos indexados por valores casi arbitrarios. Los únicos tipos de valores no aceptables como claves son valores que contienen listas o diccionarios u otros tipos mutables que se comparan por valor en lugar de por identidad de objeto, la razón es que la implementación eficiente de los diccionarios requiere que el valor <em>hash</em> de una clave permanezca constante. Los tipos numéricos utilizados para las claves obedecen las reglas normales para la comparación numérica: si dos números se comparan igual (por ejemplo, <code class="docutils literal notranslate"><span class="pre">1</span></code> y <code class="docutils literal notranslate"><span class="pre">1.0</span></code>) entonces se pueden usar indistintamente para indexar la misma entrada del diccionario.</p>
<p>Los diccionarios conservan el orden de inserción, lo que significa que las claves se mantendrán en el mismo orden en que se agregaron secuencialmente sobre el diccionario. Reemplazar una clave existente no cambia el orden, sin embargo, eliminar una clave y volver a insertarla la agregará al final en lugar de mantener su lugar anterior.</p>
<p>Los diccionarios son mutables; pueden ser creados por la notación <code class="docutils literal notranslate"><span class="pre">{...}</span></code> (vea la sección <a class="reference internal" href="expressions.html#dict"><span class="std std-ref">Despliegues de diccionario</span></a>).</p>
<p id="index-31">Los módulos de extensión <a class="reference internal" href="../library/dbm.html#module-dbm.ndbm" title="dbm.ndbm: The standard &quot;database&quot; interface, based on ndbm. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.ndbm</span></code></a> y <a class="reference internal" href="../library/dbm.html#module-dbm.gnu" title="dbm.gnu: GNU's reinterpretation of dbm. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.gnu</span></code></a> proporcionan ejemplos adicionales de tipos de mapeo, al igual que el módulo <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Los diccionarios no conservaban el orden de inserción en las versiones de Python anteriores a 3.6. En CPython 3.6, el orden de inserción se conserva, pero se consideró un detalle de implementación en ese momento en lugar de una garantía de idioma.</p>
</div>
</dd>
</dl>
</dd>
<dt>Tipos invocables</dt><dd><p id="index-32">Estos son los tipos a los que la operación de llamada de función (vea la sección <a class="reference internal" href="expressions.html#calls"><span class="std std-ref">Invocaciones</span></a>) puede ser aplicado:</p>
<dl>
<dt>Funciones definidas por el usuario</dt><dd><p id="index-33">Un objeto función definido por el usuario, es creado por un definición de función (vea la sección <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">Definiciones de funciones</span></a>). Debe llamarse con una lista de argumentos que contenga el mismo número de elementos que la lista de parámetros formales de la función.</p>
<p>Atributos especiales:</p>
<table class="docutils align-default" id="index-34">
<colgroup>
<col style="width: 37%" />
<col style="width: 46%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Atributo</p></th>
<th class="head"><p>Significado</p></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></p></td>
<td><p>El texto de documentación de la función, o <code class="docutils literal notranslate"><span class="pre">None</span></code> si no está disponible; no heredado por subclases.</p></td>
<td><p>Escribible</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a></p></td>
<td><p>El nombre de la función.</p></td>
<td><p>Escribible</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="../library/stdtypes.html#definition.__qualname__" title="definition.__qualname__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__qualname__</span></code></a></p></td>
<td><p>Las funciones <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">qualified name</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</td>
<td><p>Escribible</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code></p></td>
<td><p>El nombre del módulo en el que se definió la función, o <code class="docutils literal notranslate"><span class="pre">None</span></code> si no está disponible.</p></td>
<td><p>Escribible</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__defaults__</span></code></p></td>
<td><p>Una tupla que contiene valores de argumento predeterminados para aquellos argumentos que tienen valores predeterminados, o <code class="docutils literal notranslate"><span class="pre">None</span></code> si ningún argumento tiene un valor predeterminado.</p></td>
<td><p>Escribible</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__code__</span></code></p></td>
<td><p>El objeto de código que representa el cuerpo de la función compilada.</p></td>
<td><p>Escribible</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__globals__</span></code></p></td>
<td><p>Una referencia al diccionario que contiene las variables globales de la función — el espacio de nombres global del módulo en el que se definió la función.</p></td>
<td><p>Solo lectura</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a></p></td>
<td><p>El espacio de nombres que admite atributos de funciones arbitrarias.</p></td>
<td><p>Escribible</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__closure__</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">None</span></code> o una tupla de celdas que contienen enlaces para las variables libres de la función. Vea a continuación para obtener información sobre el atributo <code class="docutils literal notranslate"><span class="pre">cell_contents</span></code>.</p></td>
<td><p>Solo lectura</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code></p></td>
<td><p>Un diccionario que contiene anotaciones de parámetros. Las claves del dict son los nombres de los parámetros, y <code class="docutils literal notranslate"><span class="pre">'return'</span></code> para la anotación de retorno, si se proporciona. Para más información sobre trabajar con este atributo, ve <a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">Prácticas recomendadas para las anotaciones</span></a>.</p></td>
<td><p>Escribible</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">__kwdefaults__</span></code></p></td>
<td><p>Un diccionario que contiene valores predeterminados para parámetros de solo palabras clave.</p></td>
<td><p>Escribible</p></td>
</tr>
</tbody>
</table>
<p>La mayoría de los atributos etiquetados «Escribible» verifican el tipo del valor asignado.</p>
<p>Los objetos de función también admiten la obtención y configuración de atributos arbitrarios, que se pueden usar, por ejemplo, para adjuntar metadatos a funciones. La notación de puntos de atributo regular se utiliza para obtener y establecer dichos atributos. <em>Tenga en cuenta que la implementación actual solo admite atributos de función en funciones definidas por el usuario. Los atributos de función en funciones integradas pueden ser compatibles en el futuro.</em></p>
<p>Un objeto de celda tiene el atributo <code class="docutils literal notranslate"><span class="pre">cell_contents</span></code>. Esto se puede usar para obtener el valor de la celda, así como para establecer el valor.</p>
<p>Se puede recuperar información adicional sobre la definición de una función desde su objeto de código; Vea la descripción de los tipos internos a continuación. El tipo <a class="reference internal" href="../library/types.html#types.CellType" title="types.CellType"><code class="xref py py-data docutils literal notranslate"><span class="pre">cell</span></code></a> puede ser accedido en el módulo <a class="reference internal" href="../library/types.html#module-types" title="types: Names for built-in types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">types</span></code></a>.</p>
</dd>
<dt>Métodos de instancia</dt><dd><p id="index-35">Un objeto de método de instancia combina una clase, una instancia de clase y cualquier objeto invocable (normalmente una función definida por el usuario).</p>
<p id="index-36">Atributos especiales de solo lectura: <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> es el objeto de instancia de clase, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> es el objeto de función; <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> es la documentación del método (al igual que <code class="docutils literal notranslate"><span class="pre">__func__.__doc__</span></code>); <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> es el nombre del método (al igual que <code class="docutils literal notranslate"><span class="pre">__func__.__name__</span></code>); <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> es el nombre del módulo en el que el método fue definido, o <code class="docutils literal notranslate"><span class="pre">None</span></code> si no se encuentra disponible.</p>
<p>Los métodos también admiten obtener (más no establecer) los atributos arbitrarios de la función en el objeto de función subyacente.</p>
<p>Los objetos de métodos definidos por usuarios pueden ser creados al obtener el atributo de una clase (probablemente a través de la instancia de dicha clase), si tal atributo es el objeto de una función definida por el usuario o el objeto del método de una clase.</p>
<p>Cuando un objeto de instancia de método es creado al obtener un objeto de función definida por el usuario desde una clase a través de una de sus instancias, su atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> es la instancia, y el objeto de método se dice que está enlazado.  El nuevo atributo de método <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> es el objeto de función original.</p>
<p>Cuando un objeto de instancia de método es creado al obtener un objeto de método de clase a partir de una clase o instancia, su atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> es la clase misma, y su atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code> es el objeto de función subyacente al método de la clase.</p>
<p>Cuando el objeto de la instancia de método es invocado, la función subyacente (<code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code>) es llamada, insertando la instancia de clase (<code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code>) delante de la lista de argumentos.  Por ejemplo, cuando <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> es una clase que contiene la definición de una función <code class="xref py py-meth docutils literal notranslate"><span class="pre">f()</span></code>, y <code class="docutils literal notranslate"><span class="pre">x</span></code> es una instancia de <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>, invocar <code class="docutils literal notranslate"><span class="pre">x.f(1)</span></code> es equivalente a invocar <code class="docutils literal notranslate"><span class="pre">C.f(x,</span> <span class="pre">1)</span></code>.</p>
<p>Cuando el objeto de instancia de método es derivado del objeto del método de clase, la “instancia de clase” almacenada en <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> en realidad será la clase misma, de manera que invocar ya sea <code class="docutils literal notranslate"><span class="pre">x.f(1)``o</span> <span class="pre">``C.f(1)</span></code> es equivalente a invocar <code class="docutils literal notranslate"><span class="pre">f(C,1)</span></code> donde <code class="docutils literal notranslate"><span class="pre">f</span></code> es la función subyacente.</p>
<p>Tome en cuenta que la transformación de objeto de función a objeto de método de instancia ocurre cada vez que el atributo es obtenido de la instancia.  En algunos casos, una optimización fructífera es asignar el atributo a una variable local e invocarla. Note también que esta transformación únicamente ocurre con funciones definidas por usuario; otros objetos invocables (y todos los objetos no invocables) son obtenidos sin transformación.  También es importante mencionar que las funciones definidas por el usuario, que son atributos de la instancia de una clase no son convertidos a métodos enlazados; esto ocurre <em>únicamente</em> cuando la función es un atributo de la clase.</p>
</dd>
<dt>Funciones generadoras</dt><dd><p id="index-37">A function or method which uses the <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> statement (see section
<a class="reference internal" href="simple_stmts.html#yield"><span class="std std-ref">La declaración yield</span></a>) is called a <em class="dfn">generator function</em>.  Such a function, when
called, always returns an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> object which can be used to
execute the body of the function:  calling the iterator’s
<a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iterator.__next__()</span></code></a> method will cause the function to execute until
it provides a value using the <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> statement.  When the
function executes a <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> statement or falls off the end, a
<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> exception is raised and the iterator will have
reached the end of the set of values to be returned.</p>
</dd>
<dt>Funciones de corrutina</dt><dd><p id="index-38">Una función o método que es definido utilizando <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> se llama <em class="dfn">coroutine function</em>.  Dicha función, cuando es invocada, retorna un objeto <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a>.  Éste puede contener expresiones <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>, así como declaraciones <a class="reference internal" href="compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> y <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>. Ver también la sección <a class="reference internal" href="#coroutine-objects"><span class="std std-ref">Objetos de Corrutina</span></a>.</p>
</dd>
<dt>Funciones generadoras asincrónicas</dt><dd><p id="index-39">A function or method which is defined using <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> and
which uses the <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> statement is called a
<em class="dfn">asynchronous generator function</em>.  Such a function, when called,
returns an <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> object which can be used in an
<a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> statement to execute the body of the function.</p>
<p>Calling the asynchronous iterator’s
<a class="reference internal" href="#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aiterator.__anext__</span></code></a> method
will return an <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> which when awaited
will execute until it provides a value using the <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>
expression.  When the function executes an empty <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a>
statement or falls off the end, a <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> exception
is raised and the asynchronous iterator will have reached the end of
the set of values to be yielded.</p>
</dd>
<dt>Funciones incorporadas</dt><dd><p id="index-40">Un objeto de función incorporada es un envoltorio (wrapper) alrededor de una función C.  Ejemplos de funciones incorporadas son <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> y <a class="reference internal" href="../library/math.html#math.sin" title="math.sin"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.sin()</span></code></a> (<a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> es un módulo estándar incorporado). El número y tipo de argumentos son determinados por la función C. Atributos especiales de solo lectura: <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> es la cadena de documentación de la función, o <code class="docutils literal notranslate"><span class="pre">None</span></code> si no se encuentra disponible; <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> es el nombre de la función; <code class="xref py py-attr docutils literal notranslate"><span class="pre">__init__</span></code> es establecido como <code class="docutils literal notranslate"><span class="pre">None</span></code> (sin embargo ver el siguiente elemento); <code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> es el nombre del módulo en el que la función fue definida o <code class="docutils literal notranslate"><span class="pre">None</span></code> si no se encuentra disponible.</p>
</dd>
<dt>Métodos incorporados</dt><dd><p id="index-41">Éste es realmente un disfraz distinto de una función incorporada, esta vez teniendo un objeto que se pasa a la función C como un argumento extra implícito.  Un ejemplo de un método incorporado es <code class="docutils literal notranslate"><span class="pre">alist.append()</span></code>, asumiendo que <em>alist</em> es un objeto de lista. En este caso, el atributo especial de solo lectura <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> es establecido al objeto indicado por <em>alist</em>.</p>
</dd>
<dt>Clases</dt><dd><p>Classes are callable.  These objects normally act as factories for new
instances of themselves, but variations are possible for class types that
override <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a>.  The arguments of the call are passed to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code> and, in the typical case, to <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> to
initialize the new instance.</p>
</dd>
<dt>Instancias de clases</dt><dd><p>Instances of arbitrary classes can be made callable by defining a
<a class="reference internal" href="#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> method in their class.</p>
</dd>
</dl>
</dd>
<dt>Módulos</dt><dd><p id="index-42">Los módulos son una unidad básica organizacional en código Python, y son creados por el <a class="reference internal" href="import.html#importsystem"><span class="std std-ref">import system</span></a> al ser invocados ya sea por la declaración <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>, o invocando funciones como <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> y la incorporada <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a>.  Un objeto de módulo tiene un espacio de nombres implementado por un objeto de diccionario (éste es el diccionario al que hace referencia el atributo de funciones <code class="docutils literal notranslate"><span class="pre">__globals__</span></code> definido en el módulo).  Las referencias de atributos son traducidas a búsquedas en este diccionario, p. ej., <code class="docutils literal notranslate"><span class="pre">m.x</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">m.__dict__[“x”]</span></code>. Un objeto de módulo no contiene el objeto de código utilizado para iniciar el módulo (ya que no es necesario una vez que la inicialización es realizada).</p>
<p>La asignación de atributos actualiza el diccionario de espacio de nombres del módulo, p. ej., <code class="docutils literal notranslate"><span class="pre">m.x</span> <span class="pre">=</span> <span class="pre">1</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">m.__dict__[“x”]</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
<p id="index-43">Atributos predefinidos (escribibles):</p>
<blockquote>
<div><dl class="simple">
<dt><a class="reference internal" href="import.html#name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a></dt><dd><p>El nombre del módulo.</p>
</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></dt><dd><p>El texto de documentación del módulo, o <code class="docutils literal notranslate"><span class="pre">None</span></code> si no está disponible.</p>
</dd>
<dt><a class="reference internal" href="import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a></dt><dd><p>El nombre de ruta del archivo desde el que se cargó el módulo, si se cargó desde un archivo. El atributo <a class="reference internal" href="import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> puede faltar para ciertos tipos de módulos, como los módulos C que están vinculados estáticamente al intérprete. Para los módulos de extensión cargados dinámicamente desde una biblioteca compartida, es el nombre de ruta del archivo de la biblioteca compartida.</p>
</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code></dt><dd><p>Un diccionario que contiene el <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">variable annotations</span></a> recopilados durante la ejecución del cuerpo del módulo. Para buenas prácticas sobre trabajar con <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code>, por favor ve <a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">Prácticas recomendadas para las anotaciones</span></a>.</p>
</dd>
</dl>
</div></blockquote>
<p id="index-44">El atributo especial de solo lectura <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> es el espacio de nombres del módulo como un objeto de diccionario.</p>
<div class="impl-detail compound">
<p><strong>Detalles de implementación de CPython:</strong> Debido a la manera en la que CPython limpia los diccionarios de módulo, el diccionario de módulo será limpiado cuando el módulo se encuentra fuera de alcance, incluso si el diccionario aún tiene referencias existentes.  Para evitar esto, copie el diccionario o mantenga el módulo cerca mientras usa el diccionario directamente.</p>
</div>
</dd>
<dt>Clases personalizadas</dt><dd><p>Los tipos de clases personalizadas son normalmente creadas por definiciones de clases (ver sección <a class="reference internal" href="compound_stmts.html#class"><span class="std std-ref">Definiciones de clase</span></a>).  Una clase tiene implementado un espacio de nombres por un objeto de diccionario. Las referencias de atributos de clase son traducidas a búsquedas en este diccionario, p. ej., <code class="docutils literal notranslate"><span class="pre">C.x</span></code> es traducido a <code class="docutils literal notranslate"><span class="pre">C.__dict__[“x”]</span></code> (aunque hay una serie de enlaces que permiten la ubicación de atributos por otros medios). Cuando el nombre de atributo no es encontrado ahí, la búsqueda de atributo continúa en las clases base. Esta búsqueda de las clases base utiliza la orden de resolución de métodos C3 que se comporta correctamente aún en la presencia de estructuras de herencia ‘diamante’ donde existen múltiples rutas de herencia que llevan a un ancestro común. Detalles adicionales en el MRO C3 utilizados por Python pueden ser encontrados en la documentación correspondiente a la versión 2.3 en <a class="reference external" href="https://www.python.org/download/releases/2.3/mro/">https://www.python.org/download/releases/2.3/mro/</a>.</p>
<p id="index-45">Cuando la referencia de un atributo de clase (digamos, para la clase <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>) produce un objeto de método de clase, éste es transformado a un objeto de método de instancia cuyo atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> es <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>.  Cuando produce un objeto de un método estático, éste es transformado al objeto envuelto por el objeto de método estático. Ver sección <a class="reference internal" href="#descriptors"><span class="std std-ref">Implementando Descriptores</span></a> para otra manera en la que los atributos obtenidos de una clase pueden diferir de los que en realidad están contenidos en su <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>.</p>
<p id="index-46">Las asignaciones de atributos de clase actualizan el diccionario de la clase, nunca el diccionario de la clase base.</p>
<p id="index-47">Un objeto de clase puede ser invocado (ver arriba) para producir una instancia de clase (ver a continuación).</p>
<p id="index-48">Atributos especiales:</p>
<blockquote>
<div><dl class="simple">
<dt><a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a></dt><dd><p>El nombre de la clase.</p>
</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code></dt><dd><p>El nombre del módulo en el que se definió la clase.</p>
</dd>
<dt><a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a></dt><dd><p>El diccionario conteniendo el espacio de nombres de la clase.</p>
</dd>
<dt><a class="reference internal" href="../library/stdtypes.html#class.__bases__" title="class.__bases__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__bases__</span></code></a></dt><dd><p>Una tupla conteniendo las clases de base, en orden de ocurrencia en la lista de clase base.</p>
</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></dt><dd><p>El texto de documentación de la clase, o <code class="docutils literal notranslate"><span class="pre">None</span></code> si no está disponible.</p>
</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code></dt><dd><p>Un diccionario conteniendo el <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">variable annotations</span></a> recopilados durante la ejecución del cuerpo de la clase. Para buenas prácticas sobre trabajar con <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code>, por favor ve <a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">Prácticas recomendadas para las anotaciones</span></a>.</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>Instancias de clase</dt><dd><p id="index-49">A class instance is created by calling a class object (see above).  A class
instance has a namespace implemented as a dictionary which is the first place
in which attribute references are searched.  When an attribute is not found
there, and the instance’s class has an attribute by that name, the search
continues with the class attributes.  If a class attribute is found that is a
user-defined function object, it is transformed into an instance method
object whose <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> attribute is the instance.  Static method and
class method objects are also transformed; see above under «Classes».  See
section <a class="reference internal" href="#descriptors"><span class="std std-ref">Implementando Descriptores</span></a> for another way in which attributes of a class
retrieved via its instances may differ from the objects actually stored in
the class’s <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>.  If no class attribute is found, and the
object’s class has a <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> method, that is called to satisfy
the lookup.</p>
<p id="index-50">Attribute assignments and deletions update the instance’s dictionary, never a
class’s dictionary.  If the class has a <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> or
<a class="reference internal" href="#object.__delattr__" title="object.__delattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delattr__()</span></code></a> method, this is called instead of updating the instance
dictionary directly.</p>
<p id="index-51">Instancias de clases pueden pretender ser números, secuencias o mapeos si tienen métodos con ciertos nombres especiales.  Ver sección <a class="reference internal" href="#specialnames"><span class="std std-ref">Nombres especiales de método</span></a>.</p>
<p id="index-52">Atributos especiales: <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> es el diccionario de atributos; <a class="reference internal" href="../library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> es la clase de la instancia.</p>
</dd>
<dt>Objetos E/S (también conocidos como objetos de archivo)</dt><dd><p id="index-53">Un <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a> representa un archivo abierto.  Diversos accesos directos se encuentran disponibles para crear objetos de archivo: la función incorporada <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>, así como <a class="reference internal" href="../library/os.html#os.popen" title="os.popen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.popen()</span></code></a>, <a class="reference internal" href="../library/os.html#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fdopen()</span></code></a>, y el método de objetos socket <code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code> (y quizás por otras funciones y métodos proporcionados por módulos de extensión).</p>
<p>Los objetos <code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> y <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> son iniciados a objetos de archivos correspondientes a la entrada y salida estándar del intérprete, así como flujos de error; todos ellos están abiertos en el modo de texto y por lo tanto siguen la interface definida por la clase abstracta <a class="reference internal" href="../library/io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOBase</span></code></a>.</p>
</dd>
<dt>Tipos internos</dt><dd><p id="index-54">Algunos tipos utilizados internamente por el intérprete son expuestos al usuario. Sus definiciones pueden cambiar en futuras versiones del intérprete, pero son mencionadas aquí para complementar.</p>
<dl id="index-55">
<dt>Objetos de código</dt><dd><p>Los objetos de código representan código de Python ejecutable <em>compilado por bytes</em>, o <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a>. La diferencia entre un objeto de código y un objeto de función es que el objeto de función contiene una referencia explícita a los globales de la función (el módulo en el que fue definido), mientras el objeto de código no contiene contexto; de igual manera los valores por defecto de los argumentos son almacenados en el objeto de función, no en el objeto de código (porque representan valores calculados en tiempo de ejecución).  A diferencia de objetos de función, los objetos de código son inmutables y no contienen referencias (directas o indirectas) a objetos mutables.</p>
<p id="index-56">Atributos especiales de solo lectura: <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_name</span></code> da el nombre de la función; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_argcount</span></code> es el número total de argumentos posicionales (incluyendo argumentos únicamente posicionales y argumentos con valores por default); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_posonlyargcount</span></code> es el número de argumentos únicamente posicionales (incluyendo argumentos con valores por default); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_kwonlyargcountp</span></code> es el número de argumentos solo de palabra clave (incluyendo argumentos con valores por default); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_nlocals</span></code> es el número de variables usadas por la función (incluyendo argumentos); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_varnames</span></code> es una tupla que contiene los nombres con las variables locales (empezando con los nombres de argumento); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_cellvars</span></code> es una tupla que contiene los nombres de variables locales que son referenciadas por funciones anidadas; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_freevars</span></code> es una tupla que contiene los nombres de variables libres; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_code</span></code> es una cadena que representa la secuencia de instrucciones de bytecode; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_consts</span></code> es una tupla que contiene las literales usadas por el bytecode; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_names</span></code> es una tupla que contiene los nombres usados por el bytecode; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_filename</span></code> es el nombre de archivo de donde el código fue compilado; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_firstlineno</span></code> es el primer número de línea de la función; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_lnotab</span></code> es una cadena codificando el mapeo desde el desplazamiento de bytecode al número de líneas (ver el código fuente del intérprete para más detalles); <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_stacksize</span></code> es el tamaño de pila requerido; <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> es un entero codificando el número de banderas para el intérprete.</p>
<p id="index-57">Los siguientes bits de bandera son definidos por <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> : bit <code class="docutils literal notranslate"><span class="pre">0x04</span></code> es establecido si la función utiliza la sintaxis <code class="docutils literal notranslate"><span class="pre">*arguments</span></code> para aceptar un número arbitrario de argumentos posicionales; bit <code class="docutils literal notranslate"><span class="pre">0x08</span></code> es establecido si la función utiliza la sintaxis <code class="docutils literal notranslate"><span class="pre">**keywords</span></code> para aceptar argumentos de palabras clave arbitrarios; bit <code class="docutils literal notranslate"><span class="pre">0x20</span></code> es establecido si la función es un generador.</p>
<p>Declaraciones de características futuras (<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">division</span></code>) también utiliza bits en <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> para indicar si el objeto de código fue compilado con alguna característica particular habilitada: el bit <code class="docutils literal notranslate"><span class="pre">0x2000</span></code> es establecido si la función fue compilada con división futura habilitada; los bits <code class="docutils literal notranslate"><span class="pre">0x10</span></code> y <code class="docutils literal notranslate"><span class="pre">0x1000</span></code> fueron utilizados en versiones previas de Python.</p>
<p>Otros bits en <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code> son reservados para uso interno.</p>
<p id="index-58">Si un objeto de código representa una función, el primer elemento en <code class="xref py py-attr docutils literal notranslate"><span class="pre">co_consts</span></code> es la cadena de documentación de la función, o <code class="docutils literal notranslate"><span class="pre">None</span></code> si no está definido.</p>
</dd>
</dl>
<dl id="frame-objects">
<dt>Objetos de marco</dt><dd><p id="index-59">Los objetos de marco representan marcos de ejecución. Pueden ocurrir en objetos de rastreo (ver a continuación), y son también pasados hacia funciones de rastreo registradas.</p>
<p id="index-60">Atributos especiales de solo lectura: <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_back</span></code> es para el marco de pila anterior (hacia quien produce el llamado), o <code class="docutils literal notranslate"><span class="pre">None</span></code> si éste es el marco de pila inferior; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_code</span></code> es el objeto de código ejecutado en este marco; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_locals</span></code> es el diccionario utilizado para buscar variables locales; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_globals</span></code> es usado por las variables globales; <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_builtins</span></code> es utilizado por nombres incorporados (intrínsecos); <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_lasti</span></code> da la instrucción precisa (éste es un índice dentro de la cadena de bytecode del objeto de código).</p>
<p>Acceder a <code class="docutils literal notranslate"><span class="pre">f_code</span></code> lanza un objeto <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">evento de auditoría</span></a> <code class="docutils literal notranslate"><span class="pre">.__getattr__</span></code> con argumentos <code class="docutils literal notranslate"><span class="pre">obj</span></code> y <code class="docutils literal notranslate"><span class="pre">&quot;f_code&quot;</span></code> .</p>
<p id="index-61">Atributos especiales escribibles: <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace</span></code>, de lo contrario <code class="docutils literal notranslate"><span class="pre">None</span></code>, es una función llamada por distintos eventos durante la ejecución del código (éste es utilizado por el depurador). Normalmente un evento es desencadenado por cada una de las líneas fuente - esto puede ser deshabilitado estableciendo <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_lines</span></code> a <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>.</p>
<p>Las implementaciones <em>pueden</em> permitir que eventos por código de operación sean solicitados estableciendo <code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_opcodes</span></code> a <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>. Tenga en cuenta que esto puede llevar a un comportamiento indefinido del intérprete si se levantan excepciones por la función de rastreo escape hacia la función que está siendo rastreada.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">f_lineno</span></code> es el número de línea actual del marco — escribiendo a esta forma dentro de una función de rastreo salta a la línea dada (solo para el último marco). Un depurador puede implementar un comando de salto (<em>Jump</em>) (también conocido como <em>Set Next Statement</em>) al escribir en f_lineno.</p>
<p>Objetos de marco soportan un método:</p>
<dl class="py method">
<dt id="frame.clear">
<code class="sig-prename descclassname">frame.</code><code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frame.clear" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método limpia todas las referencias a variables locales mantenidas por el marco. También, si el marco pertenecía a un generador, éste es finalizado. Esto ayuda a interrumpir los ciclos de referencia que involucran objetos de marco (por ejemplo al detectar una excepción y almacenando su rastro para uso posterior).</p>
<p><a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> es lanzado si el marco se encuentra en ejecución.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

</dd>
</dl>
<dl id="traceback-objects">
<dt>Objetos de seguimiento de pila (traceback)</dt><dd><p id="index-62">Los objetos de seguimiento de pila representan el trazo de pila (<em>stack trace</em>) de una excepción. Un objeto de rastreo es creado de manera implícita cuando se da una excepción, y puede ser creada de manera explícita al llamar <a class="reference internal" href="../library/types.html#types.TracebackType" title="types.TracebackType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.TracebackType</span></code></a>.</p>
<p>Para seguimientos de pila (tracebacks) creados de manera implícita, cuando la búsqueda por un manejo de excepciones desenvuelve la pila de ejecución, en cada nivel de desenvolvimiento se inserta un objeto de rastreo al frente del rastreo actual. Cuando se entra a un manejo de excepción, la pila de rastreo se vuelve disponible para el programa. (Ver sección <a class="reference internal" href="compound_stmts.html#try"><span class="std std-ref">La sentencia try</span></a>.) Es accesible como el tercer elemento de la tupla retornada por <code class="docutils literal notranslate"><span class="pre">sys.exc_info()</span></code>, y como el atributo <code class="docutils literal notranslate"><span class="pre">__traceback__</span></code> de la excepción capturada.</p>
<p>Cuando el programa no contiene un gestor apropiado, el trazo de pila es escrito (muy bien formateado) a la secuencia de error estándar; si el intérprete es interactivo, también se vuelve disponible al usuario como <code class="docutils literal notranslate"><span class="pre">sys.last_traceback</span></code>.</p>
<p>Para seguimientos de pila creados de forma explícita, depende de su creador determinar cómo los atributos <code class="docutils literal notranslate"><span class="pre">tb_next</span></code> deberían ser ligados para formar un trazo de pila completo (<em>full stack trace</em>).</p>
<p id="index-63">Atributos especiales de solo lectura: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_frame</span></code> apunta al marco de ejecución del nivel actual; <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_lineno</span></code> da el número de línea donde ocurrió la excepción; <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_lasti</span></code> indica la instrucción precisa. El número de línea y la última instrucción en el seguimiento de pila puede diferir del número de línea de su objeto de marco si la excepción ocurrió en una declaración <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> sin una cláusula de excepción (except) correspondiente o con una cláusula <em>finally</em>.</p>
<p>Acceder a <code class="docutils literal notranslate"><span class="pre">tb_frame</span></code> lanza un objeto <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">evento de auditoría</span></a> <code class="docutils literal notranslate"><span class="pre">.__getattr__</span></code> con argumentos <code class="docutils literal notranslate"><span class="pre">obj</span></code> y <code class="docutils literal notranslate"><span class="pre">tb_frame</span></code>.</p>
<p id="index-64">Atributo especial escribible: <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_next</span></code> es el siguiente nivel en el trazo de pila (hacia el marco en donde ocurrió la excepción), o <code class="docutils literal notranslate"><span class="pre">None</span></code> si no existe un siguiente nivel.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Los objetos de seguimiento de pila ya pueden ser instanciados de manera explícita desde código de Python, y el atributo <code class="docutils literal notranslate"><span class="pre">tb_next</span></code> de instancias existentes puede ser actualizado.</p>
</div>
</dd>
<dt>Objetos de segmento (Slice objects)</dt><dd><p id="index-65">Slice objects are used to represent slices for
<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>
methods.  They are also created by the built-in <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-func docutils literal notranslate"><span class="pre">slice()</span></code></a> function.</p>
<p id="index-66">Atributos especiales de solo lectura: <code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code> es el límite inferior; <code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code> es el límite superior; <code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code> es el valor de paso; cada uno es <code class="docutils literal notranslate"><span class="pre">None</span></code> si es omitido. Estos atributos pueden ser de cualquier tipo.</p>
<p>Los objetos de segmento soportan un método:</p>
<dl class="py method">
<dt id="slice.indices">
<code class="sig-prename descclassname">slice.</code><code class="sig-name descname">indices</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">length</span></em><span class="sig-paren">)</span><a class="headerlink" href="#slice.indices" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método toma un argumento <em>length</em> de entero simple y calcula información relacionada con el segmento que el mismo describiría si fuera aplicado a una secuencia de elementos <em>length</em>. Retorna una tupla de tres enteros; respectivamente estos son los índices <em>start</em> y <em>stop</em> y el <em>step</em> o longitud del paso del segmento. Índices faltantes o fuera de los límites son manipulados de manera consistente con segmentos regulares.</p>
</dd></dl>

</dd>
<dt>Objetos de método estático</dt><dd><p>Los objetos de método estático proveen una forma de anular la transformación de objetos de función a objetos de método descritos anteriormente. Un objeto de método estático es una envoltura (<em>wrapper</em>) alrededor de cualquier otro objeto, usualmente un objeto de método definido por usuario. Cuando un objeto de método estático es obtenido desde una clase o una instancia de clase, usualmente el objeto retornado es el objeto envuelto, el cual no está objeto a ninguna transformación adicional. Los objetos de método estático también pueden ser llamados. Los objetos de método estático son creados por el constructor incorporado <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a>.</p>
</dd>
<dt>Objetos de método de clase</dt><dd><p>Un objeto de método de clase, igual que un objeto de método estático, es un envoltorio (wrapper) alrededor de otro objeto que altera la forma en la que el objeto es obtenido desde las clases y las instancias de clase. El comportamiento de los objetos de método de clase sobre tal obtención es descrita más arriba, debajo de “Métodos definidos por usuario”. Objetos de clase de método son creados por el constructor incorporado <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="special-method-names">
<span id="specialnames"></span><h2><span class="section-number">3.3. </span>Nombres especiales de método<a class="headerlink" href="#special-method-names" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-67">A class can implement certain operations that are invoked by special syntax
(such as arithmetic operations or subscripting and slicing) by defining methods
with special names. This is Python’s approach to <em class="dfn">operator overloading</em>,
allowing classes to define their own behavior with respect to language
operators.  For instance, if a class defines a method named
<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>,
and <code class="docutils literal notranslate"><span class="pre">x</span></code> is an instance of this class, then <code class="docutils literal notranslate"><span class="pre">x[i]</span></code> is roughly equivalent
to <code class="docutils literal notranslate"><span class="pre">type(x).__getitem__(x,</span> <span class="pre">i)</span></code>.  Except where mentioned, attempts to execute an
operation raise an exception when no appropriate method is defined (typically
<a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> or <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>).</p>
<p>Setting a special method to <code class="docutils literal notranslate"><span class="pre">None</span></code> indicates that the corresponding
operation is not available.  For example, if a class sets
<a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the class is not iterable, so calling
<a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> on its instances will raise a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> (without
falling back to <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>). <a class="footnote-reference brackets" href="#id9" id="id2">2</a></p>
<p>Cuando se implementa una clase que emula cualquier tipo incorporado, es importante que la emulación solo sea implementado al grado que hace sentido para el objeto que está siendo modelado. Por ejemplo, algunas secuencias pueden trabajar bien con la obtención de elementos individuales, pero extraer un segmento puede no tener mucho sentido. (Un ejemplo de esto es la interfaz <code class="xref py py-class docutils literal notranslate"><span class="pre">NodeList</span></code>, en el Modelo de Objetos del Documento del W3C.)</p>
<section id="basic-customization">
<span id="customization"></span><h3><span class="section-number">3.3.1. </span>Personalización básica<a class="headerlink" href="#basic-customization" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py method">
<dt id="object.__new__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__new__</code><span class="sig-paren">(</span><em class="sig-param">cls</em><span class="optional">[</span>, <em class="sig-param">...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__new__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p id="index-68">Es llamado para crear una nueva instancia de clase <em>cls</em>. <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> es un método estático (como un caso especial, así que no se necesita declarar como tal) que toma la clase de donde fue solicitada una instancia como su primer argumento. Los argumentos restantes son aquellos que se pasan a la expresión del constructor de objetos (para llamar a la clase). El valor retornado de <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> deberá ser la nueva instancia de objeto (normalmente una instancia de <em>cls</em>).</p>
<p>Typical implementations create a new instance of the class by invoking the
superclass’s <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> method using <code class="docutils literal notranslate"><span class="pre">super().__new__(cls[,</span> <span class="pre">...])</span></code>
with appropriate arguments and then modifying the newly created instance
as necessary before returning it.</p>
<p>Si <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> es invocado durante la construcción del objeto y éste retorna una instancia de <em>cls</em>, entonces el nuevo método <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> de la instancia será invocado como <code class="docutils literal notranslate"><span class="pre">__init__(self[,</span> <span class="pre">…])</span></code>, donde <em>self</em> es la nueva instancia y los argumentos restantes son iguales a como fueron pasados hacia el constructor de objetos.</p>
<p>Si <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> no retorna una instancia de <em>cls</em>, entonces el nuevo método <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> de la instancia no será invocado.</p>
<p><a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> es destinado principalmente para permitir a subclases de tipos inmutables (como int, str, o tuple) personalizar la creación de instancias. También es comúnmente anulado en metaclases personalizadas con el fin de personalizar la creación de clase.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__init__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="optional">[</span>, <em class="sig-param">...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__init__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p id="index-69">Llamado después de que la instancia ha sido creada (por <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a>), pero antes es retornada a quien produce la llamada. Los argumentos son aquellos pasados a la expresión del constructor de la clase. Si una clase base tiene un método <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>, el método <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> de clase derivada, de existir, debe llamarlo explícitamente para asegurar la inicialización apropiada de la clase base que es parte de la instancia; por ejemplo: <code class="docutils literal notranslate"><span class="pre">super().__init__([args…])</span></code>.</p>
<p>Debido a que <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> y <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> trabajan juntos construyendo objetos (<a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> para crearlo y <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> para personalizarlo), ningún valor distinto a <code class="docutils literal notranslate"><span class="pre">None</span></code> puede ser retornado por <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>; hacer esto puede causar que se lance una excepción <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> en tiempo de ejecución.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__del__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__del__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__del__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p id="index-70">Llamado cuando la instancia es a punto de ser destruida. Esto también es llamado finalizador o (indebidamente) destructor. Si una clase base tiene un método <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> el método <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> de la clase derivada, de existir, debe llamarlo explícitamente para asegurar la eliminación adecuada de la parte de la clase base de la instancia.</p>
<p>Es posible (¡aunque no recomendable!) para el método <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> posponer la destrucción de la instancia al crear una nueva referencia hacia ésta. Esto es llamado <em>resurrección</em> de objeto. Es dependiente de la implementación si <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> es llamado una segunda vez cuando un objeto resucitado está por ser destruido; la implementación <a class="reference internal" href="../glossary.html#term-CPython"><span class="xref std std-term">CPython</span></a> actual únicamente lo llama una vez.</p>
<p>No está garantizado que los métodos <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> sean llamados para objetos que aún existen cuando el intérprete se cierra.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x</span></code> no llama directamente <code class="docutils literal notranslate"><span class="pre">x.__del__()</span></code> — el primero disminuye el conteo de referencia para <code class="docutils literal notranslate"><span class="pre">x</span></code> uno por uno, y el segundo es llamado únicamente cuando el conteo de referencias de <code class="docutils literal notranslate"><span class="pre">x</span></code> llega a cero.</p>
</div>
<div class="impl-detail compound">
<p class="compound-first"><strong>Detalles de implementación de CPython:</strong> It is possible for a reference cycle to prevent the reference count
of an object from going to zero.  In this case, the cycle will be
later detected and deleted by the <a class="reference internal" href="../glossary.html#term-garbage-collection"><span class="xref std std-term">cyclic garbage collector</span></a>.  A common cause of reference cycles is when
an exception has been caught in a local variable.  The frame’s
locals then reference the exception, which references its own
traceback, which references the locals of all frames caught in the
traceback.</p>
<div class="compound-last admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Documentación para el módulo <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a>.</p>
</div>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Debido a las circunstancias inciertas bajo las que los métodos <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> son invocados, las excepciones que ocurren durante su ejecución son ignoradas, y una advertencia es mostrada hacia <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>. En particular:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> puede ser invocado cuando código arbitrario es ejecutado, incluyendo el de cualquier hilo arbitrario. Si <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> necesita realizar un cierre de exclusión mutua (<em>lock</em>) o invocar cualquier otro recurso que lo esté bloqueando, podría provocar un bloqueo muto (<em>deadlock</em>) ya que el recurso podría estar siendo utilizado por el código que se interrumpe al ejecutar <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a>.</p></li>
<li><p><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> puede ser ejecutado durante el cierre del intérprete. Como consecuencia, las variables globales que necesita para acceder (incluyendo otros módulos) podrían haber sido borradas o establecidas a <code class="docutils literal notranslate"><span class="pre">None</span></code>. Python garantiza que los globales cuyo nombre comienza con un guión bajo simple sean borrados de su módulo antes que los globales sean borrados; si no existen otras referencias a dichas globales, esto puede ayudar asegurando que los módulos importados aún se encuentren disponibles al momento de llamar al método <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a>.</p></li>
</ul>
</div>
<span class="target" id="index-71"></span></dd></dl>

<dl class="py method">
<dt id="object.__repr__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__repr__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__repr__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llamado por la función incorporada <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> para calcular la cadena “oficial” de representación de un objeto. Si es posible, esto debería verse como una expresión de Python válida que puede ser utilizada para recrear un objeto con el mismo valor (bajo el ambiente adecuado). Si no es posible, una cadena con la forma <code class="docutils literal notranslate"><span class="pre">&lt;…some</span> <span class="pre">useful</span> <span class="pre">description…&gt;</span></code> debe ser retornada. El valor de retorno debe ser un objeto de cadena (<em>string</em>). Si una clase define <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> pero no <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a>, entonces <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> también es utilizado cuando una cadena “informal” de representación de instancias de esas clases son requeridas.</p>
<p>Esto es típicamente utilizado para depurar, así que es importante que la representación sea rica en información e inequívoca.</p>
<span class="target" id="index-72"></span></dd></dl>

<dl class="py method">
<dt id="object.__str__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__str__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__str__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llamado por <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str(object)</span></code></a> y las funciones incorporadas <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> y <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> para calcular la “informal” o bien mostrada cadena de representación de un objeto. El valor de retorno debe ser un objeto <a class="reference internal" href="../library/stdtypes.html#textseq"><span class="std std-ref">string</span></a>.</p>
<p>Este método difiere de <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__repr__()</span></code></a> en que no hay expectativas de que <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a> retorne una expresión de Python válida: una representación más conveniente o concisa pueda ser utilizada.</p>
<p>La implementación por defecto definida por el tipo incorporado <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> llama a <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__repr__()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__bytes__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__bytes__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__bytes__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p id="index-73">Llamado por <a class="reference internal" href="../library/functions.html#func-bytes"><span class="std std-ref">bytes</span></a> para calcular la representación de la cadena de byte de un objeto. Este deberá retornar un objeto <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
<span class="target" id="index-74"></span></dd></dl>

<dl class="py method">
<dt id="object.__format__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__format__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">format_spec</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__format__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llamado por la función incorporada <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a>, y por extensión, la evaluación de <a class="reference internal" href="lexical_analysis.html#f-strings"><span class="std std-ref">formatted string literals</span></a> y el método <a class="reference internal" href="../library/stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a>, para producir la representación “formateada” de un objeto. El argumento <em>format_spec</em> es una cadena que contiene una descripción de las opciones de formato deseadas. La interpretación del argumento <em>format_spec</em> depende del tipo que implementa <a class="reference internal" href="#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__format__()</span></code></a>, sin embargo, ya sea que la mayoría de las clases deleguen el formato a uno de los tipos incorporados, o utilicen una sintaxis de opción de formato similar.</p>
<p>Ver <a class="reference internal" href="../library/string.html#formatspec"><span class="std std-ref">Especificación de formato Mini-Lenguaje</span></a> para una descripción de la sintaxis de formato estándar.</p>
<p>El valor de retorno debe ser un objeto de cadena.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>El método __format__ del mismo <code class="docutils literal notranslate"><span class="pre">object</span></code> lanza un <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> si se la pasa una cadena no vacía.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span><code class="docutils literal notranslate"><span class="pre">object.__format__(x,</span> <span class="pre">‘’)</span></code> es ahora equivalente a <code class="docutils literal notranslate"><span class="pre">str(x)</span></code> en lugar de <code class="docutils literal notranslate"><span class="pre">format(str(self),</span> <span class="pre">‘’)</span></code>.</p>
</div>
</dd></dl>

<span class="target" id="richcmpfuncs"></span><dl class="py method">
<dt id="object.__lt__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__lt__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__lt__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__le__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__le__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__le__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__eq__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__eq__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__eq__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__ne__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ne__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ne__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__gt__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__gt__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__gt__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__ge__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ge__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ge__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p id="index-75">Estos son los llamados métodos de comparación <em>rich</em>. La correspondencia entre símbolos de operador y los nombres de método es de la siguiente manera: <code class="docutils literal notranslate"><span class="pre">x&lt;y</span></code> llama <code class="docutils literal notranslate"><span class="pre">x.__lt__(y)</span></code>, <code class="docutils literal notranslate"><span class="pre">x&lt;=y</span></code> llama <code class="docutils literal notranslate"><span class="pre">x.__le__(y)</span></code>, <code class="docutils literal notranslate"><span class="pre">x==y</span></code> llama <code class="docutils literal notranslate"><span class="pre">x.__eq__(y)</span></code>, <code class="docutils literal notranslate"><span class="pre">x!=y</span></code> llama <code class="docutils literal notranslate"><span class="pre">x.__ne__(y)</span></code>, <code class="docutils literal notranslate"><span class="pre">x&gt;y</span></code> llama <code class="docutils literal notranslate"><span class="pre">x.__gt__(y)</span></code>, y <code class="docutils literal notranslate"><span class="pre">x&gt;=y</span></code> llama <code class="docutils literal notranslate"><span class="pre">x.__ge__(y)</span></code>.</p>
<p>Un método de comparación <em>rich</em> puede retornar el único <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> si no implementa la operación para un par de argumentos dados. Por convención, <code class="docutils literal notranslate"><span class="pre">False</span></code> y <code class="docutils literal notranslate"><span class="pre">True</span></code> son retornados para una comparación exitosa. Sin embargo, estos métodos pueden retornar cualquier valor, así que si el operador de comparación es utilizado en un contexto Booleano (p. ej. en la condición de una sentencia <code class="docutils literal notranslate"><span class="pre">if</span></code>), Python llamará <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a> en dicho valor para determinar si el resultado es verdadero (<em>true</em>) o falso (<em>false</em>).</p>
<p>Por defecto, <code class="docutils literal notranslate"><span class="pre">object</span></code> implementa <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> usando <code class="docutils literal notranslate"><span class="pre">is</span></code>, retornando <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> en el caso de una comparación falsa: <code class="docutils literal notranslate"><span class="pre">True</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span> <span class="pre">else</span> <span class="pre">NotImplemented</span></code>. Para <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a>, por defecto delega a <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> e invierte el resultado a menos que sea <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code>. No hay otras relaciones implícitas entre los operadores de comparación o implementaciones predeterminadas; por ejemplo, la verdad de <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">&lt;y</span> <span class="pre">o</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">y)</span></code> no implica <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span></code>. Para generar automáticamente operaciones de pedido a partir de una sola operación raíz, consulte <a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.total_ordering()</span></code></a>.</p>
<p>Ver el párrafo sobre <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> para más notas importantes sobre la creación de objetos <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> que soportan operaciones de comparación personalizadas y son utilizables como llaves de diccionario.</p>
<p>No existen versiones con argumento intercambiado de estos métodos (a ser utilizados cuando el argumento de la izquierda no soporta la operación pero el de la derecha sí); más bien, <a class="reference internal" href="#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a> y <a class="reference internal" href="#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a> son el reflejo del otro, <a class="reference internal" href="#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a> y <a class="reference internal" href="#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code></a> son un reflejo del otro, y <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> y <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a> son su propio reflejo. Si los operandos son de tipos distintos, y el tipo de operando de la derecha es una clase directa o indirecta del tipo de operando de la izquierda, el método reflejado del operando de la derecha tiene prioridad, de otro modo el método del operando de la izquierda tiene prioridad. Subclases virtuales no son consideradas.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__hash__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__hash__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__hash__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p id="index-76">Called by built-in function <a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> and for operations on members of
hashed collections including <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>, and
<a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>.  The <code class="docutils literal notranslate"><span class="pre">__hash__()</span></code> method should return an integer. The only required
property is that objects which compare equal have the same hash value; it is
advised to mix together the hash values of the components of the object that
also play a part in comparison of objects by packing them into a tuple and
hashing the tuple. Example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nick</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> trunca el valor retornado del método personalizado <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> del objeto al tamaño de <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>. Esto normalmente son 8 bytes en estructuras de 64-bits y 4 bytes en estructuras de 32 bits. Si el <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> de un objeto debe interoperar en estructuras de tamaños de bits diferentes, asegúrese de revisar la amplitud en todas las estructuras soportadas. Una forma fácil de hacer esto es con <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-c</span> <span class="pre">“import</span> <span class="pre">sys;</span> <span class="pre">print(sys.hash_info.width)”</span></code>.</p>
</div>
<p>If a class does not define an <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> method it should not define a
<a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> operation either; if it defines <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> but not
<a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>, its instances will not be usable as items in hashable
collections.  If a class defines mutable objects and implements an
<a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> method, it should not implement <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>, since the
implementation of <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> collections requires that a key’s hash value is
immutable (if the object’s hash value changes, it will be in the wrong hash
bucket).</p>
<p>Clases definidas por usuario tienen los métodos <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> y <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> por defecto; con ellos, todos los objetos se comparan de manera desigual (excepto con ellos mismos) y <code class="docutils literal notranslate"><span class="pre">x.__hash__()</span></code> retorna un valor apropiado tal que <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> implique que <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">es</span> <span class="pre">y</span></code> y <code class="docutils literal notranslate"><span class="pre">hash(x)</span> <span class="pre">==</span> <span class="pre">hash(y)</span></code>.</p>
<p>Una clase que anula <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> y no define <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> tendrá implícito su <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> establecido a <code class="docutils literal notranslate"><span class="pre">None</span></code>. Cuando el método <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> de una clase es <code class="docutils literal notranslate"><span class="pre">None</span></code>, instancias de la clase lanzarán un <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> cuando el programa intente obtener el valor del hash, y también será correctamente identificado como de hash no calculable cuando se verifique <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">collections.abc.Hashable)</span></code>.</p>
<p>Si una clase que anula <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> necesita conservar la implementación de <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> de una clase padre, al intérprete se le debe informar explícitamente estableciendo <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">&lt;ParentClass&gt;.__hash__</span></code>.</p>
<p>Si una clase que no anula <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> desea eliminar el soporte de <em>hash</em>, debe incluir <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> en la definición de clase. Una clase que define su propio <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> y que explícitamente lanza un <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> será identificado de manera incorrecta como de hash calculable por una llamada <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">collections.abc.Hashable)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Por defecto los valores de objetos str y bytes de <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> son “salados” con un valor aleatorio impredecible. Aunque se mantienen constantes dentro de un proceso Python particular, no son predecibles entre invocaciones repetidas de Python.</p>
<p>This is intended to provide protection against a denial-of-service caused
by carefully chosen inputs that exploit the worst case performance of a
dict insertion, O(n<sup>2</sup>) complexity.  See
<a class="reference external" href="http://www.ocert.org/advisories/ocert-2011-003.html">http://www.ocert.org/advisories/ocert-2011-003.html</a> for details.</p>
<p>Cambiar los valores hash afectan el orden de la iteración de los sets. Python nunca ha dado garantías en relación a este orden (y típicamente varía entre estructuras de 32-bits y 64-bits).</p>
<p>Ver también <span class="target" id="index-117"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHASHSEED"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHASHSEED</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>La aleatorización de hash es habilitada por defecto.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="object.__bool__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__bool__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__bool__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p id="index-78">Es llamado para implementar pruebas de valores de verdad y la operación incorporada <code class="docutils literal notranslate"><span class="pre">bool()</span></code>; debe retornar <code class="docutils literal notranslate"><span class="pre">False</span></code> o <code class="docutils literal notranslate"><span class="pre">True</span></code>. Cuando este método no es definido, <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> es llamado, si es definido, y el objeto es considerado verdadero (<em>true</em>) si el resultado es diferente de zero. Si la clase no define <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> ni <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a>, todas sus instancias son consideradas verdaderas (<em>true</em>).</p>
</dd></dl>

</section>
<section id="customizing-attribute-access">
<span id="attribute-access"></span><h3><span class="section-number">3.3.2. </span>Personalizando acceso a atributos<a class="headerlink" href="#customizing-attribute-access" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Los siguientes métodos pueden ser definidos para personalizar el significado de acceso a atributos (uso de, asignación a, o borrado de <code class="docutils literal notranslate"><span class="pre">x.name</span></code>) para instancias de clase.</p>
<dl class="py method">
<dt id="object.__getattr__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__getattr__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getattr__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Es llamado cuando el acceso a atributos por defecto falla con un <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> (ya sea que <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> lanza una excepción <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> porque <em>name</em> no es un atributo de instancia o un atributo en el árbol de clase para <code class="docutils literal notranslate"><span class="pre">self</span></code>; o el <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> de la propiedad de <em>name</em> lanza una excepción <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>). Este método debe retornar el valor de atributo (calculado) o lanzar una excepción <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>.</p>
<p>Tome en cuenta que si el atributo es encontrado a través del mecanismo normal, <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> no es llamado. (Esto es una desigualdad intencional entre <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> y <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a>.) Esto es realizado tanto por motivos de eficiencia y porque de otra manera <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> no tendría manera de acceder a otros atributos de la instancia. Tome en cuenta que al menos para variables de instancia, se puede fingir control total al no insertar ningún valor en el diccionario de atributo de instancia (sino insertándolos en otro objeto). Ver el método <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> a continuación para una forma de tener control total sobre el acceso de atributo.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__getattribute__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__getattribute__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getattribute__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Es llamado incondicionalmente para implementar acceso de atributo por instancias de clase. Si la clase también define <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a>, éste no será llamado a menos que <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> lo llame de manera explícita o lance una excepción <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Este método deberá retornar el valor de atributo (calculado) o lanzar una excepción <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Para evitar la recursividad infinita en este método, su implementación deberá siempre llamar al método de la clase base con el mismo nombre para acceder cualquier atributo que necesite, por ejemplo, <code class="docutils literal notranslate"><span class="pre">object.__getattribute__(self,</span> <span class="pre">name)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Este método aún puede ser sobrepasado cuando se buscan métodos especiales como resultado de una invocación implícita a través de sintaxis de lenguaje o funciones implícitas. Ver <a class="reference internal" href="#special-lookup"><span class="std std-ref">Búsqueda de método especial</span></a>.</p>
</div>
<p class="audit-hook">Lanza un <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">evento de auditoría</span></a> <code class="docutils literal notranslate"><span class="pre">object.__getattr__</span></code> con argumentos <code class="docutils literal notranslate"><span class="pre">obj</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__setattr__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__setattr__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setattr__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Es llamado cuando se intenta la asignación de atributos. Éste es llamado en lugar del mecanismo normal (p. ej. guardar el valor en el diccionario de instancias). <em>name</em> es el nombre de atributo, <em>value</em> es el valor que se le asigna.</p>
<p>Si <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> quiere asignar a un atributo de instancia, debe llamar al método de la clase base con el mismo nombre, por ejemplo, <code class="docutils literal notranslate"><span class="pre">object.__setattr__(self,</span> <span class="pre">name,</span> <span class="pre">value)</span></code>.</p>
<p class="audit-hook">Lanza un <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">evento de auditoría</span></a> <code class="docutils literal notranslate"><span class="pre">object.__setattr__</span></code> con argumentos <code class="docutils literal notranslate"><span class="pre">obj</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__delattr__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__delattr__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delattr__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Al igual que <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> pero para borrado de atributos en lugar de establecerlos. Esto solo de ser implementado si <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">obj.name</span></code> es significativo para el objeto.</p>
<p class="audit-hook">Lanza un <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">evento de auditoría</span></a> <code class="docutils literal notranslate"><span class="pre">object.__delattr__</span></code> con argumentos <code class="docutils literal notranslate"><span class="pre">obj</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__dir__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__dir__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__dir__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Es llamado cuando <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> es llamado en el objeto. Una secuencia debe ser retornada. <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> convierte la secuencia retornada a una lista y la ordena.</p>
</dd></dl>

<section id="customizing-module-attribute-access">
<h4><span class="section-number">3.3.2.1. </span>Personalizando acceso a atributos de módulo<a class="headerlink" href="#customizing-module-attribute-access" title="Enlazar permanentemente con este título">¶</a></h4>
<p id="index-79">Nombres especiales <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> y <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> también pueden ser utilizados para personalizar acceso a atributos de módulo. La función <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> a nivel del módulo debe aceptar un argumento que es el nombre del atributo y retornar el valor calculado o lanzar una excepción <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Si un atributo no es encontrado en el objeto de módulo a través de una búsqueda normal, p. ej. <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__getattribute__()</span></code></a>, entonces <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> es buscado en el módulo <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> antes de lanzar una excepción <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Si es encontrado, es llamado con el nombre de atributo y el resultado es retornado.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> debe no aceptar argumentos y retornar una secuencia de cadena de caracteres que representan los nombres accesibles en el módulo. De existir, esta función anula la búsqueda estándar <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> en un módulo.</p>
<p>Para una personalización más precisa sobre el comportamiento del módulo (estableciendo atributos, propiedades, etc.), se puede establecer el atributo <code class="docutils literal notranslate"><span class="pre">__class__</span></code> de un objeto de módulo a una subclase de <a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a>. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">ModuleType</span>

<span class="k">class</span> <span class="nc">VerboseModule</span><span class="p">(</span><span class="n">ModuleType</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Verbose </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Setting </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s1">...&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">VerboseModule</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Definiendo un módulo <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> y estableciendo un módulo <code class="docutils literal notranslate"><span class="pre">__class__</span></code> solo afecta búsquedas que utilizan la sintaxis de acceso a atributo – acceder directamente a las globales del módulo (ya sea por código dentro del módulo, o a través de una referencia al diccionario de globales del módulo) no se ve afectado.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>El atributo de módulo <code class="docutils literal notranslate"><span class="pre">__class__</span></code> es ahora escribible.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7: </span>Atributos de módulo <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> y <code class="docutils literal notranslate"><span class="pre">__dir__</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-118"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0562"><strong>PEP 562</strong></a> - Módulos __getattr__ y __dir__</dt><dd><p>Describe las funciones <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> y <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> en módulos.</p>
</dd>
</dl>
</div>
</section>
<section id="implementing-descriptors">
<span id="descriptors"></span><h4><span class="section-number">3.3.2.2. </span>Implementando Descriptores<a class="headerlink" href="#implementing-descriptors" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Los siguientes métodos solo aplican cuando una instancia de clase que contiene el método (llamado clase <em>descriptora</em>) aparece en una clase <em>propietaria</em> (el descriptor debe estar en el diccionario de clase del propietario o en el diccionario de clase de alguno de sus padres). En los ejemplos a continuación, “el atributo” se refiere al atributo cuyo nombre es la llave de la propiedad en la clase propietaria <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>.</p>
<dl class="py method">
<dt id="object.__get__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__get__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">instance</span></em>, <em class="sig-param"><span class="n">owner</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__get__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Es llamado para obtener el atributo de la clase propietaria (acceso a atributos de clase) o de una instancia de dicha clase (acceso a atributos de instancia). El argumento opcional <em>owner</em> es la clase propietaria, mientras que <em>instance</em> es la instancia a través de la cual el atributo fue accedido, o <code class="docutils literal notranslate"><span class="pre">None</span></code> cuando el atributo es accedido a través de <em>owner</em>.</p>
<p>Este método debe retornar el valor de atributo calculado o lanzar una excepción <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>.</p>
<p><span class="target" id="index-119"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0252"><strong>PEP 252</strong></a> especifica que <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> puede ser llamado con uno o dos argumentos. Los propios descriptores incorporados de Python soportan esta especificación; sin embargo, es probable que algunas herramientas de terceros tengan descriptores que requieran ambos argumentos. La propia implementación de <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> en Python siempre pasa ambos argumentos si son requeridos o no.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__set__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__set__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">instance</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__set__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Es llamado para establecer el atributo en una instancia <em>instance</em> de la clase propietaria a un nuevo valor <em>value</em>.</p>
<p>Nota, agregar <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> o <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a> cambia el tipo de descriptor a un “descriptor de datos”. Ver <a class="reference internal" href="#descriptor-invocation"><span class="std std-ref">Invocando Descriptores</span></a> para más detalles.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__delete__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__delete__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">instance</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delete__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Es llamado para borrar el atributo en una instancia <em>instance</em> de la clase propietaria.</p>
</dd></dl>

<p>El atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__objclass__</span></code> es interpretado por el módulo <a class="reference internal" href="../library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> como la especificación de la clase donde el objeto fue definido (establecer esto adecuadamente puede ayudar en introspección de atributos dinámicos de clases en tiempo de ejecución). Para invocables, puede indicar que una instancia de un tipo (o subclase) dado es esperado o requerido como el primero argumento posicional (por ejemplo, CPython establece este atributo para métodos independientes que son implementados en C).</p>
</section>
<section id="invoking-descriptors">
<span id="descriptor-invocation"></span><h4><span class="section-number">3.3.2.3. </span>Invocando Descriptores<a class="headerlink" href="#invoking-descriptors" title="Enlazar permanentemente con este título">¶</a></h4>
<p>In general, a descriptor is an object attribute with «binding behavior», one
whose attribute access has been overridden by methods in the descriptor
protocol:  <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>, <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a>, and
<a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>. If any of
those methods are defined for an object, it is said to be a descriptor.</p>
<p>El comportamiento por defecto para atributos de acceso es obtener (<em>get</em>), establecer (<em>set</em>) o borrar (<em>delete</em>) el atributo del diccionario del objeto. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">a.x</span></code> tiene una cadena de búsqueda que comienza con <code class="docutils literal notranslate"><span class="pre">a.__dict__[‘x’]</span></code>, luego <code class="docutils literal notranslate"><span class="pre">type(a).__dict__[‘x’]</span></code>, y continúa por las clases base de <code class="docutils literal notranslate"><span class="pre">type(a)</span></code> excluyendo metaclases.</p>
<p>Sin embargo, si el valor buscado es un objeto definiendo uno de los métodos del descriptor, entonces Python puede anular el comportamiento por defecto e invocar al método del descriptor en su lugar. Dónde ocurre esto en la cadena de precedencia depende de qué métodos de descriptor fueron definidos y cómo son llamados.</p>
<p>El punto de inicio por invocación de descriptor es un enlace <code class="docutils literal notranslate"><span class="pre">a.x</span></code>. Cómo los argumentos son ensamblados dependen de <code class="docutils literal notranslate"><span class="pre">a</span></code>:</p>
<dl class="simple">
<dt>Llamado Directo</dt><dd><p>El llamado más simple y menos común es cuando el código de usuario invoca directamente un método descriptor: <code class="docutils literal notranslate"><span class="pre">x.__get__(a)</span></code>.</p>
</dd>
<dt>Enlace de Instancia</dt><dd><p>Al enlazar a una instancia de objeto, <code class="docutils literal notranslate"><span class="pre">a</span></code> es transformado en un llamado: <code class="docutils literal notranslate"><span class="pre">type(a).__dict__[‘x’].__get__(a,</span> <span class="pre">type(a))</span></code>.</p>
</dd>
<dt>Enlace de Clase</dt><dd><p>Al enlazar a una clase, <code class="docutils literal notranslate"><span class="pre">A.x</span></code> es transformado en un llamado: <code class="docutils literal notranslate"><span class="pre">A.__dict__[‘x’].__get__(None,</span> <span class="pre">A)</span></code>.</p>
</dd>
<dt>Súper Enlace</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">a</span></code> is an instance of <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-class docutils literal notranslate"><span class="pre">super</span></code></a>, then the binding <code class="docutils literal notranslate"><span class="pre">super(B,</span> <span class="pre">obj).m()</span></code>
searches <code class="docutils literal notranslate"><span class="pre">obj.__class__.__mro__</span></code> for the base class <code class="docutils literal notranslate"><span class="pre">A</span></code>
immediately following <code class="docutils literal notranslate"><span class="pre">B</span></code> and then invokes the descriptor with the call:
<code class="docutils literal notranslate"><span class="pre">A.__dict__['m'].__get__(obj,</span> <span class="pre">obj.__class__)</span></code>.</p>
</dd>
</dl>
<p>For instance bindings, the precedence of descriptor invocation depends on
which descriptor methods are defined.  A descriptor can define any combination
of <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>, <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> and
<a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>.  If it does not
define <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code>, then accessing the attribute will return the descriptor
object itself unless there is a value in the object’s instance dictionary.  If
the descriptor defines <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code> and/or <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code>, it is a data
descriptor; if it defines neither, it is a non-data descriptor.  Normally, data
descriptors define both <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code>, while non-data
descriptors have just the <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> method.  Data descriptors with
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code> (and/or <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code>) defined always override a redefinition in an
instance dictionary.  In contrast, non-data descriptors can be overridden by
instances.</p>
<p>Python methods (including those decorated with
<a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;staticmethod</span></code></a> and <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;classmethod</span></code></a>) are
implemented as non-data descriptors.  Accordingly, instances can redefine and
override methods.  This allows individual instances to acquire behaviors that
differ from other instances of the same class.</p>
<p>La función <a class="reference internal" href="../library/functions.html#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a> es implementada como un descriptor de datos. Por lo tanto, las instancias no pueden anular el comportamiento de una propiedad.</p>
</section>
<section id="slots">
<span id="id3"></span><h4><span class="section-number">3.3.2.4. </span>__slots__<a class="headerlink" href="#slots" title="Enlazar permanentemente con este título">¶</a></h4>
<p><em>__slots__</em> allow us to explicitly declare data members (like
properties) and deny the creation of <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> and <em>__weakref__</em>
(unless explicitly declared in <em>__slots__</em> or available in a parent.)</p>
<p>The space saved over using <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> can be significant.
Attribute lookup speed can be significantly improved as well.</p>
<dl class="py data">
<dt id="object.__slots__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__slots__</code><a class="headerlink" href="#object.__slots__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>This class variable can be assigned a string, iterable, or sequence of
strings with variable names used by instances.  <em>__slots__</em> reserves space
for the declared variables and prevents the automatic creation of
<a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>
and <em>__weakref__</em> for each instance.</p>
</dd></dl>

<section id="notes-on-using-slots">
<span id="datamodel-note-slots"></span><h5><span class="section-number">3.3.2.4.1. </span>Notas sobre el uso de  <em>__slots__</em><a class="headerlink" href="#notes-on-using-slots" title="Enlazar permanentemente con este título">¶</a></h5>
<ul class="simple">
<li><p>When inheriting from a class without <em>__slots__</em>, the
<a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> and
<em>__weakref__</em> attribute of the instances will always be accessible.</p></li>
<li><p>Without a <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> variable, instances cannot be assigned new
variables not
listed in the <em>__slots__</em> definition.  Attempts to assign to an unlisted
variable name raises <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. If dynamic assignment of new
variables is desired, then add <code class="docutils literal notranslate"><span class="pre">'__dict__'</span></code> to the sequence of strings in
the <em>__slots__</em> declaration.</p></li>
<li><p>Without a <em>__weakref__</em> variable for each instance, classes defining
<em>__slots__</em> do not support <a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weak</span> <span class="pre">references</span></code></a> to its instances.
If weak reference
support is needed, then add <code class="docutils literal notranslate"><span class="pre">'__weakref__'</span></code> to the sequence of strings in the
<em>__slots__</em> declaration.</p></li>
<li><p><em>__slots__</em> are implemented at the class level by creating <a class="reference internal" href="#descriptors"><span class="std std-ref">descriptors</span></a>
for each variable name.  As a result, class attributes
cannot be used to set default values for instance variables defined by
<em>__slots__</em>; otherwise, the class attribute would overwrite the descriptor
assignment.</p></li>
<li><p>The action of a <em>__slots__</em> declaration is not limited to the class
where it is defined.  <em>__slots__</em> declared in parents are available in
child classes. However, child subclasses will get a <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> and
<em>__weakref__</em> unless they also define <em>__slots__</em> (which should only
contain names of any <em>additional</em> slots).</p></li>
<li><p>Si una clase define un espacio (<em>slot</em>) también definido en una clase base, la variable de instancia definida por el espacio de la clase base es inaccesible (excepto al obtener su descriptor directamente de la clase base). Esto hace que el significado del programa sea indefinido. En el futuro se podría agregar una verificación para prevenir esto.</p></li>
<li><p><a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> will be raised if nonempty <em>__slots__</em> are defined for a
class derived from a
<a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">&quot;variable-length&quot;</span> <span class="pre">built-in</span> <span class="pre">type</span></code></a> such as
<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, and <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>.</p></li>
<li><p>Any non-string <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> may be assigned to <em>__slots__</em>.</p></li>
<li><p>If a <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionary</span></code></a> is used to assign <em>__slots__</em>, the dictionary
keys will be used as the slot names. The values of the dictionary can be used
to provide per-attribute docstrings that will be recognised by
<a class="reference internal" href="../library/inspect.html#inspect.getdoc" title="inspect.getdoc"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getdoc()</span></code></a> and displayed in the output of <a class="reference internal" href="../library/functions.html#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a>.</p></li>
<li><p><a class="reference internal" href="../library/stdtypes.html#instance.__class__" title="instance.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> assignment works only if both classes have the
same <em>__slots__</em>.</p></li>
<li><p><a class="reference internal" href="../tutorial/classes.html#tut-multiple"><span class="std std-ref">Multiple inheritance</span></a> with multiple slotted parent
classes can be used,
but only one parent is allowed to have attributes created by slots
(the other bases must have empty slot layouts) - violations raise
<a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p></li>
<li><p>If an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> is used for <em>__slots__</em> then a <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a> is
created for each
of the iterator’s values. However, the <em>__slots__</em> attribute will be an empty
iterator.</p></li>
</ul>
</section>
</section>
</section>
<section id="customizing-class-creation">
<span id="class-customization"></span><h3><span class="section-number">3.3.3. </span>Personalización de creación de clases<a class="headerlink" href="#customizing-class-creation" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Whenever a class inherits from another class, <a class="reference internal" href="#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init_subclass__()</span></code></a> is
called on the parent class. This way, it is possible to write classes which
change the behavior of subclasses. This is closely related to class
decorators, but where class decorators only affect the specific class they’re
applied to, <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> solely applies to future subclasses of the
class defining the method.</p>
<dl class="py method">
<dt id="object.__init_subclass__">
<em class="property">classmethod </em><code class="sig-prename descclassname">object.</code><code class="sig-name descname">__init_subclass__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cls</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__init_subclass__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método es llamado siempre que la clase que lo contiene sea heredada. <em>cls</em> es entonces, la nueva subclase. Si se define como un método de instancia normal, éste es convertido de manera implícita a un método de clase.</p>
<p>Los argumentos de palabra clave que fueron dados a una nueva clase, son pasados a la clase <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> del padre. Por temas de compatibilidad con otras clases que usan <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code>, uno debería quitar los argumentos de palabra clave y pasar los otros a la clase base, como en:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Philosopher</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">default_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">default_name</span> <span class="o">=</span> <span class="n">default_name</span>

<span class="k">class</span> <span class="nc">AustralianPhilosopher</span><span class="p">(</span><span class="n">Philosopher</span><span class="p">,</span> <span class="n">default_name</span><span class="o">=</span><span class="s2">&quot;Bruce&quot;</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>La implementación por defecto <code class="docutils literal notranslate"><span class="pre">object.__init_subclass__</span></code> no hace nada, pero lanza un error si es llamado con cualquier argumento.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La sugerencia de metaclase <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> es consumido por el resto de la maquinaria de tipos, y nunca se pasa a las implementaciones <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code>. La clase meta actual (más que la sugerencia explícita) puede ser accedida como <code class="docutils literal notranslate"><span class="pre">type(cls)</span></code>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.</span></p>
</div>
</dd></dl>

<p>When a class is created, <code class="xref py py-meth docutils literal notranslate"><span class="pre">type.__new__()</span></code> scans the class variables
and makes callbacks to those with a <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> hook.</p>
<dl class="py method">
<dt id="object.__set_name__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__set_name__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">owner</span></em>, <em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__set_name__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llamado automáticamente al momento en el que se crea la clase propietaria <em>owner</em>. El objeto es asignado a <em>name</em> en esa clase:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>  <span class="c1"># Automatically calls: x.__set_name__(A, &#39;x&#39;)</span>
</pre></div>
</div>
<p>Si la variable de clase se asigna después de crear la clase, <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> no se llamará automáticamente. Si es necesario, <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> se puede llamar directamente:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
   <span class="k">pass</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="n">A</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">c</span>                  <span class="c1"># The hook is not called</span>
<span class="n">c</span><span class="o">.</span><span class="n">__set_name__</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>   <span class="c1"># Manually invoke the hook</span>
</pre></div>
</div>
<p>Ver <a class="reference internal" href="#class-object-creation"><span class="std std-ref">Creando el objeto de clase</span></a> para más detalles.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.</span></p>
</div>
</dd></dl>

<section id="metaclasses">
<span id="id4"></span><h4><span class="section-number">3.3.3.1. </span>Metaclases<a class="headerlink" href="#metaclasses" title="Enlazar permanentemente con este título">¶</a></h4>
<p id="index-82">Por defecto, las clases son construidas usando <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a>. El cuerpo de la clase es ejecutado en un nuevo espacio de nombres y el nombre de la clase es ligado de forma local al resultado de <code class="docutils literal notranslate"><span class="pre">type(name,</span> <span class="pre">bases,</span> <span class="pre">namespace)</span></code>.</p>
<p>El proceso de creación de clase puede ser personalizado pasando el argumento de palabra clave <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> en la línea de definición de la clase, o al heredar de una clase existente que incluya dicho argumento. En el siguiente ejemplo, ambos <code class="docutils literal notranslate"><span class="pre">MyClass</span></code> y <code class="docutils literal notranslate"><span class="pre">MySubclass</span></code> son instancias de <code class="docutils literal notranslate"><span class="pre">Meta</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MySubclass</span><span class="p">(</span><span class="n">MyClass</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Cualquier otro argumento de palabra clave que sea especificado en la definición de clase es pasado mediante todas las operaciones de metaclase descritas a continuación.</p>
<p>Cuando una definición de clase es ejecutada, los siguientes pasos ocurren:</p>
<ul class="simple">
<li><p>Entradas de la Orden de Resolución de Método (MRU) son resueltas;</p></li>
<li><p>se determina la metaclase adecuada;</p></li>
<li><p>se prepara el espacio de nombres de clase;</p></li>
<li><p>se ejecuta el cuerpo de la clase;</p></li>
<li><p>se crea el objeto de clase.</p></li>
</ul>
</section>
<section id="resolving-mro-entries">
<h4><span class="section-number">3.3.3.2. </span>Resolviendo entradas de la Orden de Resolución de Métodos (MRU)<a class="headerlink" href="#resolving-mro-entries" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Si una base que aparece en la definición de una clase no es una instancia de <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>, entonces el método <code class="docutils literal notranslate"><span class="pre">__mro_entries__</span></code> se busca en ella. Si es encontrado, se llama con la tupla de bases originales. Este método debe retornar una tupla de clases que será utilizado en lugar de esta base. La tupla puede estar vacía, en cuyo caso la base original es ignorada.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p><span class="target" id="index-120"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0560"><strong>PEP 560</strong></a> - Soporte central para módulos de clasificación y tipos genéricos</p>
</div>
</section>
<section id="determining-the-appropriate-metaclass">
<h4><span class="section-number">3.3.3.3. </span>Determinando la metaclase adecuada<a class="headerlink" href="#determining-the-appropriate-metaclass" title="Enlazar permanentemente con este título">¶</a></h4>
<p id="index-84">La metaclase adecuada para la definición de una clase es determinada de la siguiente manera:</p>
<ul class="simple">
<li><p>si no se dan bases ni metaclases explícitas, entonces se utiliza <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a>;</p></li>
<li><p>si se da una metaclase explícita y <em>no</em> es una instancia de <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a>, entonces se utiliza directamente como la metaclase;</p></li>
<li><p>si se da una instancia de <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> como la metaclase explícita, o se definen bases, entonces se utiliza la metaclase más derivada.</p></li>
</ul>
<p>La metaclase más derivada es elegida de la metaclase especificada explícitamente (si existe) y de la metaclase (p. ej. <code class="docutils literal notranslate"><span class="pre">type(cls)</span></code>) de todas las clases base especificadas.</p>
</section>
<section id="preparing-the-class-namespace">
<span id="prepare"></span><h4><span class="section-number">3.3.3.4. </span>Preparando el espacio de nombres de la clase<a class="headerlink" href="#preparing-the-class-namespace" title="Enlazar permanentemente con este título">¶</a></h4>
<p id="index-85">Once the appropriate metaclass has been identified, then the class namespace
is prepared. If the metaclass has a <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> attribute, it is called
as <code class="docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">=</span> <span class="pre">metaclass.__prepare__(name,</span> <span class="pre">bases,</span> <span class="pre">**kwds)</span></code> (where the
additional keyword arguments, if any, come from the class definition). The
<code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> method should be implemented as a
<a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod</span></code></a>. The
namespace returned by <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> is passed in to <code class="docutils literal notranslate"><span class="pre">__new__</span></code>, but when
the final class object is created the namespace is copied into a new <code class="docutils literal notranslate"><span class="pre">dict</span></code>.</p>
<p>Si la metaclase no tiene atributo <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code>, entonces el espacio de nombres de clase es iniciado como un mapeo vacío ordenado.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-121"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3115"><strong>PEP 3115</strong></a> - Metaclases en Python 3000</dt><dd><p>Introduce el enlace de espacio de nombres <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code></p>
</dd>
</dl>
</div>
</section>
<section id="executing-the-class-body">
<h4><span class="section-number">3.3.3.5. </span>Ejecutando el cuerpo de la clase<a class="headerlink" href="#executing-the-class-body" title="Enlazar permanentemente con este título">¶</a></h4>
<p id="index-87">El cuerpo de la clase es ejecutado como <code class="docutils literal notranslate"><span class="pre">exec(body,</span> <span class="pre">globals(),</span> <span class="pre">namespace)</span></code> (aproximadamente). La diferencia clave con un llamado normal a <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> es que el alcance léxico permite que el cuerpo de la clase (incluyendo cualquier método) haga referencia a nombres de los alcances actuales y externos cuando la definición de clase sucede dentro de la función.</p>
<p>Sin embargo, aún cuando la definición de clase sucede dentro de la función, los métodos definidos dentro de la clase aún no pueden ver nombres definidos dentro del alcance de la clase. Variables de clase deben ser accedidas a través del primer parámetro de instancia o métodos de clase, o a través de la referencia al léxico implícito <code class="docutils literal notranslate"><span class="pre">__class__</span></code> descrita en la siguiente sección.</p>
</section>
<section id="creating-the-class-object">
<span id="class-object-creation"></span><h4><span class="section-number">3.3.3.6. </span>Creando el objeto de clase<a class="headerlink" href="#creating-the-class-object" title="Enlazar permanentemente con este título">¶</a></h4>
<p id="index-88">Una vez que el espacio de nombres de la clase ha sido poblado al ejecutar el cuerpo de la clase, el objeto de clase es creado al llamar <code class="docutils literal notranslate"><span class="pre">metaclass(name,</span> <span class="pre">bases,</span> <span class="pre">namespace,</span> <span class="pre">**kwds)</span></code> (las palabras clave adicionales que se pasan aquí, son las mismas que aquellas pasadas en <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code>).</p>
<p>Este objeto de clase es el que será referenciado por la forma sin argumentos de <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a>. <code class="docutils literal notranslate"><span class="pre">__class__</span></code> es una referencia de cierre implícita creada por el compilador si cualquier método en el cuerpo de una clase se refiere tanto a <code class="docutils literal notranslate"><span class="pre">__class__</span></code> o <code class="docutils literal notranslate"><span class="pre">super</span></code>. Esto permite que la forma sin argumentos de <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> identifique correctamente la clase definida en base al alcance léxico, mientras la clase o instancia que fue utilizada para hacer el llamado actual es identificado en base al primer argumento que se pasa al método.</p>
<div class="impl-detail compound">
<p><strong>Detalles de implementación de CPython:</strong> En CPython 3.6 y posterior, la celda <code class="docutils literal notranslate"><span class="pre">__class__</span></code> se pasa a la metaclase como una entrada <code class="docutils literal notranslate"><span class="pre">__classcell__</span></code> en el espacio de nombres de la clase. En caso de existir, esto debe ser propagado hacia el llamado <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> para que la clase se inicie correctamente. No hacerlo resultará en un error <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> en Python 3.8.</p>
</div>
<p>Cuando se utiliza la metaclase por defecto <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>, o cualquier metaclase que finalmente llama a <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code>, los siguientes pasos de personalización adicional son invocados después de crear el objeto de clase:</p>
<ol class="arabic simple">
<li><p>El método <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> recolecta todos los atributos en el espacio de nombres de la clase que definen un método <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a>;</p></li>
<li><p>Esos métodos <code class="docutils literal notranslate"><span class="pre">__set_name__</span></code> son llamados con la clase siendo definida y el nombre de ese atributo particular asignado;</p></li>
<li><p>El gancho <a class="reference internal" href="#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init_subclass__()</span></code></a> llama al padre inmediato de la nueva clase en su orden de resolución del método.</p></li>
</ol>
<p>Después de que el objeto de clase es creado, se pasa al decorador de clase incluido en su definición (si existe) y el objeto resultante es enlazado en el espacio de nombres local como la clase definida.</p>
<p>Cuando una nueva clase es creada por <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code>, el objeto proporcionado como el parámetro de espacio de nombres es copiado a un trazado ordenado y el objeto original es descartado. La nueva copia es <em>envuelta</em> en un proxy de solo lectura, que se convierte en el atributo <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> del objeto de clase.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-122"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3135"><strong>PEP 3135</strong></a> - Nuevo súper</dt><dd><p>Describe la referencia de cierre implícita <code class="docutils literal notranslate"><span class="pre">__class__</span></code></p>
</dd>
</dl>
</div>
</section>
<section id="uses-for-metaclasses">
<h4><span class="section-number">3.3.3.7. </span>Usos para metaclases<a class="headerlink" href="#uses-for-metaclasses" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Los usos potenciales para metaclases son ilimitados. Algunas ideas que ya han sido exploradas incluyen enumeración, registros, revisión de interface, delegación automática, creación de propiedades automática, proxy, infraestructuras, y bloqueo/sincronización automática de recursos.</p>
</section>
</section>
<section id="customizing-instance-and-subclass-checks">
<h3><span class="section-number">3.3.4. </span>Personalizando revisiones de instancia y subclase<a class="headerlink" href="#customizing-instance-and-subclass-checks" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Los siguientes métodos son utilizados para anular el comportamiento por defecto de las funciones incorporadas <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> y <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>.</p>
<p>En particular, la metaclase <a class="reference internal" href="../library/abc.html#abc.ABCMeta" title="abc.ABCMeta"><code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABCMeta</span></code></a> implementa estos métodos para permitir la adición de Clases Base Abstractas (ABCs, por su nombre en inglés <em>Abstract Base Clases</em>) como “clases base virtuales” a cualquier clase o tipo (incluyendo tipos incorporados), incluyendo otros ABCs.</p>
<dl class="py method">
<dt id="class.__instancecheck__">
<code class="sig-prename descclassname">class.</code><code class="sig-name descname">__instancecheck__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">instance</span></em><span class="sig-paren">)</span><a class="headerlink" href="#class.__instancecheck__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <em>true</em> si la instancia <em>instance</em> debe ser considerada una instancia (directa o indirecta) de clase <em>class</em>. De ser definida, es llamado para implementar <code class="docutils literal notranslate"><span class="pre">isinstance(instance,</span> <span class="pre">class)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="class.__subclasscheck__">
<code class="sig-prename descclassname">class.</code><code class="sig-name descname">__subclasscheck__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">subclass</span></em><span class="sig-paren">)</span><a class="headerlink" href="#class.__subclasscheck__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <em>true</em> si la subclase <em>subclass</em> debe ser considerada una subclase (directa o indirecta) de clase <em>class</em>. De ser definida, es llamado para implementar <code class="docutils literal notranslate"><span class="pre">issubclass(subclass,</span> <span class="pre">class)</span></code>.</p>
</dd></dl>

<p>Tome en cuenta que estos métodos son buscados en el tipo (metaclase) de una clase. No pueden ser definidos como métodos de clase en la clase actual. Esto es consistente con la búsqueda de métodos especiales que son llamados en instancias, solo en este caso la instancia es por sí misma una clase.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-123"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3119"><strong>PEP 3119</strong></a> - Introducción a Clases Base Abstractas (<em>Abstract Base Classes</em>)</dt><dd><p>Incluye la especificación para personalizar el comportamiento de <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> y <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> a través de <a class="reference internal" href="#class.__instancecheck__" title="class.__instancecheck__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__instancecheck__()</span></code></a> y <a class="reference internal" href="#class.__subclasscheck__" title="class.__subclasscheck__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__subclasscheck__()</span></code></a>, con motivación para esta funcionalidad en el contexto de agregar Clases Base Abstractas (ver el módulo <a class="reference internal" href="../library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a>) al lenguaje.</p>
</dd>
</dl>
</div>
</section>
<section id="emulating-generic-types">
<h3><span class="section-number">3.3.5. </span>Emulando tipos genéricos<a class="headerlink" href="#emulating-generic-types" title="Enlazar permanentemente con este título">¶</a></h3>
<p>When using <a class="reference internal" href="../glossary.html#term-annotation"><span class="xref std std-term">type annotations</span></a>, it is often useful to
<em>parameterize</em> a <a class="reference internal" href="../glossary.html#term-generic-type"><span class="xref std std-term">generic type</span></a> using Python’s square-brackets notation.
For example, the annotation <code class="docutils literal notranslate"><span class="pre">list[int]</span></code> might be used to signify a
<a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> in which all the elements are of type <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-91"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> - Type Hints</dt><dd><p>Introducing Python’s framework for type annotations</p>
</dd>
<dt><a class="reference internal" href="../library/stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Types</span></a></dt><dd><p>Documentation for objects representing parameterized generic classes</p>
</dd>
<dt><a class="reference internal" href="../library/typing.html#generics"><span class="std std-ref">Genéricos</span></a>, <a class="reference internal" href="../library/typing.html#user-defined-generics"><span class="std std-ref">user-defined generics</span></a> and <a class="reference internal" href="../library/typing.html#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span></code></a></dt><dd><p>Documentation on how to implement generic classes that can be
parameterized at runtime and understood by static type-checkers.</p>
</dd>
</dl>
</div>
<p>A class can <em>generally</em> only be parameterized if it defines the special
class method <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code>.</p>
<dl class="py method">
<dt id="object.__class_getitem__">
<em class="property">classmethod </em><code class="sig-prename descclassname">object.</code><code class="sig-name descname">__class_getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cls</span></em>, <em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__class_getitem__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retornar un objeto representando la especialización de una clase genérica por argumentos de tipo encontrados en <em>key</em>.</p>
<p>When defined on a class, <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> is automatically a class
method. As such, there is no need for it to be decorated with
<a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;classmethod</span></code></a> when it is defined.</p>
</dd></dl>

<section id="the-purpose-of-class-getitem">
<h4><span class="section-number">3.3.5.1. </span>The purpose of <em>__class_getitem__</em><a class="headerlink" href="#the-purpose-of-class-getitem" title="Enlazar permanentemente con este título">¶</a></h4>
<p>The purpose of <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> is to allow runtime
parameterization of standard-library generic classes in order to more easily
apply <a class="reference internal" href="../glossary.html#term-type-hint"><span class="xref std std-term">type hints</span></a> to these classes.</p>
<p>To implement custom generic classes that can be parameterized at runtime and
understood by static type-checkers, users should either inherit from a standard
library class that already implements <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>, or
inherit from <a class="reference internal" href="../library/typing.html#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span></code></a>, which has its own implementation of
<code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code>.</p>
<p>Custom implementations of <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> on classes defined
outside of the standard library may not be understood by third-party
type-checkers such as mypy. Using <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> on any class for
purposes other than type hinting is discouraged.</p>
</section>
<section id="class-getitem-versus-getitem">
<span id="classgetitem-versus-getitem"></span><h4><span class="section-number">3.3.5.2. </span><em>__class_getitem__</em> versus <em>__getitem__</em><a class="headerlink" href="#class-getitem-versus-getitem" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Usually, the <a class="reference internal" href="expressions.html#subscriptions"><span class="std std-ref">subscription</span></a> of an object using square
brackets will call the <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> instance method defined on
the object’s class. However, if the object being subscribed is itself a class,
the class method <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> may be called instead.
<code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> should return a <a class="reference internal" href="../library/stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias</span></a>
object if it is properly defined.</p>
<p>Presented with the <a class="reference internal" href="../glossary.html#term-expression"><span class="xref std std-term">expression</span></a> <code class="docutils literal notranslate"><span class="pre">obj[x]</span></code>, the Python interpreter
follows something like the following process to decide whether
<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> or <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> should be
called:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">isclass</span>

<span class="k">def</span> <span class="nf">subscribe</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the result of the expression `obj[x]`&quot;&quot;&quot;</span>

    <span class="n">class_of_obj</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="c1"># If the class of obj defines __getitem__,</span>
    <span class="c1"># call class_of_obj.__getitem__(obj, x)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">class_of_obj</span><span class="p">,</span> <span class="s1">&#39;__getitem__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">class_of_obj</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># Else, if obj is a class and defines __class_getitem__,</span>
    <span class="c1"># call obj.__class_getitem__(x)</span>
    <span class="k">elif</span> <span class="n">isclass</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__class_getitem__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">__class_getitem__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Else, raise an exception</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">class_of_obj</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; object is not subscriptable&quot;</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>In Python, all classes are themselves instances of other classes. The class of
a class is known as that class’s <a class="reference internal" href="../glossary.html#term-metaclass"><span class="xref std std-term">metaclass</span></a>, and most classes have the
<a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> class as their metaclass. <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> does not define
<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, meaning that expressions such as <code class="docutils literal notranslate"><span class="pre">list[int]</span></code>,
<code class="docutils literal notranslate"><span class="pre">dict[str,</span> <span class="pre">float]</span></code> and <code class="docutils literal notranslate"><span class="pre">tuple[str,</span> <span class="pre">bytes]</span></code> all result in
<a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> being called:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># list has class &quot;type&quot; as its metaclass, like most classes:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="go">&lt;class &#39;type&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">tuple</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># &quot;list[int]&quot; calls &quot;list.__class_getitem__(int)&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
<span class="go">list[int]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># list.__class_getitem__ returns a GenericAlias object:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span>
<span class="go">&lt;class &#39;types.GenericAlias&#39;&gt;</span>
</pre></div>
</div>
<p>However, if a class has a custom metaclass that defines
<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, subscribing the class may result in different
behaviour. An example of this can be found in the <a class="reference internal" href="../library/enum.html#module-enum" title="enum: Implementation of an enumeration class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">enum</span></code></a> module:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Menu</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&quot;&quot;&quot;A breakfast menu&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="n">SPAM</span> <span class="o">=</span> <span class="s1">&#39;spam&#39;</span>
<span class="gp">... </span>    <span class="n">BACON</span> <span class="o">=</span> <span class="s1">&#39;bacon&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Enum classes have a custom metaclass:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">Menu</span><span class="p">)</span>
<span class="go">&lt;class &#39;enum.EnumMeta&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># EnumMeta defines __getitem__,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># so __class_getitem__ is not called,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># and the result is not a GenericAlias object:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Menu</span><span class="p">[</span><span class="s1">&#39;SPAM&#39;</span><span class="p">]</span>
<span class="go">&lt;Menu.SPAM: &#39;spam&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">Menu</span><span class="p">[</span><span class="s1">&#39;SPAM&#39;</span><span class="p">])</span>
<span class="go">&lt;enum &#39;Menu&#39;&gt;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-92"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0560"><strong>PEP 560</strong></a> - Core Support for typing module and generic types</dt><dd><p>Introducing <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>, and outlining when a
<a class="reference internal" href="expressions.html#subscriptions"><span class="std std-ref">subscription</span></a> results in <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code>
being called instead of <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a></p>
</dd>
</dl>
</div>
</section>
</section>
<section id="emulating-callable-objects">
<span id="callable-types"></span><h3><span class="section-number">3.3.6. </span>Emulando objetos que se pueden llamar<a class="headerlink" href="#emulating-callable-objects" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py method">
<dt id="object.__call__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="optional">[</span>, <em class="sig-param">args...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__call__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p id="index-93">Es llamado cuando la instancia es “llamada” como una función; si este método es definido, <code class="docutils literal notranslate"><span class="pre">x(arg1,</span> <span class="pre">arg2,</span> <span class="pre">…)</span></code> es una clave corta para <code class="docutils literal notranslate"><span class="pre">x.__call__(arg1,</span> <span class="pre">arg2,</span> <span class="pre">…)</span></code>.</p>
</dd></dl>

</section>
<section id="emulating-container-types">
<span id="sequence-types"></span><h3><span class="section-number">3.3.7. </span>Emulando tipos de contenedores<a class="headerlink" href="#emulating-container-types" title="Enlazar permanentemente con este título">¶</a></h3>
<p>The following methods can be defined to implement container objects.  Containers
usually are <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequences</span></a> (such as <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">lists</span></code></a> or
<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuples</span></code></a>) or <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mappings</span></a> (like
<a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionaries</span></code></a>),
but can represent other containers as well.  The first set of methods is used
either to emulate a sequence or to emulate a mapping; the difference is that for
a sequence, the allowable keys should be the integers <em>k</em> for which <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span>
<span class="pre">N</span></code> where <em>N</em> is the length of the sequence, or <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> objects, which define a
range of items.  It is also recommended that mappings provide the methods
<code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">items()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">setdefault()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">popitem()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code>, and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code> behaving similar to those for Python’s standard <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionary</span></code></a>
objects.  The <a class="reference internal" href="../library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> module provides a
<a class="reference internal" href="../library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableMapping</span></code></a>
<a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a> to help create those methods from a base set of
<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, <a class="reference internal" href="#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a>, <a class="reference internal" href="#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delitem__()</span></code></a>, and <code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code>.
Mutable sequences should provide methods <code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">extend()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">insert()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">remove()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">reverse()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code>, like Python standard <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>
objects. Finally,
sequence types should implement addition (meaning concatenation) and
multiplication (meaning repetition) by defining the methods
<a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a>, <a class="reference internal" href="#object.__radd__" title="object.__radd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__radd__()</span></code></a>, <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a>,
<a class="reference internal" href="#object.__mul__" title="object.__mul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mul__()</span></code></a>, <a class="reference internal" href="#object.__rmul__" title="object.__rmul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rmul__()</span></code></a> and <a class="reference internal" href="#object.__imul__" title="object.__imul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__imul__()</span></code></a>
described below; they should not define other numerical
operators.  It is recommended that both mappings and sequences implement the
<a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> method to allow efficient use of the <code class="docutils literal notranslate"><span class="pre">in</span></code>
operator; for
mappings, <code class="docutils literal notranslate"><span class="pre">in</span></code> should search the mapping’s keys; for sequences, it should
search through the values.  It is further recommended that both mappings and
sequences implement the <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> method to allow efficient iteration
through the container; for mappings, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> should iterate
through the object’s keys; for sequences, it should iterate through the values.</p>
<dl class="py method">
<dt id="object.__len__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__len__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__len__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p id="index-94">Es llamado para implementar la función incorporada <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>. Debe retornar la longitud del objeto, un entero <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 0. También, un objeto que no define un método <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> y cuyo método <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> retorna cero, es considerado como falso en un contexto booleano.</p>
<div class="impl-detail compound">
<p><strong>Detalles de implementación de CPython:</strong> En CPython, se requiere que la longitud sea como mucho <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.maxsize</span></code></a>. Si la longitud es más grande que <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.maxsize</span></code> algunas características (como <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>) pueden lanzar una excepción <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>. Para prevenir lanzar una excepción <code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code> al validar la verdad de un valor, un objeto debe definir un método <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="object.__length_hint__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__length_hint__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__length_hint__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Es llamado para implementar <a class="reference internal" href="../library/operator.html#operator.length_hint" title="operator.length_hint"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.length_hint()</span></code></a>. Debe retornar una longitud estimada para el objeto (que puede ser mayor o menor que la longitud actual). La longitud debe ser un entero <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 0. El valor de retorno también debe ser <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-const docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> el cual es tratado de igual forma a que si el método <code class="docutils literal notranslate"><span class="pre">__length_hint__</span></code> no existiera en absoluto. Este método es puramente una optimización y nunca es requerido para precisión.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<div class="admonition note" id="index-95">
<p class="admonition-title">Nota</p>
<p>La segmentación se hace exclusivamente con los siguientes tres métodos. Un llamado como</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>
</div>
<p>es traducido a</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>
</div>
<p>etcétera. Elementos faltantes de segmentos siempre son llenados con <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</div>
<dl class="py method">
<dt id="object.__getitem__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getitem__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Called to implement evaluation of <code class="docutils literal notranslate"><span class="pre">self[key]</span></code>. For <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequence</span></a> types,
the accepted keys should be integers and slice objects.  Note that the
special interpretation of negative indexes (if the class wishes to emulate a
<a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequence</span></a> type) is up to the <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> method. If <em>key</em> is
of an inappropriate type, <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> may be raised; if of a value
outside the set of indexes for the sequence (after any special
interpretation of negative values), <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> should be raised. For
<a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a> types, if <em>key</em> is missing (not in the container),
<a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> should be raised.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>ciclos <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> esperan que una excepción <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> sea lanzada para que índices ilegales permitan la detección adecuada del fin de una secuencia.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>When <a class="reference internal" href="expressions.html#subscriptions"><span class="std std-ref">subscripting</span></a> a <em>class</em>, the special
class method <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> may be called instead of
<code class="docutils literal notranslate"><span class="pre">__getitem__()</span></code>. See <a class="reference internal" href="#classgetitem-versus-getitem"><span class="std std-ref">__class_getitem__ versus __getitem__</span></a> for more
details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="object.__setitem__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__setitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setitem__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Es llamado para implementar la asignación a <code class="docutils literal notranslate"><span class="pre">self[key]</span></code>. Lo mismo con respecto a <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>. Esto solo debe ser implementado para mapeos si los objetos permiten cambios a los valores de las llaves, o si nuevas llaves pueden ser añadidas, o para secuencias si los elementos pueden ser reemplazados. Las mismas excepciones deben ser lanzadas para valores de <em>key</em> inadecuados con respecto al método <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__delitem__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__delitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delitem__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Es llamado para implementar el borrado de <code class="docutils literal notranslate"><span class="pre">self[key]</span></code>. Lo mismo con respecto a <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>. Esto solo debe ser implementado para mapeos si los objetos permiten el borrado de llaves, o para secuencias si los elementos pueden ser eliminados de la secuencia. Las mismas excepciones deben ser lanzadas por valores de <em>key</em> inapropiados con respecto al método <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__missing__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__missing__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__missing__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Es llamado por <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>.<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> para implementar <code class="docutils literal notranslate"><span class="pre">self[key]</span></code> para subclases de diccionarios cuando la llave no se encuentra en el diccionario.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__iter__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__iter__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iter__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>This method is called when an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> is required for a container.
This method should return a new iterator object that can iterate over all the
objects in the container.  For mappings, it should iterate over the keys of
the container.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__reversed__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__reversed__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__reversed__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Es llamado (si existe) por la función incorporada <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> para implementar una interacción invertida. Debe retornar un nuevo objeto iterador que itere sobre todos los objetos en el contenedor en orden inverso.</p>
<p>Si el método <a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> no es proporcionado, la función incorporada <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> recurrirá a utilizar el protocolo de secuencia (<a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> y <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>). Objetos que permiten el protocolo de secuencia deben únicamente proporcionar <a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> si no pueden proporcionar una implementación que sea más eficiente que la proporcionada por <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a>.</p>
</dd></dl>

<p>Los operadores de prueba de pertenencia (<a class="reference internal" href="expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> and <a class="reference internal" href="expressions.html#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a>) son normalmente implementados como una iteración sobre un contenedor. Sin embargo, los objetos de contenedor pueden proveer el siguiente método especial con una implementación más eficiente, que tampoco requiere que el objeto sea iterable.</p>
<dl class="py method">
<dt id="object.__contains__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__contains__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">item</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__contains__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Es llamado para implementar operadores de prueba de pertenencia. Deben retornar <em>true</em> si <em>item</em> se encuentra en <em>self</em>, de lo contrario <em>false</em>. Para objetos de mapeo, estos debe considerar las llaves del mapeo en lugar de los valores o los pares de llave-valor.</p>
<p>Para objetos que no definen <a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a>, la prueba de pertenencia primero intenta la iteración a través de <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>, y luego el antiguo protocolo de iteración de secuencia a través de <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, ver <a class="reference internal" href="expressions.html#membership-test-details"><span class="std std-ref">esta sección en la referencia del lenguaje</span></a>.</p>
</dd></dl>

</section>
<section id="emulating-numeric-types">
<span id="numeric-types"></span><h3><span class="section-number">3.3.8. </span>Emulando tipos numéricos<a class="headerlink" href="#emulating-numeric-types" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Los siguientes métodos pueden ser definidos para emular objetos numéricos. Métodos que corresponden a operaciones que no son permitidas por el número particular implementado (por ejemplo, operaciones bit a bit para números no enteros) se deben dejar sin definir.</p>
<dl class="py method">
<dt id="object.__add__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__add__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__add__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__sub__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__sub__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__sub__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__mul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__mul__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mul__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__matmul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__matmul__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__matmul__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__truediv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__truediv__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__truediv__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__floordiv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__floordiv__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__floordiv__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__mod__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__mod__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mod__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__divmod__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__divmod__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__divmod__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__pow__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__pow__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="optional">[</span>, <em class="sig-param">modulo</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__pow__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__lshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__lshift__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__lshift__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__rshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rshift__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rshift__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__and__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__and__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__and__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__xor__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__xor__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__xor__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__or__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__or__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__or__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p id="index-96">Estos métodos son llamados para implementar las operaciones aritméticas binarias (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>, <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>). Por ejemplo, para evaluar la expresión <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>, donde <em>x</em> es instancia de una clase que tiene un método <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">x.__add__(y)</span></code> es llamado. El método <a class="reference internal" href="#object.__divmod__" title="object.__divmod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__divmod__()</span></code></a> debe ser el equivalente a usar <a class="reference internal" href="#object.__floordiv__" title="object.__floordiv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__floordiv__()</span></code></a> y <a class="reference internal" href="#object.__mod__" title="object.__mod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mod__()</span></code></a>; no debe ser relacionado a <a class="reference internal" href="#object.__truediv__" title="object.__truediv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__truediv__()</span></code></a>. Se debe tomar en cuenta que <a class="reference internal" href="#object.__pow__" title="object.__pow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__pow__()</span></code></a> debe ser definido para aceptar un tercer argumento opcional si la versión ternaria de la función incorporada <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> es soportada.</p>
<p>Si alguno de esos métodos no permiten la operación con los argumentos suministrados, debe retornar <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__radd__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__radd__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__radd__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__rsub__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rsub__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rsub__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__rmul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rmul__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmul__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__rmatmul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rmatmul__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmatmul__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__rtruediv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rtruediv__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rtruediv__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__rfloordiv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rfloordiv__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rfloordiv__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__rmod__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rmod__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmod__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__rdivmod__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rdivmod__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rdivmod__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__rpow__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rpow__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="optional">[</span>, <em class="sig-param">modulo</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__rpow__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__rlshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rlshift__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rlshift__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__rrshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rrshift__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rrshift__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__rand__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rand__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rand__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__rxor__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__rxor__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rxor__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__ror__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ror__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ror__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p id="index-97">Estos métodos son llamados para implementar las operaciones aritméticas binarias (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>, <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>) con operandos reflejados (intercambiados). Estas funciones son llamadas únicamente si el operando izquierdo no soporta la operación correspondiente <a class="footnote-reference brackets" href="#id10" id="id5">3</a> y los operandos son de tipos diferentes. <a class="footnote-reference brackets" href="#id11" id="id6">4</a> Por ejemplo, para evaluar la expresión <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></code>, donde <em>y</em> es instancia de una clase que tiene un método <a class="reference internal" href="#object.__rsub__" title="object.__rsub__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rsub__()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">y.__rsub__(x)</span></code> es llamado si <code class="docutils literal notranslate"><span class="pre">x.__sub__(y)</span></code> retorna <em>NotImplemented</em>.</p>
<p id="index-98">Se debe tomar en cuenta que la función ternaria <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> no intentará llamar a <a class="reference internal" href="#object.__rpow__" title="object.__rpow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rpow__()</span></code></a> (las reglas de coerción se volverían demasiado complicadas).</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si el tipo del operando de la derecha es una subclase del tipo del operando de la izquierda y esa subclase proporciona el método reflejado para la operación, este método será llamado antes del método no reflejado del operando izquierdo. Este comportamiento permite que las subclases anulen las operaciones de sus predecesores.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="object.__iadd__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__iadd__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iadd__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__isub__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__isub__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__isub__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__imul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__imul__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imul__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__imatmul__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__imatmul__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imatmul__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__itruediv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__itruediv__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__itruediv__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__ifloordiv__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ifloordiv__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ifloordiv__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__imod__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__imod__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imod__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__ipow__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ipow__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em><span class="optional">[</span>, <em class="sig-param">modulo</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__ipow__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__ilshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ilshift__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ilshift__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__irshift__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__irshift__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__irshift__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__iand__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__iand__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iand__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__ixor__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ixor__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ixor__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__ior__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ior__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ior__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Estos métodos son llamados para implementar las asignaciones aritméticas aumentadas (<code class="docutils literal notranslate"><span class="pre">+=</span></code>, <code class="docutils literal notranslate"><span class="pre">-=</span></code>, <code class="docutils literal notranslate"><span class="pre">*=</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;=</span></code>, <code class="docutils literal notranslate"><span class="pre">/=</span></code>, <code class="docutils literal notranslate"><span class="pre">//=</span></code>, <code class="docutils literal notranslate"><span class="pre">%=</span></code>, <code class="docutils literal notranslate"><span class="pre">**=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>, <code class="docutils literal notranslate"><span class="pre">^=</span></code>, <code class="docutils literal notranslate"><span class="pre">|=</span></code>). Estos métodos deben intentar realizar la operación <em>in-place</em> (modificando <em>self</em>) y retornar el resultado (que puede, pero no tiene que ser <em>self</em>). Si un método específico no es definido, la asignación aumentada regresa a los métodos normales. Por ejemplo, si <em>x</em> es la instancia de una clase con el método <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">y</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x.__iadd__(y)</span></code>. De lo contrario <code class="docutils literal notranslate"><span class="pre">x.__add__(y)</span></code> y <code class="docutils literal notranslate"><span class="pre">y.__radd__(x)</span></code> se consideran al igual que con la evaluación de <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>. En ciertas situaciones, asignaciones aumentadas pueden resultar en errores no esperados (ver <a class="reference internal" href="../faq/programming.html#faq-augmented-assignment-tuple-error"><span class="std std-ref">¿Por qué hacer lo siguiente, a_tuple[i] += ['item'], lanza una excepción cuando la suma funciona?</span></a>), pero este comportamiento es en realidad parte del modelo de datos.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__neg__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__neg__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__neg__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__pos__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__pos__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__pos__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__abs__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__abs__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__abs__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__invert__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__invert__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__invert__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p id="index-99">Es llamado para implementar las operaciones aritméticas unarias (<code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a> and <code class="docutils literal notranslate"><span class="pre">~</span></code>).</p>
</dd></dl>

<dl class="py method">
<dt id="object.__complex__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__complex__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__complex__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__int__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__int__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__int__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__float__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__float__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__float__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p id="index-100">Es llamado para implementar las funciones incorporadas <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a>, <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> y <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a>. Debe retornar un valor del tipo apropiado.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__index__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__index__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__index__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Es llamado para implementar <a class="reference internal" href="../library/operator.html#operator.index" title="operator.index"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.index()</span></code></a>, y cuando sea que Python necesite convertir sin pérdidas el objeto numérico a un objeto entero (tal como en la segmentación o <em>slicing</em>, o las funciones incorporadas <a class="reference internal" href="../library/functions.html#bin" title="bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin()</span></code></a>, <a class="reference internal" href="../library/functions.html#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a> y <a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a>). La presencia de este método indica que el objeto numérico es un tipo entero. Debe retornar un entero.</p>
<p>Si <a class="reference internal" href="#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a>, <a class="reference internal" href="#object.__float__" title="object.__float__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__float__()</span></code></a> y <a class="reference internal" href="#object.__complex__" title="object.__complex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__complex__()</span></code></a> no son definidos, entonces todas las funciones incorporadas correspondientes <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>, <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a> y <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a> vuelven a <a class="reference internal" href="#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__round__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__round__</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="optional">[</span>, <em class="sig-param">ndigits</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__round__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__trunc__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__trunc__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__trunc__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__floor__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__floor__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__floor__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="object.__ceil__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__ceil__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ceil__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p id="index-101">Es llamado para implementar la función incorporada <a class="reference internal" href="../library/functions.html#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a> y las funciones <a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> <a class="reference internal" href="../library/math.html#math.trunc" title="math.trunc"><code class="xref py py-func docutils literal notranslate"><span class="pre">trunc()</span></code></a>, <a class="reference internal" href="../library/math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor()</span></code></a> y <a class="reference internal" href="../library/math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">ceil()</span></code></a>. A menos que <em>ndigits</em> sea pasado a <code class="xref py py-meth docutils literal notranslate"><span class="pre">__round__()</span></code> todos estos métodos deben retornar el valor del objeto truncado a <a class="reference internal" href="../library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a> (normalmente <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>).</p>
<p>The built-in function <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> falls back to <a class="reference internal" href="#object.__trunc__" title="object.__trunc__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__trunc__()</span></code></a> if neither
<a class="reference internal" href="#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a> nor <a class="reference internal" href="#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> is defined.</p>
</dd></dl>

</section>
<section id="with-statement-context-managers">
<span id="context-managers"></span><h3><span class="section-number">3.3.9. </span>Gestores de Contexto en la Declaración <em>with</em><a class="headerlink" href="#with-statement-context-managers" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Un <em class="dfn">context manager</em> es un objeto que define el contexto en tiempo de ejecución a ser establecido cuando se ejecuta una declaración <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>. El gestor de contexto maneja la entrada y la salida del contexto en tiempo de ejecución deseado para la ejecución del bloque de código. Los gestores de contexto son normalmente invocados utilizando la declaración <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> (descritos en la sección <a class="reference internal" href="compound_stmts.html#with"><span class="std std-ref">La sentencia with</span></a>), pero también pueden ser utilizados al invocar directamente sus métodos.</p>
<p id="index-102">Usos típicos de los gestores de contexto incluyen guardar y restablecer diversos tipos de declaraciones globales, bloquear y desbloquear recursos, cerrar archivos abiertos, etc.</p>
<p>Para más información sobre gestores de contexto, ver <a class="reference internal" href="../library/stdtypes.html#typecontextmanager"><span class="std std-ref">Tipos Gestores de Contexto</span></a>.</p>
<dl class="py method">
<dt id="object.__enter__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__enter__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__enter__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Ingresa al contexto en tiempo de ejecución relacionado con este objeto. La declaración <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> ligará el valor de retorno de este método al objetivo especificado en cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> de la declaración, en caso de existir.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__exit__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__exit__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">exc_type</span></em>, <em class="sig-param"><span class="n">exc_value</span></em>, <em class="sig-param"><span class="n">traceback</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__exit__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Sale del contexto en tiempo de ejecución relacionado a este objeto. Los parámetros describen la excepción que causa la salida del contexto. Si éste se termina sin excepción, los tres argumentos serán <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>.</p>
<p>Si se proporciona una excepción, y el método desea eliminarla (por ejemplo, prevenir que sea propagada), debe retornar un valor verdadero. De lo contrario, la excepción será procesada de forma normal al salir de este método.</p>
<p>Se debe tomar en cuenta que los métodos <a class="reference internal" href="#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> no deben lanzar de nuevo la excepción que se pasa; esto es la responsabilidad de quien hace el llamado.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-124"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0343"><strong>PEP 343</strong></a> - La declaración “with”</dt><dd><p>La especificación, el antecedente, y los ejemplos para la declaración de Python <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>.</p>
</dd>
</dl>
</div>
</section>
<section id="customizing-positional-arguments-in-class-pattern-matching">
<span id="class-pattern-matching"></span><h3><span class="section-number">3.3.10. </span>Personalización de argumentos posicionales en la coincidencia de patrones de clase<a class="headerlink" href="#customizing-positional-arguments-in-class-pattern-matching" title="Enlazar permanentemente con este título">¶</a></h3>
<p>When using a class name in a pattern, positional arguments in the pattern are not
allowed by default, i.e. <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">MyClass(x,</span> <span class="pre">y)</span></code> is typically invalid without special
support in <code class="docutils literal notranslate"><span class="pre">MyClass</span></code>. To be able to use that kind of pattern, the class needs to
define a <em>__match_args__</em> attribute.</p>
<dl class="py data">
<dt id="object.__match_args__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__match_args__</code><a class="headerlink" href="#object.__match_args__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>A esta variable de clase se le puede asignar una tupla de cadenas. Cuando esta clase se utiliza en un patrón de clase con argumentos posicionales, cada argumento posicional se convertirá en un argumento de palabra clave, utilizando el valor correspondiente en <em>__match_args__</em> como palabra clave. La ausencia de este atributo es equivalente a establecerlo en <code class="docutils literal notranslate"><span class="pre">()</span></code>.</p>
</dd></dl>

<p>Por ejemplo, si <code class="docutils literal notranslate"><span class="pre">MyClass.__match_args__</span></code> es <code class="docutils literal notranslate"><span class="pre">(&quot;left&quot;,</span> <span class="pre">&quot;center&quot;,</span> <span class="pre">&quot;right&quot;)</span></code> eso significa que <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">MyClass(x,</span> <span class="pre">y)</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">MyClass(left=x,</span> <span class="pre">center=y)</span></code>. Ten en cuenta que el número de argumentos en el patrón debe ser menor o igual que el número de elementos en <em>__match_args__</em>; si es más grande, el intento de coincidencia de patrón producirá un <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-125"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0634"><strong>PEP 634</strong></a> - Coincidencia de patrones estructurales</dt><dd><p>La especificación para la declaración <code class="docutils literal notranslate"><span class="pre">match</span></code> de Python.</p>
</dd>
</dl>
</div>
</section>
<section id="special-method-lookup">
<span id="special-lookup"></span><h3><span class="section-number">3.3.11. </span>Búsqueda de método especial<a class="headerlink" href="#special-method-lookup" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para clases personalizadas, invocaciones implícitas de métodos especiales solo están garantizados para trabajar correctamente si son definidos en un tipo de objeto, no en el diccionario de instancia del objeto. Ese comportamiento es la razón por la que el siguiente código lanza una excepción:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">object of type &#39;C&#39; has no len()</span>
</pre></div>
</div>
<p>The rationale behind this behaviour lies with a number of special methods such
as <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> and <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> that are implemented
by all objects,
including type objects. If the implicit lookup of these methods used the
conventional lookup process, they would fail when invoked on the type object
itself:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">descriptor &#39;__hash__&#39; of &#39;int&#39; object needs an argument</span>
</pre></div>
</div>
<p>Intentar invocar de manera incorrecta el método no ligado de una clase de esta forma a veces es denominado como ‘confusión de metaclase’, y se evita sobrepasando la instancia al buscar métodos especiales:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In addition to bypassing any instance attributes in the interest of
correctness, implicit special method lookup generally also bypasses the
<a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> method even of the object’s metaclass:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Metaclass getattribute invoked&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Class getattribute invoked&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>                 <span class="c1"># Explicit lookup via instance</span>
<span class="go">Class getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="fm">__len__</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>          <span class="c1"># Explicit lookup via type</span>
<span class="go">Metaclass getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>                      <span class="c1"># Implicit lookup</span>
<span class="go">10</span>
</pre></div>
</div>
<p>Bypassing the <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> machinery in this fashion
provides significant scope for speed optimisations within the
interpreter, at the cost of some flexibility in the handling of
special methods (the special method <em>must</em> be set on the class
object itself in order to be consistently invoked by the interpreter).</p>
</section>
</section>
<section id="coroutines">
<span id="index-105"></span><h2><span class="section-number">3.4. </span>Corrutinas<a class="headerlink" href="#coroutines" title="Enlazar permanentemente con este título">¶</a></h2>
<section id="awaitable-objects">
<h3><span class="section-number">3.4.1. </span>Objetos Esperables<a class="headerlink" href="#awaitable-objects" title="Enlazar permanentemente con este título">¶</a></h3>
<p>An <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> object generally implements an <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> method.
<a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">Coroutine objects</span></a> returned from <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> functions
are awaitable.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>The <a class="reference internal" href="../glossary.html#term-generator-iterator"><span class="xref std std-term">generator iterator</span></a> objects returned from generators
decorated with <a class="reference internal" href="../library/types.html#types.coroutine" title="types.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">types.coroutine()</span></code></a> or <a class="reference internal" href="../library/asyncio-task.html#asyncio.coroutine" title="asyncio.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.coroutine()</span></code></a>
are also awaitable, but they do not implement <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>.</p>
</div>
<dl class="py method">
<dt id="object.__await__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__await__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__await__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Debe retornar un <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>. Debe ser utilizado para implementar objetos <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a>. Por ejemplo, <a class="reference internal" href="../library/asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> implementa este método para ser compatible con la expresión <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>The language doesn’t place any restriction on the type or value of the
objects yielded by the iterator returned by <code class="docutils literal notranslate"><span class="pre">__await__</span></code>, as this is
specific to the implementation of the asynchronous execution framework
(e.g. <a class="reference internal" href="../library/asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a>) that will be managing the <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> object.</p>
</div>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p><span class="target" id="index-126"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> para información adicional sobre objetos esperables.</p>
</div>
</section>
<section id="coroutine-objects">
<span id="id7"></span><h3><span class="section-number">3.4.2. </span>Objetos de Corrutina<a class="headerlink" href="#coroutine-objects" title="Enlazar permanentemente con este título">¶</a></h3>
<p><a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">Coroutine objects</span></a> are <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> objects.
A coroutine’s execution can be controlled by calling <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> and
iterating over the result.  When the coroutine has finished executing and
returns, the iterator raises <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>, and the exception’s
<code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> attribute holds the return value.  If the
coroutine raises an exception, it is propagated by the iterator.  Coroutines
should not directly raise unhandled <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> exceptions.</p>
<p>Las corrutinas también tienen los métodos mencionados a continuación, los cuales son análogos a los de los generadores. (ver <a class="reference internal" href="expressions.html#generator-methods"><span class="std std-ref">Métodos generador-iterador</span></a>). Sin embargo, a diferencia de los generadores, las corrutinas no soportan directamente iteración.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5.2: </span>Es un error <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> esperar a una corrutina más de una vez.</p>
</div>
<dl class="py method">
<dt id="coroutine.send">
<code class="sig-prename descclassname">coroutine.</code><code class="sig-name descname">send</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.send" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Starts or resumes execution of the coroutine.  If <em>value</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>,
this is equivalent to advancing the iterator returned by
<a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>.  If <em>value</em> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, this method delegates
to the <a class="reference internal" href="expressions.html#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> method of the iterator that caused
the coroutine to suspend.  The result (return value,
<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>, or other exception) is the same as when
iterating over the <code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code> return value, described above.</p>
</dd></dl>

<dl class="py method">
<dt id="coroutine.throw">
<code class="sig-prename descclassname">coroutine.</code><code class="sig-name descname">throw</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.throw" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt>
<code class="sig-prename descclassname">coroutine.</code><code class="sig-name descname">throw</code><span class="sig-paren">(</span><em class="sig-param">type</em><span class="optional">[</span>, <em class="sig-param">value</em><span class="optional">[</span>, <em class="sig-param">traceback</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Raises the specified exception in the coroutine.  This method delegates
to the <a class="reference internal" href="expressions.html#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> method of the iterator that caused
the coroutine to suspend, if it has such a method.  Otherwise,
the exception is raised at the suspension point.  The result
(return value, <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>, or other exception) is the same as
when iterating over the <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> return value, described
above.  If the exception is not caught in the coroutine, it propagates
back to the caller.</p>
</dd></dl>

<dl class="py method">
<dt id="coroutine.close">
<code class="sig-prename descclassname">coroutine.</code><code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.close" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Causa que la corrutina misma se borre a sí misma y termine su ejecución. Si la corrutina es suspendida, este método primero delega a <a class="reference internal" href="expressions.html#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a>, si existe, del iterador que causó la suspensión de la corrutina. Luego lanza una excepción <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> en el punto de suspensión, causando que la corrutina se borre a sí misma. Finalmente, la corrutina es marcada como completada, aún si nunca inició.</p>
<p>Objetos de corrutina son cerrados automáticamente utilizando el proceso anterior cuando están a punto de ser destruidos.</p>
</dd></dl>

</section>
<section id="asynchronous-iterators">
<span id="async-iterators"></span><h3><span class="section-number">3.4.3. </span>Iteradores asíncronos<a class="headerlink" href="#asynchronous-iterators" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Un <em>iterador asíncrono</em> puede llamar código asíncrono en su método <code class="docutils literal notranslate"><span class="pre">__anext__</span></code>.</p>
<p>Iteradores asíncronos pueden ser utilizados en la declaración <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>.</p>
<dl class="py method">
<dt id="object.__aiter__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__aiter__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aiter__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Debe retornar un objeto de <em>iterador asíncrono</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__anext__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__anext__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__anext__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Debe retornar un <em>esperable</em> (awaitable) resultante en el siguiente valor del iterador. Debe levantar una excepción <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> cuando la iteración termina.</p>
</dd></dl>

<p>Un ejemplo de objeto iterable asíncrono:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Reader</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="fm">__aiter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__anext__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopAsyncIteration</span>
        <span class="k">return</span> <span class="n">val</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Prior to Python 3.7, <a class="reference internal" href="#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> could return an <em>awaitable</em>
that would resolve to an
<a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a>.</p>
<p>Starting with Python 3.7, <a class="reference internal" href="#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> must return an
asynchronous iterator object.  Returning anything else
will result in a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> error.</p>
</div>
</section>
<section id="asynchronous-context-managers">
<span id="async-context-managers"></span><h3><span class="section-number">3.4.4. </span>Gestores de Contexto Asíncronos<a class="headerlink" href="#asynchronous-context-managers" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Un <em>gestor de contexto asíncrono</em> es un <em>gestor de contexto</em> que puede suspender la ejecución en sus métodos <code class="docutils literal notranslate"><span class="pre">__aenter__</span></code> y <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code>.</p>
<p>Los gestores de contexto asíncronos pueden ser utilizados en una declaración <a class="reference internal" href="compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a>.</p>
<dl class="py method">
<dt id="object.__aenter__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__aenter__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aenter__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Semánticamente similar a <a class="reference internal" href="#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a>, siendo la única diferencia que debe retorna un <em>esperable</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="object.__aexit__">
<code class="sig-prename descclassname">object.</code><code class="sig-name descname">__aexit__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">exc_type</span></em>, <em class="sig-param"><span class="n">exc_value</span></em>, <em class="sig-param"><span class="n">traceback</span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aexit__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Semánticamente similar a <a class="reference internal" href="#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a>, siendo la única diferencia que debe retornar un <em>esperable</em>.</p>
</dd></dl>

<p>Un ejemplo de una clase de gestor de contexto asíncrono:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AsyncContextManager</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="s1">&#39;entering context&#39;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="s1">&#39;exiting context&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
<p class="rubric">Notas a pie de página</p>
<dl class="footnote brackets">
<dt class="label" id="id8"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Es posible cambiar en algunos casos un tipo de objeto bajo ciertas circunstancias controladas. Generalmente no es buena idea, ya que esto puede llevar a un comportamiento bastante extraño de no ser tratado correctamente.</p>
</dd>
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>The <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>, <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>,
<a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a>, and <a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> methods have
special handling for this; others
will still raise a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>, but may do so by relying on
the behavior that <code class="docutils literal notranslate"><span class="pre">None</span></code> is not callable.</p>
</dd>
<dt class="label" id="id10"><span class="brackets"><a class="fn-backref" href="#id5">3</a></span></dt>
<dd><p>“No soporta” aquí significa que la clase no tiene tal método, o el método retorna <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code>. No establecer el método a <code class="docutils literal notranslate"><span class="pre">None</span></code> si se quiere forzar el retroceso al método reflejado del operando correcto—eso, por el contrario, tendrá un efecto opuesto de bloquear explícitamente dicho retroceso.</p>
</dd>
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id6">4</a></span></dt>
<dd><p>For operands of the same type, it is assumed that if the non-reflected
method – such as <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a> – fails then the overall
operation is not
supported, which is why the reflected method is not called.</p>
</dd>
</dl>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. Modelo de datos</a><ul>
<li><a class="reference internal" href="#objects-values-and-types">3.1. Objetos, valores y tipos</a></li>
<li><a class="reference internal" href="#the-standard-type-hierarchy">3.2. Jerarquía de tipos estándar</a></li>
<li><a class="reference internal" href="#special-method-names">3.3. Nombres especiales de método</a><ul>
<li><a class="reference internal" href="#basic-customization">3.3.1. Personalización básica</a></li>
<li><a class="reference internal" href="#customizing-attribute-access">3.3.2. Personalizando acceso a atributos</a><ul>
<li><a class="reference internal" href="#customizing-module-attribute-access">3.3.2.1. Personalizando acceso a atributos de módulo</a></li>
<li><a class="reference internal" href="#implementing-descriptors">3.3.2.2. Implementando Descriptores</a></li>
<li><a class="reference internal" href="#invoking-descriptors">3.3.2.3. Invocando Descriptores</a></li>
<li><a class="reference internal" href="#slots">3.3.2.4. __slots__</a><ul>
<li><a class="reference internal" href="#notes-on-using-slots">3.3.2.4.1. Notas sobre el uso de  <em>__slots__</em></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-class-creation">3.3.3. Personalización de creación de clases</a><ul>
<li><a class="reference internal" href="#metaclasses">3.3.3.1. Metaclases</a></li>
<li><a class="reference internal" href="#resolving-mro-entries">3.3.3.2. Resolviendo entradas de la Orden de Resolución de Métodos (MRU)</a></li>
<li><a class="reference internal" href="#determining-the-appropriate-metaclass">3.3.3.3. Determinando la metaclase adecuada</a></li>
<li><a class="reference internal" href="#preparing-the-class-namespace">3.3.3.4. Preparando el espacio de nombres de la clase</a></li>
<li><a class="reference internal" href="#executing-the-class-body">3.3.3.5. Ejecutando el cuerpo de la clase</a></li>
<li><a class="reference internal" href="#creating-the-class-object">3.3.3.6. Creando el objeto de clase</a></li>
<li><a class="reference internal" href="#uses-for-metaclasses">3.3.3.7. Usos para metaclases</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-instance-and-subclass-checks">3.3.4. Personalizando revisiones de instancia y subclase</a></li>
<li><a class="reference internal" href="#emulating-generic-types">3.3.5. Emulando tipos genéricos</a><ul>
<li><a class="reference internal" href="#the-purpose-of-class-getitem">3.3.5.1. The purpose of <em>__class_getitem__</em></a></li>
<li><a class="reference internal" href="#class-getitem-versus-getitem">3.3.5.2. <em>__class_getitem__</em> versus <em>__getitem__</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#emulating-callable-objects">3.3.6. Emulando objetos que se pueden llamar</a></li>
<li><a class="reference internal" href="#emulating-container-types">3.3.7. Emulando tipos de contenedores</a></li>
<li><a class="reference internal" href="#emulating-numeric-types">3.3.8. Emulando tipos numéricos</a></li>
<li><a class="reference internal" href="#with-statement-context-managers">3.3.9. Gestores de Contexto en la Declaración <em>with</em></a></li>
<li><a class="reference internal" href="#customizing-positional-arguments-in-class-pattern-matching">3.3.10. Personalización de argumentos posicionales en la coincidencia de patrones de clase</a></li>
<li><a class="reference internal" href="#special-method-lookup">3.3.11. Búsqueda de método especial</a></li>
</ul>
</li>
<li><a class="reference internal" href="#coroutines">3.4. Corrutinas</a><ul>
<li><a class="reference internal" href="#awaitable-objects">3.4.1. Objetos Esperables</a></li>
<li><a class="reference internal" href="#coroutine-objects">3.4.2. Objetos de Corrutina</a></li>
<li><a class="reference internal" href="#asynchronous-iterators">3.4.3. Iteradores asíncronos</a></li>
<li><a class="reference internal" href="#asynchronous-context-managers">3.4.4. Gestores de Contexto Asíncronos</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="lexical_analysis.html"
                        title="capítulo anterior"><span class="section-number">2. </span>Análisis léxico</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="executionmodel.html"
                        title="próximo capítulo"><span class="section-number">4. </span>Modelo de ejecución</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/reference/datamodel.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. Modelo de ejecución"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. Análisis léxico"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Referencia del Lenguaje Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">3. </span>Modelo de datos</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 27, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>