
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="logging — Instalación de logging para Python" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/logging.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Source code: Lib/logging/__init__.py Important: Esta página contiene la información de referencia de la API. Para información sobre tutorial y discusión de temas más avanzados, ver Tutorial básico,..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Source code: Lib/logging/__init__.py Important: Esta página contiene la información de referencia de la API. Para información sobre tutorial y discusión de temas más avanzados, ver Tutorial básico,..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>logging — Instalación de logging para Python &#8212; documentación de Python - 3.11.2</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=2d3badd06fe70b34b68db01f99471ce1624ffe4a" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.11.2"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="logging.config — Configuración de registro" href="logging.config.html" />
    <link rel="prev" title="getopt — Analizador de estilo C para opciones de línea de comando" href="getopt.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/logging.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code> — Instalación de logging para Python</a><ul>
<li><a class="reference internal" href="#logger-objects">Objetos logger</a></li>
<li><a class="reference internal" href="#logging-levels">Niveles de logging</a></li>
<li><a class="reference internal" href="#handler-objects">Gestor de objetos</a></li>
<li><a class="reference internal" href="#formatter-objects">Objetos formateadores</a></li>
<li><a class="reference internal" href="#filter-objects">Filtro de Objetos</a></li>
<li><a class="reference internal" href="#logrecord-objects">Objetos LogRecord</a></li>
<li><a class="reference internal" href="#logrecord-attributes">Atributos LogRecord</a></li>
<li><a class="reference internal" href="#loggeradapter-objects">Objetos LoggerAdapter</a></li>
<li><a class="reference internal" href="#thread-safety">Seguridad del hilo</a></li>
<li><a class="reference internal" href="#module-level-functions">Funciones a nivel de módulo</a></li>
<li><a class="reference internal" href="#module-level-attributes">Atributos a nivel de módulo</a></li>
<li><a class="reference internal" href="#integration-with-the-warnings-module">Integración con el módulo de advertencias</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="getopt.html"
                          title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">getopt</span></code> — Analizador de estilo C para opciones de línea de comando</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="logging.config.html"
                          title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.config</span></code> — Configuración de registro</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/library/logging.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="logging.config.html" title="logging.config — Configuración de registro"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="getopt.html" title="getopt — Analizador de estilo C para opciones de línea de comando"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" accesskey="U">Servicios genéricos del sistema operativo</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code> — Instalación de logging para Python</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-logging">
<span id="logging-logging-facility-for-python"></span><h1><a class="reference internal" href="#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> — Instalación de logging para Python<a class="headerlink" href="#module-logging" title="Enlazar permanentemente con este título">¶</a></h1>
<p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.11/Lib/logging/__init__.py">Lib/logging/__init__.py</a></p>
<aside class="sidebar">
<p class="sidebar-title">Important</p>
<p>Esta página contiene la información de referencia de la API. Para información sobre tutorial y discusión de temas más avanzados, ver</p>
<ul class="simple">
<li><p><a class="reference internal" href="../howto/logging.html#logging-basic-tutorial"><span class="std std-ref">Tutorial básico</span></a></p></li>
<li><p><a class="reference internal" href="../howto/logging.html#logging-advanced-tutorial"><span class="std std-ref">Tutorial avanzado</span></a></p></li>
<li><p><a class="reference internal" href="../howto/logging-cookbook.html#logging-cookbook"><span class="std std-ref">Libro de recetas de Logging</span></a></p></li>
</ul>
</aside>
<hr class="docutils" />
<p>Este módulo define funciones y clases que implementan un sistema flexible de logging de eventos para aplicaciones y bibliotecas.</p>
<p>El beneficio clave de tener la API de logging proporcionada por un módulo de la biblioteca estándar es que todos los módulos de Python pueden participar en el logging, por lo que el registro de su aplicación puede incluir sus propios mensajes integrados con mensajes de módulos de terceros.</p>
<p>El ejemplo simple:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; import logging
&gt;&gt;&gt; logging.warning(&#39;Watch out!&#39;)
WARNING:root:Watch out!
</pre></div>
</div>
<p>The module provides a lot of functionality and flexibility.  If you are
unfamiliar with logging, the best way to get to grips with it is to view the
tutorials (<strong>see the links above and on the right</strong>).</p>
<p>Las clases básicas definidas por el módulo, junto con sus funciones, se enumeran a continuación.</p>
<ul class="simple">
<li><p>Los loggers exponen la interfaz que el código de la aplicación usa directamente.</p></li>
<li><p>Los gestores envían los registros (creados por los loggers) al destino apropiado.</p></li>
<li><p>Los filtros proporcionan una facilidad de ajuste preciso para determinar que registros generar.</p></li>
<li><p>Los formateadores especifican el diseño de los registros en el resultado final.</p></li>
</ul>
<section id="logger-objects">
<span id="logger"></span><h2>Objetos logger<a class="headerlink" href="#logger-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los loggers tienen los siguientes atributos y métodos. Tenga en cuenta que los loggers <em>NUNCA</em> deben ser instanciados directamente, siempre a través de la función de nivel de módulo <code class="docutils literal notranslate"><span class="pre">logging.getLogger(name)</span></code>. Múltiples llamadas a <a class="reference internal" href="#logging.getLogger" title="logging.getLogger"><code class="xref py py-func docutils literal notranslate"><span class="pre">getLogger()</span></code></a> con el mismo nombre siempre retornarán una referencia al mismo objeto Logger.</p>
<p>El <code class="docutils literal notranslate"><span class="pre">name</span></code> es potencialmente un valor jerárquico separado por puntos, como <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code> (aunque también podría ser simplemente <code class="docutils literal notranslate"><span class="pre">`foo</span></code>, por ejemplo). Los loggers que están más abajo en la lista jerárquica son hijos de los loggers que están más arriba en la lista. Por ejemplo, dado un logger con el nombre de <code class="docutils literal notranslate"><span class="pre">foo</span></code>, los logger con los nombres de <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code>, <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code> y <code class="docutils literal notranslate"><span class="pre">foo.bam</span></code> son descendientes de <code class="docutils literal notranslate"><span class="pre">foo</span></code>. La jerarquía del nombre del logger es análoga a la jerarquía del paquete Python e idéntica si organiza los logger por módulo utilizando la construcción recomendada <code class="docutils literal notranslate"><span class="pre">logging.getLogger(__name__)</span></code>. Debido que en un módulo, <code class="docutils literal notranslate"><span class="pre">__name__</span></code> es el nombre del módulo en el espacio de nombres del paquete Python.</p>
<dl class="py class">
<dt class="sig sig-object py" id="logging.Logger">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">Logger</span></span><a class="headerlink" href="#logging.Logger" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><dl class="py attribute">
<dt class="sig sig-object py" id="logging.Logger.propagate">
<span class="sig-name descname"><span class="pre">propagate</span></span><a class="headerlink" href="#logging.Logger.propagate" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si este atributo se evalúa como verdadero, los eventos registrados en este logger se pasarán a los gestores de los loggers de nivel superior (ancestro), además de los gestores asociados a este logger. Los mensajes se pasan directamente a los gestores de los loggers ancestrales; no se consideran ni el nivel ni los filtros de los loggers ancestrales en cuestión.</p>
<p>Si esto se evalúa como falso, los mensajes de registro no se pasan a los gestores de los logger ancestrales.</p>
<p>Explicándolo con un ejemplo: Si el atributo propagado del logger llamado <code class="docutils literal notranslate"><span class="pre">A.B.C</span></code> se evalúa a true, cualquier evento registrado en <code class="docutils literal notranslate"><span class="pre">A.B.C</span></code> a través de una llamada a un método como <code class="docutils literal notranslate"><span class="pre">logging.getLogger('A.B.C').error(...)</span></code> será [sujeto a pasar el nivel de ese logger y la configuración del filtro] pasado a su vez a cualquier manejador adjunto a los loggers llamados <code class="docutils literal notranslate"><span class="pre">A.B</span></code>, <code class="docutils literal notranslate"><span class="pre">A</span></code> y al logger raíz, después de ser pasado primero a cualquier manejador adjunto a <code class="docutils literal notranslate"><span class="pre">A.B.C</span></code>. Si cualquier logger en la cadena <code class="docutils literal notranslate"><span class="pre">A.B.C</span></code>, <code class="docutils literal notranslate"><span class="pre">A.B</span></code>, <code class="docutils literal notranslate"><span class="pre">A</span></code> tiene su atributo <code class="docutils literal notranslate"><span class="pre">propagate</span></code> a false, entonces ese es el último logger a cuyos manejadores se les ofrece el evento a manejar, y la propagación se detiene en ese punto.</p>
<p>El constructor establece este atributo en <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si adjunta un controlador a un logger <em>y</em> uno o más de sus ancestros, puede emitir el mismo registro varias veces. En general, no debería necesitar adjuntar un gestor a más de un logger; si solo lo adjunta al logger apropiado que está más arriba en la jerarquía del logger, verá todos los eventos registrados por todos los logger descendientes, siempre que la configuración de propagación sea <code class="docutils literal notranslate"><span class="pre">True</span></code>. Un escenario común es adjuntar gestores solo al logger raíz y dejar que la propagación se encargue del resto.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.setLevel">
<span class="sig-name descname"><span class="pre">setLevel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.setLevel" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece el umbral para este logger en <em>level</em>. Los mensajes de logging que son menos severos que <em>level</em> serán ignorados; los mensajes de logging que tengan un nivel de severidad <em>level</em> o superior serán emitidos por cualquier gestor o gestores que atiendan este logger, a menos que el nivel de un gestor haya sido configurado en un nivel de severidad más alto que <em>level</em>.</p>
<p>Cuando se crea un logger, el nivel se establece en <code class="xref py py-const docutils literal notranslate"><span class="pre">NOTSET</span></code> (que hace que todos los mensajes se procesen cuando el logger es el logger raíz, o la delegación al padre cuando el logger no es un logger raíz). Tenga en cuenta que el logger raíz se crea con el nivel <code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code>.</p>
<p>El término “delegación al padre” significa que si un logger tiene un nivel de NOTSET, su cadena de logger ancestrales se atraviesa hasta que se encuentra un ancestro con un nivel diferente a NOTSET o se alcanza la raíz.</p>
<p>Si se encuentra un antepasado con un nivel distinto de NOTSET, entonces el nivel de ese antepasado se trata como el nivel efectivo del logger donde comenzó la búsqueda de antepasados, y se utiliza para determinar cómo se maneja un evento de registro.</p>
<p>Si se alcanza la raíz y tiene un nivel de NOTSET, se procesarán todos los mensajes. De lo contrario, el nivel de la raíz se utilizará como el nivel efectivo.</p>
<p>Ver <a class="reference internal" href="#levels"><span class="std std-ref">Niveles de logging</span></a> para obtener una lista de niveles.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>El parámetro <em>level</em> ahora acepta una representación de cadena del nivel como “INFO” como alternativa a las constantes de enteros como <code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code>. Sin embargo, tenga en cuenta que los niveles se almacenan internamente como e.j. <a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getEffectiveLevel()</span></code></a> y <a class="reference internal" href="#logging.Logger.isEnabledFor" title="logging.Logger.isEnabledFor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isEnabledFor()</span></code></a> retornará/esperará que se pasen enteros.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.isEnabledFor">
<span class="sig-name descname"><span class="pre">isEnabledFor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.isEnabledFor" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Indica si este logger procesará un mensaje de gravedad <em>level</em>. Este método verifica primero el nivel de nivel de módulo establecido por <code class="docutils literal notranslate"><span class="pre">logging.disable(level)</span></code> y luego el nivel efectivo del logger según lo determinado por <a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getEffectiveLevel()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.getEffectiveLevel">
<span class="sig-name descname"><span class="pre">getEffectiveLevel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.getEffectiveLevel" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Indica el nivel efectivo para este logger. Si se ha establecido un valor distinto de <code class="xref py py-const docutils literal notranslate"><span class="pre">NOTSET</span></code> utilizando <a class="reference internal" href="#logging.Logger.setLevel" title="logging.Logger.setLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLevel()</span></code></a>, se retorna. De lo contrario, la jerarquía se atraviesa hacia la raíz hasta que se encuentre un valor que no sea <code class="xref py py-const docutils literal notranslate"><span class="pre">NOTSET</span></code> y se retorna ese valor. El valor retornado es un entero, típicamente uno de <code class="xref py py-const docutils literal notranslate"><span class="pre">logging.DEBUG</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">logging.INFO</span></code> etc.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.getChild">
<span class="sig-name descname"><span class="pre">getChild</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suffix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.getChild" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un logger que es descendiente de este logger, según lo determinado por el sufijo. Por lo tanto, <code class="docutils literal notranslate"><span class="pre">logging.getLogger('abc').getChild('def.ghi')</span></code> retornaría el mismo logger que retornaría <code class="docutils literal notranslate"><span class="pre">logging.getLogger('abc.def.ghi')</span></code>. Este es un método convenientemente útil cuando el logger principal se nombra usando e.j. <code class="docutils literal notranslate"><span class="pre">__name__</span></code> en lugar de una cadena literal.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.debug">
<span class="sig-name descname"><span class="pre">debug</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.debug" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Logs a message with level <code class="xref py py-const docutils literal notranslate"><span class="pre">DEBUG</span></code> on this logger. The <em>msg</em> is the
message format string, and the <em>args</em> are the arguments which are merged into
<em>msg</em> using the string formatting operator. (Note that this means that you can
use keywords in the format string, together with a single dictionary argument.)
No % formatting operation is performed on <em>msg</em> when no <em>args</em> are supplied.</p>
<p>Hay cuatro argumentos de palabras clave <em>kwargs</em> que se inspeccionan: <em>exc_info</em>, <em>stack_info</em>, <em>stacklevel</em> y <em>extra</em>.</p>
<p>Si <em>exc_info</em> no se evalúa como falso, hace que se agregue información de excepción al mensaje de registro. Si se proporciona una tupla de excepción (en el formato retornado por <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>) o se proporciona una instancia de excepción, se utiliza; de lo contrario, se llama a <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> para obtener la información de excepción.</p>
<p>El segundo argumento opcional con la palabra clave <em>stack_info</em>, que por defecto es <code class="docutils literal notranslate"><span class="pre">False</span></code>. Si es verdadero, la información de la pila agregara el mensaje de registro, incluida la actual llamada del registro. Tenga en cuenta que esta no es la misma información de la pila que se muestra al especificar <em>exc_info</em>: la primera son los cuadros de la pila desde la parte inferior de la pila hasta la llamada de registro en el hilo actual, mientras que la segunda es la información sobre los cuadros de la pila que se han desenrollado, siguiendo una excepción, mientras busca gestores de excepción.</p>
<p>Puede especificar <em>stack_info</em> independientemente de <em>exc_info</em>, por ejemplo solo para mostrar cómo llegaste a cierto punto en tu código, incluso cuando no se lanzaron excepciones. Los marcos de la pila se imprimen siguiendo una línea de encabezado que dice:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Stack (most recent call last):
</pre></div>
</div>
<p>Esto imita el <code class="docutils literal notranslate"><span class="pre">Traceback</span> <span class="pre">(most</span> <span class="pre">recent</span> <span class="pre">call</span> <span class="pre">last):</span></code> que se usa cuando se muestran marcos de excepción.</p>
<p>El tercer argumento opcional con la palabra clave <em>stacklevel</em>, que por defecto es <code class="docutils literal notranslate"><span class="pre">1</span></code>. Si es mayor que 1, se omite el número correspondiente de cuadros de pila al calcular el número de línea y el nombre de la función establecidos en <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> creado para el evento de registro. Esto se puede utilizar en el registro de ayudantes para que el nombre de la función, el nombre de archivo y el número de línea registrados no sean la información para la función/método auxiliar, sino más bien su llamador. El nombre de este parámetro refleja el equivalente en el modulo <a class="reference internal" href="warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code></a>.</p>
<p>El cuarto argumento de palabra clave es <em>extra</em>, que se puede usar para pasar un diccionario que se usa para completar el __dict__ de <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> creado para el evento de registro con atributos definidos por el usuario. Estos atributos personalizados se pueden usar a su gusto. Podrían incorporarse en mensajes registrados. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">FORMAT</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%(asctime)s</span><span class="s1"> </span><span class="si">%(clientip)-15s</span><span class="s1"> </span><span class="si">%(user)-8s</span><span class="s1"> </span><span class="si">%(message)s</span><span class="s1">&#39;</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">FORMAT</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;clientip&#39;</span><span class="p">:</span> <span class="s1">&#39;192.168.0.1&#39;</span><span class="p">,</span> <span class="s1">&#39;user&#39;</span><span class="p">:</span> <span class="s1">&#39;fbloggs&#39;</span><span class="p">}</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;tcpserver&#39;</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Protocol problem: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;connection reset&#39;</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p>imprimiría algo como</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset
</pre></div>
</div>
<p>The keys in the dictionary passed in <em>extra</em> should not clash with the keys used
by the logging system. (See the section on <a class="reference internal" href="#logrecord-attributes"><span class="std std-ref">Atributos LogRecord</span></a> for more
information on which keys are used by the logging system.)</p>
<p>Si elige usar estos atributos en los mensajes registrados, debe tener cuidado. En el ejemplo anterior, se ha configurado <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> con una cadena de formato que espera <em>clientip</em> y “usuario” en el diccionario de atributos de <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a>. Si faltan, el mensaje no se registrará porque se producirá una excepción de formato de cadena. En este caso, siempre debe pasar el diccionario <em>extra</em> con estas teclas.</p>
<p>Si bien esto puede ser molesto, esta función está diseñada para su uso en circunstancias especializadas, como servidores de subprocesos múltiples donde el mismo código se ejecuta en muchos contextos, y las condiciones interesantes que surgen dependen de este contexto (como la dirección IP del cliente remoto y autenticado nombre de usuario, en el ejemplo anterior). En tales circunstancias, es probable que se especialice <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a>s con particular <a class="reference internal" href="#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handler</span></code></a>s.</p>
<p>Si no hay ningún controlador asociado a este registrador (o cualquiera de sus antepasados, teniendo en cuenta los atributos relevantes <a class="reference internal" href="#logging.Logger.propagate" title="logging.Logger.propagate"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Logger.propagate</span></code></a>), el mensaje se enviará al controlador establecido en <a class="reference internal" href="#logging.lastResort" title="logging.lastResort"><code class="xref py py-attr docutils literal notranslate"><span class="pre">lastResort</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Se agregó el parámetro <em>stack_info</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>El parámetro <em>exc_info</em> ahora puede aceptar instancias de excepción.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Se agregó el parámetro <em>stacklevel</em>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.info">
<span class="sig-name descname"><span class="pre">info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.info" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Registra un mensaje con el nivel <code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code> en este logger. Los argumentos se interpretan como <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.warning">
<span class="sig-name descname"><span class="pre">warning</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.warning" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Registra un mensaje con el nivel <code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code> en este logger. Los argumentos se interpretan como <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Hay un método obsoleto <code class="docutils literal notranslate"><span class="pre">warn</span></code> que es funcionalmente idéntico a <code class="docutils literal notranslate"><span class="pre">warning</span></code>. Como <code class="docutils literal notranslate"><span class="pre">warn</span></code> está en desuso, no lo use, use <code class="docutils literal notranslate"><span class="pre">warning</span></code> en su lugar.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.error">
<span class="sig-name descname"><span class="pre">error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.error" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Registra un mensaje con nivel <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code> en este logger. Los argumentos se interpretan como <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.critical">
<span class="sig-name descname"><span class="pre">critical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.critical" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Registra un mensaje con el nivel <code class="xref py py-const docutils literal notranslate"><span class="pre">CRITICAL</span></code> en este logger. Los argumentos se interpretan como <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.log" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Registra un mensaje con nivel entero <em>level</em> en este logger. Los otros argumentos se interpretan como <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.exception">
<span class="sig-name descname"><span class="pre">exception</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.exception" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Registra un mensaje con nivel <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code> en este logger. Los argumentos se interpretan como <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>. La información de excepción se agrega al mensaje de registro. Este método solo debe llamarse desde un gestor de excepciones.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.addFilter">
<span class="sig-name descname"><span class="pre">addFilter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filter</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.addFilter" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Agrega el filtro <em>filter</em> especificado a este logger.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.removeFilter">
<span class="sig-name descname"><span class="pre">removeFilter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filter</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.removeFilter" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Elimina el filtro <em>filter</em> especificado de este logger.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.filter">
<span class="sig-name descname"><span class="pre">filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.filter" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Aplique los filtros de este logger al registro y retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si se va a procesar el registro. Los filtros se consultan a su vez, hasta que uno de ellos retorna un valor falso. Si ninguno de ellos retorna un valor falso, el registro será procesado (pasado a los gestores). Si se retorna un valor falso, no se produce más procesamiento del registro.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.addHandler">
<span class="sig-name descname"><span class="pre">addHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hdlr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.addHandler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Agrega el gestor especificado <em>hdlr</em> a este logger.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.removeHandler">
<span class="sig-name descname"><span class="pre">removeHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hdlr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.removeHandler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Elimina el gestor especificado <em>hdlr</em> de este logger.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.findCaller">
<span class="sig-name descname"><span class="pre">findCaller</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stack_info</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stacklevel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.findCaller" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Encuentra el nombre de archivo de origen de la invoca y el número de línea. Retorna el nombre del archivo, el número de línea, el nombre de la función y la información de la pila como una tupla de 4 elementos. La información de la pila se retorna como <code class="docutils literal notranslate"><span class="pre">None</span></code> a menos que <em>stack_info</em> sea <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>El parámetro <em>stacklevel</em> se pasa del código que llama a <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a> y otras API. Si es mayor que 1, el exceso se utiliza para omitir los cuadros de la pila antes de determinar los valores que se retornarán. Esto generalmente será útil al llamar a las API de registro desde un <em>helper/wrapper</em>, de modo que la información en el registro de eventos no se refiera al <em>helper/wrapper</em>, sino al código que lo llama.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.handle">
<span class="sig-name descname"><span class="pre">handle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.handle" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Gestiona un registro pasándolo a todos los gestores asociados con este logger y sus antepasados (hasta que se encuentre un valor falso de <em>propagar</em>). Este método se utiliza para registros no empaquetados recibidos de un socket, así como para aquellos creados localmente. El filtrado a nivel de logger se aplica usando <a class="reference internal" href="#logging.Logger.filter" title="logging.Logger.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.makeRecord">
<span class="sig-name descname"><span class="pre">makeRecord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lno</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sinfo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.makeRecord" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este es un método <em>factory</em> que se puede sobreescribir en subclases para crear instancias especializadas <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Logger.hasHandlers">
<span class="sig-name descname"><span class="pre">hasHandlers</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.hasHandlers" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Comprueba si este logger tiene algún controlador configurado. Esto se hace buscando gestores en este logger y sus padres en la jerarquía del logger. Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si se encontró un gestor, de lo contrario, <code class="docutils literal notranslate"><span class="pre">False</span></code> . El método deja de buscar en la jerarquía cada vez que se encuentra un logger con el atributo <em>propagate</em> establecido en falso: ese será el último logger que verificará la existencia de gestores.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Los logger ahora se pueden serializar y deserializar (<em>pickled and unpickled</em>).</p>
</div>
</dd></dl>

</section>
<section id="logging-levels">
<span id="levels"></span><h2>Niveles de logging<a class="headerlink" href="#logging-levels" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los valores numéricos de los niveles de logging se dan en la siguiente tabla. Estos son principalmente de interés si desea definir sus propios niveles y necesita que tengan valores específicos en relación con los niveles predefinidos. Si define un nivel con el mismo valor numérico, sobrescribe el valor predefinido; se pierde el nombre predefinido.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 48%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Nivel</p></th>
<th class="head"><p>Valor numérico</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">CRITICAL</span></code></p></td>
<td><p>50</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ERROR</span></code></p></td>
<td><p>40</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">WARNING</span></code></p></td>
<td><p>30</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">INFO</span></code></p></td>
<td><p>20</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DEBUG</span></code></p></td>
<td><p>10</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">NOTSET</span></code></p></td>
<td><p>0</p></td>
</tr>
</tbody>
</table>
</section>
<section id="handler-objects">
<span id="handler"></span><h2>Gestor de objetos<a class="headerlink" href="#handler-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los gestores tienen los siguientes atributos y métodos. Tenga en cuenta que <a class="reference internal" href="#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handler</span></code></a> nunca se instancia directamente; Esta clase actúa como base para subclases más útiles. Sin embargo, el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> en las subclases debe llamar a <a class="reference internal" href="#logging.Handler.__init__" title="logging.Handler.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Handler.__init__()</span></code></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="logging.Handler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">Handler</span></span><a class="headerlink" href="#logging.Handler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">NOTSET</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.__init__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Inicializa la instancia <a class="reference internal" href="#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handler</span></code></a> estableciendo su nivel, configurando la lista de filtros en la lista vacía y creando un bloqueo (usando <a class="reference internal" href="#logging.Handler.createLock" title="logging.Handler.createLock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">createLock()</span></code></a>) para serializar el acceso a un mecanismo de E/S.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.createLock">
<span class="sig-name descname"><span class="pre">createLock</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.createLock" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Inicializa un bloqueo de subprocesos que se puede utilizar para serializar el acceso a la funcionalidad de E/S subyacente que puede no ser segura para subprocesos.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.acquire">
<span class="sig-name descname"><span class="pre">acquire</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.acquire" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Adquiere el bloqueo de hilo creado con <a class="reference internal" href="#logging.Handler.createLock" title="logging.Handler.createLock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">createLock()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.release">
<span class="sig-name descname"><span class="pre">release</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.release" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Libera el bloqueo de hilo adquirido con <a class="reference internal" href="#logging.Handler.acquire" title="logging.Handler.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.setLevel">
<span class="sig-name descname"><span class="pre">setLevel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.setLevel" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece el umbral para este gestor en <em>level</em>. Los mensajes de registro que son menos severos que <em>level</em> serán ignorados. Cuando se crea un controlador, el nivel se establece en <code class="xref py py-const docutils literal notranslate"><span class="pre">NOTSET</span></code> (lo que hace que se procesen todos los mensajes).</p>
<p>Ver <a class="reference internal" href="#levels"><span class="std std-ref">Niveles de logging</span></a> para obtener una lista de niveles.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>El parámetro <em>level</em> ahora acepta una representación de cadena del nivel como “INFO” como alternativa a las constantes de enteros como <code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.setFormatter">
<span class="sig-name descname"><span class="pre">setFormatter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.setFormatter" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> para este controlador en <em>fmt</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.addFilter">
<span class="sig-name descname"><span class="pre">addFilter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filter</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.addFilter" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Agrega el filtro <em>filter</em> especificado a este gestor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.removeFilter">
<span class="sig-name descname"><span class="pre">removeFilter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filter</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.removeFilter" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Elimina el filtro especificado <em>filter</em> de este gestor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.filter">
<span class="sig-name descname"><span class="pre">filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.filter" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Aplique los filtros de este gestor al registro y retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si se va a procesar el registro. Los filtros se consultan a su vez, hasta que uno de ellos retorna un valor falso. Si ninguno de ellos retorna un valor falso, se emitirá el registro. Si uno retorna un valor falso, el controlador no emitirá el registro.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.flush">
<span class="sig-name descname"><span class="pre">flush</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.flush" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Asegúrese de que toda la salida de logging se haya vaciado. Esta versión no hace nada y está destinada a ser implementada por subclases.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.close" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Poner en orden los recursos utilizados por el gestor. Esta versión no genera salida, pero elimina el controlador de una lista interna de gestores que se cierra cuando se llama a <a class="reference internal" href="#logging.shutdown" title="logging.shutdown"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutdown()</span></code></a>. Las subclases deben garantizar que esto se llame desde métodos <a class="reference internal" href="#logging.Handler.close" title="logging.Handler.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> sobreescritos.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.handle">
<span class="sig-name descname"><span class="pre">handle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.handle" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Emite condicionalmente el registro especifico, según los filtros que se hayan agregado al controlador. Envuelve la actual emisión del registro con <em>acquisition/release</em> del hilo de bloqueo E/S.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.handleError">
<span class="sig-name descname"><span class="pre">handleError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.handleError" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método debe llamarse desde los gestores cuando se encuentra una excepción durante una llamada a <a class="reference internal" href="#logging.Handler.emit" title="logging.Handler.emit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">emit()</span></code></a>. Si el atributo de nivel de módulo <code class="docutils literal notranslate"><span class="pre">raiseExceptions</span></code> es <code class="docutils literal notranslate"><span class="pre">False</span></code>, las excepciones se ignoran silenciosamente. Esto es lo que más se necesita para un sistema de registro: a la mayoría de los usuarios no les importan los errores en el sistema de registro, están más interesados en los errores de la aplicación. Sin embargo, puede reemplazar esto con un gestor personalizado si lo desea. El registro especificado es el que se estaba procesando cuando se produjo la excepción. (El valor predeterminado de <code class="docutils literal notranslate"><span class="pre">raiseExceptions</span></code> es <code class="docutils literal notranslate"><span class="pre">True</span></code>, ya que es más útil durante el desarrollo).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.format">
<span class="sig-name descname"><span class="pre">format</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.format" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Formato para un registro - si se configura un formateador, úselo. De lo contrario, use el formateador predeterminado para el módulo.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Handler.emit">
<span class="sig-name descname"><span class="pre">emit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Handler.emit" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Haga lo que sea necesario para registrar de forma especifica el registro. Esta versión está destinada a ser implementada por subclases y, por lo tanto, lanza un <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>Este método es llamado después de que un bloqueo a nivel de gestor es adquirido, el cual es liberado después de que este método retorna. Cuando sobrescriba este método, tenga en cuenta que debe tener cuidado al llamar a cualquier cosa que invoque a otras partes de la API de registro que puedan realizar bloqueos, ya que esto podría provocar un bloqueo. Específicamente:</p>
<ul class="simple">
<li><p>Las API de configuración del registro adquieren el bloqueo a nivel de módulo y, a continuación, los bloqueos a nivel de gestor individual a medida que se configuran dichos gestores.</p></li>
<li><p>Many logging APIs lock the module-level lock. If such an API is called
from this method, it could cause a deadlock if a configuration call is
made on another thread, because that thread will try to acquire the
module-level lock <em>before</em> the handler-level lock, whereas this thread
tries to acquire the module-level lock <em>after</em> the handler-level lock
(because in this method, the handler-level lock has already been acquired).</p></li>
</ul>
</div>
</dd></dl>

</dd></dl>

<p>Para obtener una lista de gestores incluidos como estándar, consulte <a class="reference internal" href="logging.handlers.html#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a>.</p>
</section>
<section id="formatter-objects">
<span id="id1"></span><h2>Objetos formateadores<a class="headerlink" href="#formatter-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<p><a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> tiene los siguientes atributos y métodos. Son responsables de convertir una <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> a (generalmente) una cadena que puede ser interpretada por un sistema humano o externo. La base <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> permite especificar una cadena de formato. Si no se proporciona ninguno, se utiliza el valor predeterminado de <code class="docutils literal notranslate"><span class="pre">'%(message)s'</span></code>, que solo incluye el mensaje en la llamada de registro. Para tener elementos de información adicionales en la salida formateada (como una marca de tiempo), siga leyendo.</p>
<p>Un formateador se puede inicializar con una cadena de formato que utiliza el conocimiento de los atributos <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a>, como el valor predeterminado mencionado anteriormente, haciendo uso del hecho de que el mensaje y los argumentos del usuario están formateados previamente en <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a>’s con <em>message</em> como atributo. Esta cadena de formato contiene claves de mapeo de Python %-style estándar. Ver la sección <a class="reference internal" href="stdtypes.html#old-string-formatting"><span class="std std-ref">Formateo de cadenas al estilo *printf*</span></a> para obtener más información sobre el formato de cadenas.</p>
<p>Las claves de mapeo útiles en a <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> se dan en la sección sobre <a class="reference internal" href="#logrecord-attributes"><span class="std std-ref">Atributos LogRecord</span></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="logging.Formatter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">Formatter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">datefmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">style</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'%'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">defaults</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Formatter" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una nueva instancia de <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a>. La instancia se inicializa con una cadena de formato para el mensaje en su conjunto, así como una cadena de formato para la porción fecha/hora de un mensaje. Si no se especifica <em>fmt</em>, se utiliza <code class="docutils literal notranslate"><span class="pre">'%(message)s'</span></code>. Si no se especifica <em>datefmt</em>, se utiliza un formato que se describe en la documentación <a class="reference internal" href="#logging.Formatter.formatTime" title="logging.Formatter.formatTime"><code class="xref py py-meth docutils literal notranslate"><span class="pre">formatTime()</span></code></a>.</p>
<p>El parámetro <em>style</em> puede ser uno de “%”, “{”” o “$” y determina cómo se fusionará la cadena de formato con sus datos: usando uno de %-formatting, <a class="reference internal" href="stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> o <a class="reference internal" href="string.html#string.Template" title="string.Template"><code class="xref py py-class docutils literal notranslate"><span class="pre">string.Template</span></code></a>. Esto solo aplica al formato de cadenas de caracteres <em>fmt</em> (e.j. <code class="docutils literal notranslate"><span class="pre">'%(message)s'</span></code> o <code class="docutils literal notranslate"><span class="pre">{message}</span></code>), no al mensaje pasado actualmente al <code class="docutils literal notranslate"><span class="pre">Logger.debug</span></code> etc; ver <a class="reference internal" href="../howto/logging-cookbook.html#formatting-styles"><span class="std std-ref">Usar estilos de formato particulares en toda su aplicación</span></a> para más información sobre usar {- y formateado-$ para mensajes de log.</p>
<p>El parámetro <em>defaults</em> puede ser un diccionario con valores por defecto para usar en campos personalizados. Por ejemplo: <code class="docutils literal notranslate"><span class="pre">logging.Formatter('%(ip)s</span> <span class="pre">%(message)s',</span> <span class="pre">defaults={&quot;ip&quot;:</span> <span class="pre">None})</span></code></p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Se agregó el parámetro <em>style</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Se agregó el parámetro <em>validate</em>. Si el estilo es incorrecto o no coincidente, <em>fmt</em> lanzará un <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>. Por ejemplo: <code class="docutils literal notranslate"><span class="pre">logging.Formatter('%(asctime)s</span> <span class="pre">-</span> <span class="pre">%(message)s',</span> <span class="pre">style='{')</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Se agregó el parámetro <em>defaults</em>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="logging.Formatter.format">
<span class="sig-name descname"><span class="pre">format</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Formatter.format" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>The record’s attribute dictionary is used as the operand to a string
formatting operation. Returns the resulting string. Before formatting the
dictionary, a couple of preparatory steps are carried out. The <em>message</em>
attribute of the record is computed using <em>msg</em> % <em>args</em>. If the
formatting string contains <code class="docutils literal notranslate"><span class="pre">'(asctime)'</span></code>, <a class="reference internal" href="#logging.Formatter.formatTime" title="logging.Formatter.formatTime"><code class="xref py py-meth docutils literal notranslate"><span class="pre">formatTime()</span></code></a> is called
to format the event time. If there is exception information, it is
formatted using <a class="reference internal" href="#logging.Formatter.formatException" title="logging.Formatter.formatException"><code class="xref py py-meth docutils literal notranslate"><span class="pre">formatException()</span></code></a> and appended to the message. Note
that the formatted exception information is cached in attribute
<em>exc_text</em>. This is useful because the exception information can be
pickled and sent across the wire, but you should be careful if you have
more than one <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> subclass which customizes the formatting
of exception information. In this case, you will have to clear the cached
value (by setting the <em>exc_text</em> attribute to <code class="docutils literal notranslate"><span class="pre">None</span></code>) after a formatter
has done its formatting, so that the next formatter to handle the event
doesn’t use the cached value, but recalculates it afresh.</p>
<p>Si la información de la pila está disponible, se agrega después de la información de la excepción, usando <a class="reference internal" href="#logging.Formatter.formatStack" title="logging.Formatter.formatStack"><code class="xref py py-meth docutils literal notranslate"><span class="pre">formatStack()</span></code></a> para transformarla si es necesario.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Formatter.formatTime">
<span class="sig-name descname"><span class="pre">formatTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">datefmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Formatter.formatTime" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método debe ser llamado desde <a class="reference internal" href="functions.html#format" title="format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">format()</span></code></a> por un formateador que espera un tiempo formateado . Este método se puede reemplazar en formateadores para proporcionar cualquier requisito específico, pero el comportamiento básico es el siguiente: if <em>datefmt</em> (una cadena), se usa con <a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.strftime()</span></code></a> para formatear el tiempo de creación del registro De lo contrario, se utiliza el formato “%Y-%m-%d %H:%M:%S,uuu”, donde la parte <em>uuu</em> es un valor de milisegundos y las otras letras son <a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.strftime()</span></code></a> . Un ejemplo de tiempo en este formato es <code class="docutils literal notranslate"><span class="pre">2003-01-23</span> <span class="pre">00:29:50,411</span></code>. Se retorna la cadena resultante.</p>
<p>Esta función utiliza una función configurable por el usuario para convertir el tiempo de creación en una tupla. Por defecto, se utiliza <a class="reference internal" href="time.html#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.localtime()</span></code></a>; Para cambiar esto para una instancia de formateador particular, se agrega el atributo <code class="docutils literal notranslate"><span class="pre">converter</span></code> en una función con igual firma como <a class="reference internal" href="time.html#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.localtime()</span></code></a> o <a class="reference internal" href="time.html#time.gmtime" title="time.gmtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.gmtime()</span></code></a>. Para cambiarlo en todos los formateadores, por ejemplo, si desea que todos los tiempos de registro se muestren en GMT, agregue el atributo <code class="docutils literal notranslate"><span class="pre">converter</span></code> en la clase <code class="docutils literal notranslate"><span class="pre">Formatter</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Anteriormente, el formato predeterminado estaba codificado como en este ejemplo: <code class="docutils literal notranslate"><span class="pre">2010-09-06</span> <span class="pre">22:38:15,292</span></code> donde la parte anterior a la coma es manejada por una cadena de formato strptime (<code class="docutils literal notranslate"><span class="pre">'%Y-%m-%d</span> <span class="pre">%H:%M:%S'</span></code>), y la parte después de la coma es un valor de milisegundos. Debido a que strptime no tiene una posición de formato para milisegundos, el valor de milisegundos se agrega usando otra cadena de formato, <code class="docutils literal notranslate"><span class="pre">'%s,%03d'</span></code>— ambas cadenas de formato se han codificado en este método. Con el cambio, estas cadenas se definen como atributos de nivel de clase que pueden <em>overridden</em> a nivel de instancia cuando se desee. Los nombres de los atributos son <code class="docutils literal notranslate"><span class="pre">default_time_format</span></code> (para una cadena de formato strptime) y <code class="docutils literal notranslate"><span class="pre">default_msec_format</span></code> (para agregar el valor de milisegundos).</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.9: </span>El formato <code class="docutils literal notranslate"><span class="pre">default_msec_format</span></code> puede ser <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Formatter.formatException">
<span class="sig-name descname"><span class="pre">formatException</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exc_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Formatter.formatException" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Formatea la información de una excepción especificada (una excepción como una tupla estándar es retornada por <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>) como una cadena. Esta implementación predeterminada solo usa <a class="reference internal" href="traceback.html#traceback.print_exception" title="traceback.print_exception"><code class="xref py py-func docutils literal notranslate"><span class="pre">traceback.print_exception()</span></code></a>. La cadena resultantes retornada.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.Formatter.formatStack">
<span class="sig-name descname"><span class="pre">formatStack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stack_info</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Formatter.formatStack" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Formatea la información de una pila especificada (una cadena es retornada por <a class="reference internal" href="traceback.html#traceback.print_stack" title="traceback.print_stack"><code class="xref py py-func docutils literal notranslate"><span class="pre">traceback.print_stack()</span></code></a>, pero con la ultima línea removida) como una cadena. Esta implementación predeterminada solo retorna el valor de entrada.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="logging.BufferingFormatter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">BufferingFormatter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">linefmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.BufferingFormatter" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>A base formatter class suitable for subclassing when you want to format a
number of records. You can pass a <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> instance which you want
to use to format each line (that corresponds to a single record). If not
specified, the default formatter (which just outputs the event message) is
used as the line formatter.</p>
<dl class="py method">
<dt class="sig sig-object py" id="logging.BufferingFormatter.formatHeader">
<span class="sig-name descname"><span class="pre">formatHeader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">records</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.BufferingFormatter.formatHeader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una cabecera para una lista de <em>registros</em>. La implementación base sólo retorna la cadena vacía. Tendrá que anular este método si desea un comportamiento específico, por ejemplo, mostrar el recuento de registros, un título o una línea separadora.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.BufferingFormatter.formatFooter">
<span class="sig-name descname"><span class="pre">formatFooter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">records</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.BufferingFormatter.formatFooter" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un pie de página para una lista de <em>registros</em>. La implementación base sólo retorna la cadena vacía. Tendrá que anular este método si desea un comportamiento específico, por ejemplo, para mostrar el recuento de registros o una línea separadora.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="logging.BufferingFormatter.format">
<span class="sig-name descname"><span class="pre">format</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">records</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.BufferingFormatter.format" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el texto formateado de una lista de <em>registros</em>. La implementación base sólo retorna la cadena vacía si no hay registros; en caso contrario, retorna la concatenación de la cabecera, cada registro formateado con el formateador de líneas y el pie de página.</p>
</dd></dl>

</dd></dl>

</section>
<section id="filter-objects">
<span id="filter"></span><h2>Filtro de Objetos<a class="headerlink" href="#filter-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los <code class="docutils literal notranslate"><span class="pre">Manejadores</span></code> y los <code class="docutils literal notranslate"><span class="pre">Registradores</span></code> pueden usar los <code class="docutils literal notranslate"><span class="pre">Filtros</span></code> para un filtrado más sofisticado que el proporcionado por los niveles. La clase de filtro base solo permite eventos que están por debajo de cierto punto en la jerarquía del logger. Por ejemplo, un filtro inicializado con “A.B” permitirá los eventos registrados por los logger “A.B”, “A.B.C”, “A.B.C.D”, “A.B.D” etc., pero no “A.BB”, “B.A.B”, etc. Si se inicializa con una cadena vacía, se pasan todos los eventos.</p>
<dl class="py class">
<dt class="sig sig-object py" id="logging.Filter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">Filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Filter" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una instancia de la clase <a class="reference internal" href="#logging.Filter" title="logging.Filter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Filter</span></code></a>. Si se especifica <em>name</em>, nombra un logger que, junto con sus hijos, tendrá sus eventos permitidos a través del filtro. Si <em>name</em> es una cadena vacía, permite todos los eventos.</p>
<dl class="py method">
<dt class="sig sig-object py" id="logging.Filter.filter">
<span class="sig-name descname"><span class="pre">filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">record</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Filter.filter" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>¿Se apuntará el registro especificado? Retorna cero para no, distinto de cero para sí. Si se considera apropiado, el registro puede modificarse in situ mediante este método.</p>
</dd></dl>

</dd></dl>

<p>Tenga en cuenta que los filtros adjuntos a los gestores se consultan antes de que el gestor emita un evento, mientras que los filtros adjuntos a los loggers se consultan cada vez que se registra un evento (usando <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>, <a class="reference internal" href="#logging.info" title="logging.info"><code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code></a>, etc.), antes de enviar un evento a los gestores. Esto significa que los eventos que han sido generados por loggers descendientes no serán filtrados por la configuración del filtro del logger, a menos que el filtro también se haya aplicado a esos loggers descendientes.</p>
<p>En realidad, no se necesita la subclase <code class="docutils literal notranslate"><span class="pre">Filtro</span></code>: se puede pasar cualquier instancia que tenga un método de <code class="docutils literal notranslate"><span class="pre">filter</span></code> con la misma semántica.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>No es necesario crear clases especializadas de <code class="docutils literal notranslate"><span class="pre">Filter</span></code> ni usar otras clases con un método <code class="docutils literal notranslate"><span class="pre">filter</span></code>: puede usar una función (u otra invocable) como filtro. La lógica de filtrado verificará si el objeto de filtro tiene un atributo <code class="docutils literal notranslate"><span class="pre">filter</span></code>: si lo tiene, se asume que es un <code class="docutils literal notranslate"><span class="pre">Filter</span></code> y se llama a su método <a class="reference internal" href="#logging.Filter.filter" title="logging.Filter.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a>. De lo contrario, se supone que es invocable y se llama con el registro como único parámetro. El valor retornado debe ajustarse al retornado por <a class="reference internal" href="#logging.Filter.filter" title="logging.Filter.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a>.</p>
</div>
<p>Aunque los filtros se utilizan principalmente para filtrar registros basados en criterios más sofisticados que los niveles, son capaces de ver cada registro que es procesado por el gestor o logger al que están adjuntos: esto puede ser útil si desea hacer cosas como contar cuántos registros fueron procesados por un logger o gestor en particular, o agregando, cambiando o quitando atributos en <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> que se está procesando. Obviamente, el cambio de LogRecord debe hacerse con cierto cuidado, pero permite la inyección de información contextual en los registros (ver <a class="reference internal" href="../howto/logging-cookbook.html#filters-contextual"><span class="std std-ref">Usar filtros para impartir información contextual</span></a>).</p>
</section>
<section id="logrecord-objects">
<span id="log-record"></span><h2>Objetos LogRecord<a class="headerlink" href="#logrecord-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las instancias <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> son creadas automáticamente por <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> cada vez que se registra algo, y se pueden crear manualmente a través de <a class="reference internal" href="#logging.makeLogRecord" title="logging.makeLogRecord"><code class="xref py py-func docutils literal notranslate"><span class="pre">makeLogRecord()</span></code></a> (por ejemplo, a partir de un evento serializado (<em>pickled</em>) recibido en la transmisión).</p>
<dl class="py class">
<dt class="sig sig-object py" id="logging.LogRecord">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">LogRecord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pathname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lineno</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc_info</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sinfo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.LogRecord" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Contiene toda la información pertinente al evento que se registra.</p>
<p>The primary information is passed in <em>msg</em> and <em>args</em>,
which are combined using <code class="docutils literal notranslate"><span class="pre">msg</span> <span class="pre">%</span> <span class="pre">args</span></code> to create
the <code class="xref py py-attr docutils literal notranslate"><span class="pre">message</span></code> attribute of the record.</p>
<dl class="field-list simple">
<dt class="field-odd">Parámetros</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<a class="reference internal" href="stdtypes.html#str" title="str"><em>str</em></a>) – The name of the logger used to log the event
represented by this <code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code>.
Note that the logger name in the <code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code>
will always have this value,
even though it may be emitted by a handler
attached to a different (ancestor) logger.</p></li>
<li><p><strong>level</strong> (<a class="reference internal" href="functions.html#int" title="int"><em>int</em></a>) – El <a class="reference internal" href="#levels"><span class="std std-ref">numeric level</span></a> del evento de registro (como <code class="docutils literal notranslate"><span class="pre">10</span></code> para <code class="docutils literal notranslate"><span class="pre">DEBUG</span></code>, <code class="docutils literal notranslate"><span class="pre">20</span></code> para <code class="docutils literal notranslate"><span class="pre">INFO</span></code>, etc). Tenga en cuenta que esto se convierte en <em>dos</em> atributos del LogRecord: <code class="xref py py-attr docutils literal notranslate"><span class="pre">levelno</span></code> para el valor numérico y <code class="xref py py-attr docutils literal notranslate"><span class="pre">levelname</span></code> para el nombre del nivel correspondiente.</p></li>
<li><p><strong>pathname</strong> (<a class="reference internal" href="stdtypes.html#str" title="str"><em>str</em></a>) – The full string path of the source file
where the logging call was made.</p></li>
<li><p><strong>lineno</strong> (<a class="reference internal" href="functions.html#int" title="int"><em>int</em></a>) – El número de línea en el archivo de origen donde se realizó la llamada logging.</p></li>
<li><p><strong>msg</strong> (<a class="reference internal" href="stdtypes.html#str" title="str"><em>str</em></a>) – The event description message,
which can be a %-format string with placeholders for variable data.</p></li>
<li><p><strong>args</strong> (<a class="reference internal" href="stdtypes.html#tuple" title="tuple"><em>tuple</em></a><em> | </em><a class="reference internal" href="stdtypes.html#dict" title="dict"><em>dict</em></a><em>[</em><a class="reference internal" href="stdtypes.html#str" title="str"><em>str</em></a><em>, </em><a class="reference internal" href="typing.html#typing.Any" title="typing.Any"><em>Any</em></a><em>]</em>) – Datos variables para fusionar en el argumento <em>msg</em> para obtener la descripción del evento.</p></li>
<li><p><strong>exc_info</strong> (<a class="reference internal" href="stdtypes.html#tuple" title="tuple"><em>tuple</em></a><em>[</em><a class="reference internal" href="functions.html#type" title="type"><em>type</em></a><em>[</em><a class="reference internal" href="exceptions.html#BaseException" title="BaseException"><em>BaseException</em></a><em>]</em><em>, </em><a class="reference internal" href="exceptions.html#BaseException" title="BaseException"><em>BaseException</em></a><em>, </em><a class="reference internal" href="types.html#types.TracebackType" title="types.TracebackType"><em>types.TracebackType</em></a><em>] </em><em>| </em><em>None</em>) – An exception tuple with the current exception information,
as returned by <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>,
or <code class="docutils literal notranslate"><span class="pre">None</span></code> if no exception information is available.</p></li>
<li><p><strong>func</strong> (<a class="reference internal" href="stdtypes.html#str" title="str"><em>str</em></a><em> | </em><em>None</em>) – El nombre de la función o método desde el que se invocó la llamada de logging.</p></li>
<li><p><strong>sinfo</strong> (<a class="reference internal" href="stdtypes.html#str" title="str"><em>str</em></a><em> | </em><em>None</em>) – Una cadena de texto que representa la información de la pila desde la base de la pila en el hilo actual, hasta la llamada de logging.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="logging.LogRecord.getMessage">
<span class="sig-name descname"><span class="pre">getMessage</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.LogRecord.getMessage" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el mensaje para la instancia <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> después de fusionar cualquier argumento proporcionado por el usuario con el mensaje. Si el argumento del mensaje proporcionado por el usuario para la llamada de logging no es una cadena de caracteres, se invoca <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> para convertirlo en una cadena. Esto permite el uso de clases definidas por el usuario como mensajes, cuyo método <code class="docutils literal notranslate"><span class="pre">__str__</span></code> puede retornar la cadena de formato real que se utilizará.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>La creación de <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> se ha hecho más configurable al proporcionar una fábrica que se utiliza para crear el registro. La fábrica se puede configurar usando <a class="reference internal" href="#logging.getLogRecordFactory" title="logging.getLogRecordFactory"><code class="xref py py-func docutils literal notranslate"><span class="pre">getLogRecordFactory()</span></code></a> y <a class="reference internal" href="#logging.setLogRecordFactory" title="logging.setLogRecordFactory"><code class="xref py py-func docutils literal notranslate"><span class="pre">setLogRecordFactory()</span></code></a> (ver esto para la firma de la fábrica).</p>
</div>
<p>Esta funcionalidad se puede utilizar para inyectar sus propios valores en <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> en el momento de la creación. Puede utilizar el siguiente patrón:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">old_factory</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogRecordFactory</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">record_factory</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">record</span> <span class="o">=</span> <span class="n">old_factory</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">record</span><span class="o">.</span><span class="n">custom_attribute</span> <span class="o">=</span> <span class="mh">0xdecafbad</span>
    <span class="k">return</span> <span class="n">record</span>

<span class="n">logging</span><span class="o">.</span><span class="n">setLogRecordFactory</span><span class="p">(</span><span class="n">record_factory</span><span class="p">)</span>
</pre></div>
</div>
<p>Con este patrón, se podrían encadenar varias fábricas y, siempre que no sobrescriban los atributos de las demás o se sobrescriban involuntariamente los atributos estándar enumerados anteriormente, no debería haber sorpresas.</p>
</dd></dl>

</section>
<section id="logrecord-attributes">
<span id="id2"></span><h2>Atributos LogRecord<a class="headerlink" href="#logrecord-attributes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>The LogRecord has a number of attributes, most of which are derived from the
parameters to the constructor. (Note that the names do not always correspond
exactly between the LogRecord constructor parameters and the LogRecord
attributes.) These attributes can be used to merge data from the record into
the format string. The following table lists (in alphabetical order) the
attribute names, their meanings and the corresponding placeholder in a %-style
format string.</p>
<p>Si utilizas formato-{} (<a class="reference internal" href="stdtypes.html#str.format" title="str.format"><code class="xref py py-func docutils literal notranslate"><span class="pre">str.format()</span></code></a>), puedes usar <code class="docutils literal notranslate"><span class="pre">{attrname}</span></code> como marcador de posición en la cadena de caracteres de formato. Si está utilizando formato-$ (<a class="reference internal" href="string.html#string.Template" title="string.Template"><code class="xref py py-class docutils literal notranslate"><span class="pre">string.Template</span></code></a>), use la forma <code class="docutils literal notranslate"><span class="pre">${attrname}</span></code>. En ambos casos, por supuesto, reemplace <code class="docutils literal notranslate"><span class="pre">attrname</span></code> con el nombre de atributo real que desea utilizar.</p>
<p>En el caso del formato-{}, puede especificar <em>flags</em> de formato colocándolos después del nombre del atributo, separados con dos puntos. Por ejemplo: un marcador de posición de <code class="docutils literal notranslate"><span class="pre">{msecs:03d}</span></code> formateará un valor de milisegundos de <code class="docutils literal notranslate"><span class="pre">4</span></code> como <code class="docutils literal notranslate"><span class="pre">004</span></code>. Consulte la documentación <a class="reference internal" href="stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> para obtener detalles completos sobre las opciones disponibles.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 28%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Nombre del atributo</p></th>
<th class="head"><p>Formato</p></th>
<th class="head"><p>Descripción</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>args</p></td>
<td><p>No debería necesitar formatear esto usted mismo.</p></td>
<td><p>La tupla de argumentos se fusionó en <code class="docutils literal notranslate"><span class="pre">msg</span></code> para producir un <code class="docutils literal notranslate"><span class="pre">messsage</span></code>, o un dict cuyos valores se utilizan para la fusión (cuando solo hay un argumento y es un diccionario).</p></td>
</tr>
<tr class="row-odd"><td><p>asctime</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(asctime)s</span></code></p></td>
<td><p>Fecha y Hora en formato legible por humanos cuando se creó <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a>. De forma predeterminada, tiene el formato “2003-07-08 16: 49: 45,896” (los números después de la coma son milisegundos).</p></td>
</tr>
<tr class="row-even"><td><p>created</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(created)f</span></code></p></td>
<td><p>Tiempo en que se creó <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> (según lo retornado por <a class="reference internal" href="time.html#time.time" title="time.time"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.time()</span></code></a>).</p></td>
</tr>
<tr class="row-odd"><td><p>exc_info</p></td>
<td><p>No debería necesitar formatear esto usted mismo.</p></td>
<td><p>Tupla de excepción (al modo <code class="docutils literal notranslate"><span class="pre">sys.exc_info</span></code>) o, si no se ha producido ninguna excepción, <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p>filename</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(filename)s</span></code></p></td>
<td><p>Parte del nombre de archivo de <code class="docutils literal notranslate"><span class="pre">pathname</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>funcName</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(funcName)s</span></code></p></td>
<td><p>Nombre de la función que contiene la llamada de logging.</p></td>
</tr>
<tr class="row-even"><td><p>levelname</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(levelname)s</span></code></p></td>
<td><p>Texto de nivel de logging para el mensaje (<code class="docutils literal notranslate"><span class="pre">'DEBUG'</span></code>, <code class="docutils literal notranslate"><span class="pre">'INFO'</span></code>, <code class="docutils literal notranslate"><span class="pre">'WARNING'</span></code>, <code class="docutils literal notranslate"><span class="pre">'ERROR'</span></code>, <code class="docutils literal notranslate"><span class="pre">'CRITICAL'</span></code>).</p></td>
</tr>
<tr class="row-odd"><td><p>levelno</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(levelno)s</span></code></p></td>
<td><p>Número de nivel de logging para el mensaje (<code class="xref py py-const docutils literal notranslate"><span class="pre">DEBUG</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">CRITICAL</span></code>).</p></td>
</tr>
<tr class="row-even"><td><p>lineno</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(lineno)d</span></code></p></td>
<td><p>Número de línea original donde se emitió la llamada de logging (si está disponible).</p></td>
</tr>
<tr class="row-odd"><td><p>message</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(message)s</span></code></p></td>
<td><p>El mensaje registrado, computado como <code class="docutils literal notranslate"><span class="pre">msg</span> <span class="pre">%</span> <span class="pre">args</span></code>. Esto se establece cuando se invoca <a class="reference internal" href="#logging.Formatter.format" title="logging.Formatter.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Formatter.format()</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><p>module</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(module)s</span></code></p></td>
<td><p>Módulo (parte del nombre de <code class="docutils literal notranslate"><span class="pre">filename</span></code>).</p></td>
</tr>
<tr class="row-odd"><td><p>msecs</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(msecs)d</span></code></p></td>
<td><p>Porción de milisegundos del tiempo en que se creó <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><p>msg</p></td>
<td><p>No debería necesitar formatear esto usted mismo.</p></td>
<td><p>La cadena de caracteres de formato pasada en la llamada logging original. Se fusionó con <code class="docutils literal notranslate"><span class="pre">args</span></code> para producir un <code class="docutils literal notranslate"><span class="pre">message</span></code>, o un objeto arbitrario (ver <a class="reference internal" href="../howto/logging.html#arbitrary-object-messages"><span class="std std-ref">Usando objetos arbitrarios como mensajes</span></a>).</p></td>
</tr>
<tr class="row-odd"><td><p>name</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(name)s</span></code></p></td>
<td><p>Nombre del logger usado para registrar la llamada.</p></td>
</tr>
<tr class="row-even"><td><p>pathname</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(pathname)s</span></code></p></td>
<td><p>Nombre de ruta completo del archivo de origen donde se emitió la llamada de logging (si está disponible).</p></td>
</tr>
<tr class="row-odd"><td><p>process</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(process)d</span></code></p></td>
<td><p>ID de proceso (si está disponible).</p></td>
</tr>
<tr class="row-even"><td><p>processName</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(processName)s</span></code></p></td>
<td><p>Nombre del proceso (si está disponible).</p></td>
</tr>
<tr class="row-odd"><td><p>relativeCreated</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(relativeCreated)d</span></code></p></td>
<td><p>Tiempo en milisegundos cuando se creó el LogRecord, en relación con el tiempo en que se cargó el módulo logging.</p></td>
</tr>
<tr class="row-even"><td><p>stack_info</p></td>
<td><p>No debería necesitar formatear esto usted mismo.</p></td>
<td><p>Apila la información del marco (si está disponible) desde la parte inferior de la pila en el hilo actual hasta la llamada de registro que dio como resultado la generación de este registro.</p></td>
</tr>
<tr class="row-odd"><td><p>thread</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(thread)d</span></code></p></td>
<td><p>ID de hilo (si está disponible).</p></td>
</tr>
<tr class="row-even"><td><p>threadName</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%(threadName)s</span></code></p></td>
<td><p>Nombre del hilo (si está disponible).</p></td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.1: </span><em>processName</em> fue agregado.</p>
</div>
</section>
<section id="loggeradapter-objects">
<span id="logger-adapter"></span><h2>Objetos LoggerAdapter<a class="headerlink" href="#loggeradapter-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las instancias <a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">LoggerAdapter</span></code></a> se utilizan para pasar convenientemente información contextual en las llamadas de logging. Para ver un ejemplo de uso, consulte la sección sobre <a class="reference internal" href="../howto/logging-cookbook.html#context-info"><span class="std std-ref">agregar información contextual a su salida de logging</span></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="logging.LoggerAdapter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">LoggerAdapter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logger</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.LoggerAdapter" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una instancia de <a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">LoggerAdapter</span></code></a> inicializada con una instancia subyacente <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> y un objeto del tipo <em>dict</em>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="logging.LoggerAdapter.process">
<span class="sig-name descname"><span class="pre">process</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.LoggerAdapter.process" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Modifica el mensaje y/o los argumentos de palabra clave pasados a una llamada de logging para insertar información contextual. Esta implementación toma el objeto pasado como <em>extra</em> al constructor y lo agrega a <em>kwargs</em> usando la clave “extra”. El valor de retorno es una tupla (<em>msg</em>, <em>kwargs</em>) que tiene las versiones (posiblemente modificadas) de los argumentos pasados.</p>
</dd></dl>

</dd></dl>

<p>Además de lo anterior, <a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">LoggerAdapter</span></code></a> admite los siguientes métodos de <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a>: <a class="reference internal" href="#logging.Logger.debug" title="logging.Logger.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>, <a class="reference internal" href="#logging.Logger.info" title="logging.Logger.info"><code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code></a>, <a class="reference internal" href="#logging.Logger.warning" title="logging.Logger.warning"><code class="xref py py-meth docutils literal notranslate"><span class="pre">warning()</span></code></a>, <a class="reference internal" href="#logging.Logger.error" title="logging.Logger.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">error()</span></code></a>, <a class="reference internal" href="#logging.Logger.exception" title="logging.Logger.exception"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exception()</span></code></a>, <a class="reference internal" href="#logging.Logger.critical" title="logging.Logger.critical"><code class="xref py py-meth docutils literal notranslate"><span class="pre">critical()</span></code></a>, <a class="reference internal" href="#logging.Logger.log" title="logging.Logger.log"><code class="xref py py-meth docutils literal notranslate"><span class="pre">log()</span></code></a>, <a class="reference internal" href="#logging.Logger.isEnabledFor" title="logging.Logger.isEnabledFor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isEnabledFor()</span></code></a>, <a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getEffectiveLevel()</span></code></a>, <a class="reference internal" href="#logging.Logger.setLevel" title="logging.Logger.setLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLevel()</span></code></a> y <a class="reference internal" href="#logging.Logger.hasHandlers" title="logging.Logger.hasHandlers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hasHandlers()</span></code></a>. Estos métodos tienen las mismas firmas que sus contrapartes en <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a>, por lo que puede usar los dos tipos de instancias indistintamente.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Los métodos <a class="reference internal" href="#logging.Logger.isEnabledFor" title="logging.Logger.isEnabledFor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isEnabledFor()</span></code></a>, <a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getEffectiveLevel()</span></code></a>, <a class="reference internal" href="#logging.Logger.setLevel" title="logging.Logger.setLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLevel()</span></code></a> y <a class="reference internal" href="#logging.Logger.hasHandlers" title="logging.Logger.hasHandlers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hasHandlers()</span></code></a> se agregaron a <a class="reference internal" href="#logging.LoggerAdapter" title="logging.LoggerAdapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">LoggerAdapter</span></code></a> . Estos métodos se delegan al logger subyacente.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Se añadieron el atributo Attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">manager</span></code> y el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">_log()</span></code>, que delegan al logger subyacente y permiten que los adaptadores se aniden.</p>
</div>
</section>
<section id="thread-safety">
<h2>Seguridad del hilo<a class="headerlink" href="#thread-safety" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El módulo logging está diseñado para ser seguro para subprocesos sin que sus clientes tengan que realizar ningún trabajo especial. Lo logra mediante el uso de bloqueos de hilos; hay un bloqueo para serializar el acceso a los datos compartidos del módulo, y cada gestor también crea un bloqueo para serializar el acceso a su E/S subyacente.</p>
<p>Si está implementando gestores de señales asíncronos usando el módulo <a class="reference internal" href="signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a>, es posible que no pueda usar logging desde dichos gestores. Esto se debe a que las implementaciones de bloqueo en el módulo <a class="reference internal" href="threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> no siempre son reentrantes y, por lo tanto, no se pueden invocar desde dichos gestores de señales.</p>
</section>
<section id="module-level-functions">
<h2>Funciones a nivel de módulo<a class="headerlink" href="#module-level-functions" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Además de las clases descritas anteriormente, hay una serie de funciones a nivel de módulo.</p>
<dl class="py function">
<dt class="sig sig-object py" id="logging.getLogger">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">getLogger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.getLogger" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un logger con el nombre especificado o, si el nombre es <code class="docutils literal notranslate"><span class="pre">None</span></code>, retorna un logger que es el logger principal de la jerarquía. Si se especifica, el nombre suele ser un nombre jerárquico separado por puntos como <em>“a”</em>, <em>“a.b”</em> or <em>“a.b.c.d”</em>. La elección de estos nombres depende totalmente del desarrollador que utiliza logging.</p>
<p>Todas las llamadas a esta función con un nombre dado retornan la misma instancia de logger. Esto significa que las instancias del logger nunca necesitan pasar entre diferentes partes de una aplicación.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.getLoggerClass">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">getLoggerClass</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.getLoggerClass" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna ya sea la clase estándar <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a>, o la última clase pasada a <a class="reference internal" href="#logging.setLoggerClass" title="logging.setLoggerClass"><code class="xref py py-func docutils literal notranslate"><span class="pre">setLoggerClass()</span></code></a>. Esta función se puede llamar desde una nueva definición de clase, para garantizar que la instalación de una clase personalizada <a class="reference internal" href="#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> no deshaga las <em>customizaciones</em> ya aplicadas por otro código. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyLogger</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">getLoggerClass</span><span class="p">()):</span>
    <span class="c1"># ... override behaviour here</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.getLogRecordFactory">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">getLogRecordFactory</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.getLogRecordFactory" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un invocable que se usa para crear una <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2: </span>Esta función se ha proporcionado, junto con <a class="reference internal" href="#logging.setLogRecordFactory" title="logging.setLogRecordFactory"><code class="xref py py-func docutils literal notranslate"><span class="pre">setLogRecordFactory()</span></code></a>, para permitir a los desarrolladores un mayor control sobre cómo <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> representa un evento logging construido.</p>
</div>
<p>Consulte <a class="reference internal" href="#logging.setLogRecordFactory" title="logging.setLogRecordFactory"><code class="xref py py-func docutils literal notranslate"><span class="pre">setLogRecordFactory()</span></code></a> para obtener más información sobre cómo se llama a la fábrica.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.debug">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">debug</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.debug" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Registra un mensaje con el nivel <code class="xref py py-const docutils literal notranslate"><span class="pre">DEBUG</span></code> en el logger raíz. <em>msg * es la cadena de carácteres de formato del mensaje y *args</em> son los argumentos que se fusionan en <em>msg</em> usando el operador de formato de cadena. (Tenga en cuenta que esto significa que puede utilizar palabras clave en la cadena de formato, junto con un único argumento de diccionario).</p>
<p>Hay tres argumentos de palabras clave en <em>kwargs</em> que se inspeccionan: <em>exc_info</em> que, si no se evalúa como falso, hace que se agregue información de excepción al mensaje de registro. Si se proporciona una tupla de excepción (en el formato retornado por <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>) o una instancia de excepción, se utiliza; de lo contrario, se llama a <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> para obtener la información de la excepción.</p>
<p>El segundo argumento opcional con la palabra clave <em>stack_info</em>, que por defecto es <code class="docutils literal notranslate"><span class="pre">False</span></code>. Si es verdadero, la información de la pila agregara el mensaje de registro, incluida la actual llamada del registro. Tenga en cuenta que esta no es la misma información de la pila que se muestra al especificar <em>exc_info</em>: la primera son los cuadros de la pila desde la parte inferior de la pila hasta la llamada de registro en el hilo actual, mientras que la segunda es la información sobre los cuadros de la pila que se han desenrollado, siguiendo una excepción, mientras busca gestores de excepción.</p>
<p>Puede especificar <em>stack_info</em> independientemente de <em>exc_info</em>, por ejemplo solo para mostrar cómo llegaste a cierto punto en tu código, incluso cuando no se lanzaron excepciones. Los marcos de la pila se imprimen siguiendo una línea de encabezado que dice:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Stack (most recent call last):
</pre></div>
</div>
<p>Esto imita el <code class="docutils literal notranslate"><span class="pre">Traceback</span> <span class="pre">(most</span> <span class="pre">recent</span> <span class="pre">call</span> <span class="pre">last):</span></code> que se usa cuando se muestran marcos de excepción.</p>
<p>El tercer argumento de palabra clave opcional es <em>extra</em> que se puede usar para pasar un diccionario que se usa para completar el __dict__ de LogRecord creado para el evento de registro con atributos definidos por el usuario. Estos atributos personalizados se pueden utilizar como desee. Por ejemplo, podrían incorporarse a mensajes registrados. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">FORMAT</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%(asctime)s</span><span class="s1"> </span><span class="si">%(clientip)-15s</span><span class="s1"> </span><span class="si">%(user)-8s</span><span class="s1"> </span><span class="si">%(message)s</span><span class="s1">&#39;</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">FORMAT</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;clientip&#39;</span><span class="p">:</span> <span class="s1">&#39;192.168.0.1&#39;</span><span class="p">,</span> <span class="s1">&#39;user&#39;</span><span class="p">:</span> <span class="s1">&#39;fbloggs&#39;</span><span class="p">}</span>
<span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Protocol problem: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;connection reset&#39;</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p>imprimiría algo como:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset
</pre></div>
</div>
<p>Las claves en el diccionario pasado <em>extra</em> no deben entrar en conflicto con las claves utilizadas por el sistema de registro. (Ver la documentación de <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> para obtener más información sobre qué claves utiliza el sistema de registro).</p>
<p>Si opta por utilizar estos atributos en los mensajes registrados, debemos tener cuidado. En el caso anterior, por ejemplo, <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> se ha configurado con una cadena de caracteres de formato que espera “clientip” y “user” en el diccionario de atributos de LogRecord. Si faltan, el mensaje no se registrará porque se producirá una excepción de formato de cadena. Entonces, en este caso, siempre debe pasar el diccionario <em>extra</em> con estas claves.</p>
<p>Si bien esto puede ser molesto, esta función está diseñada para su uso en circunstancias especializadas, como servidores de subprocesos múltiples donde el mismo código se ejecuta en muchos contextos, y las condiciones interesantes que surgen dependen de este contexto (como la dirección IP del cliente remoto y autenticado nombre de usuario, en el ejemplo anterior). En tales circunstancias, es probable que se especialice <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a>s con particular <a class="reference internal" href="#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handler</span></code></a>s.</p>
<p>Esta función (así como <a class="reference internal" href="#logging.info" title="logging.info"><code class="xref py py-func docutils literal notranslate"><span class="pre">info()</span></code></a>, <a class="reference internal" href="#logging.warning" title="logging.warning"><code class="xref py py-func docutils literal notranslate"><span class="pre">warning()</span></code></a>, <a class="reference internal" href="#logging.error" title="logging.error"><code class="xref py py-func docutils literal notranslate"><span class="pre">error()</span></code></a> and <a class="reference internal" href="#logging.critical" title="logging.critical"><code class="xref py py-func docutils literal notranslate"><span class="pre">critical()</span></code></a>) llamará a <a class="reference internal" href="#logging.basicConfig" title="logging.basicConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">basicConfig()</span></code></a> si el registrador raíz no tiene ningún controlador conectado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Se agregó el parámetro <em>stack_info</em>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.info">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.info" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Registra un mensaje con nivel <code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code> en el logger raíz. Los argumentos se interpretan como <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.warning">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">warning</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.warning" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Registra un mensaje con nivel <code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code> en el logger raíz. Los argumentos se interpretan como <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Hay una función obsoleta <code class="docutils literal notranslate"><span class="pre">warn</span></code> que es funcionalmente idéntica a <code class="docutils literal notranslate"><span class="pre">warning</span></code>. Como <code class="docutils literal notranslate"><span class="pre">warn</span></code> está deprecado, por favor no lo use, use <code class="docutils literal notranslate"><span class="pre">warning</span></code> en su lugar.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.error">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.error" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Registra un mensaje con nivel <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code> en el logger raíz. Los argumentos se interpretan como <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.critical">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">critical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.critical" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Registra un mensaje con nivel <code class="xref py py-const docutils literal notranslate"><span class="pre">CRITICAL</span></code> en el logger raíz. Los argumentos se interpretan como <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.exception">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">exception</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.exception" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Registra un mensaje con nivel <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code> en el logger raíz. Los argumentos se interpretan como <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a>. Se agrega información de excepción al mensaje de logging. Esta función solo se debe llamar desde un gestor de excepciones.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.log">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.log" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Registra un mensaje con nivel <em>level</em> en el logger raíz. Los argumentos restantes se interpretan como <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.disable">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">disable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">CRITICAL</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.disable" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Proporciona un nivel superior de <em>level</em> para todos los loggers que tienen prioridad sobre el propio nivel del logger. Cuando surge la necesidad de reducir temporalmente la salida de logging en toda la aplicación, esta función puede resultar útil. Su efecto es deshabilitar todas las llamadas de gravedad <em>level</em> e inferior, de modo que si lo llaman con un valor de INFO, todos los eventos INFO y DEBUG se descartarán, mientras que los de gravedad WARNING y superiores se procesarán de acuerdo con el nivel efectivo del logger. Si se llama a <code class="docutils literal notranslate"><span class="pre">logging.disable(logging.NOTSET)</span></code> , elimina efectivamente este nivel primordial, de modo que la salida del registro depende nuevamente de los niveles efectivos de los loggers individuales.</p>
<p>Tenga en cuenta que si ha definido un nivel de logging personalizado superior a <code class="docutils literal notranslate"><span class="pre">CRITICAL</span></code> (esto no es recomendado), no podrá confiar en el valor predeterminado para el parámetro <em>level</em>, pero tendrá que proporcionar explícitamente un valor adecuado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>El parámetro <em>level</em> se estableció por defecto en el nivel <code class="docutils literal notranslate"><span class="pre">CRITICAL</span></code>. Consulte el Issue #28524 para obtener más información sobre este cambio.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.addLevelName">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">addLevelName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">levelName</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.addLevelName" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Asocia nivel <em>level</em> con el texto <em>levelName</em> en un diccionario interno, que se utiliza para asignar niveles numéricos a una representación textual, por ejemplo, cuando <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> formatea un mensaje. Esta función también se puede utilizar para definir sus propios niveles. Las únicas restricciones son que todos los niveles utilizados deben registrarse utilizando esta función, los niveles deben ser números enteros positivos y deben aumentar en orden creciente de severidad.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si está pensando en definir sus propios niveles, consulte la sección sobre <a class="reference internal" href="../howto/logging.html#custom-levels"><span class="std std-ref">Niveles personalizados</span></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.getLevelNamesMapping">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">getLevelNamesMapping</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.getLevelNamesMapping" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una correspondencia entre los nombres de nivel y sus correspondientes niveles de registro. Por ejemplo, la cadena «CRITICAL» corresponde a <code class="xref py py-const docutils literal notranslate"><span class="pre">CRITICAL</span></code>. La correspondencia retornada se copia de una correspondencia interna en cada llamada a esta función.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.getLevelName">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">getLevelName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.getLevelName" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la representación textual o numérica del nivel de registro <em>level</em>.</p>
<p>Si <em>level</em> es uno de los niveles predefinidos <code class="xref py py-const docutils literal notranslate"><span class="pre">CRITICAL</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code> o <code class="xref py py-const docutils literal notranslate"><span class="pre">DEBUG</span></code> entonces se obtiene la cadena correspondiente. Si has asociado niveles con nombres usando <a class="reference internal" href="#logging.addLevelName" title="logging.addLevelName"><code class="xref py py-func docutils literal notranslate"><span class="pre">addLevelName()</span></code></a> entonces se retorna el nombre que has asociado con <em>level</em>. Si se pasa un valor numérico correspondiente a uno de los niveles definidos, se retorna la representación de cadena correspondiente.</p>
<p>El parámetro <em>level</em> también acepta una representación de cadena del nivel como, por ejemplo, «INFO». En estos casos, esta función retorna el correspondiente valor numérico del nivel.</p>
<p>If no matching numeric or string value is passed in, the string
“Level %s” % level is returned.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Los niveles internamente son números enteros (ya que deben compararse en la lógica de logging). Esta función se utiliza para convertir entre un nivel entero y el nombre del nivel que se muestra en la salida de logging formateado mediante el especificador de formato <code class="docutils literal notranslate"><span class="pre">%(levelname)s</span></code> (ver <a class="reference internal" href="#logrecord-attributes"><span class="std std-ref">Atributos LogRecord</span></a>).</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>En las versiones de Python anteriores a la 3.4, esta función también podría pasar un nivel de texto y retornaría el valor numérico correspondiente del nivel. Este comportamiento indocumentado se consideró un error y se eliminó en Python 3.4, pero se restableció en 3.4.2 debido a que conserva la compatibilidad con versiones anteriores.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.makeLogRecord">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">makeLogRecord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">attrdict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.makeLogRecord" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea y retorna una nueva instancia <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> cuyos atributos están definidos por <em>attrdict</em>. Esta función es útil para tomar un diccionario de atributos serializado (<em>pickled</em>) <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a>, enviado a través de un socket, y reconstituido como una instancia <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> en el extremo receptor.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.basicConfig">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">basicConfig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.basicConfig" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Realiza una configuración básica para el sistema de logging creando una <a class="reference internal" href="logging.handlers.html#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamHandler</span></code></a> con un <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> predeterminado y agregándolo al logger raíz. Las funciones <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-func docutils literal notranslate"><span class="pre">debug()</span></code></a>, <a class="reference internal" href="#logging.info" title="logging.info"><code class="xref py py-func docutils literal notranslate"><span class="pre">info()</span></code></a>, <a class="reference internal" href="#logging.warning" title="logging.warning"><code class="xref py py-func docutils literal notranslate"><span class="pre">warning()</span></code></a>, <a class="reference internal" href="#logging.error" title="logging.error"><code class="xref py py-func docutils literal notranslate"><span class="pre">error()</span></code></a> y <a class="reference internal" href="#logging.critical" title="logging.critical"><code class="xref py py-func docutils literal notranslate"><span class="pre">critical()</span></code></a> llamarán <a class="reference internal" href="#logging.basicConfig" title="logging.basicConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">basicConfig()</span></code></a> automáticamente si no se definen gestores para el logger raíz.</p>
<p>Esta función no hace nada si el logger raíz ya tiene gestores configurados, a menos que el argumento de palabra clave <em>force</em> esté establecido como <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Esta función debe llamarse desde el hilo principal antes de que se inicien otros hilos. En las versiones de Python anteriores a 2.7.1 y 3.2, si se llama a esta función desde varios subprocesos, es posible (en raras circunstancias) que se agregue un gestor al logger raíz más de una vez, lo que genera resultados inesperados como mensajes duplicados en el registro.</p>
</div>
<p>Se admiten los siguientes argumentos de palabras clave.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 24%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Formato</p></th>
<th class="head"><p>Descripción</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>filename</em></p></td>
<td><p>Specifies that a <a class="reference internal" href="logging.handlers.html#logging.FileHandler" title="logging.FileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code></a> be
created, using the specified filename,
rather than a <a class="reference internal" href="logging.handlers.html#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamHandler</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><em>filemode</em></p></td>
<td><p>Si se especifica <em>filename</em>, abre el archivo en <a class="reference internal" href="functions.html#filemodes"><span class="std std-ref">mode</span></a>. Por defecto es <code class="docutils literal notranslate"><span class="pre">'a'</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><em>format</em></p></td>
<td><p>Utiliza la cadena de caracteres de formato especificada para el gestor.Los atributos por defecto son <code class="docutils literal notranslate"><span class="pre">levelname</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code> y <code class="docutils literal notranslate"><span class="pre">message</span></code> separado por dos puntos.</p></td>
</tr>
<tr class="row-odd"><td><p><em>datefmt</em></p></td>
<td><p>Utiliza el formato de fecha/hora especificado, aceptado por <a class="reference internal" href="time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.strftime()</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><p><em>style</em></p></td>
<td><p>Si <em>format</em> es especificado, utilice este estilo para la cadena de caracteres de formato. Uno de <code class="docutils literal notranslate"><span class="pre">'%'</span></code>, <code class="docutils literal notranslate"><span class="pre">'{'</span></code> o <code class="docutils literal notranslate"><span class="pre">'$'</span></code> para <a class="reference internal" href="stdtypes.html#old-string-formatting"><span class="std std-ref">printf-style</span></a>, <a class="reference internal" href="stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> o <a class="reference internal" href="string.html#string.Template" title="string.Template"><code class="xref py py-class docutils literal notranslate"><span class="pre">string.Template</span></code></a> respectivamente. El valor predeterminado es <code class="docutils literal notranslate"><span class="pre">'%'</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><em>level</em></p></td>
<td><p>Establece el nivel del logger raíz en el <a class="reference internal" href="#levels"><span class="std std-ref">level</span></a> especificado.</p></td>
</tr>
<tr class="row-even"><td><p><em>stream</em></p></td>
<td><p>Utiliza la secuencia especificada para inicializar <a class="reference internal" href="logging.handlers.html#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamHandler</span></code></a>. Tenga en cuenta que este argumento es incompatible con <em>filename</em> - si ambos están presentes, se lanza un <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><em>handlers</em></p></td>
<td><p>Si se especifica, debe ser una iteración de los gestores ya creados para agregar al logger raíz. A cualquier gestor que aún no tenga un formateador configurado se le asignará el formateador predeterminado creado en esta función. Tenga en cuenta que este argumento es incompatible con <em>filename</em> o <em>stream</em>; si ambos están presentes, se lanza un <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><em>force</em></p></td>
<td><p>Si este argumento de palabra clave se especifica como verdadero, los gestores existentes adjuntos al logger raíz se eliminan y cierran antes de llevar a cabo la configuración tal como se especifica en los otros argumentos.</p></td>
</tr>
<tr class="row-odd"><td><p><em>encoding</em></p></td>
<td><p>If this keyword argument is specified along
with <em>filename</em>, its value is used when the
<a class="reference internal" href="logging.handlers.html#logging.FileHandler" title="logging.FileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code></a> is created, and thus
used when opening the output file.</p></td>
</tr>
<tr class="row-even"><td><p><em>errors</em></p></td>
<td><p>If this keyword argument is specified along
with <em>filename</em>, its value is used when the
<a class="reference internal" href="logging.handlers.html#logging.FileHandler" title="logging.FileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code></a> is created, and thus
used when opening the output file. If not
specified, the value “backslashreplace” is
used. Note that if <code class="docutils literal notranslate"><span class="pre">None</span></code> is specified,
it will be passed as such to <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>,
which means that it will be treated the
same as passing “errors”.</p></td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Se agregó el argumento <em>style</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Se agregó el argumento <em>handlers</em>. Se agregaron verificaciones adicionales para detectar situaciones en las que se especifican argumentos incompatibles (por ejemplo, <em>handlers</em> junto con <em>stream</em> o <em>filename</em>, o <em>stream</em> junto con <em>filename</em>).</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Se agregó el argumento <em>force</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.9: </span>Se han añadido los argumentos <em>encoding</em> y <em>errors</em>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.shutdown">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">shutdown</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.shutdown" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Informa al sistema de logging para realizar un apagado ordenado descargando y cerrando todos los gestores. Esto se debe llamar al salir de la aplicación y no se debe hacer ningún uso posterior del sistema de logging después de esta llamada.</p>
<p>Cuando se importa el módulo de logging, registra esta función como un gestor de salida (ver <a class="reference internal" href="atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a>), por lo que normalmente no es necesario hacerlo manualmente.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.setLoggerClass">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">setLoggerClass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">klass</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.setLoggerClass" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Le dice al sistema de logging que use la clase <em>klass</em> al crear una instancia de un logger. La clase debe definir <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> tal que solo se requiera un argumento de nombre, y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> debe llamar <code class="xref py py-meth docutils literal notranslate"><span class="pre">Logger.__init__()</span></code>. Por lo general, esta función se llama antes de cualquier loggers sea instanciado por las aplicaciones que necesitan utilizar un comportamiento de logger personalizado. Después de esta llamada, como en cualquier otro momento, no cree instancias de loggers directamente usando la subclase: continúe usando la API <a class="reference internal" href="#logging.getLogger" title="logging.getLogger"><code class="xref py py-func docutils literal notranslate"><span class="pre">logging.getLogger()</span></code></a> para obtener sus loggers.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="logging.setLogRecordFactory">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">setLogRecordFactory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">factory</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.setLogRecordFactory" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece un invocable que se utiliza para crear <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parámetros</dt>
<dd class="field-odd"><p><strong>factory</strong> – La fábrica invocable que se utilizará para crear una instancia de un registro.</p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2: </span>Esta función se ha proporcionado, junto con <a class="reference internal" href="#logging.getLogRecordFactory" title="logging.getLogRecordFactory"><code class="xref py py-func docutils literal notranslate"><span class="pre">getLogRecordFactory()</span></code></a>, para permitir a los desarrolladores un mayor control sobre cómo se construye <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> que representa un evento de logging.</p>
</div>
<p>La fábrica tiene la siguiente firma:</p>
<p><code class="docutils literal notranslate"><span class="pre">factory(name,</span> <span class="pre">level,</span> <span class="pre">fn,</span> <span class="pre">lno,</span> <span class="pre">msg,</span> <span class="pre">args,</span> <span class="pre">exc_info,</span> <span class="pre">func=None,</span> <span class="pre">sinfo=None,</span> <span class="pre">**kwargs)</span></code></p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">name</dt>
<dd class="field-odd"><p>El nombre del logger.</p>
</dd>
<dt class="field-even">level</dt>
<dd class="field-even"><p>El nivel de logging (numérico).</p>
</dd>
<dt class="field-odd">fn</dt>
<dd class="field-odd"><p>El nombre de ruta completo del archivo donde se realizó la llamada de logging.</p>
</dd>
<dt class="field-even">lno</dt>
<dd class="field-even"><p>El número de línea en el archivo donde se realizó la llamada de logging.</p>
</dd>
<dt class="field-odd">msg</dt>
<dd class="field-odd"><p>El mensaje de logging.</p>
</dd>
<dt class="field-even">args</dt>
<dd class="field-even"><p>Los argumentos para el mensaje de logging.</p>
</dd>
<dt class="field-odd">exc_info</dt>
<dd class="field-odd"><p>Una tupla de excepción o <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
<dt class="field-even">func</dt>
<dd class="field-even"><p>El nombre de la función o método que invocó la llamada de logging.</p>
</dd>
<dt class="field-odd">sinfo</dt>
<dd class="field-odd"><p>Un seguimiento de pila como el que proporciona <a class="reference internal" href="traceback.html#traceback.print_stack" title="traceback.print_stack"><code class="xref py py-func docutils literal notranslate"><span class="pre">traceback.print_stack()</span></code></a>, que muestra la jerarquía de llamadas.</p>
</dd>
<dt class="field-even">kwargs</dt>
<dd class="field-even"><p>Argumentos de palabras clave adicionales.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

</section>
<section id="module-level-attributes">
<h2>Atributos a nivel de módulo<a class="headerlink" href="#module-level-attributes" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="py attribute">
<dt class="sig sig-object py" id="logging.lastResort">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">lastResort</span></span><a class="headerlink" href="#logging.lastResort" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un «gestor de último recurso» está disponible a través de este atributo. Esta es una <a class="reference internal" href="logging.handlers.html#logging.StreamHandler" title="logging.StreamHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamHandler</span></code></a> que escribe en <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> con un nivel <code class="docutils literal notranslate"><span class="pre">WARNING</span></code>, y se usa para gestionar eventos de logging en ausencia de cualquier configuración de logging. El resultado final es simplemente imprimir el mensaje en <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>. Esto reemplaza el mensaje de error anterior que decía que «no se pudieron encontrar gestores para el logger XYZ». Si necesita el comportamiento anterior por alguna razón, <code class="docutils literal notranslate"><span class="pre">lastResort</span></code> se puede configurar en <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

</section>
<section id="integration-with-the-warnings-module">
<h2>Integración con el módulo de advertencias<a class="headerlink" href="#integration-with-the-warnings-module" title="Enlazar permanentemente con este título">¶</a></h2>
<p>La función <a class="reference internal" href="#logging.captureWarnings" title="logging.captureWarnings"><code class="xref py py-func docutils literal notranslate"><span class="pre">captureWarnings()</span></code></a> se puede utilizar para integrar <a class="reference internal" href="#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> con el módulo <a class="reference internal" href="warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code></a>.</p>
<dl class="py function">
<dt class="sig sig-object py" id="logging.captureWarnings">
<span class="sig-prename descclassname"><span class="pre">logging.</span></span><span class="sig-name descname"><span class="pre">captureWarnings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">capture</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#logging.captureWarnings" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta función se utiliza para activar y desactivar la captura de advertencias (<em>warnings</em>).</p>
<p>Si <em>capture</em> es <code class="docutils literal notranslate"><span class="pre">True</span></code>, las advertencias emitidas por el módulo <a class="reference internal" href="warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code></a> serán redirigidas al sistema de logging. Específicamente, una advertencia se formateará usando <a class="reference internal" href="warnings.html#warnings.formatwarning" title="warnings.formatwarning"><code class="xref py py-func docutils literal notranslate"><span class="pre">warnings.formatwarning()</span></code></a> y la cadena de caracteres resultante se registrará en un logger  llamado <code class="docutils literal notranslate"><span class="pre">'py.warnings'</span></code> con severidad <code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code>.</p>
<p>Si <em>capture</em> es <code class="docutils literal notranslate"><span class="pre">False</span></code>, la redirección de advertencias al sistema de logging se detendrá y las advertencias serán redirigidas a sus destinos originales (es decir, aquellos en vigor antes de que se llamara a <code class="docutils literal notranslate"><span class="pre">captureWarnings(True)</span></code>).</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt>Módulo <a class="reference internal" href="logging.config.html#module-logging.config" title="logging.config: Configuration of the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.config</span></code></a></dt><dd><p>API de configuración para el módulo logging.</p>
</dd>
<dt>Módulo <a class="reference internal" href="logging.handlers.html#module-logging.handlers" title="logging.handlers: Handlers for the logging module."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.handlers</span></code></a></dt><dd><p>Gestores útiles incluidos con el módulo logging.</p>
</dd>
<dt><span class="target" id="index-1"></span><a class="pep reference external" href="https://peps.python.org/pep-0282/"><strong>PEP 282</strong></a> - A Logging System</dt><dd><p>La propuesta que describió esta característica para su inclusión en la biblioteca estándar de Python.</p>
</dd>
<dt><a class="reference external" href="https://old.red-dove.com/python_logging.html">Paquete logging original de Python</a></dt><dd><p>Esta es la fuente original del paquete <a class="reference internal" href="#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a>. La versión del paquete disponible en este sitio es adecuada para usar con Python 1.5.2, 2.1.xy 2.2.x, que no incluyen el paquete <a class="reference internal" href="#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> en la biblioteca estándar.</p>
</dd>
</dl>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code> — Instalación de logging para Python</a><ul>
<li><a class="reference internal" href="#logger-objects">Objetos logger</a></li>
<li><a class="reference internal" href="#logging-levels">Niveles de logging</a></li>
<li><a class="reference internal" href="#handler-objects">Gestor de objetos</a></li>
<li><a class="reference internal" href="#formatter-objects">Objetos formateadores</a></li>
<li><a class="reference internal" href="#filter-objects">Filtro de Objetos</a></li>
<li><a class="reference internal" href="#logrecord-objects">Objetos LogRecord</a></li>
<li><a class="reference internal" href="#logrecord-attributes">Atributos LogRecord</a></li>
<li><a class="reference internal" href="#loggeradapter-objects">Objetos LoggerAdapter</a></li>
<li><a class="reference internal" href="#thread-safety">Seguridad del hilo</a></li>
<li><a class="reference internal" href="#module-level-functions">Funciones a nivel de módulo</a></li>
<li><a class="reference internal" href="#module-level-attributes">Atributos a nivel de módulo</a></li>
<li><a class="reference internal" href="#integration-with-the-warnings-module">Integración con el módulo de advertencias</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="getopt.html"
                          title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">getopt</span></code> — Analizador de estilo C para opciones de línea de comando</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="logging.config.html"
                          title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging.config</span></code> — Configuración de registro</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/library/logging.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="logging.config.html" title="logging.config — Configuración de registro"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="getopt.html" title="getopt — Analizador de estilo C para opciones de línea de comando"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" >Servicios genéricos del sistema operativo</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code> — Instalación de logging para Python</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 23, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>