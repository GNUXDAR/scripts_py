
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="Qué hay de nuevo en Python 3.0" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/whatsnew/3.0.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Autor, Guido van Rossum,. Este artículo explica las nuevas características de Python 3.0, en comparación con 2.6. Python 3.0, también conocido como «Python 3000» o «Py3K», es la primera versión int..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Autor, Guido van Rossum,. Este artículo explica las nuevas características de Python 3.0, en comparación con 2.6. Python 3.0, también conocido como «Python 3000» o «Py3K», es la primera versión int..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>Qué hay de nuevo en Python 3.0 &#8212; documentación de Python - 3.11.2</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=2d3badd06fe70b34b68db01f99471ce1624ffe4a" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.11.2"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="Qué hay de nuevo en Python 2.7" href="2.7.html" />
    <link rel="prev" title="Qué hay de nuevo en Python 3.1" href="3.1.html" />
    <link rel="canonical" href="https://docs.python.org/3/whatsnew/3.0.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">Qué hay de nuevo en Python 3.0</a><ul>
<li><a class="reference internal" href="#common-stumbling-blocks">Escollos comunes</a><ul>
<li><a class="reference internal" href="#print-is-a-function"><em>Print</em> es una función</a></li>
<li><a class="reference internal" href="#views-and-iterators-instead-of-lists">Vistas e iteradores en lugar de listas</a></li>
<li><a class="reference internal" href="#ordering-comparisons">Comparaciones de ordenamiento</a></li>
<li><a class="reference internal" href="#integers">Enteros</a></li>
<li><a class="reference internal" href="#text-vs-data-instead-of-unicode-vs-8-bit">Texto vs. datos en lugar de unicode vs. 8 bits</a></li>
</ul>
</li>
<li><a class="reference internal" href="#overview-of-syntax-changes">Descripción general de los cambios de sintaxis</a><ul>
<li><a class="reference internal" href="#new-syntax">Nueva sintaxis</a></li>
<li><a class="reference internal" href="#changed-syntax">Sintaxis modificada</a></li>
<li><a class="reference internal" href="#removed-syntax">Sintaxis eliminada</a></li>
</ul>
</li>
<li><a class="reference internal" href="#changes-already-present-in-python-2-6">Cambios ya presentes en Python 2.6</a></li>
<li><a class="reference internal" href="#library-changes">Cambios de biblioteca</a></li>
<li><a class="reference internal" href="#pep-3101-a-new-approach-to-string-formatting"><strong>PEP 3101</strong>: Un nuevo enfoque al formateo de cadena de caracteres</a></li>
<li><a class="reference internal" href="#changes-to-exceptions">Cambios a excepciones</a></li>
<li><a class="reference internal" href="#miscellaneous-other-changes">Otros cambios diversos</a><ul>
<li><a class="reference internal" href="#operators-and-special-methods">Operadores y métodos especiales</a></li>
<li><a class="reference internal" href="#builtins">Incorporados</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-and-c-api-changes">Construcción y cambios a la API de C</a></li>
<li><a class="reference internal" href="#performance">Rendimiento</a></li>
<li><a class="reference internal" href="#porting-to-python-3-0">Migración a Python 3.0</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="3.1.html"
                          title="capítulo anterior">Qué hay de nuevo en Python 3.1</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="2.7.html"
                          title="próximo capítulo">Qué hay de nuevo en Python 2.7</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/whatsnew/3.0.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="2.7.html" title="Qué hay de nuevo en Python 2.7"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="3.1.html" title="Qué hay de nuevo en Python 3.1"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Qué hay de nuevo en Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Qué hay de nuevo en Python 3.0</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-3-0">
<h1>Qué hay de nuevo en Python 3.0<a class="headerlink" href="#what-s-new-in-python-3-0" title="Enlazar permanentemente con este título">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Autor</dt>
<dd class="field-odd"><p>Guido van Rossum</p>
</dd>
</dl>
<p>Este artículo explica las nuevas características de Python 3.0, en comparación con 2.6. Python 3.0, también conocido como «Python 3000» o «Py3K», es la primera versión <em>intentionally backwards incompatible</em> de Python. Python 3.0 se lanzó el 3 de diciembre de 2008. Hay más cambios que en una versión típica y más que son importantes para todos los usuarios de Python. Sin embargo, después de digerir los cambios, descubrirá que Python realmente no ha cambiado tanto; en general, estamos solucionando principalmente molestias y defectos conocidos, y eliminando una gran cantidad de viejas cosas.</p>
<p>Este artículo no intenta proporcionar una especificación completa de todas las características nuevas, sino que intenta proporcionar una visión general conveniente. Para obtener más información, se debe consultar la documentación de Python 3.0 y/o los muchos PEP a los que se hace referencia en el texto. Si se desea comprender la lógica completa de implementación y diseño para una característica determinada, los PEP suelen tener más detalles que la documentación regular, pero téngase en cuenta que los PEP generalmente no se mantienen actualizados una vez que una característica se ha implementado completamente.</p>
<p>Debido a restricciones de tiempo, este documento no es tan completo como debería haber sido. Como siempre para una nueva versión, el archivo <code class="docutils literal notranslate"><span class="pre">Misc/NEWS</span></code> en la distribución de origen contiene una gran cantidad de información detallada sobre cada pequeña cosa que se cambió.</p>
<section id="common-stumbling-blocks">
<h2>Escollos comunes<a class="headerlink" href="#common-stumbling-blocks" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Esta sección contiene esos pequeños cambios que probablemente generarán tropiezos si se está acostumbrado a Python 2.5.</p>
<section id="print-is-a-function">
<h3><em>Print</em> es una función<a class="headerlink" href="#print-is-a-function" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La declaración <code class="docutils literal notranslate"><span class="pre">print</span></code> se ha sustituido por una función <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a>, con argumentos de palabra clave para reemplazar la mayor parte de la sintaxis especial de la antigua declaración <code class="docutils literal notranslate"><span class="pre">print</span></code> (<span class="target" id="index-71"></span><a class="pep reference external" href="https://peps.python.org/pep-3105/"><strong>PEP 3105</strong></a>). Ejemplos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Old</span><span class="p">:</span> <span class="nb">print</span> <span class="s2">&quot;The answer is&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="mi">2</span>
<span class="n">New</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The answer is&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>

<span class="n">Old</span><span class="p">:</span> <span class="nb">print</span> <span class="n">x</span><span class="p">,</span>           <span class="c1"># Trailing comma suppresses newline</span>
<span class="n">New</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>  <span class="c1"># Appends a space instead of a newline</span>

<span class="n">Old</span><span class="p">:</span> <span class="nb">print</span>              <span class="c1"># Prints a newline</span>
<span class="n">New</span><span class="p">:</span> <span class="nb">print</span><span class="p">()</span>            <span class="c1"># You must call the function!</span>

<span class="n">Old</span><span class="p">:</span> <span class="nb">print</span> <span class="o">&gt;&gt;</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;fatal error&quot;</span>
<span class="n">New</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;fatal error&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>

<span class="n">Old</span><span class="p">:</span> <span class="nb">print</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>       <span class="c1"># prints repr((x, y))</span>
<span class="n">New</span><span class="p">:</span> <span class="nb">print</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>      <span class="c1"># Not the same as print(x, y)!</span>
</pre></div>
</div>
<p>También se puede personalizar el separador entre ítems, por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There are &lt;&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span><span class="p">,</span> <span class="s2">&quot;&gt; possibilities!&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>que genera:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>There are &lt;4294967296&gt; possibilities!
</pre></div>
</div>
<p>Nota:</p>
<ul class="simple">
<li><p>La función <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> no soporta la característica «softspace» de la declaración <code class="docutils literal notranslate"><span class="pre">print</span></code> vieja. Por ejemplo, en Python 2.x <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">&quot;A\n&quot;,</span> <span class="pre">&quot;B&quot;</span></code> escribiría <code class="docutils literal notranslate"><span class="pre">&quot;A\nB\n&quot;</span></code>; pero en Python 3.0, <code class="docutils literal notranslate"><span class="pre">print(&quot;A\n&quot;,</span> <span class="pre">&quot;B&quot;)</span></code> escribe <code class="docutils literal notranslate"><span class="pre">&quot;A\n</span> <span class="pre">B\n&quot;</span></code>.</p></li>
<li><p>Inicialmente, te encontrarás escribiendo mucho la antigua <code class="docutils literal notranslate"><span class="pre">print</span> <span class="pre">x</span></code> en modo interactivo. ¡Es hora de volver a entrenar los dedos para escribir <code class="docutils literal notranslate"><span class="pre">print(x)</span></code> en su lugar!</p></li>
<li><p>En el uso de la herramienta de conversión fuente-a-fuente <code class="docutils literal notranslate"><span class="pre">2to3</span></code>, todos las declaraciones <code class="docutils literal notranslate"><span class="pre">print</span></code> son automáticamente convertidas a una llamada de la función <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a>, por lo que en general esto no es un problema para proyectos más grandes.</p></li>
</ul>
</section>
<section id="views-and-iterators-instead-of-lists">
<h3>Vistas e iteradores en lugar de listas<a class="headerlink" href="#views-and-iterators-instead-of-lists" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Algunas APIs bien conocidas no retornan más listas:</p>
<ul>
<li><p>Los métodos <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> <a class="reference internal" href="../library/stdtypes.html#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.keys()</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#dict.items" title="dict.items"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.items()</span></code></a> y <a class="reference internal" href="../library/stdtypes.html#dict.values" title="dict.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.values()</span></code></a> retornan «vistas» en lugar de listas. Por ejemplo, esto no funciona más: <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">d.keys();</span> <span class="pre">k.sort()</span></code>. Se usa <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">sorted(d)</span></code> en su lugar (esto funciona también en Python 2.5 y es igual de eficiente).</p></li>
<li><p>Además, los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.iterkeys()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.iteritems()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.itervalues()</span></code> ya no son compatibles.</p></li>
<li><p><a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> y <a class="reference internal" href="../library/functions.html#filter" title="filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">filter()</span></code></a> retornan iteradores. Si realmente se necesita una lista y las secuencias de entrada son todas de igual longitud, una solución rápida es envolver <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> en <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-func docutils literal notranslate"><span class="pre">list()</span></code></a>, por ejemplo <code class="docutils literal notranslate"><span class="pre">list(map(...))</span></code>, pero una mejor solución es a menudo utilizar una lista por comprensión (especialmente cuando el código original utiliza <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a>), o reescribir el código para que no necesite una lista en absoluto. Particularmente complicado es <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> invocado para los efectos secundarios de la función; la transformación correcta es usar un bucle <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> normal (ya que crear una lista sería simplemente un desperdicio).</p>
<p>Si las secuencias de entrada no tienen la misma longitud, <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> se detendrá en la terminación de la más corta de las secuencias. Para una compatibilidad completa con <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> de Python 2.x, también se envuelve las secuencias en <a class="reference internal" href="../library/itertools.html#itertools.zip_longest" title="itertools.zip_longest"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.zip_longest()</span></code></a>, por ejemplo <code class="docutils literal notranslate"><span class="pre">map(func,</span> <span class="pre">*sequences)</span></code> se convierte en <code class="docutils literal notranslate"><span class="pre">list(map(func,</span> <span class="pre">itertools.zip_longest(*sequences)))</span></code>.</p>
</li>
<li><p><a class="reference internal" href="../library/stdtypes.html#range" title="range"><code class="xref py py-func docutils literal notranslate"><span class="pre">range()</span></code></a> ahora se comporta como <code class="xref py py-func docutils literal notranslate"><span class="pre">xrange()</span></code> solía comportarse, excepto que funciona con valores de tamaño arbitrario. Este último ya no existe.</p></li>
<li><p><a class="reference internal" href="../library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> ahora retorna un iterador.</p></li>
</ul>
</section>
<section id="ordering-comparisons">
<h3>Comparaciones de ordenamiento<a class="headerlink" href="#ordering-comparisons" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Python 3.0 ha simplificado las reglas para las comparaciones de ordenamiento:</p>
<ul class="simple">
<li><p>Los operadores de comparaciones de ordenamiento (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>,``”&gt;``, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>) lanzan una excepción <em>TypeError</em> cuando los operandos no tienen un orden natural significativo. Por lo tanto, expresiones como <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;</span> <span class="pre">''</span></code>, <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&gt;</span> <span class="pre">None</span></code> o <code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">&lt;=</span> <span class="pre">len</span></code> ya no son válidas, y por ejemplo <code class="docutils literal notranslate"><span class="pre">Ninguno</span> <span class="pre">&lt;</span> <span class="pre">Ninguno</span></code> lanza <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> en lugar de retornar <code class="docutils literal notranslate"><span class="pre">False</span></code>. Un corolario es que ordenar una lista heterogénea ya no tiene sentido – todos los elementos deben ser comparables entre sí. Tener en cuenta que esto no se aplica a los operadores <code class="docutils literal notranslate"><span class="pre">==</span></code> y <code class="docutils literal notranslate"><span class="pre">!=</span></code>: los objetos de diferentes tipos incomparables siempre se comparan desiguales entre sí.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">builtin.sorted()</span></code> y <a class="reference internal" href="../library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> ya no aceptan el argumento <em>cmp</em> que proporciona una función de comparación. Utilice el argumento <em>key</em> en su lugar. N.B. los argumentos <em>key</em> y <em>reverse</em> ahora son «argumentos por palabra clave».</p></li>
<li><p>La función <code class="xref py py-func docutils literal notranslate"><span class="pre">cmp()</span></code> debe tratarse como quitada, y el método especial <code class="xref py py-meth docutils literal notranslate"><span class="pre">__cmp__()</span></code> ya no es compatible. Utilizar <code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code> para el ordenamiento, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code> con <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code>, y otras comparaciones costosas según sea necesario. (Si realmente se necesita la funcionalidad <code class="xref py py-func docutils literal notranslate"><span class="pre">cmp()</span></code>, se puede utilizar la expresión <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">&gt;</span> <span class="pre">b)</span> <span class="pre">-</span> <span class="pre">(a</span> <span class="pre">&lt;</span> <span class="pre">b)</span></code> como el equivalente para <code class="docutils literal notranslate"><span class="pre">cmp(a,</span> <span class="pre">b)</span></code>.)</p></li>
</ul>
</section>
<section id="integers">
<h3>Enteros<a class="headerlink" href="#integers" title="Enlazar permanentemente con este título">¶</a></h3>
<ul class="simple">
<li><p><span class="target" id="index-72"></span><a class="pep reference external" href="https://peps.python.org/pep-0237/"><strong>PEP 237</strong></a>: Esencialmente, <code class="xref py py-class docutils literal notranslate"><span class="pre">long</span></code> renombrado a <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>. Es decir, solo hay un tipo integral incorporado, denominado <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>; pero se comporta sobre todo como el viejo tipo <code class="xref py py-class docutils literal notranslate"><span class="pre">long</span></code>.</p></li>
<li><p><span class="target" id="index-73"></span><a class="pep reference external" href="https://peps.python.org/pep-0238/"><strong>PEP 238</strong></a>: Una expresión como <code class="docutils literal notranslate"><span class="pre">1/2</span></code> retorna un float. Utilizar <code class="docutils literal notranslate"><span class="pre">1//2</span></code> para obtener el comportamiento de truncamiento. (Esta última sintaxis ha existido durante años, al menos desde Python 2.2.)</p></li>
<li><p>Se eliminó la constante <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.maxint</span></code>, ya que ya no hay un límite para el valor de los enteros. Sin embargo, <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.maxsize</span></code></a> se puede utilizar como un entero mayor que cualquier lista práctica o índice de cadena de caracteres. Se ajusta al tamaño entero «natural» de la implementación y suele ser el mismo que <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.maxint</span></code> en versiones anteriores de la misma plataforma (suponiendo las mismas opciones de compilación).</p></li>
<li><p>El <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> de un entero largo ya no incluye la <code class="docutils literal notranslate"><span class="pre">L</span></code> final, por lo que el código que elimina incondicionalmente ese carácter cortará el último dígito en su lugar. (Utilizar <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> en su lugar.)</p></li>
<li><p>Los literales octales ya no usan la forma <code class="docutils literal notranslate"><span class="pre">0720</span></code>; úsese <code class="docutils literal notranslate"><span class="pre">0o720</span></code> en su lugar.</p></li>
</ul>
</section>
<section id="text-vs-data-instead-of-unicode-vs-8-bit">
<h3>Texto vs. datos en lugar de unicode vs. 8 bits<a class="headerlink" href="#text-vs-data-instead-of-unicode-vs-8-bit" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Todo lo que pensabas saber sobre datos binarios y Unicode ha cambiado.</p>
<ul class="simple">
<li><p>Python 3.0 utiliza los conceptos de <em>text</em> y <em>datos</em> (binarios) en lugar de cadenas de caracteres Unicode y cadenas de caracteres de 8 bits. Todo el texto es Unicode; sin embargo el Unicode <em>codificado</em> se representa como datos binarios. El tipo utilizado para contener texto es <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, el tipo utilizado para contener datos es <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. La mayor diferencia con la situación 2.x es que cualquier intento de mezclar texto y datos en Python 3.0 lanza un <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>, mientras que si se mezclan cadenas Unicode y de 8 bits en Python 2.x, funcionaría si la cadena de 8 bits contuviera sólo bytes de 7 bits (ASCII), pero se obtendría un <a class="reference internal" href="../library/exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code></a> si contenía valores no ASCII. Este comportamiento específico del valor ha causado numerosas caras tristes a lo largo de los años.</p></li>
<li><p>Como consecuencia de este cambio en la filosofía, prácticamente todo el código que utiliza Unicode, codificaciones o datos binarios muy probablemente tiene que cambiar. El cambio es para mejor, ya que en el mundo 2.x había numerosos errores que tenían que ver con la mezcla de texto codificado y sin codificar. Para estar preparado en Python 2.x, comienza a usar <code class="xref py py-class docutils literal notranslate"><span class="pre">unicode</span></code> para todo el texto sin codificar, y <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> solo para datos binarios o codificados. Luego , la herramienta <code class="docutils literal notranslate"><span class="pre">2to3</span></code> hará la mayor parte del trabajo por ti.</p></li>
<li><p>Ya no se puede utilizar literales <code class="docutils literal notranslate"><span class="pre">u&quot;...&quot;</span></code> para texto Unicode. Sin embargo, se debe usar literales <code class="docutils literal notranslate"><span class="pre">b&quot;...&quot;</span></code> para los datos binarios.</p></li>
<li><p>Como los tipos <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> y <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> no se pueden mezclar, siempre se deben convertir explícitamente entre ellos. Utilizar <a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> para pasar de <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> a <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, y <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> para pasar de <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> a <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>. También se puede utilizar <code class="docutils literal notranslate"><span class="pre">bytes(s,</span> <span class="pre">encoding=...)</span></code> y <code class="docutils literal notranslate"><span class="pre">str(b,</span> <span class="pre">encoding=...)</span></code>, respectivamente.</p></li>
<li><p>Al igual que <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, el tipo <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> es inmutable. Hay un tipo <em>mutable</em> independiente para contener datos binarios almacenados en búfer, <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>. Casi todas las API que aceptan <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> también aceptan <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>. La API mutable se basa en <code class="xref py py-class docutils literal notranslate"><span class="pre">collections.</span> <span class="pre">MutableSequence</span></code>.</p></li>
<li><p>Todas las barras invertidas en literales de cadena de caracteres sin formato se interpretan literalmente. Esto significa que los escapes <code class="docutils literal notranslate"><span class="pre">'\U'</span></code> y <code class="docutils literal notranslate"><span class="pre">'\u'</span></code> en cadenas de caracteres sin formato no se tratan especialmente. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">r'\u20ac'</span></code> es una cadena de 6 caracteres en Python 3.0, mientras que en 2.6, <code class="docutils literal notranslate"><span class="pre">ur'\u20ac'</span></code> era el único carácter «euro». (Por supuesto, este cambio sólo afecta a los literales de cadena de caracteres sin formato; el carácter del euro es <code class="docutils literal notranslate"><span class="pre">'\u20ac'</span></code> en Python 3.0.)</p></li>
<li><p>Se eliminó el tipo abstracto <code class="xref py py-class docutils literal notranslate"><span class="pre">basestring</span></code> incorporado. Se utiliza <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> en su lugar. Los tipos <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> y <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> no tienen suficiente funcionalidad en común para garantizar una clase base compartida. La herramienta <code class="docutils literal notranslate"><span class="pre">2to3</span></code> (ver más abajo) reemplaza cada aparición de <code class="xref py py-class docutils literal notranslate"><span class="pre">basestring</span></code> por <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p></li>
<li><p>Los archivos abiertos como archivos de texto (todavía el modo predeterminado para <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>) siempre utilizan una codificación para asignar entre cadenas de caracteres(en memoria) y bytes (en disco). Los archivos binarios (abiertos con una <code class="docutils literal notranslate"><span class="pre">b</span></code> en el argumento modo) siempre utilizan bytes en la memoria. Esto significa que si un archivo se abre utilizando un modo o codificación incorrectos, es probable que la E/S falle ruidosamente, en lugar de producir datos incorrectos de forma silenciosa. También significa que incluso los usuarios de Unix tendrán que especificar el modo correcto (texto o binario) al abrir un archivo. Hay una codificación predeterminada dependiente de la plataforma, que en las plataformas Unix se puede establecer con la variable de entorno <code class="docutils literal notranslate"><span class="pre">LANG</span></code> (y a veces también con algunas otras variables de entorno relacionadas con la configuración regional específicas de la plataforma). En muchos casos, pero no en todos, el valor predeterminado del sistema es UTF-8; nunca se debe contar con este valor predeterminado. Cualquier aplicación que lea o escriba más que texto ASCII puro probablemente debería tener una manera de invalidar la codificación. Ya no es necesario utilizar las secuencias compatibles con la codificación en el módulo <a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a>.</p></li>
<li><p>Los valores iniciales de <a class="reference internal" href="../library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin</span></code></a>, <a class="reference internal" href="../library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a> y <a class="reference internal" href="../library/sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a> ahora son archivos de texto solo unicode (es decir, son instancias de <a class="reference internal" href="../library/io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOBase</span></code></a>). Para leer y escribir datos de bytes con estas secuencias, se debe usar su atributo <a class="reference internal" href="../library/io.html#io.TextIOBase.buffer" title="io.TextIOBase.buffer"><code class="xref py py-data docutils literal notranslate"><span class="pre">io.TextIOBase.buffer</span></code></a>.</p></li>
<li><p>Los nombres de archivos son pasados y retornados de cadenas desde APIs como cadenas de caracteres (Unicode). Esto puede presentar problemas específicos de plataformas porque en algunas plataformas los nombres de archivos son cadenas de caracteres de bytes arbitrarios. (Por otro lado, en Windows los nombres de archivos son almacenados de forma nativa como Unicode.) Como solución alternativa, la mayoría de las APIs (por ejemplo <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> y muchas otras funciones en el módulo <a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a>) que toman nombres de archivos aceptan tanto objetos <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> como cadenas de caracteres, y algunas APIs tienen una forma de demandar por un valor de retorno <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. Por lo tanto, <a class="reference internal" href="../library/os.html#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.listdir()</span></code></a> retorna una lista de instancias <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> si el argumento es una instancia <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, y <a class="reference internal" href="../library/os.html#os.getcwdb" title="os.getcwdb"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.getcwdb()</span></code></a> retorna el directorio de trabajo actual como una instancia <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. Tener en cuenta que cuando <a class="reference internal" href="../library/os.html#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.listdir()</span></code></a> retorna una lista de cadenas de caracteres, los nombres de archivo que no se pueden decodificar correctamente se omiten en lugar de lanzar <a class="reference internal" href="../library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>.</p></li>
<li><p>Algunas APIs del sistema como <a class="reference internal" href="../library/os.html#os.environ" title="os.environ"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.environ</span></code></a> y <a class="reference internal" href="../library/sys.html#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.argv</span></code></a> también pueden presentar problemas cuando los bytes puestos a disposición por el sistema no son interpretables usando la codificación predeterminada. Probablemente el mejor abordaje sea asignando la variable <code class="docutils literal notranslate"><span class="pre">LANG</span></code> y volviendo a ejecutar el programa.</p></li>
<li><p><span class="target" id="index-74"></span><a class="pep reference external" href="https://peps.python.org/pep-3138/"><strong>PEP 3138</strong></a>: El <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> de una cadena de caracteres ya no escapa caracteres no ASCII. Sin embargo, todavía escapa caracteres de control caracteres y puntos de código con estado no imprimible en el estándar the Unicode.</p></li>
<li><p><span class="target" id="index-75"></span><a class="pep reference external" href="https://peps.python.org/pep-3120/"><strong>PEP 3120</strong></a>: La codificación de fuente predeterminada ahora es UTF-8.</p></li>
<li><p><span class="target" id="index-76"></span><a class="pep reference external" href="https://peps.python.org/pep-3131/"><strong>PEP 3131</strong></a>: Letras no ASCII ahora están permitidas en identificadores. (De todas maneras, la librería estándar permanece como sólo ASCII con la excepción de nombres de colaboradores en comentarios.)</p></li>
<li><p>Los módulos <code class="xref py py-mod docutils literal notranslate"><span class="pre">StringIO</span></code> and <code class="xref py py-mod docutils literal notranslate"><span class="pre">cStringIO</span></code> ya no están. En su lugar, se importa el módulo the <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> y se usa <a class="reference internal" href="../library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a> o <a class="reference internal" href="../library/io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BytesIO</span></code></a> para texto y datos respectivamente.</p></li>
<li><p>Ver también <a class="reference internal" href="../howto/unicode.html#unicode-howto"><span class="std std-ref">CÓMO (HOWTO) Unicode</span></a>, que fue actualizado para Python 3.0.</p></li>
</ul>
</section>
</section>
<section id="overview-of-syntax-changes">
<h2>Descripción general de los cambios de sintaxis<a class="headerlink" href="#overview-of-syntax-changes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Esta sección brinda una descripción general breve de cada cambio <em>sintáctico</em> en Python 3.0.</p>
<section id="new-syntax">
<h3>Nueva sintaxis<a class="headerlink" href="#new-syntax" title="Enlazar permanentemente con este título">¶</a></h3>
<ul>
<li><p><span class="target" id="index-77"></span><a class="pep reference external" href="https://peps.python.org/pep-3107/"><strong>PEP 3107</strong></a>: Argumento de función y anotaciones de valor retornado. Esto proporciona una forma estandarizada de anotar los parámetros y el valor retornado de una función. No hay semántica asociada a estas anotaciones, excepto que se pueden introspeccionar en tiempo de ejecución mediante el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code>. La intención es fomentar la experimentación a través de metaclases, decoradores o <em>frameworks</em>.</p></li>
<li><p><span class="target" id="index-78"></span><a class="pep reference external" href="https://peps.python.org/pep-3102/"><strong>PEP 3102</strong></a>: Argumentos de sólo palabra clave. Los parámetros con nombre que se producen después de <code class="docutils literal notranslate"><span class="pre">*args</span></code> en la lista de parámetros <em>deben</em> especificarse mediante la sintaxis de palabra clave en la llamada. También puede usarse apenas un <code class="docutils literal notranslate"><span class="pre">*</span></code> sólo en la lista de parámetros para indicar que no se acepta una lista de argumentos de longitud variable, pero se tiene argumentos de sólo palabra clave.</p></li>
<li><p>Los argumentos de palabra clave se permiten después de la lista de clases base en una definición de clase. Esto lo usa la nueva convención para especificar una metaclase (consultar la sección siguiente), pero también se puede usar para otros fines, siempre y cuando la metaclase la admita.</p></li>
<li><p><span class="target" id="index-79"></span><a class="pep reference external" href="https://peps.python.org/pep-3104/"><strong>PEP 3104</strong></a>: Declaración <a class="reference internal" href="../reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a>. Utilizando <code class="docutils literal notranslate"><span class="pre">nonlocal</span> <span class="pre">x</span></code> ahora se puede asignar directamente a una variable en un entorno externo (pero no global). <code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code> es una nueva palabra reservada.</p></li>
<li><p><span class="target" id="index-80"></span><a class="pep reference external" href="https://peps.python.org/pep-3132/"><strong>PEP 3132</strong></a>: Desempaque iterable extendido. Ahora se puede escribir cosas como <code class="docutils literal notranslate"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">*rest</span> <span class="pre">=</span> <span class="pre">some_sequence</span></code>. E incluso <code class="docutils literal notranslate"><span class="pre">*rest,</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">cosas</span></code>. El objeto <code class="docutils literal notranslate"><span class="pre">rest</span></code> es siempre una lista (posiblemente vacía); el lado derecho puede ser cualquier iterable. Ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Esto asigna <em>a</em> a <code class="docutils literal notranslate"><span class="pre">0</span></code>, <em>b</em> a <code class="docutils literal notranslate"><span class="pre">4</span></code>, y <em>rest</em> a <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code>.</p>
</li>
<li><p>Comprensiones por diccionario: <code class="docutils literal notranslate"><span class="pre">{k:</span> <span class="pre">v</span> <span class="pre">for</span> <span class="pre">k,</span> <span class="pre">v</span> <span class="pre">in</span> <span class="pre">cosas}</span></code> significa lo mismo que <code class="docutils literal notranslate"><span class="pre">dict(cosas)</span></code>, pero es más flexible. (Esto es <span class="target" id="index-81"></span><a class="pep reference external" href="https://peps.python.org/pep-0274/"><strong>PEP 274</strong></a> reivindicado. :-)</p></li>
<li><p>Asignar los literales, por ejemplo, <code class="docutils literal notranslate"><span class="pre">{1,</span> <span class="pre">2}</span></code>. Tener en cuenta que <code class="docutils literal notranslate"><span class="pre">{}</span></code> es un diccionario vacío; utilizar <code class="docutils literal notranslate"><span class="pre">set()</span></code> para un conjunto vacío. También se admiten las comprensiones de conjunto; por ejemplo, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">cosas</span></code> significa lo mismo que <code class="docutils literal notranslate"><span class="pre">set(cosas)</span></code>, pero es más flexible.</p></li>
<li><p>Nuevos octales literales, por ejemplo, <code class="docutils literal notranslate"><span class="pre">0o720</span></code> (ya en 2.6). Los octales literales viejos (<code class="docutils literal notranslate"><span class="pre">0720</span></code>) se eliminaron.</p></li>
<li><p>Nuevos literales binarios, por ejemplo, <code class="docutils literal notranslate"><span class="pre">0b1010</span></code> (ya en 2.6), y hay una nueva función incorporada correspondiente, <a class="reference internal" href="../library/functions.html#bin" title="bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin()</span></code></a>.</p></li>
<li><p>Los literales de bytes se introducen con un <code class="docutils literal notranslate"><span class="pre">b</span></code> o <code class="docutils literal notranslate"><span class="pre">B</span></code> delantero, y hay una nueva función incorporada correspondiente, <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes()</span></code></a>.</p></li>
</ul>
</section>
<section id="changed-syntax">
<h3>Sintaxis modificada<a class="headerlink" href="#changed-syntax" title="Enlazar permanentemente con este título">¶</a></h3>
<ul>
<li><p><span class="target" id="index-82"></span><a class="pep reference external" href="https://peps.python.org/pep-3109/"><strong>PEP 3109</strong></a> y <span class="target" id="index-83"></span><a class="pep reference external" href="https://peps.python.org/pep-3134/"><strong>PEP 3134</strong></a>: Nueva sintaxis de la instrucción <a class="reference internal" href="../reference/simple_stmts.html#raise"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">raise</span></code></a>: <code class="samp docutils literal notranslate"><span class="pre">raise</span> <span class="pre">[</span><em><span class="pre">expr</span></em> <span class="pre">[from</span> <em><span class="pre">expr</span></em><span class="pre">]]</span></code>. Ver a continuación.</p></li>
<li><p><code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> y <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> ahora son palabras reservadas. (Desde 2.6, de hecho.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code> y <code class="docutils literal notranslate"><span class="pre">None</span></code> son palabras reservadas. (2.6 parcialmente estableció restricciones ya en <code class="docutils literal notranslate"><span class="pre">None</span></code>.)</p></li>
<li><p>Cambio de <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> <em>exc</em>, <em>var</em> a <code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code> <em>exc</em> <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> <em>var</em>.Ver <span class="target" id="index-84"></span><a class="pep reference external" href="https://peps.python.org/pep-3110/"><strong>PEP 3110</strong></a>.</p></li>
<li><p><span class="target" id="index-85"></span><a class="pep reference external" href="https://peps.python.org/pep-3115/"><strong>PEP 3115</strong></a>: Nueva sintaxis de metaclase. En lugar de:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">M</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>ahora se debe usar:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">M</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Ya no se admite la variable de módulo global <code class="xref py py-data docutils literal notranslate"><span class="pre">__metaclass__</span></code>. (Era una muleta para facilitar al valor predeterminado a las clases de estilo nuevo sin derivar todas las clases de <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>.)</p>
</li>
<li><p>Las listas por comprensión ya no admiten la forma sintáctica <code class="samp docutils literal notranslate"><span class="pre">[...</span> <span class="pre">for</span> <em><span class="pre">var</span></em> <span class="pre">in</span> <em><span class="pre">item1</span></em><span class="pre">,</span> <em><span class="pre">item2</span></em><span class="pre">,</span> <span class="pre">...]</span></code>. Utilizar <code class="samp docutils literal notranslate"><span class="pre">[...</span> <span class="pre">for</span><em><span class="pre">var</span></em> <span class="pre">in</span> <span class="pre">(</span><em><span class="pre">item1</span></em><span class="pre">,</span> <em><span class="pre">item2</span></em><span class="pre">,</span> <span class="pre">...)]</span></code> en su lugar. También tener en cuenta que las listas por comprensión tienen semántica diferente: están más cerca del azúcar sintáctico para una expresión de generador dentro de un constructor <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-func docutils literal notranslate"><span class="pre">list()</span></code></a> y, en particular, las variables de control de bucle ya no se filtran en el ámbito circundante.</p></li>
<li><p>La <em>elipsis</em> (<code class="docutils literal notranslate"><span class="pre">...</span></code>) puede ser utilizada como una expresión atómica en cualquier lugar. (Previamente sólo estaba permitida en segmentos.) Asimismo, esto ahora <em>debe</em> ser escrito como <code class="docutils literal notranslate"><span class="pre">...</span></code>. (Anteriormente, también podía ser escrito como <code class="docutils literal notranslate"><span class="pre">.</span> <span class="pre">.</span> <span class="pre">.</span></code>, por un mero accidente de la gramática.)</p></li>
</ul>
</section>
<section id="removed-syntax">
<h3>Sintaxis eliminada<a class="headerlink" href="#removed-syntax" title="Enlazar permanentemente con este título">¶</a></h3>
<ul class="simple">
<li><p><span class="target" id="index-86"></span><a class="pep reference external" href="https://peps.python.org/pep-3113/"><strong>PEP 3113</strong></a>: Desempaque de parámetros de tupla eliminados. Ya no se puede escribir <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">foo(a,</span> <span class="pre">(b,</span> <span class="pre">c)):</span> <span class="pre">...</span></code>. Utilizar <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">foo(a,</span> <span class="pre">b_c):</span> <span class="pre">b,</span> <span class="pre">c</span> <span class="pre">=</span> <span class="pre">b_c</span></code> en su lugar.</p></li>
<li><p>Comillas invertidas eliminadas (usar <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> en su lugar).</p></li>
<li><p>Eliminados <code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code> (usar <code class="docutils literal notranslate"><span class="pre">!=</span></code> en su lugar).</p></li>
<li><p>Palabra clave eliminada: <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> ya no es una palabra clave; continúa siendo una función. (Afortunadamente la sintaxis de la función también era aceptada en 2.x.) Asimismo, nótese que la <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> ya no toma un argumento de flujo; en lugar de <code class="docutils literal notranslate"><span class="pre">exec(f)</span></code> se puede utilizar <code class="docutils literal notranslate"><span class="pre">exec(f.read())</span></code>.</p></li>
<li><p>Literales enteros no admiten más <code class="docutils literal notranslate"><span class="pre">l</span></code> o <code class="docutils literal notranslate"><span class="pre">L</span></code> finales.</p></li>
<li><p>Literales de cadena de caracteres no admiten más <code class="docutils literal notranslate"><span class="pre">u</span></code> or <code class="docutils literal notranslate"><span class="pre">U</span></code> iniciales.</p></li>
<li><p>La sintaxis <a class="reference internal" href="../reference/simple_stmts.html#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> <em>module</em> <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> <code class="docutils literal notranslate"><span class="pre">*</span></code> solo se permite en el nivel de módulo, ya no dentro de las funciones.</p></li>
<li><p>La única sintaxis aceptable para <em>imports</em> relativos es <code class="samp docutils literal notranslate"><span class="pre">from</span> <span class="pre">.[</span><em><span class="pre">module</span></em><span class="pre">]</span> <span class="pre">import</span> <em><span class="pre">name</span></em></code>. Todos los formularios <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> que no comienzan con <code class="docutils literal notranslate"><span class="pre">.</span></code> son interpretados como <em>imports</em> absolutos</p></li>
<li><p>Se eliminaron las clases clásicas.</p></li>
</ul>
</section>
</section>
<section id="changes-already-present-in-python-2-6">
<h2>Cambios ya presentes en Python 2.6<a class="headerlink" href="#changes-already-present-in-python-2-6" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Dado que es de suponer que muchos usuarios saltan directamente de Python 2.5 a Python 3.0, esta sección recuerda al lector nuevas características que se diseñaron originalmente para Python 3.0 pero que fueron llevadas hacia atrás a Python 2.6. Las secciones correspondientes en <a class="reference internal" href="2.6.html#whats-new-in-2-6"><span class="std std-ref">Qué hay de nuevo en Python 2.6</span></a> deberían ser consultadas para descripciones más largas.</p>
<ul class="simple">
<li><p><a class="reference internal" href="2.6.html#pep-0343"><span class="std std-ref">PEP 343: La sentencia “with”</span></a>.La declaración <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> ahora es una característica estándar y ya no necesita ser importada del <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a>. También puede revisarse <a class="reference internal" href="2.6.html#new-26-context-managers"><span class="std std-ref">Escribiendo gestores de contexto</span></a> y <a class="reference internal" href="2.6.html#new-module-contextlib"><span class="std std-ref">El módulo contextlib</span></a>.</p></li>
<li><p><a class="reference internal" href="2.6.html#pep-0366"><span class="std std-ref">PEP 366: Importaciones relativas explícitas desde un módulo principal</span></a>. Esto mejora la utilidad de opción <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a> cuando el módulo al que se hace referencia vive en un paquete.</p></li>
<li><p><a class="reference internal" href="2.6.html#pep-0370"><span class="std std-ref">PEP 370: Directorio de site-packages por usuario</span></a>.</p></li>
<li><p><a class="reference internal" href="2.6.html#pep-0371"><span class="std std-ref">PEP 371: El paquete multiprocessing</span></a>.</p></li>
<li><p><a class="reference internal" href="2.6.html#pep-3101"><span class="std std-ref">PEP 3101: Formateo avanzado de cadena de caracteres</span></a>. Nota: la descripción 2.6 menciona el método <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">format()</span></code></a> tanto para cadenas de caracteres 8 bits como de Unicode. En 3.0, solo el tipo <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> (cadenas de texto con compatibilidad con Unicode) admite este método; el tipo <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> no. El plan es a la larga convertir esta en la única API para el formato de cadena de caracteres y comenzar a dejar de utilizar el operador <code class="docutils literal notranslate"><span class="pre">%</span></code> en Python 3.1.</p></li>
<li><p><a class="reference internal" href="2.6.html#pep-3105"><span class="std std-ref">PEP 3105: print como función</span></a>. Esta ahora es una característica estándar y ya no necesita ser importada de <a class="reference internal" href="../library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a>. Más detalles fueron dados anteriormente.</p></li>
<li><p><a class="reference internal" href="2.6.html#pep-3110"><span class="std std-ref">PEP 3110: Cambios en el manejo de excepciones</span></a>. La sintaxis <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> <em>exc</em> <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> <em>var</em> ahora es estándar y <code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code> <em>exc</em>, <em>var</em> ya no es compatible. (Por supuesto, la parte <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> <em>var</em> sigue siendo opcional.)</p></li>
<li><p><a class="reference internal" href="2.6.html#pep-3112"><span class="std std-ref">PEP 3112: Literales de bytes</span></a>. La notación literal de cadena de caracteres <code class="docutils literal notranslate"><span class="pre">b&quot;...&quot;</span></code> (y sus variantes como <code class="docutils literal notranslate"><span class="pre">b'...'</span></code>, <code class="docutils literal notranslate"><span class="pre">b&quot;&quot;&quot;...&quot;&quot;&quot;</span></code>, y <code class="docutils literal notranslate"><span class="pre">br&quot;...&quot;</span></code>) ahora genera un literal de tipo <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p></li>
<li><p><a class="reference internal" href="2.6.html#pep-3116"><span class="std std-ref">PEP 3116: Nueva biblioteca de E/S</span></a>. El módulo <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> ahora es la forma estándar de hacer E/S de archivos. La función incorporada <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> ahora es un alias para <a class="reference internal" href="../library/io.html#io.open" title="io.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">io.open()</span></code></a> y tiene argumentos de palabra clave adicionales <em>encoding</em>, <em>errors</em>, <em>newline</em> y <em>closefd</em>. Tener en cuenta también que un argumento <em>mode</em> inválido ahora lanza <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>, no <a class="reference internal" href="../library/exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IOError</span></code></a>. Se puede acceder al objeto de archivo binario subyacente a un objeto de archivo de texto como <code class="xref py py-attr docutils literal notranslate"><span class="pre">f.buffer</span></code> (pero tener en cuenta que el objeto de texto mantiene un búfer de sí mismo para acelerar las operaciones de codificación y descodificación).</p></li>
<li><p><a class="reference internal" href="2.6.html#pep-3118"><span class="std std-ref">PEP 3118: Protocolo revisado de la memoria intermedia</span></a>. El antiguo <code class="xref py py-func docutils literal notranslate"><span class="pre">buffer()</span></code> incorporado ahora realmente se ha eliminado; el <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-func docutils literal notranslate"><span class="pre">memoryview()</span></code></a> incorporado nuevo proporciona (mayormente) una funcionalidad similar.</p></li>
<li><p><a class="reference internal" href="2.6.html#pep-3119"><span class="std std-ref">PEP 3119: Clases base abstractas</span></a>. El módulo <a class="reference internal" href="../library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a> y los ABC definidos en el módulo <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> desempeñan un papel algo más destacado en el lenguaje ahora, y los tipos de colección incorporados como <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> y <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> se ajustan a los ABCs de <code class="xref py py-class docutils literal notranslate"><span class="pre">collections.MutableMapping</span></code> y <code class="xref py py-class docutils literal notranslate"><span class="pre">collections.MutableSequence</span></code>, respectivamente.</p></li>
<li><p><a class="reference internal" href="2.6.html#pep-3127"><span class="std std-ref">PEP 3127: Soporte y sintaxis de literales enteros</span></a>. Como se mencionó anteriormente, la nueva notación literal octal es la única admitida y se han agregado literales binarios.</p></li>
<li><p><a class="reference internal" href="2.6.html#pep-3129"><span class="std std-ref">PEP 3129: Decoradores de clase</span></a>.</p></li>
<li><p><a class="reference internal" href="2.6.html#pep-3141"><span class="std std-ref">PEP 3141: Una jerarquía de tipos para los números</span></a>. El módulo <a class="reference internal" href="../library/numbers.html#module-numbers" title="numbers: Numeric abstract base classes (Complex, Real, Integral, etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">numbers</span></code></a> es otro uso nuevo de ABCs, definiendo la «torre numérica» de Python. También tener en cuenta el nuevo módulo <a class="reference internal" href="../library/fractions.html#module-fractions" title="fractions: Rational numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">fractions</span></code></a> que implementa <a class="reference internal" href="../library/numbers.html#numbers.Rational" title="numbers.Rational"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Rational</span></code></a>.</p></li>
</ul>
</section>
<section id="library-changes">
<h2>Cambios de biblioteca<a class="headerlink" href="#library-changes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Debido a las limitaciones de tiempo, este documento no cubre exhaustivamente los muy extensos cambios en la biblioteca estándar. <span class="target" id="index-87"></span><a class="pep reference external" href="https://peps.python.org/pep-3108/"><strong>PEP 3108</strong></a> es la referencia para los principales cambios en la biblioteca. Aquí hay una revisión de cápsula:</p>
<ul>
<li><p>Se eliminaron muchos módulos antiguos. Algunos, como <code class="xref py py-mod docutils literal notranslate"><span class="pre">gopherlib</span></code> (ya no se usa) y <code class="xref py py-mod docutils literal notranslate"><span class="pre">md5</span></code> (reemplazado por <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a>), ya estaban en desuso por <span class="target" id="index-88"></span><a class="pep reference external" href="https://peps.python.org/pep-0004/"><strong>PEP 4</strong></a>. Otros fueron eliminados como resultado de la eliminación de soporte para varias plataformas como Irix, BeOS y Mac OS 9 (ver <span class="target" id="index-89"></span><a class="pep reference external" href="https://peps.python.org/pep-0011/"><strong>PEP 11</strong></a>). Algunos módulos también fueron seleccionados para su eliminación en Python 3.0 debido a la falta de uso o porque existe un mejor reemplazo. Consultar <span class="target" id="index-90"></span><a class="pep reference external" href="https://peps.python.org/pep-3108/"><strong>PEP 3108</strong></a> para obtener una lista exhaustiva.</p></li>
<li><p>El paquete <code class="xref py py-mod docutils literal notranslate"><span class="pre">bsddb3</span></code> fue eliminado porque su presencia en la biblioteca estándar principal ha demostrado con el tiempo ser una particular carga para los desarrolladores principales, debido a la inestabilidad de las pruebas y la programación del lanzamiento de Berkeley DB. Sin embargo, el paquete está vivo y bien, mantenido externamente en <a class="reference external" href="https://www.jcea.es/programacion/pybsddb.htm">https://www.jcea.es/programacion/pybsddb.htm</a>.</p></li>
<li><p>Algunos módulos fueron renombrados porque su antiguo nombre desobedeció <span class="target" id="index-91"></span><a class="pep reference external" href="https://peps.python.org/pep-0008/"><strong>PEP 8</strong></a>, o por varias otras razones. Aquí está la lista:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Nombre anterior</p></th>
<th class="head"><p>Nombre nuevo</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>_winreg</p></td>
<td><p>winreg</p></td>
</tr>
<tr class="row-odd"><td><p>ConfigParser</p></td>
<td><p>configparser</p></td>
</tr>
<tr class="row-even"><td><p>copy_reg</p></td>
<td><p>copyreg</p></td>
</tr>
<tr class="row-odd"><td><p>Queue</p></td>
<td><p>queue</p></td>
</tr>
<tr class="row-even"><td><p>SocketServer</p></td>
<td><p>socketserver</p></td>
</tr>
<tr class="row-odd"><td><p>markupbase</p></td>
<td><p>_markupbase</p></td>
</tr>
<tr class="row-even"><td><p>repr</p></td>
<td><p>reprlib</p></td>
</tr>
<tr class="row-odd"><td><p>test.test_support</p></td>
<td><p>test.support</p></td>
</tr>
</tbody>
</table>
</li>
<li><p>Un patrón común en Python 2.x es tener una versión de un módulo implementado en Python puro, con una versión acelerada opcional implementada como una extensión C; por ejemplo, <a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> y <code class="xref py py-mod docutils literal notranslate"><span class="pre">cPickle</span></code>. Esto coloca la carga de importar la versión acelerada y volver a caer en la versión de Python pura en cada usuario de estos módulos. En Python 3.0, las versiones aceleradas se consideran detalles de implementación de las versiones puras de Python. Los usuarios siempre deberían importar la versión estándar, que intenta importar la versión acelerada y vuelve a la versión de Python pura. El par <a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> / <code class="xref py py-mod docutils literal notranslate"><span class="pre">cPickle</span></code> recibió este tratamiento. El módulo <a class="reference internal" href="../library/profile.html#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a> está en la lista para 3.1. El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">StringIO</span></code> se ha convertido en una clase en el módulo <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a>.</p></li>
<li><p>Algunos módulos relacionados se han agrupado en paquetes y, por lo general, los nombres de submódulo se han simplificado. Los nuevos paquetes resultantes son:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../library/dbm.html#module-dbm" title="dbm: Interfaces to various Unix &quot;database&quot; formats."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm</span></code></a> (<code class="xref py py-mod docutils literal notranslate"><span class="pre">anydbm</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">dbhash</span></code>, <a class="reference internal" href="../library/dbm.html#module-dbm" title="dbm: Interfaces to various Unix &quot;database&quot; formats."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm</span></code></a>,
<code class="xref py py-mod docutils literal notranslate"><span class="pre">dumbdbm</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">gdbm</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">whichdb</span></code>).</p></li>
<li><p><a class="reference internal" href="../library/html.html#module-html" title="html: Helpers for manipulating HTML."><code class="xref py py-mod docutils literal notranslate"><span class="pre">html</span></code></a> (<code class="xref py py-mod docutils literal notranslate"><span class="pre">HTMLParser</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">htmlentitydefs</span></code>).</p></li>
<li><p><a class="reference internal" href="../library/http.html#module-http" title="http: HTTP status codes and messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">http</span></code></a> (<code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">BaseHTTPServer</span></code>,
<code class="xref py py-mod docutils literal notranslate"><span class="pre">CGIHTTPServer</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">SimpleHTTPServer</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">Cookie</span></code>,
<code class="xref py py-mod docutils literal notranslate"><span class="pre">cookielib</span></code>).</p></li>
<li><p><a class="reference internal" href="../library/tkinter.html#module-tkinter" title="tkinter: Interface to Tcl/Tk for graphical user interfaces"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tkinter</span></code></a> (todos los módulos relacionados con <code class="xref py py-mod docutils literal notranslate"><span class="pre">Tkinter</span></code> excepto <a class="reference internal" href="../library/turtle.html#module-turtle" title="turtle: An educational framework for simple graphics applications"><code class="xref py py-mod docutils literal notranslate"><span class="pre">turtle</span></code></a>). Al público objetivo de <a class="reference internal" href="../library/turtle.html#module-turtle" title="turtle: An educational framework for simple graphics applications"><code class="xref py py-mod docutils literal notranslate"><span class="pre">turtle</span></code></a> no le interesa realmente <a class="reference internal" href="../library/tkinter.html#module-tkinter" title="tkinter: Interface to Tcl/Tk for graphical user interfaces"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tkinter</span></code></a>. También tener en cuenta que a partir de Python 2.6, la funcionalidad de <a class="reference internal" href="../library/turtle.html#module-turtle" title="turtle: An educational framework for simple graphics applications"><code class="xref py py-mod docutils literal notranslate"><span class="pre">turtle</span></code></a> se ha mejorado considerablemente.</p></li>
<li><p><a class="reference internal" href="../library/urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> (<a class="reference internal" href="../library/urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib2</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">urlparse</span></code>,
<code class="xref py py-mod docutils literal notranslate"><span class="pre">robotparse</span></code>).</p></li>
<li><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpc</span></code> (<code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpclib</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">DocXMLRPCServer</span></code>,
<code class="xref py py-mod docutils literal notranslate"><span class="pre">SimpleXMLRPCServer</span></code>).</p></li>
</ul>
</li>
</ul>
<p>Algunos otros cambios a los módulos de la biblioteca estándar, no cubiertos por <span class="target" id="index-92"></span><a class="pep reference external" href="https://peps.python.org/pep-3108/"><strong>PEP 3108</strong></a>:</p>
<ul class="simple">
<li><p>Quitado <code class="xref py py-mod docutils literal notranslate"><span class="pre">sets</span></code>. Usar la clase incorporada <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-func docutils literal notranslate"><span class="pre">set()</span></code></a>.</p></li>
<li><p>Limpiado el módulo <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a>: quitado <code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exitfunc()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_clear()</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.exc_type</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.exc_value</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.exc_traceback</span></code>. (Notar que <a class="reference internal" href="../library/sys.html#sys.last_type" title="sys.last_type"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.last_type</span></code></a> etc. permanece.)</p></li>
<li><p>Limpiado del tipo <a class="reference internal" href="../library/array.html#array.array" title="array.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">array.array</span></code></a>: los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> ya no están; usar <code class="xref py py-meth docutils literal notranslate"><span class="pre">fromfile()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">tofile()</span></code> en su lugar. Asimismo, the el código de tipo <code class="docutils literal notranslate"><span class="pre">'c'</span></code> para arreglo ya no está– utilizar o bien <code class="docutils literal notranslate"><span class="pre">'b'</span></code> para bytes o <code class="docutils literal notranslate"><span class="pre">'u'</span></code> para caracteres Unicode.</p></li>
<li><p>Limpieza del módulo <a class="reference internal" href="../library/operator.html#module-operator" title="operator: Functions corresponding to the standard operators."><code class="xref py py-mod docutils literal notranslate"><span class="pre">operator</span></code></a>: quitados <code class="xref py py-func docutils literal notranslate"><span class="pre">sequenceIncludes()</span></code> y <code class="xref py py-func docutils literal notranslate"><span class="pre">isCallable()</span></code>.</p></li>
<li><p>Limpieza del módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">thread</span></code>: <code class="xref py py-func docutils literal notranslate"><span class="pre">acquire_lock()</span></code> y <code class="xref py py-func docutils literal notranslate"><span class="pre">release_lock()</span></code> ya no están; utilizar <code class="xref py py-func docutils literal notranslate"><span class="pre">acquire()</span></code> y <code class="xref py py-func docutils literal notranslate"><span class="pre">release()</span></code> en su lugar.</p></li>
<li><p>Limpieza del módulo <a class="reference internal" href="../library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a>: quitada la API <code class="xref py py-func docutils literal notranslate"><span class="pre">jumpahead()</span></code>.</p></li>
<li><p>El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">new</span></code> ya no está.</p></li>
<li><p>Las funciones <code class="xref py py-func docutils literal notranslate"><span class="pre">os.tmpnam()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">os.tempnam()</span></code> y <code class="xref py py-func docutils literal notranslate"><span class="pre">os.tmpfile()</span></code> se han eliminado en favor del módulo <a class="reference internal" href="../library/tempfile.html#module-tempfile" title="tempfile: Generate temporary files and directories."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tempfile</span></code></a>.</p></li>
<li><p>El módulo <a class="reference internal" href="../library/tokenize.html#module-tokenize" title="tokenize: Lexical scanner for Python source code."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tokenize</span></code></a> se ha cambiado para trabajar con bytes. El punto de entrada principal es ahora <a class="reference internal" href="../library/tokenize.html#tokenize.tokenize" title="tokenize.tokenize"><code class="xref py py-func docutils literal notranslate"><span class="pre">tokenize.tokenize()</span></code></a>, en lugar de generate_tokens.</p></li>
<li><p><code class="xref py py-data docutils literal notranslate"><span class="pre">string.letters</span></code> y sus amigos (<code class="xref py py-data docutils literal notranslate"><span class="pre">string.lowercase</span></code> y <code class="xref py py-data docutils literal notranslate"><span class="pre">string.uppercase</span></code>) se han ido. Utilice <a class="reference internal" href="../library/string.html#string.ascii_letters" title="string.ascii_letters"><code class="xref py py-data docutils literal notranslate"><span class="pre">string.ascii_letters</span></code></a>, etc. en su lugar. (El motivo de la eliminación es que <code class="xref py py-data docutils literal notranslate"><span class="pre">string.letters</span></code> y sus amigos tenían un comportamiento específico de la configuración regional, lo cual es una mala idea para «constantes» globales con nombres tan atractivos).</p></li>
<li><p>Renombrado el módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">__builtin__</span></code> a <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> (quitando los guiones bajos, agregando una “s”). La variable <code class="xref py py-data docutils literal notranslate"><span class="pre">__builtins__</span></code> encontrada en la mayoría de los espacios de nombres globales no tiene cambios. Para modificar un <em>builtin</em>, Se debería usar <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a>, no <code class="xref py py-data docutils literal notranslate"><span class="pre">__builtins__</span></code>!</p></li>
</ul>
</section>
<section id="pep-3101-a-new-approach-to-string-formatting">
<h2><span class="target" id="index-58"></span><a class="pep reference external" href="https://peps.python.org/pep-3101/"><strong>PEP 3101</strong></a>: Un nuevo enfoque al formateo de cadena de caracteres<a class="headerlink" href="#pep-3101-a-new-approach-to-string-formatting" title="Enlazar permanentemente con este título">¶</a></h2>
<ul class="simple">
<li><p>Un nuevo sistema para operaciones de formateo de cadenas de caracteres incorporadas reemplaza el operador de formato de cadena de caracteres <code class="docutils literal notranslate"><span class="pre">%</span></code>. (De todas maneras, el operador <code class="docutils literal notranslate"><span class="pre">%</span></code> sigue siento soportado; será obsoleto en Python 3.1 y quitado del lenguaje en algún momento más adelante.) Leer <span class="target" id="index-93"></span><a class="pep reference external" href="https://peps.python.org/pep-3101/"><strong>PEP 3101</strong></a> para la primicia completa.</p></li>
</ul>
</section>
<section id="changes-to-exceptions">
<h2>Cambios a excepciones<a class="headerlink" href="#changes-to-exceptions" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las APIs para lanzar y capturar excepciones se limpiaron y se agregaron nuevas características poderosas:</p>
<ul>
<li><p><span class="target" id="index-94"></span><a class="pep reference external" href="https://peps.python.org/pep-0352/"><strong>PEP 352</strong></a>: Todas las excepciones deben derivarse (directa o indirectamente) de <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a>. Esta es la raíz de la jerarquía de excepciones. Esto no es nuevo como recomendación, pero el <em>requisito</em> de heredar de <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a> es nuevo. (Python 2.6 aún permitía que las clases clásicas se lanzaran, y no ponía ninguna restricción en lo que se podía capturar.) Como consecuencia, las excepciones de cadena de caracteres finalmente están verdaderamente y completamente muertas.</p></li>
<li><p>Casi todas las excepciones deberían de hecho derivarse de <a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a>; <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a> sólo debe utilizarse como clase base para las excepciones que solo deben controlarse en el nivel superior, como <a class="reference internal" href="../library/exceptions.html#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemExit</span></code></a> o <a class="reference internal" href="../library/exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>. El modismo recomendado para controlar todas las excepciones excepto esta última categoría es usar <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> <a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a>.</p></li>
<li><p><code class="xref py py-exc docutils literal notranslate"><span class="pre">StandardError</span></code> fue eliminado.</p></li>
<li><p>Las excepciones ya no se comportan como secuencias. Utilizar el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">args</span></code> en su lugar.</p></li>
<li><p><span class="target" id="index-95"></span><a class="pep reference external" href="https://peps.python.org/pep-3109/"><strong>PEP 3109</strong></a>: Lanzando excepciones. Ahora se debe usar <code class="samp docutils literal notranslate"><span class="pre">raise</span> <em><span class="pre">Exception</span></em><span class="pre">(</span><em><span class="pre">args</span></em><span class="pre">)</span></code> en lugar de <code class="samp docutils literal notranslate"><span class="pre">raise</span> <em><span class="pre">Exception</span></em><span class="pre">,</span> <em><span class="pre">args</span></em></code>. Adicionalmente, ya no se puede especificar explícitamente un traceback; en su lugar, si se <em>debe</em> hacer esto, se puede asignar directamente al atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__traceback__</span></code> (ver debajo).</p></li>
<li><p><span class="target" id="index-96"></span><a class="pep reference external" href="https://peps.python.org/pep-3110/"><strong>PEP 3110</strong></a>: Atrapando excepciones. Ahora se debe usar <code class="samp docutils literal notranslate"><span class="pre">except</span> <em><span class="pre">AlgunaExcepcion</span></em> <span class="pre">como</span> <em><span class="pre">variable</span></em></code> en lugar de <code class="samp docutils literal notranslate"><span class="pre">except</span> <em><span class="pre">AlgunaExcepcion</span></em><span class="pre">,</span> <em><span class="pre">variable</span></em></code>. Además, la <em>variable</em> es específicamente eliminada cuando el bloque <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> se deja.</p></li>
<li><p><span class="target" id="index-97"></span><a class="pep reference external" href="https://peps.python.org/pep-3134/"><strong>PEP 3134</strong></a>: Encadenamiento de excepciones. Hay dos casos: encadenamiento implícito y encadenamiento explícito. El encadenamiento implícito se produce cuando se lanza una excepción en un bloque de controlador <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> o <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a>. Esto suele ocurrir debido a un error en el bloque de controlador; llamamos a esto una excepción <em>secundaria</em>. En este caso, la excepción original (que se estaba controlando) se guarda como el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__context__</span></code> de la excepción secundaria. El encadenamiento explícito se invoca con esta sintaxis:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">raise</span> <span class="n">SecondaryException</span><span class="p">()</span> <span class="kn">from</span> <span class="nn">primary_exception</span>
</pre></div>
</div>
<p>(donde <em>primary_exception</em> es cualquier expresión que produce un objeto de excepción, probablemente una excepción que se detectó anteriormente). En este caso, la excepción principal se almacena en el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__cause__</span></code> de la excepción secundaria. El traceback impreso recorre la cadena de atributos <code class="xref py py-attr docutils literal notranslate"><span class="pre">__cause__</span></code> y <code class="xref py py-attr docutils literal notranslate"><span class="pre">__context__</span></code> cuando se produce una excepción no controlada e imprime un traceback independiente para cada componente de la cadena, con la excepción principal en la parte superior. (Los usuarios de Java pueden reconocer este comportamiento.)</p>
</li>
<li><p><span class="target" id="index-98"></span><a class="pep reference external" href="https://peps.python.org/pep-3134/"><strong>PEP 3134</strong></a>: Los objetos de excepción ahora almacenan su traceback como el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__traceback__</span></code>. Esto significa que un objeto de excepción ahora contiene toda la información relativa a una excepción y hay menos razones para usar <a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> (aunque este último no se quita).</p></li>
<li><p>Algunos mensajes de excepción se mejoraron cuando Windows falla al cargar un módulo de extensión. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">error</span> <span class="pre">code</span> <span class="pre">193</span></code> ahora es <code class="docutils literal notranslate"><span class="pre">%1</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">a</span> <span class="pre">valid</span> <span class="pre">Win32</span> <span class="pre">application</span></code>. Las cadenas de caracteres ahora tratan con configuraciones regionales no inglesas.</p></li>
</ul>
</section>
<section id="miscellaneous-other-changes">
<h2>Otros cambios diversos<a class="headerlink" href="#miscellaneous-other-changes" title="Enlazar permanentemente con este título">¶</a></h2>
<section id="operators-and-special-methods">
<h3>Operadores y métodos especiales<a class="headerlink" href="#operators-and-special-methods" title="Enlazar permanentemente con este título">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">!=</span></code> ahora retorna lo opuesto de <code class="docutils literal notranslate"><span class="pre">==</span></code>, salvo que <code class="docutils literal notranslate"><span class="pre">==</span></code> retorne <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>.</p></li>
<li><p>El concepto de «métodos independientes» fue quitado del lenguaje. Cuando se refiere a un método como atributo de clase, ahora se obtiene un objeto de función simple.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getslice__()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__setslice__()</span></code> y  <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delslice__()</span></code> se quitaron. La sintaxis <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code> ahora se traduce a <code class="docutils literal notranslate"><span class="pre">a.__getitem__(slice(i,</span> <span class="pre">j))</span></code> (o <code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code> o <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delitem__()</span></code>, cuando se utiliza como destino de asignación o eliminación, respectivamente).</p></li>
<li><p><span class="target" id="index-99"></span><a class="pep reference external" href="https://peps.python.org/pep-3114/"><strong>PEP 3114</strong></a>: El método estándar <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a> se ha renombrado como <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a>.</p></li>
<li><p>Los métodos especiales <code class="xref py py-meth docutils literal notranslate"><span class="pre">__oct__()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hex__()</span></code> se quitaron – <a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a> y <a class="reference internal" href="../library/functions.html#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a> utilizan <code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code> ahora para convertir el argumento a un entero.</p></li>
<li><p>Soporte eliminado para <code class="xref py py-attr docutils literal notranslate"><span class="pre">__members__</span></code> y <code class="xref py py-attr docutils literal notranslate"><span class="pre">__methods__</span></code>.</p></li>
<li><p>Se ha cambiado el nombre de los atributos de función denominados <code class="xref py py-attr docutils literal notranslate"><span class="pre">func_X</span></code> para utilizar el formulario <code class="xref py py-data docutils literal notranslate"><span class="pre">__X__</span></code>, liberando estos nombres en el espacio de nombres de atributo de función para los atributos definidos por el usuario.  Es decir, <code class="xref py py-attr docutils literal notranslate"><span class="pre">func_closure</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">func_code</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">func_defaults</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">func_dict</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">func_doc</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">func_globals</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">func_name</span></code> se renombraron a <code class="xref py py-attr docutils literal notranslate"><span class="pre">__closure__</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__code__</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__defaults__</span></code>, <a class="reference internal" href="../library/stdtypes.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__globals__</span></code>, <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a>, respectivamente.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">__nonzero__()</span></code> ahora es <code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code>.</p></li>
</ul>
</section>
<section id="builtins">
<h3>Incorporados<a class="headerlink" href="#builtins" title="Enlazar permanentemente con este título">¶</a></h3>
<ul class="simple">
<li><p><span class="target" id="index-100"></span><a class="pep reference external" href="https://peps.python.org/pep-3135/"><strong>PEP 3135</strong></a>: Nuevo <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a>. Ahora se puede invocar <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> sin argumentos y (suponiendo que se encuentra en un método de instancia normal definido dentro de una declaración <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a>) se elegirá automáticamente la clase y la instancia correctas. Con argumentos, el comportamiento de <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> no cambia.</p></li>
<li><p><span class="target" id="index-101"></span><a class="pep reference external" href="https://peps.python.org/pep-3111/"><strong>PEP 3111</strong></a>: <code class="xref py py-func docutils literal notranslate"><span class="pre">raw_input()</span></code> se renombró a <a class="reference internal" href="../library/functions.html#input" title="input"><code class="xref py py-func docutils literal notranslate"><span class="pre">input()</span></code></a>.  Es decir, la nueva función <a class="reference internal" href="../library/functions.html#input" title="input"><code class="xref py py-func docutils literal notranslate"><span class="pre">input()</span></code></a> lee una línea de <a class="reference internal" href="../library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin</span></code></a> y la retorna con la línea final despojada. Lanza <a class="reference internal" href="../library/exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a> si la entrada se termina prematuramente. Para obtener el comportamiento anterior de <a class="reference internal" href="../library/functions.html#input" title="input"><code class="xref py py-func docutils literal notranslate"><span class="pre">input()</span></code></a>, utilice <code class="docutils literal notranslate"><span class="pre">eval(input())</span></code>.</p></li>
<li><p>Se añadió una nueva función incorporada <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a> para llamar al método <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> sobre un objeto.</p></li>
<li><p>La estrategia de redondeo de la función <a class="reference internal" href="../library/functions.html#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a> y el tipo de retorno han cambiado.  Los casos exactamente a mitad de camino ahora se redondean al resultado par más cercano en lugar de alejarse de cero. (Por ejemplo, <code class="docutils literal notranslate"><span class="pre">round(2.5)</span></code> ahora retorna “”2”” en lugar de <code class="docutils literal notranslate"><span class="pre">3</span></code>.) <code class="docutils literal notranslate"><span class="pre">round(x[,</span> <span class="pre">n])</span></code> ahora delega en <code class="docutils literal notranslate"><span class="pre">x.__round__([n])</span></code> en lugar de retornar siempre un float. Por lo general, retorna un entero cuando se llama con un único argumento y un valor del mismo tipo que <code class="docutils literal notranslate"><span class="pre">x</span></code> cuando se llama con dos argumentos.</p></li>
<li><p>Se movió <code class="xref py py-func docutils literal notranslate"><span class="pre">intern()</span></code> a <a class="reference internal" href="../library/sys.html#sys.intern" title="sys.intern"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.intern()</span></code></a>.</p></li>
<li><p>Se eliminó: <code class="xref py py-func docutils literal notranslate"><span class="pre">apply()</span></code>. En lugar de <code class="docutils literal notranslate"><span class="pre">apply(f,</span> <span class="pre">args)</span></code> se utiliza <code class="docutils literal notranslate"><span class="pre">f(*args)</span></code>.</p></li>
<li><p>Se eliminó <a class="reference internal" href="../library/functions.html#callable" title="callable"><code class="xref py py-func docutils literal notranslate"><span class="pre">callable()</span></code></a>. En lugar de <code class="docutils literal notranslate"><span class="pre">callable(f)</span></code> se puede utilizar <code class="docutils literal notranslate"><span class="pre">isinstance(f,</span> <span class="pre">collections.Callable)</span></code>. La función <code class="xref py py-func docutils literal notranslate"><span class="pre">operator.isCallable()</span></code> también se quitó.</p></li>
<li><p>Se eliminó <code class="xref py py-func docutils literal notranslate"><span class="pre">coerce()</span></code>. Esta función ya no sirve para nada ahora que las clases clásicas se han quitado.</p></li>
<li><p>Se eliminó <code class="xref py py-func docutils literal notranslate"><span class="pre">execfile()</span></code>. En lugar de <code class="docutils literal notranslate"><span class="pre">execfile(fn)</span></code> utilizar <code class="docutils literal notranslate"><span class="pre">exec(open(fn).read())</span></code>.</p></li>
<li><p>Se eliminó el tipo <code class="xref py py-class docutils literal notranslate"><span class="pre">file</span></code>. Se utiliza <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>. Ahora hay varios tipos diferentes de secuencias que se abren y pueden retornar en el módulo <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a>.</p></li>
<li><p>Se eliminó <code class="xref py py-func docutils literal notranslate"><span class="pre">reduce()</span></code>. Se puede utilizar <a class="reference internal" href="../library/functools.html#functools.reduce" title="functools.reduce"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.reduce()</span></code></a> si es realmente necesario; de todas maneras, 99 por ciento del tiempo un bucle <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> explícito es más legible.</p></li>
<li><p>Se eliminó <code class="xref py py-func docutils literal notranslate"><span class="pre">reload()</span></code>. Se utiliza <a class="reference internal" href="../library/imp.html#imp.reload" title="imp.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">imp.reload()</span></code></a>.</p></li>
<li><p>Se eliminó <code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.has_key()</span></code> – se utiliza el operador <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> en su lugar.</p></li>
</ul>
</section>
</section>
<section id="build-and-c-api-changes">
<h2>Construcción y cambios a la API de C<a class="headerlink" href="#build-and-c-api-changes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Debido a restricciones de tiempo, aquí hay una <em>muy</em> incompleta lista de cambios a la API de C.</p>
<ul class="simple">
<li><p>Se ha eliminado el soporte para varias plataformas, incluyendo pero no limitado a Mac OS 9, BeOS, RISCOS, Irix y Tru64.</p></li>
<li><p><span class="target" id="index-102"></span><a class="pep reference external" href="https://peps.python.org/pep-3118/"><strong>PEP 3118</strong></a>: Nueva API de búfer.</p></li>
<li><p><span class="target" id="index-103"></span><a class="pep reference external" href="https://peps.python.org/pep-3121/"><strong>PEP 3121</strong></a>: Inicialización y finalización de módulos de extensión.</p></li>
<li><p><span class="target" id="index-104"></span><a class="pep reference external" href="https://peps.python.org/pep-3123/"><strong>PEP 3123</strong></a>: Haciendo <a class="reference internal" href="../c-api/structures.html#c.PyObject_HEAD" title="PyObject_HEAD"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_HEAD</span></code></a> conforme al estándar C.</p></li>
<li><p>No más compatibilidad con API C para ejecución restringida.</p></li>
<li><p>Las API C <code class="xref c c-func docutils literal notranslate"><span class="pre">PyNumber_Coerce()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">PyNumber_CoerceEx()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">PyMember_Get()</span></code>, y <code class="xref c c-func docutils literal notranslate"><span class="pre">PyMember_Set()</span></code> se eliminan.</p></li>
<li><p>La nueva API C <a class="reference internal" href="../c-api/import.html#c.PyImport_ImportModuleNoBlock" title="PyImport_ImportModuleNoBlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ImportModuleNoBlock()</span></code></a>, trabaja como <a class="reference internal" href="../c-api/import.html#c.PyImport_ImportModule" title="PyImport_ImportModule"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ImportModule()</span></code></a> pero no bloqueará en el bloqueo de importación (en su lugar, retornará un error).</p></li>
<li><p>Se renombró la conversión booleana de ranura de nivel C y el método: <code class="docutils literal notranslate"><span class="pre">nb_nonzero</span></code> ahora es <code class="docutils literal notranslate"><span class="pre">nb_bool</span></code>.</p></li>
<li><p>Se eliminó <code class="xref c c-macro docutils literal notranslate"><span class="pre">METH_OLDARGS</span></code> y <code class="xref c c-macro docutils literal notranslate"><span class="pre">WITH_CYCLE_GC</span></code> de la API C.</p></li>
</ul>
</section>
<section id="performance">
<h2>Rendimiento<a class="headerlink" href="#performance" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El resultado neto de las generalizaciones 3.0 es que Python 3.0 ejecuta el punto de referencia <em>pystone</em> alrededor de 10% más lenta que Python 2.5. Lo más probable es que la mayor causa sea la eliminación de mayúsculas y minúsculas especiales para enteros pequeños. Hay margen de mejora, ¡pero sucederá después de que se publique 3.0!</p>
</section>
<section id="porting-to-python-3-0">
<h2>Migración a Python 3.0<a class="headerlink" href="#porting-to-python-3-0" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Para migrar código Python 2.5 o 2.6 existente a Python 3.0, la mejor estrategia es la siguiente:</p>
<ol class="arabic simple" start="0">
<li><p>(Prerrequisito:) Comenzar con excelente cobertura de test.</p></li>
<li><p>Migrar a Python 2.6. Esto no debería representar más trabajo que la migración promedio de Python 2.x a Python 2.(x+1). Asegurarse que todos los test pasen.</p></li>
<li><p>(Todavía utilizando 2.6:) Activar el modificador de línea de comandos <code class="xref std std-option docutils literal notranslate"><span class="pre">-3</span></code>. Esto habilita las advertencias sobre las características que se eliminarán (o cambiarán) en 3.0. Ejecutar el conjunto de pruebas de nuevo y corregir el código sobre el que se recibe advertencias hasta que no queden advertencias y todas las pruebas sigan pasando.</p></li>
<li><p>Ejecutar el traductor de origen a origen <code class="docutils literal notranslate"><span class="pre">2to3</span></code> sobre el árbol de código fuente. (Consultar <a class="reference internal" href="../library/2to3.html#to3-reference"><span class="std std-ref">2to3 — Traducción automática de código de Python 2 a 3</span></a> para obtener más información sobre esta herramienta.) Ejecutar el resultado de la traducción en Python 3.0. Corregir manualmente los problemas restantes, solucionando problemas hasta que todos las pruebas vuelvan a pasar.</p></li>
</ol>
<p>No se recomienda intentar escribir código fuente que se ejecute sin cambios en Python 2.6 y 3.0; se tendría que usar un estilo de codificación muy contorsionado, por ejemplo, evitando las sentencias <code class="docutils literal notranslate"><span class="pre">print</span></code>, metaclases y mucho más. Si se mantiene una biblioteca que necesita soportar Python 2.6 y Python 3.0, el mejor enfoque es modificar el paso 3 anterior editando la versión 2.6 del código fuente y ejecutando el traductor <code class="docutils literal notranslate"><span class="pre">2to3</span></code> de nuevo, en lugar de editar la versión 3.0 del código fuente.</p>
<p>Para migrar las extensiones C a Python 3.0, por favor ver <a class="reference internal" href="../howto/cporting.html#cporting-howto"><span class="std std-ref">Portar módulos de extensión a Python 3</span></a>.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">Qué hay de nuevo en Python 3.0</a><ul>
<li><a class="reference internal" href="#common-stumbling-blocks">Escollos comunes</a><ul>
<li><a class="reference internal" href="#print-is-a-function"><em>Print</em> es una función</a></li>
<li><a class="reference internal" href="#views-and-iterators-instead-of-lists">Vistas e iteradores en lugar de listas</a></li>
<li><a class="reference internal" href="#ordering-comparisons">Comparaciones de ordenamiento</a></li>
<li><a class="reference internal" href="#integers">Enteros</a></li>
<li><a class="reference internal" href="#text-vs-data-instead-of-unicode-vs-8-bit">Texto vs. datos en lugar de unicode vs. 8 bits</a></li>
</ul>
</li>
<li><a class="reference internal" href="#overview-of-syntax-changes">Descripción general de los cambios de sintaxis</a><ul>
<li><a class="reference internal" href="#new-syntax">Nueva sintaxis</a></li>
<li><a class="reference internal" href="#changed-syntax">Sintaxis modificada</a></li>
<li><a class="reference internal" href="#removed-syntax">Sintaxis eliminada</a></li>
</ul>
</li>
<li><a class="reference internal" href="#changes-already-present-in-python-2-6">Cambios ya presentes en Python 2.6</a></li>
<li><a class="reference internal" href="#library-changes">Cambios de biblioteca</a></li>
<li><a class="reference internal" href="#pep-3101-a-new-approach-to-string-formatting"><strong>PEP 3101</strong>: Un nuevo enfoque al formateo de cadena de caracteres</a></li>
<li><a class="reference internal" href="#changes-to-exceptions">Cambios a excepciones</a></li>
<li><a class="reference internal" href="#miscellaneous-other-changes">Otros cambios diversos</a><ul>
<li><a class="reference internal" href="#operators-and-special-methods">Operadores y métodos especiales</a></li>
<li><a class="reference internal" href="#builtins">Incorporados</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-and-c-api-changes">Construcción y cambios a la API de C</a></li>
<li><a class="reference internal" href="#performance">Rendimiento</a></li>
<li><a class="reference internal" href="#porting-to-python-3-0">Migración a Python 3.0</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="3.1.html"
                          title="capítulo anterior">Qué hay de nuevo en Python 3.1</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="2.7.html"
                          title="próximo capítulo">Qué hay de nuevo en Python 2.7</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/whatsnew/3.0.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="2.7.html" title="Qué hay de nuevo en Python 2.7"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="3.1.html" title="Qué hay de nuevo en Python 3.1"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Qué hay de nuevo en Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Qué hay de nuevo en Python 3.0</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 23, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>