
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>re — Operaciones con expresiones regulares &#8212; documentación de Python - 3.10.10</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.10.10"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="difflib — Funciones auxiliares para calcular deltas" href="difflib.html" />
    <link rel="prev" title="string — Operaciones comunes de cadena de caracteres" href="string.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/re.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> — Operaciones con expresiones regulares</a><ul>
<li><a class="reference internal" href="#regular-expression-syntax">Sintaxis de expresiones regulares</a></li>
<li><a class="reference internal" href="#module-contents">Contenidos del módulo</a><ul>
<li><a class="reference internal" href="#flags">Flags</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#exceptions">Exceptions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#regular-expression-objects">Objetos expresión regular</a></li>
<li><a class="reference internal" href="#match-objects">Objetos de coincidencia</a></li>
<li><a class="reference internal" href="#regular-expression-examples">Ejemplos de expresiones regulares</a><ul>
<li><a class="reference internal" href="#checking-for-a-pair">Buscando un par</a></li>
<li><a class="reference internal" href="#simulating-scanf">Simular scanf()</a></li>
<li><a class="reference internal" href="#search-vs-match">search() vs. match()</a></li>
<li><a class="reference internal" href="#making-a-phonebook">Haciendo una guía telefónica</a></li>
<li><a class="reference internal" href="#text-munging">Mungear texto</a></li>
<li><a class="reference internal" href="#finding-all-adverbs">Encontrar todos los adverbios</a></li>
<li><a class="reference internal" href="#finding-all-adverbs-and-their-positions">Encontrar todos los adverbios y sus posiciones</a></li>
<li><a class="reference internal" href="#raw-string-notation">Notación de cadena <em>raw</em></a></li>
<li><a class="reference internal" href="#writing-a-tokenizer">Escribir un Tokenizador</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="string.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code> — Operaciones comunes de cadena de caracteres</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="difflib.html"
                        title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code> — Funciones auxiliares para calcular deltas</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/re.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="difflib.html" title="difflib — Funciones auxiliares para calcular deltas"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="string.html" title="string — Operaciones comunes de cadena de caracteres"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La Biblioteca Estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="text.html" accesskey="U">Servicios de procesamiento de texto</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> — Operaciones con expresiones regulares</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-re">
<span id="re-regular-expression-operations"></span><h1><a class="reference internal" href="#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> — Operaciones con expresiones regulares<a class="headerlink" href="#module-re" title="Enlazar permanentemente con este título">¶</a></h1>
<p><strong>Código fuente:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/re.py">Lib/re.py</a></p>
<hr class="docutils" />
<p>Este módulo proporciona operaciones de coincidencia de expresiones regulares similares a las encontradas en Perl.</p>
<p>Tanto los patrones como las cadenas de texto a buscar pueden ser cadenas de Unicode (<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>) así como cadenas de 8 bits (<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>). Sin embargo, las cadenas Unicode y las cadenas de 8 bits no se pueden mezclar: es decir, no se puede hacer coincidir una cadena Unicode con un patrón de bytes o viceversa; del mismo modo, al pedir una sustitución, la cadena de sustitución debe ser del mismo tipo que el patrón y la cadena de búsqueda.</p>
<p>Las expresiones regulares usan el carácter de barra inversa (<code class="docutils literal notranslate"><span class="pre">'\'</span></code>) para indicar formas especiales o para permitir el uso de caracteres especiales sin invocar su significado especial.  Esto choca con el uso de Python de este carácter para el mismo propósito con los literales de cadena; por ejemplo, para hacer coincidir una barra inversa literal, se podría escribir <code class="docutils literal notranslate"><span class="pre">'\\\\'</span></code> como patrón, porque la expresión regular debe ser <code class="docutils literal notranslate"><span class="pre">\\</span></code>, y cada barra inversa debe ser expresada como <code class="docutils literal notranslate"><span class="pre">\\</span></code> dentro de un literal de cadena regular de Python.  También, notar que cualquier secuencia de escape inválida mientras se use la barra inversa de Python en los literales de cadena ahora genera un <a class="reference internal" href="exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> y en el futuro esto se convertirá en un <a class="reference internal" href="exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>.  Este comportamiento ocurrirá incluso si es una secuencia de escape válida para una expresión regular.</p>
<p>La solución es usar la notación de cadena <em>raw</em> de Python para los patrones de expresiones regulares; las barras inversas no se manejan de ninguna manera especial en un literal de cadena prefijado con <code class="docutils literal notranslate"><span class="pre">'r'</span></code>.  Así que <code class="docutils literal notranslate"><span class="pre">r&quot;\n&quot;</span></code> es una cadena de dos caracteres que contiene <code class="docutils literal notranslate"><span class="pre">'\'</span></code> y <code class="docutils literal notranslate"><span class="pre">'n'</span></code>, mientras que <code class="docutils literal notranslate"><span class="pre">&quot;\n&quot;</span></code> es una cadena de un carácter que contiene una nueva línea.  Normalmente los patrones se expresan en código Python usando esta notación de cadena <em>raw</em>.</p>
<p>Es importante señalar que la mayoría de las operaciones de expresiones regulares están disponibles como funciones y métodos a nivel de módulo en <a class="reference internal" href="#re-objects"><span class="std std-ref">expresiones regulares compiladas</span></a> (expresiones regulares compiladas).  Las funciones son atajos que no requieren de compilar un objeto regex primero, aunque pasan por alto algunos parámetros de ajuste.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>El módulo de terceros <a class="reference external" href="https://pypi.org/project/regex/">regex</a> , cuenta con una API compatible con el módulo de la biblioteca estándar <a class="reference internal" href="#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a>, el cual ofrece una funcionalidad adicional y un soporte Unicode más completo.</p>
</div>
<section id="regular-expression-syntax">
<span id="re-syntax"></span><h2>Sintaxis de expresiones regulares<a class="headerlink" href="#regular-expression-syntax" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Una expresión regular (o RE, por sus siglas en inglés) especifica un conjunto de cadenas que coinciden con ella; las funciones de este módulo permiten comprobar si una determinada cadena coincide con una expresión regular dada (o si una expresión regular dada coincide con una determinada cadena, que se reduce a lo mismo).</p>
<p>Las expresiones regulares pueden ser concatenadas para formar nuevas expresiones regulares; si <em>A</em> y <em>B</em> son ambas expresiones regulares, entonces <em>AB</em> es también una expresión regular. En general, si una cadena <em>p</em> coincide con <em>A</em> y otra cadena <em>q</em> coincide con <em>B</em>, la cadena <em>porque</em> coincidirá con AB.  Esto se mantiene a menos que <em>A</em> o <em>B</em> contengan operaciones de baja precedencia; condiciones límite entre <em>A</em> y <em>B</em>; o tengan referencias de grupo numeradas.  Así, las expresiones complejas pueden construirse fácilmente a partir de expresiones primitivas más simples como las que se describen aquí.  Para detalles de la teoría e implementación de las expresiones regulares, consulte el libro de Friedl <a class="reference internal" href="#frie09" id="id1"><span>[Frie09]</span></a>, o casi cualquier libro de texto sobre la construcción de compiladores.</p>
<p>A continuación se explica brevemente el formato de las expresiones regulares.  Para más información y una presentación más amena, consultar la <a class="reference internal" href="../howto/regex.html#regex-howto"><span class="std std-ref">Expresiones regulares COMOS (HOWTO)</span></a>.</p>
<p>Las expresiones regulares pueden contener tanto caracteres especiales como ordinarios. La mayoría de los caracteres ordinarios, como <code class="docutils literal notranslate"><span class="pre">'A'</span></code>, <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, o <code class="docutils literal notranslate"><span class="pre">'0'</span></code> son las expresiones regulares más sencillas; simplemente se ajustan a sí mismas.  Se pueden concatenar caracteres ordinarios, así que <code class="docutils literal notranslate"><span class="pre">last</span></code> coincide con la cadena <code class="docutils literal notranslate"><span class="pre">'last'</span></code>.  (En el resto de esta sección, se escribirán los RE en <code class="docutils literal notranslate"><span class="pre">este</span> <span class="pre">estilo</span> <span class="pre">especial</span></code>, normalmente sin comillas, y las cadenas que deban coincidir <code class="docutils literal notranslate"><span class="pre">'entre</span> <span class="pre">comillas</span> <span class="pre">simples'</span></code>.)</p>
<p>Algunos caracteres, como <code class="docutils literal notranslate"><span class="pre">'|'</span></code> o <code class="docutils literal notranslate"><span class="pre">'('</span></code>, son especiales. Los caracteres especiales representan clases de caracteres ordinarios, o afectan a la forma en que se interpretan las expresiones regulares que los rodean.</p>
<p>Los delimitadores de repetición (<code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code>, <code class="docutils literal notranslate"><span class="pre">{m,n}</span></code>, etc.) no pueden ser anidados directamente. Esto evita la ambigüedad con el sufijo modificador no <em>greedy</em> (codiciosos) <code class="docutils literal notranslate"><span class="pre">?</span></code>, y con otros modificadores en otras implementaciones. Para aplicar una segunda repetición a una repetición interna, se pueden usar paréntesis. Por ejemplo, la expresión <code class="docutils literal notranslate"><span class="pre">(?:a{6})*</span></code> coincide con cualquier múltiplo de seis caracteres <code class="docutils literal notranslate"><span class="pre">'a'</span></code>.</p>
<p>Los caracteres especiales son:</p>
<dl class="simple" id="index-0">
<dt><code class="docutils literal notranslate"><span class="pre">.</span></code></dt><dd><p>(Punto.) En el modo predeterminado, esto coincide con cualquier carácter excepto con una nueva línea.  Si se ha especificado el indicador <a class="reference internal" href="#re.DOTALL" title="re.DOTALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">DOTALL</span></code></a>, esto coincide con cualquier carácter que incluya una nueva línea.</p>
</dd>
</dl>
<dl class="simple" id="index-1">
<dt><code class="docutils literal notranslate"><span class="pre">^</span></code></dt><dd><p>(Circunflejo.)  Coincide con el comienzo de la cadena, y en modo <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> también coincide inmediatamente después de cada nueva línea.</p>
</dd>
</dl>
<dl class="simple" id="index-2">
<dt><code class="docutils literal notranslate"><span class="pre">$</span></code></dt><dd><p>Coincide con el final de la cadena o justo antes de la nueva línea al final de la cadena, y en modo <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> también coincide antes de una nueva línea.  <code class="docutils literal notranslate"><span class="pre">foo</span></code> coincide con “foo” y “foobar”, mientras que la expresión regular <code class="docutils literal notranslate"><span class="pre">foo$</span></code> sólo coincide con “foo”.  Más interesante aún, al buscar <code class="docutils literal notranslate"><span class="pre">foo.$</span></code> en <code class="docutils literal notranslate"><span class="pre">'foo1\nfoo2\n'</span></code> coincide con “foo2” normalmente, pero solo “foo1” en <code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE`</span></code>; si busca un solo <code class="docutils literal notranslate"><span class="pre">$</span></code> en <code class="docutils literal notranslate"><span class="pre">'foo\n'</span></code> encontrará dos coincidencias (vacías): una justo antes de una nueva línea, y otra al final de la cadena.</p>
</dd>
</dl>
<dl class="simple" id="index-3">
<dt><code class="docutils literal notranslate"><span class="pre">*</span></code></dt><dd><p>Hace que el RE resultante coincida con 0 o más repeticiones del RE precedente, tantas repeticiones como sean posibles.  <code class="docutils literal notranslate"><span class="pre">ab*</span></code> coincidirá con “a”, “ab” o “a” seguido de cualquier número de “b”.</p>
</dd>
</dl>
<dl class="simple" id="index-4">
<dt><code class="docutils literal notranslate"><span class="pre">+</span></code></dt><dd><p>Hace que la RE resultante coincida con 1 o más repeticiones de la RE precedente. <code class="docutils literal notranslate"><span class="pre">ab+</span></code> coincidirá con “a” seguido de cualquier número distinto de cero de “b”; no coincidirá solo con “a”.</p>
</dd>
</dl>
<dl class="simple" id="index-5">
<dt><code class="docutils literal notranslate"><span class="pre">?</span></code></dt><dd><p>Hace que la RE resultante coincida con 0 o 1 repeticiones de la RE precedente. <code class="docutils literal notranslate"><span class="pre">ab?</span></code> coincidirá con “a” o “ab”.</p>
</dd>
</dl>
<dl class="simple" id="index-6">
<dt><code class="docutils literal notranslate"><span class="pre">*?</span></code>, <code class="docutils literal notranslate"><span class="pre">+?</span></code>, <code class="docutils literal notranslate"><span class="pre">??</span></code></dt><dd><p>Los delimitadores «*», «+» y «*» son todos <em class="dfn">greedy</em> (codiciosos); coinciden con la mayor cantidad de texto posible.  A veces este comportamiento no es deseado; si el RE <code class="docutils literal notranslate"><span class="pre">&lt;.*&gt;</span></code> se utiliza para coincidir con <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;</span> <span class="pre">b</span> <span class="pre">&lt;c&gt;'</span></code>, coincidirá con toda la cadena, y no sólo con <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;'</span></code>.  Añadiendo <code class="docutils literal notranslate"><span class="pre">?</span></code> después del delimitador hace que se realice la coincidencia de manera <em class="dfn">non-greedy</em> o <em class="dfn">minimal</em>; coincidirá la <em>mínima</em> cantidad de caracteres como sea posible.  Usando el RE <code class="docutils literal notranslate"><span class="pre">&lt;.*?&gt;</span></code> sólo coincidirá con <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;'</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-7">
<dt><code class="docutils literal notranslate"><span class="pre">{m}</span></code></dt><dd><p>Especifica que exactamente <em>m</em> copias de la RE anterior deben coincidir; menos coincidencias hacen que la RE entera no coincida.  Por ejemplo, <code class="docutils literal notranslate"><span class="pre">a{6}</span></code> coincidirá exactamente con seis caracteres <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, pero no con cinco.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{m,n}</span></code></dt><dd><p>Hace que el RE resultante coincida de <em>m</em> a <em>n</em> repeticiones del RE precedente, tratando de coincidir con el mayor número de repeticiones posible.  Por ejemplo, <code class="docutils literal notranslate"><span class="pre">a{3,5}</span></code> coincidirá de 3 a 5 caracteres <code class="docutils literal notranslate"><span class="pre">'a'</span></code>.  Omitiendo <em>m</em> se especifica un límite inferior de cero, y omitiendo <em>n</em> se especifica un límite superior infinito.  Por ejemplo, <code class="docutils literal notranslate"><span class="pre">a{4,}b</span></code> coincidirá con <code class="docutils literal notranslate"><span class="pre">'aaaab'</span></code> o mil caracteres <code class="docutils literal notranslate"><span class="pre">'a'</span></code> seguidos de una <code class="docutils literal notranslate"><span class="pre">'b'</span></code>, pero no <code class="docutils literal notranslate"><span class="pre">'aaab'</span></code>. La coma no puede ser omitida o el modificador se confundiría con la forma descrita anteriormente.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">{m,n}?</span></code></dt><dd><p>Hace que el RE resultante coincida de <em>m</em> a <em>n</em> repeticiones del RE precedente, tratando de coincidir con el <em>mínimo de</em> repeticiones posible.  Esta es la versión <em>non-greedy</em> (no codiciosa) del delimitador anterior.  Por ejemplo, en la cadena de 6 caracteres <code class="docutils literal notranslate"><span class="pre">'aaaaaaa'</span></code>, <code class="docutils literal notranslate"><span class="pre">a{3,5}</span></code> coincidirá con 5 caracteres <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, mientras que <code class="docutils literal notranslate"><span class="pre">a{3,5}?</span></code> solo coincidirá con 3 caracteres.</p>
</dd>
</dl>
<dl id="index-8">
<dt><code class="docutils literal notranslate"><span class="pre">\</span></code></dt><dd><p>O bien se escapan a los caracteres especiales (lo que le permite hacer coincidir caracteres como <code class="docutils literal notranslate"><span class="pre">'*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'?'</span></code>, y así sucesivamente), o se señala una secuencia especial; las secuencias especiales se explican más adelante.</p>
<p>Si no se utiliza una cadena <em>raw</em> para expresar el patrón, recuerde que Python también utiliza la barra inversa como secuencia de escape en los literales de la cadena; si el analizador sintáctico de Python no reconoce la secuencia de escape, la barra inversa y el carácter subsiguiente se incluyen en la cadena resultante.  Sin embargo, si Python quisiera reconocer la secuencia resultante, la barra inversa debería repetirse dos veces.  Esto es complicado y difícil de entender, por lo que se recomienda encarecidamente utilizar cadenas <em>raw</em> para todas las expresiones salvo las más simples.</p>
</dd>
</dl>
<dl id="index-9">
<dt><code class="docutils literal notranslate"><span class="pre">[]</span></code></dt><dd><p>Se utiliza para indicar un conjunto de caracteres.  En un conjunto:</p>
<ul class="simple">
<li><p>Los caracteres pueden ser listados individualmente, ej. <code class="docutils literal notranslate"><span class="pre">[amk]</span></code> coincidirá con <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, o <code class="docutils literal notranslate"><span class="pre">'k'</span></code>.</p></li>
</ul>
<ul class="simple" id="index-10">
<li><p>Los rangos de caracteres se pueden indicar mediante dos caracteres y separándolos con un <code class="docutils literal notranslate"><span class="pre">'-'</span></code>. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">[a-z]</span></code> coincidirá con cualquier letra ASCII en minúscula, <code class="docutils literal notranslate"><span class="pre">[0-5][0-9]</span></code> coincidirá con todos los números de dos dígitos desde el <code class="docutils literal notranslate"><span class="pre">00</span></code> hasta el <code class="docutils literal notranslate"><span class="pre">59</span></code>, y <code class="docutils literal notranslate"><span class="pre">[0-9A-Fa-f]</span></code> coincidirá con cualquier dígito hexadecimal.  Si se escapa <code class="docutils literal notranslate"><span class="pre">-</span></code> (por ejemplo, <code class="docutils literal notranslate"><span class="pre">[a\-z]</span></code>) o si se coloca como el primer o el último carácter (por ejemplo, <code class="docutils literal notranslate"><span class="pre">[-a]</span></code> o <code class="docutils literal notranslate"><span class="pre">[a-]</span></code>), coincidirá con un literal <code class="docutils literal notranslate"><span class="pre">'-'</span></code>.</p></li>
<li><p>Los caracteres especiales pierden su significado especial dentro de los sets.  Por ejemplo, <code class="docutils literal notranslate"><span class="pre">[(+*)]</span></code> coincidirá con cualquiera de los caracteres literales <code class="docutils literal notranslate"><span class="pre">'('</span></code>, <code class="docutils literal notranslate"><span class="pre">'+'</span></code>, <code class="docutils literal notranslate"><span class="pre">'*'</span></code>, o <code class="docutils literal notranslate"><span class="pre">')'</span></code>.</p></li>
</ul>
<ul class="simple" id="index-11">
<li><p>Las clases de caracteres como <code class="docutils literal notranslate"><span class="pre">\w</span></code> o <code class="docutils literal notranslate"><span class="pre">\S</span></code> (definidas más adelante) también se aceptan dentro de un conjunto, aunque los caracteres que coinciden dependen de si el modo <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> o <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> está activo.</p></li>
</ul>
<ul class="simple" id="index-12">
<li><p>Los caracteres que no están dentro de un rango pueden ser coincidentes con <em class="dfn">complementing</em> el conjunto. Si el primer carácter del conjunto es <code class="docutils literal notranslate"><span class="pre">'^'</span></code>, todos los caracteres que <em>no</em> están en el conjunto coincidirán. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">[^5]</span></code> coincidirá con cualquier carácter excepto con <code class="docutils literal notranslate"><span class="pre">'5'</span></code>, y <code class="docutils literal notranslate"><span class="pre">[^^]</span></code> coincidirá con cualquier carácter excepto con <code class="docutils literal notranslate"><span class="pre">'^'</span></code>. <code class="docutils literal notranslate"><span class="pre">^</span></code> no tiene un significado especial si no es el primer carácter del conjunto.</p></li>
<li><p>To match a literal <code class="docutils literal notranslate"><span class="pre">']'</span></code> inside a set, precede it with a backslash, or
place it at the beginning of the set.  For example, both <code class="docutils literal notranslate"><span class="pre">[()[\]{}]</span></code> and
<code class="docutils literal notranslate"><span class="pre">[]()[{}]</span></code> will match a right bracket, as well as left bracket, braces,
and parentheses.</p></li>
</ul>
<ul class="simple">
<li><p>El soporte de conjuntos anidados y operaciones de conjuntos como en <a class="reference external" href="https://unicode.org/reports/tr18/">Unicode Technical Standard #18</a> podría ser añadido en el futuro. Esto cambiaría la sintaxis, así que por el momento se planteará un <a class="reference internal" href="exceptions.html#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FutureWarning</span></code></a> en casos ambiguos para facilitar este cambio. Ello incluye conjuntos que empiecen con un literal <code class="docutils literal notranslate"><span class="pre">'['</span></code> o que contengan secuencias de caracteres literales <code class="docutils literal notranslate"><span class="pre">'—'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&amp;&amp;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'~~'</span></code> y <code class="docutils literal notranslate"><span class="pre">'||'</span></code>. Para evitar una advertencia, utilizar el código de escape con una barra inversa.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span><a class="reference internal" href="exceptions.html#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FutureWarning</span></code></a> se genera si un conjunto de caracteres contiene construcciones que cambiarán semánticamente en el futuro.</p>
</div>
</dd>
</dl>
<dl class="simple" id="index-13">
<dt><code class="docutils literal notranslate"><span class="pre">|</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">A|B</span></code>, donde <em>A</em> y <em>B</em> pueden ser RE arbitrarias, crea una expresión regular que coincidirá con <em>A</em> or <em>B</em>. Un número arbitrario de RE puede ser separado por <code class="docutils literal notranslate"><span class="pre">'|'</span></code> de esta manera. Esto puede también ser usado dentro de grupos (ver más adelante). Cuando la cadena de destino es procesada, los RE separados por <code class="docutils literal notranslate"><span class="pre">'|'</span></code> son probados de izquierda a derecha. Cuando un patrón coincide completamente, esa rama es aceptada. Esto significa que una vez que <em>A</em> coincida, <em>B</em> no se comprobará más, incluso si se produce una coincidencia general más larga. En otras palabras, el operador de <code class="docutils literal notranslate"><span class="pre">'|'</span></code> nunca es codicioso. Para emparejar un literal <code class="docutils literal notranslate"><span class="pre">'|'</span></code>, se usa <code class="docutils literal notranslate"><span class="pre">\|</span></code>, o se envuelve dentro de una clase de caracteres, como en <code class="docutils literal notranslate"><span class="pre">[|]</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-14">
<dt><code class="docutils literal notranslate"><span class="pre">(...)</span></code></dt><dd><p>Coincide con cualquier expresión regular que esté dentro de los paréntesis, e indica el comienzo y el final de un grupo; el contenido de un grupo puede ser recuperado después de que se haya realizado una coincidencia, y puede coincidir más adelante en la cadena con la secuencia especial <code class="docutils literal notranslate"><span class="pre">\number</span></code>, que se describe más adelante. Para hacer coincidir los literales <code class="docutils literal notranslate"><span class="pre">`'('</span></code> o <code class="docutils literal notranslate"><span class="pre">')'</span></code>, se usa <code class="docutils literal notranslate"><span class="pre">\(</span></code> o <code class="docutils literal notranslate"><span class="pre">\)</span></code>, o se envuelve dentro de una clase de caracteres: <code class="docutils literal notranslate"><span class="pre">[(]</span></code>, <code class="docutils literal notranslate"><span class="pre">[)]</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-15">
<dt><code class="docutils literal notranslate"><span class="pre">(?...)</span></code></dt><dd><p>Esta es una notación de extensión (un <code class="docutils literal notranslate"><span class="pre">'?'</span></code> después de un <code class="docutils literal notranslate"><span class="pre">'('</span></code> no tiene ningún otro significado). El primer carácter después de <code class="docutils literal notranslate"><span class="pre">'?'</span></code> determina el significado y la sintaxis de la construcción. Las extensiones normalmente no crean un nuevo grupo; <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;…)</span></code> es la única excepción a esta regla. A continuación se muestran las extensiones actualmente soportadas.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(?aiLmsux)</span></code></dt><dd><p>(Una o más letras del conjunto <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code>.) El grupo coincide con la cadena vacía; las letras ponen los indicadores correspondientes: <a class="reference internal" href="#re.A" title="re.A"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.A</span></code></a> (coincidencia sólo en ASCII), <a class="reference internal" href="#re.I" title="re.I"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.I</span></code></a> (ignorar mayúsculas o minúsculas), <code class="xref py py-const docutils literal notranslate"><span class="pre">re.</span> <span class="pre">L</span></code> (dependiente de la configuración regional), <a class="reference internal" href="#re.M" title="re.M"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.M</span></code></a> (multilínea), <a class="reference internal" href="#re.S" title="re.S"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.S</span></code></a> (el punto coincide con todo), <code class="xref py py-const docutils literal notranslate"><span class="pre">re.U</span></code> (coincidencia con Unicode), y <a class="reference internal" href="#re.X" title="re.X"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.X</span></code></a> (modo <em>verbose</em>), para toda la expresión regular. (Los indicadores se describen en <a class="reference internal" href="#contents-of-module-re"><span class="std std-ref">Contenidos del módulo</span></a>.) Esto es útil si se desea incluir los indicadores como parte de la expresión regular, en lugar de pasar un argumento <em>flag</em> (indicador) a la función <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>. Los indicadores deben ser usados primero en la cadena de expresión.</p>
</dd>
</dl>
<dl id="index-16">
<dt><code class="docutils literal notranslate"><span class="pre">(?:...)</span></code></dt><dd><p>Una versión no capturable de los paréntesis regulares. Hace coincidir cualquier expresión regular que esté dentro de los paréntesis, pero la subcadena coincidente con el grupo <em>no puede</em> ser recuperada después de realizar una coincidencia o referenciada más adelante en el patrón.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">(?aiLmsux-imsx:...)</span></code></dt><dd><p>(Cero o más letras del conjunto <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code>, opcionalmente seguido de <code class="docutils literal notranslate"><span class="pre">'-'</span></code> seguido de una o más letras de <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code>.) Las letras ponen o quitan los indicadores correspondientes: <a class="reference internal" href="#re.A" title="re.A"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.A</span></code></a> (coincidencia sólo en ASCII), <a class="reference internal" href="#re.I" title="re.I"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.I</span></code></a> (ignorar mayúsculas o minúsculas), <code class="xref py py-const docutils literal notranslate"><span class="pre">re.</span> <span class="pre">L</span></code> (dependiente de la configuración regional), <a class="reference internal" href="#re.M" title="re.M"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.M</span></code></a> (multilínea), <a class="reference internal" href="#re.S" title="re.S"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.S</span></code></a> (el punto coincide con todo), <code class="xref py py-const docutils literal notranslate"><span class="pre">re.U</span></code> (coincidencia con Unicode), y <a class="reference internal" href="#re.X" title="re.X"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.X</span></code></a> (modo <em>verbose</em>) para la parte de la expresión. (Los indicadores se describen en <a class="reference internal" href="#contents-of-module-re"><span class="std std-ref">Contenidos del módulo</span></a>.)</p>
<p>Las letras <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code> y <code class="docutils literal notranslate"><span class="pre">'u'</span></code> se excluyen mutuamente cuando se usan como indicadores en línea, así que no pueden combinarse o ser seguidos por <code class="docutils literal notranslate"><span class="pre">'-'</span></code>. En cambio, cuando uno de ellos aparece en un grupo dentro de la línea, anula el modo de coincidencia en el grupo que lo rodea. En los patrones Unicode, <code class="docutils literal notranslate"><span class="pre">(?a:…)</span></code> cambia al modo de concordancia sólo en ASCII, y <code class="docutils literal notranslate"><span class="pre">(?u:…)</span></code> cambia al modo de concordancia Unicode (por defecto). En el patrón de bytes <code class="docutils literal notranslate"><span class="pre">(?L:…)</span></code> se cambia a una correspondencia en función de la configuración regional, y <code class="docutils literal notranslate"><span class="pre">(?a:…)</span></code> se cambia a una correspondencia sólo en ASCII (predeterminado). Esta anulación sólo tiene efecto para el grupo de línea restringida, y el modo de coincidencia original se restaura fuera del grupo.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Las letras <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code> y <code class="docutils literal notranslate"><span class="pre">'u'</span></code> también pueden ser usadas en un grupo.</p>
</div>
</dd>
</dl>
<dl id="index-17">
<dt><code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code></dt><dd><p>Similar a los paréntesis regulares, pero la subcadena coincidente con el grupo es accesible a través del nombre simbólico del grupo, <em>name</em> . Los nombres de grupo deben ser identificadores válidos de Python, y cada nombre de grupo debe ser definido sólo una vez dentro de una expresión regular.  Un grupo simbólico es también un grupo numerado, del mismo modo que si el grupo no tuviera nombre.</p>
<p>Los grupos con nombre pueden ser referenciados en tres contextos. Si el patrón es <code class="docutils literal notranslate"><span class="pre">(?P&lt;quote&gt;['&quot;]).*?(?P=quote)</span></code> (es decir, hacer coincidir una cadena citada con comillas simples o dobles):</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 53%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Contexto de la referencia al grupo <em>quote</em> (cita)</p></th>
<th class="head"><p>Formas de hacer referencia</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>en el mismo patrón en sí mismo</p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(?P=quote)</span></code> (como se muestra)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\1</span></code></p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>cuando se procesa el objeto de la coincidencia <em>m</em></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">m.group('quote')</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">m.end('quote')</span></code> (etc.)</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>en una cadena pasada al argumento <em>repl</em> de <code class="docutils literal notranslate"><span class="pre">re.sub()</span></code></p></td>
<td><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\g&lt;quote&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\g&lt;1&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\1</span></code></p></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl class="simple" id="index-18">
<dt><code class="docutils literal notranslate"><span class="pre">(?P=name)</span></code></dt><dd><p>Una referencia inversa a un grupo nombrado; coincide con cualquier texto correspondido por el grupo anterior llamado <em>name</em>.</p>
</dd>
</dl>
<dl class="simple" id="index-19">
<dt><code class="docutils literal notranslate"><span class="pre">(?#...)</span></code></dt><dd><p>Un comentario; el contenido de los paréntesis es simplemente ignorado.</p>
</dd>
</dl>
<dl class="simple" id="index-20">
<dt><code class="docutils literal notranslate"><span class="pre">(?=...)</span></code></dt><dd><p>Coincide si <code class="docutils literal notranslate"><span class="pre">…</span></code> coincide con el siguiente patrón, pero no procesa nada de la cadena. Esto se llama una <em class="dfn">lookahead assertion</em> (aserción de búsqueda anticipada). Por ejemplo, <code class="docutils literal notranslate"><span class="pre">Isaac</span> <span class="pre">(?=Asimov)</span></code> coincidirá con <code class="docutils literal notranslate"><span class="pre">'Isaac</span> <span class="pre">'</span></code> sólo si va seguido de <code class="docutils literal notranslate"><span class="pre">'Asimov'</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-21">
<dt><code class="docutils literal notranslate"><span class="pre">(?!...)</span></code></dt><dd><p>Coincide si <code class="docutils literal notranslate"><span class="pre">…</span></code> no coincide con el siguiente. Esta es una <em class="dfn">negative lookahead assertion</em> (aserción negativa de búsqueda anticipada). Por ejemplo, <code class="docutils literal notranslate"><span class="pre">Isaac</span> <span class="pre">(?!Asimov)</span></code> coincidirá con <code class="docutils literal notranslate"><span class="pre">'Isaac</span> <span class="pre">'</span></code> sólo si <em>no</em> es seguido por <code class="docutils literal notranslate"><span class="pre">'Asimov'</span></code>.</p>
</dd>
</dl>
<dl id="index-22">
<dt><code class="docutils literal notranslate"><span class="pre">(?&lt;=...)</span></code></dt><dd><p>Coincide si la posición actual en la cadena es precedida por una coincidencia para <code class="docutils literal notranslate"><span class="pre">…</span></code> que termina en la posición actual.  Esto se llama una <em class="dfn">positive lookbehind assertion</em> (aserciones positivas de búsqueda tardía). <code class="docutils literal notranslate"><span class="pre">(?&lt;=abc)def</span></code> encontrará una coincidencia en <code class="docutils literal notranslate"><span class="pre">'abcdef'</span></code>, ya que la búsqueda tardía hará una copia de seguridad de 3 caracteres y comprobará si el patrón contenido coincide. El patrón contenido sólo debe coincidir con cadenas de alguna longitud fija, lo que significa que <code class="docutils literal notranslate"><span class="pre">abc</span></code> o <code class="docutils literal notranslate"><span class="pre">a|b</span></code> están permitidas, pero <code class="docutils literal notranslate"><span class="pre">a*</span></code> y <code class="docutils literal notranslate"><span class="pre">a{3,4}</span></code> no lo están.  Hay que tener en cuenta que los patrones que empiezan con aserciones positivas de búsqueda tardía no coincidirán con el principio de la cadena que se está buscando; lo más probable es que se quiera usar la función <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> en lugar de la función <a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;(?&lt;=abc)def&#39;</span><span class="p">,</span> <span class="s1">&#39;abcdef&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;def&#39;</span>
</pre></div>
</div>
<p>Este ejemplo busca una palabra seguida de un guión:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?&lt;=-)\w+&#39;</span><span class="p">,</span> <span class="s1">&#39;spam-egg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;egg&#39;</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Se añadió soporte a las referencias de grupo de longitud fija.</p>
</div>
</dd>
</dl>
<dl class="simple" id="index-23">
<dt><code class="docutils literal notranslate"><span class="pre">(?&lt;!...)</span></code></dt><dd><p>Coincide si la posición actual en la cadena no está precedida por una coincidencia de «…».  Esto se llama una <em class="dfn">negative lookbehind assertion</em> (Aserciones negativas de búsqueda tardía).  Similar a las aserciones positivas de búsqueda tardía, el patrón contenido sólo debe coincidir con cadenas de alguna longitud fija.  Los patrones que empiezan con aserciones negativas pueden coincidir al principio de la cadena que se busca.</p>
</dd>
</dl>
<span class="target" id="re-conditional-expression"></span><dl class="simple" id="index-24">
<dt><code class="docutils literal notranslate"><span class="pre">(?(id/name)yes-pattern|no-pattern)</span></code></dt><dd><p>Tratará de coincidir con el <code class="docutils literal notranslate"><span class="pre">yes-pattern</span></code> (con patrón) si el grupo con un <em>id</em> o  <em>nombre</em> existe, y con el <code class="docutils literal notranslate"><span class="pre">no-pattern</span></code> (sin patrón) si no existe. El <code class="docutils literal notranslate"><span class="pre">no-pattern</span></code> es opcional y puede ser omitido. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">(&lt;)?(\w+&#64;\w+(?:\.\w+)+)(?(1)&gt;||$)</span></code> es un patrón de coincidencia de correo electrónico deficiente, ya que coincidirá con <code class="docutils literal notranslate"><span class="pre">'&lt;user&#64;host.com&gt;'</span></code> así como con <code class="docutils literal notranslate"><span class="pre">'user&#64;host.com'</span></code>, pero no con <code class="docutils literal notranslate"><span class="pre">'&lt;user&#64;host.com'</span></code> ni con <code class="docutils literal notranslate"><span class="pre">'user&#64;host.com&gt;'</span></code>.</p>
</dd>
</dl>
<p>Las secuencias especiales consisten en <code class="docutils literal notranslate"><span class="pre">'\'</span></code> y un carácter de la lista que aparece más adelante. Si el carácter ordinario no es un dígito ASCII o una letra ASCII, entonces el RE resultante coincidirá con el segundo carácter.  Por ejemplo, <code class="docutils literal notranslate"><span class="pre">\$</span></code> coincide con el carácter <code class="docutils literal notranslate"><span class="pre">'$'</span></code>.</p>
<dl class="simple" id="index-25">
<dt><code class="docutils literal notranslate"><span class="pre">\number</span></code></dt><dd><p>Coincide con el contenido del grupo del mismo número.  Los grupos se numeran empezando por el 1. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">(.+)</span> <span class="pre">\1</span></code> coincide con <code class="docutils literal notranslate"><span class="pre">'el</span> <span class="pre">el'</span></code> o <code class="docutils literal notranslate"><span class="pre">'55</span> <span class="pre">55'</span></code>, pero no con <code class="docutils literal notranslate"><span class="pre">'elel'</span></code> (notar el espacio después del grupo).  Esta secuencia especial sólo puede ser usada para hacer coincidir uno de los primeros 99 grupos.  Si el primer dígito del <em>número</em> es 0, o el <em>número</em> tiene 3 dígitos octales, no se interpretará como una coincidencia de grupo, sino como el carácter con valor octal <em>número</em>. Dentro de los <code class="docutils literal notranslate"><span class="pre">'['</span></code> y <code class="docutils literal notranslate"><span class="pre">']'</span></code> de una clase de caracteres, todos los escapes numéricos son tratados como caracteres.</p>
</dd>
</dl>
<dl class="simple" id="index-26">
<dt><code class="docutils literal notranslate"><span class="pre">\A</span></code></dt><dd><p>Coincide sólo al principio de la cadena.</p>
</dd>
</dl>
<dl id="index-27">
<dt><code class="docutils literal notranslate"><span class="pre">\b</span></code></dt><dd><p>Coincide con la cadena vacía, pero sólo al principio o al final de una palabra. Una palabra se define como una secuencia de caracteres de palabras.  Notar que formalmente, <code class="docutils literal notranslate"><span class="pre">\b</span></code> se define como el límite entre un carácter <code class="docutils literal notranslate"><span class="pre">\w</span></code> y un carácter <code class="docutils literal notranslate"><span class="pre">\W</span></code> (o viceversa), o entre <code class="docutils literal notranslate"><span class="pre">\w</span></code> y el principio/fin de la cadena. Esto significa que <code class="docutils literal notranslate"><span class="pre">r'\bfoo\b'</span></code> coincide con <code class="docutils literal notranslate"><span class="pre">'foo'</span></code>, <code class="docutils literal notranslate"><span class="pre">'foo.'</span></code>, <code class="docutils literal notranslate"><span class="pre">'(foo)'</span></code>, <code class="docutils literal notranslate"><span class="pre">'bar</span> <span class="pre">foo</span> <span class="pre">baz'</span></code> pero no <code class="docutils literal notranslate"><span class="pre">'foobar'</span></code> o <code class="docutils literal notranslate"><span class="pre">'foo3'</span></code>.</p>
<p>Por defecto, los alfanuméricos Unicode son los que se usan en los patrones Unicode, pero esto se puede cambiar usando el indicador <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a>.  Los límites de las palabras están determinados por la configuración regional actual si se usa el indicador <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a>. Dentro de un rango de caracteres, <code class="docutils literal notranslate"><span class="pre">\b</span></code> representa el carácter de retroceso (<em>backspace</em>), para compatibilidad con los literales de las cadenas de Python.</p>
</dd>
</dl>
<dl class="simple" id="index-28">
<dt><code class="docutils literal notranslate"><span class="pre">\B</span></code></dt><dd><p>Coincide con la cadena vacía, pero sólo cuando <em>no</em> está al principio o al final de una palabra.  Esto significa que <code class="docutils literal notranslate"><span class="pre">r'py\B'</span></code> coincide con <code class="docutils literal notranslate"><span class="pre">'python'</span></code>, <code class="docutils literal notranslate"><span class="pre">'py3'</span></code>, <code class="docutils literal notranslate"><span class="pre">'py2'</span></code>, pero no con <code class="docutils literal notranslate"><span class="pre">'py'</span></code>, <code class="docutils literal notranslate"><span class="pre">'py.'</span></code> o <code class="docutils literal notranslate"><span class="pre">'py!'</span></code>. <code class="docutils literal notranslate"><span class="pre">\B</span></code> es justo lo opuesto a <code class="docutils literal notranslate"><span class="pre">\b</span></code>, por lo que los caracteres de las palabras en los patrones de Unicode son alfanuméricos o el subrayado, aunque esto puede ser cambiado usando el indicador <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a>.  Los límites de las palabras están determinados por la configuración regional actual si se usa el indicador <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a>.</p>
</dd>
</dl>
<dl class="simple" id="index-29">
<dt><code class="docutils literal notranslate"><span class="pre">\d</span></code></dt><dd><dl class="simple">
<dt>Para los patrones de Unicode (str):</dt><dd><p>Coincide con cualquier dígito decimal de Unicode (es decir, cualquier carácter de la categoría de caracteres de Unicode [Nd]).  Esto incluye a <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code>, y también muchos otros caracteres de dígitos.  Si se usa el indicador <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a>, sólo coincide con <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code>.</p>
</dd>
<dt>Para patrones de 8 bits (bytes):</dt><dd><p>Coincide con cualquier dígito decimal; esto equivale a <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="index-30">
<dt><code class="docutils literal notranslate"><span class="pre">\D</span></code></dt><dd><p>Coincide con cualquier carácter que no sea un dígito decimal. Esto es lo opuesto a <code class="docutils literal notranslate"><span class="pre">\d</span></code>. Si se usa el indicador <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> esto se convierte en el equivalente a <code class="docutils literal notranslate"><span class="pre">[^0-9]</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-31">
<dt><code class="docutils literal notranslate"><span class="pre">\s</span></code></dt><dd><dl class="simple">
<dt>Para los patrones de Unicode (str):</dt><dd><p>Coincide con los caracteres de los espacios en blanco de Unicode (que incluye <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code>, y también muchos otros caracteres, por ejemplo los espacios duros exigidos por las reglas tipográficas en muchos idiomas). Si se usa el indicador <code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII`</span></code>, sólo <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code> coincide.</p>
</dd>
<dt>Para patrones de 8 bits (bytes):</dt><dd><p>Coincide con los caracteres considerados como espacios en blanco en el conjunto de caracteres ASCII, lo que equivale a <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="index-32">
<dt><code class="docutils literal notranslate"><span class="pre">\S</span></code></dt><dd><p>Coincide con cualquier carácter que no sea un carácter de espacio en blanco. Esto es lo opuesto a <code class="docutils literal notranslate"><span class="pre">\s</span></code>. Si se usa el indicador <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> se convierte en el equivalente a <cite>[^ tnrfv]</cite>.</p>
</dd>
</dl>
<dl class="simple" id="index-33">
<dt><code class="docutils literal notranslate"><span class="pre">\w</span></code></dt><dd><dl class="simple">
<dt>Para los patrones de Unicode (str):</dt><dd><p>Matches Unicode word characters; this includes alphanumeric characters (as defined by <a class="reference internal" href="stdtypes.html#str.isalnum" title="str.isalnum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.isalnum()</span></code></a>)
as well as the underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>).
If the <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag is used, only <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9_]</span></code> is matched.</p>
</dd>
<dt>Para patrones de 8 bits (bytes):</dt><dd><p>Coincide con los caracteres considerados alfanuméricos en el conjunto de caracteres ASCII; esto equivale a <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9_]</span></code>.  Si se usa el indicador <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a>, coincide con los caracteres considerados alfanuméricos en la configuración regional actual y el guión bajo.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="index-34">
<dt><code class="docutils literal notranslate"><span class="pre">\W</span></code></dt><dd><p>Coincide con cualquier carácter que no sea un carácter de una palabra. Esto es lo opuesto a <code class="docutils literal notranslate"><span class="pre">\w</span></code>. Si se usa el indicador <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> esto se convierte en el equivalente a <code class="docutils literal notranslate"><span class="pre">[^a-zA-Z0-9_]</span></code>.  Si se usa el indicador <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a>, coincide con los caracteres que no son ni alfanuméricos en la configuración regional actual ni con el guión bajo.</p>
</dd>
</dl>
<dl class="simple" id="index-35">
<dt><code class="docutils literal notranslate"><span class="pre">\Z</span></code></dt><dd><p>Coincide sólo el final de la cadena.</p>
</dd>
</dl>
<p id="index-36">La mayoría de los escapes estándar soportados por los literales de la cadena de Python también son aceptados por el analizador de expresiones regulares:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>\<span class="n">a</span>      \<span class="n">b</span>      \<span class="n">f</span>      \<span class="n">n</span>
\<span class="n">N</span>      \<span class="n">r</span>      \<span class="n">t</span>      \<span class="n">u</span>
\<span class="n">U</span>      \<span class="n">v</span>      \<span class="n">x</span>      \\
</pre></div>
</div>
<p>(Notar que <code class="docutils literal notranslate"><span class="pre">\b</span></code> se usa para representar los límites de las palabras, y significa «retroceso» (<em>backspace</em>) sólo dentro de las clases de caracteres.)</p>
<p>Las secuencias de escape <code class="docutils literal notranslate"><span class="pre">'\u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'\U'</span></code> y <code class="docutils literal notranslate"><span class="pre">'\N'</span></code> sólo se reconocen en los patrones Unicode.  En los patrones de bytes son errores.  Los escapes desconocidos de las letras ASCII se reservan para su uso posterior y se consideran errores.</p>
<p>Los escapes octales se incluyen en una forma limitada.  Si el primer dígito es un 0, o si hay tres dígitos octales, se considera un escape octal. De lo contrario, es una referencia de grupo.  En cuanto a los literales de cadena, los escapes octales siempre tienen como máximo tres dígitos de longitud.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Se han añadido las secuencias de escape <code class="docutils literal notranslate"><span class="pre">'\u'</span></code> y <code class="docutils literal notranslate"><span class="pre">'\U'</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Los escapes desconocidos que consisten en <code class="docutils literal notranslate"><span class="pre">'\'</span></code> y una letra ASCII ahora son errores.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Se añadió la secuencia de escape <code class="docutils literal notranslate"><span class="pre">'\N{name}'</span></code>. Como en los literales de cadena, se expande al carácter Unicode nombrado (por ej. <code class="docutils literal notranslate"><span class="pre">'\N{EM</span> <span class="pre">DASH}'</span></code>).</p>
</div>
</section>
<section id="module-contents">
<span id="contents-of-module-re"></span><h2>Contenidos del módulo<a class="headerlink" href="#module-contents" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El módulo define varias funciones, constantes y una excepción. Algunas de las funciones son versiones simplificadas de los métodos completos de las expresiones regulares compiladas.  La mayoría de las aplicaciones no triviales utilizan siempre la forma compilada.</p>
<section id="flags">
<h3>Flags<a class="headerlink" href="#flags" title="Enlazar permanentemente con este título">¶</a></h3>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Ahora las constantes de indicadores son instancias de <code class="xref py py-class docutils literal notranslate"><span class="pre">RegexFlag</span></code>, que es una subclase de <a class="reference internal" href="enum.html#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a>.</p>
</div>
<dl class="py data">
<dt id="re.A">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">A</code><a class="headerlink" href="#re.A" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="re.ASCII">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">ASCII</code><a class="headerlink" href="#re.ASCII" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Hace que <code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\W</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\B</span></code>, <code class="docutils literal notranslate"><span class="pre">\d</span></code>, <code class="docutils literal notranslate"><span class="pre">\D</span></code>, <code class="docutils literal notranslate"><span class="pre">\s</span></code> y <code class="docutils literal notranslate"><span class="pre">\S</span></code> realicen una coincidencia ASCII en lugar de una concordancia Unicode.  Esto sólo tiene sentido para los patrones de Unicode, y se ignora para los patrones de bytes. Corresponde al indicador en línea <code class="docutils literal notranslate"><span class="pre">(?a)</span></code>.</p>
<p>Notar que para la compatibilidad con versiones anteriores, el indicador <code class="xref py py-const docutils literal notranslate"><span class="pre">re.U</span></code> todavía existe (así como su sinónimo <code class="xref py py-const docutils literal notranslate"><span class="pre">re.UNICODE</span></code> y su contraparte incrustada <code class="docutils literal notranslate"><span class="pre">(?u)</span></code>), pero estos son redundantes en Python 3 ya que las coincidencias son Unicode por defecto para las cadenas (y no se permite la coincidencia Unicode para los bytes).</p>
</dd></dl>

<dl class="py data">
<dt id="re.DEBUG">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">DEBUG</code><a class="headerlink" href="#re.DEBUG" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Muestra información de depuración (<em>debug</em>) sobre la expresión compilada. No hay un indicador en línea que corresponda.</p>
</dd></dl>

<dl class="py data">
<dt id="re.I">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">I</code><a class="headerlink" href="#re.I" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="re.IGNORECASE">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">IGNORECASE</code><a class="headerlink" href="#re.IGNORECASE" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Realiza una coincidencia insensible a las mayúsculas y minúsculas; expresiones como <code class="docutils literal notranslate"><span class="pre">[A-Z]</span></code> también coincidirán con las minúsculas.  La coincidencia completa de Unicode (como <code class="docutils literal notranslate"><span class="pre">Ü</span></code> coincidencia <code class="docutils literal notranslate"><span class="pre">ü</span></code>) también funciona a menos que el indicador <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.ASCII</span></code></a> se utilice para desactivar las coincidencias que no sean ASCII.  La configuración regional vigente no cambia el efecto de este indicador a menos que también se use el indicador <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.LOCALE</span></code></a>. Corresponde al indicador en línea <code class="docutils literal notranslate"><span class="pre">(?i)</span></code>.</p>
<p>Notar que cuando los patrones Unicode <code class="docutils literal notranslate"><span class="pre">[a-z]</span></code> o <code class="docutils literal notranslate"><span class="pre">[A-Z]</span></code> se usan en combinación con el flag <code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORECASE`</span></code>, coincidirán con las 52 letras ASCII y 4 letras adicionales no ASCII: “İ” (U+0130, letra mayúscula latina I con punto arriba), “ı” (U+0131, letra minúscula latina sin punto i), “ſ” (U+017F, letra minúscula latina s larga) y “K” (U+212A, signo Kelvin). Si se usa el indicador <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a>, sólo las letras de la “a” a la “z” y de la “A” a la “Z” coinciden.</p>
</dd></dl>

<dl class="py data">
<dt id="re.L">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">L</code><a class="headerlink" href="#re.L" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="re.LOCALE">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">LOCALE</code><a class="headerlink" href="#re.LOCALE" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Hace que las coincidencias <code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\W</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\B</span></code> y las coincidencias insensibles a mayúsculas y minúsculas dependan de la configuración regional vigente.  Este indicador sólo puede ser usado con patrones de bytes.  Se desaconseja su uso ya que el mecanismo de configuración regional no es fiable, sólo maneja una «cultura» a la vez, y sólo funciona con localizaciones de 8 bits.  La coincidencia Unicode ya está activada por defecto en Python 3 para los patrones Unicode (str), y es capaz de manejar diferentes localizaciones/idiomas. Corresponde al indicador en línea <code class="docutils literal notranslate"><span class="pre">(?L)</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span><a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.LOCALE</span></code></a> sólo se puede usar con patrones de bytes y no es compatible con <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.ASCII</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Los objetos expresión regular compilados con el indicador <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.LOCALE</span></code></a> ya no dependen del lugar en el momento de la compilación.  Sólo la configuración regional durante la coincidencia afecta al resultado obtenido.</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="re.M">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">M</code><a class="headerlink" href="#re.M" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="re.MULTILINE">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">MULTILINE</code><a class="headerlink" href="#re.MULTILINE" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Cuando se especifica, el patrón de caracteres <code class="docutils literal notranslate"><span class="pre">'^'</span></code> coincide al principio de la cadena y al principio de cada línea (inmediatamente después de cada nueva línea); y el patrón de caracteres <code class="docutils literal notranslate"><span class="pre">'$'</span></code> coincide al final de la cadena y al final de cada línea (inmediatamente antes de cada nueva línea).  Por defecto, <code class="docutils literal notranslate"><span class="pre">'^'</span></code> coincide sólo al principio de la cadena, y <code class="docutils literal notranslate"><span class="pre">'$'</span></code> sólo al final de la cadena e inmediatamente antes de la nueva línea (si la hay) al final de la cadena. Corresponde al indicador en línea <code class="docutils literal notranslate"><span class="pre">(?m)</span></code>.</p>
</dd></dl>

<dl class="py data">
<dt id="re.S">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">S</code><a class="headerlink" href="#re.S" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="re.DOTALL">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">DOTALL</code><a class="headerlink" href="#re.DOTALL" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Hace que el carácter especial <code class="docutils literal notranslate"><span class="pre">'.'</span></code> coincida con cualquier carácter, incluyendo una nueva línea. Sin este indicador, <code class="docutils literal notranslate"><span class="pre">'.'</span></code> coincidirá con cualquier cosa, <em>excepto</em> con una nueva línea. Corresponde al indicador en línea <code class="docutils literal notranslate"><span class="pre">(?s)</span></code>.</p>
</dd></dl>

<dl class="py data">
<dt id="re.X">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">X</code><a class="headerlink" href="#re.X" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="re.VERBOSE">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">VERBOSE</code><a class="headerlink" href="#re.VERBOSE" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p id="index-37">This flag allows you to write regular expressions that look nicer and are
more readable by allowing you to visually separate logical sections of the
pattern and add comments. Whitespace within the pattern is ignored, except
when in a character class, or when preceded by an unescaped backslash,
or within tokens like <code class="docutils literal notranslate"><span class="pre">*?</span></code>, <code class="docutils literal notranslate"><span class="pre">(?:</span></code> or <code class="docutils literal notranslate"><span class="pre">(?P&lt;...&gt;</span></code>. For example, <code class="docutils literal notranslate"><span class="pre">(?</span> <span class="pre">:</span></code>
and <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">?</span></code> are not allowed.
When a line contains a <code class="docutils literal notranslate"><span class="pre">#</span></code> that is not in a character class and is not
preceded by an unescaped backslash, all characters from the leftmost such
<code class="docutils literal notranslate"><span class="pre">#</span></code> through the end of the line are ignored.</p>
<p>Esto significa que los dos siguientes objetos expresión regular que coinciden con un número decimal son funcionalmente iguales:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;\d +  # the integral part</span>
<span class="s2">                   \.    # the decimal point</span>
<span class="s2">                   \d *  # some fractional digits&quot;&quot;&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\d+\.\d*&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Corresponde al indicador en línea <code class="docutils literal notranslate"><span class="pre">(?x)</span></code>.</p>
</dd></dl>

</section>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py function">
<dt id="re.compile">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">compile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.compile" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Compila un patrón de expresión regular en un <a class="reference internal" href="#re-objects"><span class="std std-ref">objeto de expresión regular</span></a>, que puede ser usado para las coincidencias usando <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a>, <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> y otros métodos, descritos más adelante.</p>
<p>El comportamiento de la expresión puede modificarse especificando un valor de <em>indicadores</em>. Los valores pueden ser cualquiera de las siguientes variables, combinadas usando el operador OR (el operador <code class="docutils literal notranslate"><span class="pre">|</span></code>).</p>
<p>La secuencia</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
<p>es equivalente a</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
<p>pero usando <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> y guardando el objeto resultante de la expresión regular para su reutilización es más eficiente cuando la expresión será usada varias veces en un solo programa.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Las versiones compiladas de los patrones más recientes pasaron a <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> y las funciones de coincidencia a nivel de módulo están en caché, así que los programas que usan sólo unas pocas expresiones regulares a la vez no tienen que preocuparse de compilar expresiones regulares.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="re.search">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">search</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.search" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Examina a través de la <em>string</em> («cadena») buscando el primer lugar donde el <em>pattern</em> («patrón») de la expresión regular produce una coincidencia, y retorna un <a class="reference internal" href="#match-objects"><span class="std std-ref">objeto match</span></a> correspondiente.  Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si ninguna posición en la cadena coincide con el patrón; notar que esto es diferente a encontrar una coincidencia de longitud cero en algún punto de la cadena.</p>
</dd></dl>

<dl class="py function">
<dt id="re.match">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">match</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.match" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si cero o más caracteres al principio de la <em>string</em> («cadena») coinciden con el <em>pattern</em> («patrón») de la expresión regular, retorna un <a class="reference internal" href="#match-objects"><span class="std std-ref">objeto match</span></a> correspondiente.  Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si la cadena no coincide con el patrón; notar que esto es diferente de una coincidencia de longitud cero.</p>
<p>Notar que incluso en el modo <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a>, <a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a> sólo coincidirá al principio de la cadena y no al principio de cada línea.</p>
<p>Si se quiere localizar una coincidencia en cualquier lugar de la <em>string</em> («cadena»), se utiliza <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> en su lugar (ver también <a class="reference internal" href="#search-vs-match"><span class="std std-ref">search() vs. match()</span></a>).</p>
</dd></dl>

<dl class="py function">
<dt id="re.fullmatch">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">fullmatch</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.fullmatch" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si toda la <em>string</em> («cadena») coincide con el <em>pattern</em> («patrón») de la expresión regular, retorna un correspondiente <a class="reference internal" href="#match-objects"><span class="std std-ref">objeto match</span></a>.  Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si la cadena no coincide con el patrón; notar que esto es diferente de una coincidencia de longitud cero.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="re.split">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">maxsplit</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.split" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Divide la <em>string</em> («cadena») por el número de ocurrencias del <em>pattern</em> («patrón»).  Si se utilizan paréntesis de captura en <em>pattern</em>, entonces el texto de todos los grupos en el patrón también se retornan como parte de la lista resultante. Si <em>maxsplit</em> (máxima divisibilidad) es distinta de cero, como mucho se producen <em>maxsplit</em> divisiones, y el resto de la cadena se retorna como elemento final de la lista.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;words&#39;, &#39;words&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W+)&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;.&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;words, words.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;[a-f]+&#39;</span><span class="p">,</span> <span class="s1">&#39;0a3B9&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="go">[&#39;0&#39;, &#39;3&#39;, &#39;9&#39;]</span>
</pre></div>
</div>
<p>Si hay grupos de captura en el separador y coincide al principio de la cadena, el resultado comenzará con una cadena vacía.  Lo mismo ocurre con el final de la cadena:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W+)&#39;</span><span class="p">,</span> <span class="s1">&#39;...words, words...&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;...&#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;...&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<p>De esa manera, los componentes de los separadores se encuentran siempre en los mismos índices relativos dentro de la lista de resultados.</p>
<p>Las coincidencias vacías para el patrón dividen la cadena sólo cuando no están adyacentes a una coincidencia vacía anterior.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\b&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;Words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W*&#39;</span><span class="p">,</span> <span class="s1">&#39;...words...&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;&#39;, &#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;d&#39;, &#39;s&#39;, &#39;&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W*)&#39;</span><span class="p">,</span> <span class="s1">&#39;...words...&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;...&#39;, &#39;&#39;, &#39;&#39;, &#39;w&#39;, &#39;&#39;, &#39;o&#39;, &#39;&#39;, &#39;r&#39;, &#39;&#39;, &#39;d&#39;, &#39;&#39;, &#39;s&#39;, &#39;...&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.1: </span>Se añadió el argumento de los indicadores opcionales.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Se añadió el soporte de la división en un patrón que podría coincidir con una cadena vacía.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="re.findall">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">findall</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.findall" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna todas las coincidencias no superpuestas de <em>pattern</em> en <em>string</em>, como una lista de strings o tuplas. El <em>string</em> se escanea de izquierda a derecha y las coincidencias se retornan en el orden en que se encuentran. Las coincidencias vacías se incluyen en el resultado.</p>
<p>El resultado depende del número de grupos detectados en el patrón. Si no hay grupos, retorna una lista de strings que coincidan con el patrón completo. Si existe exactamente un grupo, retorna una lista de strings que coincidan con ese grupo. Si hay varios grupos presentes, retorna una lista de tuplas de strings que coinciden con los grupos. Los grupos que no son detectados no afectan la forma del resultado.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\bf[a-z]*&#39;</span><span class="p">,</span> <span class="s1">&#39;which foot or hand fell fastest&#39;</span><span class="p">)</span>
<span class="go">[&#39;foot&#39;, &#39;fell&#39;, &#39;fastest&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\w+)=(\d+)&#39;</span><span class="p">,</span> <span class="s1">&#39;set width=20 and height=10&#39;</span><span class="p">)</span>
<span class="go">[(&#39;width&#39;, &#39;20&#39;), (&#39;height&#39;, &#39;10&#39;)]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Las coincidencias no vacías ahora pueden empezar justo después de una coincidencia vacía anterior.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="re.finditer">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">finditer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.finditer" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> que produce <a class="reference internal" href="#match-objects"><span class="std std-ref">objetos de coincidencia</span></a> sobre todas las coincidencias no superpuestas para <em>pattern</em> («patrón») de RE en la <em>string</em> («cadena»).  La <em>string</em> es examinada de izquierda a derecha, y las coincidencias son retornadas en el orden en que se encuentran.  Las coincidencias vacías se incluyen en el resultado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Las coincidencias no vacías ahora pueden empezar justo después de una coincidencia vacía anterior.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="re.sub">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">sub</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern</span></em>, <em class="sig-param"><span class="n">repl</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">count</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.sub" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la cadena obtenida reemplazando las ocurrencias no superpuestas del <em>pattern</em> («patrón») en la <em>string</em> («cadena») por el reemplazo de <em>repl</em>.  Si el patrón no se encuentra, se retorna <em>string</em> sin cambios.  <em>repl</em> puede ser una cadena o una función; si es una cadena, cualquier barra inversa escapada en ella es procesada.  Es decir, <code class="docutils literal notranslate"><span class="pre">\n</span></code> se convierte en un carácter de una sola línea nueva, <code class="docutils literal notranslate"><span class="pre">\r</span></code> se convierte en un retorno de carro, y así sucesivamente.  Los escapes desconocidos de las letras ASCII se reservan para un uso futuro y se tratan como errores.  Otros escapes desconocidos como <code class="docutils literal notranslate"><span class="pre">\&amp;</span></code> no se utilizan. Las referencias inversas, como <code class="docutils literal notranslate"><span class="pre">\6</span></code>, se reemplazan por la subcadena que corresponde al grupo 6 del patrón. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):&#39;</span><span class="p">,</span>
<span class="gp">... </span>       <span class="sa">r</span><span class="s1">&#39;static PyObject*\npy_\1(void)\n{&#39;</span><span class="p">,</span>
<span class="gp">... </span>       <span class="s1">&#39;def myfunc():&#39;</span><span class="p">)</span>
<span class="go">&#39;static PyObject*\npy_myfunc(void)\n{&#39;</span>
</pre></div>
</div>
<p>Si <em>repl</em> es una función, se llama para cada ocurrencia no superpuesta de <em>pattern</em>.  La función toma un solo argumento <a class="reference internal" href="#match-objects"><span class="std std-ref">objeto match</span></a>, y retorna la cadena de sustitución.  Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">dashrepl</span><span class="p">(</span><span class="n">matchobj</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39; &#39;</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39;-&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;-{1,2}&#39;</span><span class="p">,</span> <span class="n">dashrepl</span><span class="p">,</span> <span class="s1">&#39;pro----gram-files&#39;</span><span class="p">)</span>
<span class="go">&#39;pro--gram files&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\sAND\s&#39;</span><span class="p">,</span> <span class="s1">&#39; &amp; &#39;</span><span class="p">,</span> <span class="s1">&#39;Baked Beans And Spam&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="go">&#39;Baked Beans &amp; Spam&#39;</span>
</pre></div>
</div>
<p>El patrón puede ser una cadena o un <a class="reference internal" href="#re-objects"><span class="std std-ref">objeto patrón</span></a>.</p>
<p>El argumento opcional <em>count</em> («recuento») es el número máximo de ocurrencias de patrones a ser reemplazados; <em>count</em> debe ser un número entero no negativo.  Si se omite o es cero, todas las ocurrencias serán reemplazadas. Las coincidencias vacías del patrón se reemplazan sólo cuando no están adyacentes a una coincidencia vacía anterior, así que <code class="docutils literal notranslate"><span class="pre">sub('x*',</span> <span class="pre">'-',</span> <span class="pre">'abxd')</span></code> retorna <code class="docutils literal notranslate"><span class="pre">'-a-b--d-'</span></code>.</p>
<p id="index-38">En los argumentos <em>repl</em> de tipo cadena, además de los escapes de caracteres y las referencias inversas descritas anteriormente, <code class="docutils literal notranslate"><span class="pre">\g&lt;name&gt;</span></code> usará la subcadena coincidente con el grupo llamado <code class="docutils literal notranslate"><span class="pre">name</span></code>, como se define en la sintaxis <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code>. <code class="docutils literal notranslate"><span class="pre">\g&lt;number&gt;</span></code> utiliza el número de grupo correspondiente; <code class="docutils literal notranslate"><span class="pre">\g&lt;2&gt;</span></code> es por lo tanto equivalente a <code class="docutils literal notranslate"><span class="pre">\2</span></code>, pero no es ambiguo en un reemplazo como sucede con <code class="docutils literal notranslate"><span class="pre">\g&lt;2&gt;0</span></code>.  <code class="docutils literal notranslate"><span class="pre">\20</span></code> se interpretaría como una referencia al grupo 20, no como una referencia al grupo 2 seguido del carácter literal <code class="docutils literal notranslate"><span class="pre">'0'</span></code>.  La referencia inversa <code class="docutils literal notranslate"><span class="pre">\g&lt;0&gt;</span></code> sustituye en toda la subcadena coincidente con la RE.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.1: </span>Se añadió el argumento de los indicadores opcionales.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Los grupos no coincidentes son reemplazados por una cadena vacía.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Los escapes desconocidos en el <em>pattern</em> que consisten en <code class="docutils literal notranslate"><span class="pre">'\'</span></code> y una letra ASCII ahora son errores.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Los escapes desconocidos en <em>repl</em> que consisten en <code class="docutils literal notranslate"><span class="pre">'\'</span></code> y una letra ASCII ahora son errores.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Las coincidencias vacías para el patrón se reemplazan cuando están adyacentes a una coincidencia anterior no vacía.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="re.subn">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">subn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern</span></em>, <em class="sig-param"><span class="n">repl</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">count</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.subn" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Realiza la misma operación que <a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a>, pero retorna una tupla <code class="docutils literal notranslate"><span class="pre">(new_string,</span> <span class="pre">number_of_subs_made)</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.1: </span>Se añadió el argumento de los indicadores opcionales.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Los grupos no coincidentes son reemplazados por una cadena vacía.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="re.escape">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">escape</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pattern</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.escape" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Caracteres de escape especiales en <em>pattern</em> (» patrón»). Esto es útil si quieres hacer coincidir una cadena literal arbitraria que puede tener metacaracteres de expresión regular en ella.  Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s1">&#39;https://www.python.org&#39;</span><span class="p">))</span>
<span class="go">https://www\.python\.org</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">legal_chars</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">digits</span> <span class="o">+</span> <span class="s2">&quot;!#$%&amp;&#39;*+-.^_`|~:&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">]+&#39;</span> <span class="o">%</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">legal_chars</span><span class="p">))</span>
<span class="go">[abcdefghijklmnopqrstuvwxyz0123456789!\#\$%\&amp;&#39;\*\+\-\.\^_`\|\~:]+</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">operators</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;**&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">operators</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))))</span>
<span class="go">/|\-|\+|\*\*|\*</span>
</pre></div>
</div>
<p>Esta función no debe usarse para la cadena de reemplazo en <a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a> y <a class="reference internal" href="#re.subn" title="re.subn"><code class="xref py py-func docutils literal notranslate"><span class="pre">subn()</span></code></a>, sólo deben escaparse las barras inversas.  Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">digits_re</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\d+&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span> <span class="o">=</span> <span class="s1">&#39;/usr/sbin/sendmail - 0 errors, 12 warnings&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">digits_re</span><span class="p">,</span> <span class="n">digits_re</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">),</span> <span class="n">sample</span><span class="p">))</span>
<span class="go">/usr/sbin/sendmail - \d+ errors, \d+ warnings</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>El carácter de <code class="docutils literal notranslate"><span class="pre">'_'</span></code> ya no se escapa.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Sólo se escapan los caracteres que pueden tener un significado especial en una expresión regular. Como resultado, <code class="docutils literal notranslate"><span class="pre">'!'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&quot;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'%'</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;'&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">','</span></code>, <code class="docutils literal notranslate"><span class="pre">'/'</span></code>, <code class="docutils literal notranslate"><span class="pre">':'</span></code>, <code class="docutils literal notranslate"><span class="pre">';'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'='</span></code>, <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> y <code class="docutils literal notranslate"><span class="pre">&quot;`&quot;</span></code> ya no se escapan.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="re.purge">
<code class="sig-prename descclassname">re.</code><code class="sig-name descname">purge</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#re.purge" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Despeja la caché de expresión regular.</p>
</dd></dl>

</section>
<section id="exceptions">
<h3>Exceptions<a class="headerlink" href="#exceptions" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py exception">
<dt id="re.error">
<em class="property">exception </em><code class="sig-prename descclassname">re.</code><code class="sig-name descname">error</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">pattern</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pos</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.error" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Excepción señalada cuando una cadena enviada a una de las funciones descritas aquí no es una expresión regular válida (por ejemplo, podría contener paréntesis no coincidentes) o cuando se produce algún otro error durante la compilación o la coincidencia.  Nunca es un error si una cadena no contiene ninguna coincidencia para un patrón.  La instancia de error tiene los siguientes atributos adicionales:</p>
<dl class="py attribute">
<dt id="re.error.msg">
<code class="sig-name descname">msg</code><a class="headerlink" href="#re.error.msg" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El mensaje de error sin formato.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.error.pattern">
<code class="sig-name descname">pattern</code><a class="headerlink" href="#re.error.pattern" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El patrón de expresión regular.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.error.pos">
<code class="sig-name descname">pos</code><a class="headerlink" href="#re.error.pos" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El índice en <em>pattern</em> («patrón») donde la compilación falló (puede ser <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.error.lineno">
<code class="sig-name descname">lineno</code><a class="headerlink" href="#re.error.lineno" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La línea correspondiente a <em>pos</em> (puede ser <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.error.colno">
<code class="sig-name descname">colno</code><a class="headerlink" href="#re.error.colno" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La columna correspondiente a <em>pos</em> (puede ser <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Se añadieron atributos adicionales.</p>
</div>
</dd></dl>

</section>
</section>
<section id="regular-expression-objects">
<span id="re-objects"></span><h2>Objetos expresión regular<a class="headerlink" href="#regular-expression-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los objetos expresión regular compilados soportan los siguientes métodos y atributos:</p>
<dl class="py method">
<dt id="re.Pattern.search">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">search</code><span class="sig-paren">(</span><em class="sig-param">string</em><span class="optional">[</span>, <em class="sig-param">pos</em><span class="optional">[</span>, <em class="sig-param">endpos</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.search" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Escanea a través de la <em>string</em> («cadena») buscando la primera ubicación donde esta expresión regular produce una coincidencia, y retorna un <a class="reference internal" href="#match-objects"><span class="std std-ref">objeto match</span></a> correspondiente.  Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si ninguna posición en la cadena coincide con el patrón; notar que esto es diferente a encontrar una coincidencia de longitud cero en algún punto de la cadena.</p>
<p>El segundo parámetro opcional <em>pos</em> proporciona un índice en la cadena donde la búsqueda debe comenzar; por defecto es <code class="docutils literal notranslate"><span class="pre">0</span></code>.  Esto no es completamente equivalente a dividir la cadena; el patrón de carácter <code class="docutils literal notranslate"><span class="pre">'^'</span></code> coincide en el inicio real de la cadena y en las posiciones justo después de una nueva línea, pero no necesariamente en el índice donde la búsqueda va a comenzar.</p>
<p>El parámetro opcional <em>endpos</em> limita hasta dónde se buscará la cadena; será como si la cadena fuera de <em>endpos</em> caracteres de largo, por lo que sólo se buscará una coincidencia entre los caracteres de <em>pos</em> a <code class="docutils literal notranslate"><span class="pre">endpos</span> <span class="pre">-</span> <span class="pre">1</span></code>.  Si <em>endpos</em> es menor que <em>pos</em>, no se encontrará ninguna coincidencia; de lo contrario, si <em>rx</em> es un objeto de expresión regular compilado, <code class="docutils literal notranslate"><span class="pre">rx.search(string,</span> <span class="pre">0,</span> <span class="pre">50)</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">rx.search(string[:50],</span> <span class="pre">0)</span></code>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>     <span class="c1"># Match at index 0</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;d&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># No match; search doesn&#39;t include the &quot;d&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="re.Pattern.match">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">match</code><span class="sig-paren">(</span><em class="sig-param">string</em><span class="optional">[</span>, <em class="sig-param">pos</em><span class="optional">[</span>, <em class="sig-param">endpos</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.match" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si cero o más caracteres en el <em>beginning</em> («comienzo») de la <em>string</em> («cadena») coinciden con esta expresión regular, retorna un <a class="reference internal" href="#match-objects"><span class="std std-ref">objeto match</span></a> correspondiente. Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si la cadena no coincide con el patrón; notar que esto es diferente de una coincidencia de longitud cero.</p>
<p>Los parámetros opcionales <em>pos</em> y <em>endpos</em> tienen el mismo significado que para el método <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;o&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>      <span class="c1"># No match as &quot;o&quot; is not at the start of &quot;dog&quot;.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1"># Match as &quot;o&quot; is the 2nd character of &quot;dog&quot;.</span>
<span class="go">&lt;re.Match object; span=(1, 2), match=&#39;o&#39;&gt;</span>
</pre></div>
</div>
<p>Si se quiere encontrar una coincidencia en cualquier lugar de <em>string</em>, utilizar <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> en su lugar (ver también <a class="reference internal" href="#search-vs-match"><span class="std std-ref">search() vs. match()</span></a>).</p>
</dd></dl>

<dl class="py method">
<dt id="re.Pattern.fullmatch">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">fullmatch</code><span class="sig-paren">(</span><em class="sig-param">string</em><span class="optional">[</span>, <em class="sig-param">pos</em><span class="optional">[</span>, <em class="sig-param">endpos</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.fullmatch" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si toda la <em>string</em> («cadena») coincide con esta expresión regular, retorna un <a class="reference internal" href="#match-objects"><span class="std std-ref">objeto match</span></a> correspondiente.  Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si la cadena no coincide con el patrón; notar que esto es diferente de una coincidencia de longitud cero.</p>
<p>Los parámetros opcionales <em>pos</em> y <em>endpos</em> tienen el mismo significado que para el método <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;o[gh]&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>      <span class="c1"># No match as &quot;o&quot; is not at the start of &quot;dog&quot;.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;ogre&quot;</span><span class="p">)</span>     <span class="c1"># No match as not the full string matches.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;doggie&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>   <span class="c1"># Matches within given limits.</span>
<span class="go">&lt;re.Match object; span=(1, 3), match=&#39;og&#39;&gt;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="re.Pattern.split">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">maxsplit</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.split" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Idéntico a la función <a class="reference internal" href="#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a>, usando el patrón compilado.</p>
</dd></dl>

<dl class="py method">
<dt id="re.Pattern.findall">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">findall</code><span class="sig-paren">(</span><em class="sig-param">string</em><span class="optional">[</span>, <em class="sig-param">pos</em><span class="optional">[</span>, <em class="sig-param">endpos</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.findall" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Similar a la función <a class="reference internal" href="#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a>, usando el patrón compilado, pero también acepta parámetros opcionales <em>pos</em> y <em>endpos</em> que limitan la región de búsqueda como para <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="re.Pattern.finditer">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">finditer</code><span class="sig-paren">(</span><em class="sig-param">string</em><span class="optional">[</span>, <em class="sig-param">pos</em><span class="optional">[</span>, <em class="sig-param">endpos</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.finditer" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Similar a la función <a class="reference internal" href="#re.finditer" title="re.finditer"><code class="xref py py-func docutils literal notranslate"><span class="pre">finditer()</span></code></a>, usando el patrón compilado, pero también acepta parámetros opcionales <em>pos</em> y <em>endpos</em> que limitan la región de búsqueda como para <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="re.Pattern.sub">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">sub</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">repl</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">count</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.sub" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Idéntico a la función <a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a>, usando el patrón compilado.</p>
</dd></dl>

<dl class="py method">
<dt id="re.Pattern.subn">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">subn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">repl</span></em>, <em class="sig-param"><span class="n">string</span></em>, <em class="sig-param"><span class="n">count</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.subn" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Idéntico a la función <a class="reference internal" href="#re.subn" title="re.subn"><code class="xref py py-func docutils literal notranslate"><span class="pre">subn()</span></code></a>, usando el patrón compilado.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.Pattern.flags">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">flags</code><a class="headerlink" href="#re.Pattern.flags" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Los indicadores regex de coincidencia. Esta es una combinación de los indicadores dados a <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a>, cualquier indicador <code class="docutils literal notranslate"><span class="pre">(?...)</span></code> en línea en el patrón, y los indicadores implícitos como <code class="xref py py-data docutils literal notranslate"><span class="pre">UNICODE</span></code> si el patrón es una cadena de Unicode.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.Pattern.groups">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">groups</code><a class="headerlink" href="#re.Pattern.groups" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El número de grupos de captura en el patrón.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.Pattern.groupindex">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">groupindex</code><a class="headerlink" href="#re.Pattern.groupindex" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un diccionario que mapea cualquier nombre de grupo simbólico definido por <code class="docutils literal notranslate"><span class="pre">(?P&lt;id&gt;)</span></code> para agrupar números.  El diccionario está vacío si no se utilizaron grupos simbólicos en el patrón.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.Pattern.pattern">
<code class="sig-prename descclassname">Pattern.</code><code class="sig-name descname">pattern</code><a class="headerlink" href="#re.Pattern.pattern" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La cadena de patrones a partir de la cual el objeto de patrón fue compilado.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Se añadió el soporte de <a class="reference internal" href="copy.html#copy.copy" title="copy.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.copy()</span></code></a> y <a class="reference internal" href="copy.html#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a>.  Los objetos expresión regular compilados se consideran atómicos.</p>
</div>
</section>
<section id="match-objects">
<span id="id2"></span><h2>Objetos de coincidencia<a class="headerlink" href="#match-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los objetos de coincidencia siempre tienen un valor booleano de <code class="docutils literal notranslate"><span class="pre">True</span></code> («Verdadero»). Ya que <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> y <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> retornan <code class="docutils literal notranslate"><span class="pre">None</span></code> cuando no hay coincidencia. Se puede probar si hubo una coincidencia con una simple declaración <code class="docutils literal notranslate"><span class="pre">if</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>
<span class="k">if</span> <span class="n">match</span><span class="p">:</span>
    <span class="n">process</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>
</pre></div>
</div>
<p>Los objetos de coincidencia admiten los siguientes métodos y atributos:</p>
<dl class="py method">
<dt id="re.Match.expand">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">expand</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">template</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.expand" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la cadena obtenida al hacer la sustitución de la barra inversa en la cadena de la plantilla <em>template</em>, como se hace con el método <a class="reference internal" href="#re.Pattern.sub" title="re.Pattern.sub"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sub()</span></code></a>. Escapes como <code class="docutils literal notranslate"><span class="pre">\n</span></code> son convertidos a los caracteres apropiados, y las referencias inversas numéricas (<code class="docutils literal notranslate"><span class="pre">\1</span></code>, <code class="docutils literal notranslate"><span class="pre">\2</span></code>) y las referencias inversas con nombre (<code class="docutils literal notranslate"><span class="pre">\g&lt;1&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">\g&lt;name&gt;</span></code>) son reemplazadas por el contenido del grupo correspondiente.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Los grupos no coincidentes son reemplazados por una cadena vacía.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="re.Match.group">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">group</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">group1</em>, <em class="sig-param">...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.group" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna uno o más subgrupos de la coincidencia.  Si hay un solo argumento, el resultado es una sola cadena; si hay múltiples argumentos, el resultado es una tupla con un elemento por argumento. Sin argumentos, <em>group1</em> tiene un valor por defecto de cero (se retorna la coincidencia completa). Si un argumento <em>groupN</em> es cero, el valor de retorno correspondiente es toda la cadena coincidente; si está en el rango inclusivo [1..99], es la cadena coincidente con el grupo correspondiente entre paréntesis.  Si un número de grupo es negativo o mayor que el número de grupos definidos en el patrón, se produce una excepción <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>. Si un grupo está contenido en una parte del patrón que no coincidió, el resultado correspondiente es <code class="docutils literal notranslate"><span class="pre">None</span></code>. Si un grupo está contenido en una parte del patrón que coincidió varias veces, se retorna la última coincidencia.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+) (\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Isaac Newton, physicist&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>       <span class="c1"># The entire match</span>
<span class="go">&#39;Isaac Newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>       <span class="c1"># The first parenthesized subgroup.</span>
<span class="go">&#39;Isaac&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>       <span class="c1"># The second parenthesized subgroup.</span>
<span class="go">&#39;Newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>    <span class="c1"># Multiple arguments give us a tuple.</span>
<span class="go">(&#39;Isaac&#39;, &#39;Newton&#39;)</span>
</pre></div>
</div>
<p>Si la expresión regular usa la sintaxis <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code>, los argumentos <em>groupN</em> también pueden ser cadenas que identifican a los grupos por su nombre de grupo.  Si un argumento de cadena no se usa como nombre de grupo en el patrón, se produce una excepción <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>.</p>
<p>Un ejemplo moderadamente complicado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;first_name&gt;\w+) (?P&lt;last_name&gt;\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Malcolm Reynolds&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;first_name&#39;</span><span class="p">)</span>
<span class="go">&#39;Malcolm&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;last_name&#39;</span><span class="p">)</span>
<span class="go">&#39;Reynolds&#39;</span>
</pre></div>
</div>
<p>Los grupos nombrados también pueden ser referidos por su índice:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;Malcolm&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;Reynolds&#39;</span>
</pre></div>
</div>
<p>Si un grupo coincide varias veces, sólo se puede acceder a la última coincidencia:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(..)+&quot;</span><span class="p">,</span> <span class="s2">&quot;a1b2c3&quot;</span><span class="p">)</span>  <span class="c1"># Matches 3 times.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                        <span class="c1"># Returns only the last match.</span>
<span class="go">&#39;c3&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="re.Match.__getitem__">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">g</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.__getitem__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esto es idéntico a <code class="docutils literal notranslate"><span class="pre">m.group(g)</span></code>.  Esto permite un acceso más fácil a un grupo individual de una coincidencia:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+) (\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Isaac Newton, physicist&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>       <span class="c1"># The entire match</span>
<span class="go">&#39;Isaac Newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>       <span class="c1"># The first parenthesized subgroup.</span>
<span class="go">&#39;Isaac&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>       <span class="c1"># The second parenthesized subgroup.</span>
<span class="go">&#39;Newton&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="re.Match.groups">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">groups</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.groups" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una tupla que contenga todos los subgrupos de la coincidencia, desde 1 hasta tantos grupos como haya en el patrón.  El argumento <em>default</em> («por defecto») se utiliza para los grupos que no participaron en la coincidencia; por defecto es <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\d+)\.(\d+)&quot;</span><span class="p">,</span> <span class="s2">&quot;24.1632&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
<span class="go">(&#39;24&#39;, &#39;1632&#39;)</span>
</pre></div>
</div>
<p>Si hacemos que el decimal y todo lo que sigue sea opcional, no todos los grupos podrían participar en la coincidencia.  Estos grupos serán por defecto <code class="docutils literal notranslate"><span class="pre">None</span></code> a menos que se utilice el argumento <em>default</em>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\d+)\.?(\d+)?&quot;</span><span class="p">,</span> <span class="s2">&quot;24&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>      <span class="c1"># Second group defaults to None.</span>
<span class="go">(&#39;24&#39;, None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>   <span class="c1"># Now, the second group defaults to &#39;0&#39;.</span>
<span class="go">(&#39;24&#39;, &#39;0&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="re.Match.groupdict">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">groupdict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.groupdict" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un diccionario que contiene todos los subgrupos <em>nombrados</em> de la coincidencia, tecleado por el nombre del subgrupo.  El argumento <em>por defecto</em> se usa para los grupos que no participaron en la coincidencia; por defecto es <code class="docutils literal notranslate"><span class="pre">None</span></code>.  Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;first_name&gt;\w+) (?P&lt;last_name&gt;\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Malcolm Reynolds&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
<span class="go">{&#39;first_name&#39;: &#39;Malcolm&#39;, &#39;last_name&#39;: &#39;Reynolds&#39;}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="re.Match.start">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">start</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">group</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.start" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="re.Match.end">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">end</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">group</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.end" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna los índices del comienzo y el final de la subcadena coincidiendo con el <em>group</em>; el <em>group</em> por defecto es cero (es decir, toda la subcadena coincidente). Retorna <code class="docutils literal notranslate"><span class="pre">-1</span></code> si <em>grupo</em> existe pero no ha contribuido a la coincidencia.  Para un objeto coincidente <em>m</em>, y un grupo <em>g</em> que sí contribuyó a la coincidencia, la subcadena coincidente con el grupo <em>g</em> (equivalente a <code class="docutils literal notranslate"><span class="pre">m.group(g)</span></code>) es</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="o">.</span><span class="n">string</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">g</span><span class="p">):</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="n">g</span><span class="p">)]</span>
</pre></div>
</div>
<p>Notar que <code class="docutils literal notranslate"><span class="pre">m.start(group)</span></code> será igual a <code class="docutils literal notranslate"><span class="pre">m.end(group)</span></code> si <em>group</em> coincidió con una cadena nula.  Por ejemplo, después de <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">re.search('b(c?)',</span> <span class="pre">'cba')</span></code>, <code class="docutils literal notranslate"><span class="pre">m.start(0)</span></code> es 1, <code class="docutils literal notranslate"><span class="pre">m.end(0)</span></code> es 2, <code class="docutils literal notranslate"><span class="pre">m.start(1)</span></code> y <code class="docutils literal notranslate"><span class="pre">m.end(1)</span></code> son ambos 2, y <code class="docutils literal notranslate"><span class="pre">m.start(2)</span></code> produce una excepción <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>.</p>
<p>Un ejemplo que eliminará <em>remove_this</em> («quita esto») de las direcciones de correo electrónico:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">email</span> <span class="o">=</span> <span class="s2">&quot;tony@tiremove_thisger.net&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;remove_this&quot;</span><span class="p">,</span> <span class="n">email</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">email</span><span class="p">[:</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">()]</span> <span class="o">+</span> <span class="n">email</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">():]</span>
<span class="go">&#39;tony@tiger.net&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="re.Match.span">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">span</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">group</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.span" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Para una coincidencia <em>m</em>, retorna la tupla-2 <code class="docutils literal notranslate"><span class="pre">(m.inicio(grupo),</span> <span class="pre">m.fin(grupo))</span></code>. Notar que si <em>group</em> no contribuyó a la coincidencia, esto es <code class="docutils literal notranslate"><span class="pre">(-1,</span> <span class="pre">-1)</span></code>. <em>group</em> por se convierte a cero para toda la coincidencia.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.Match.pos">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">pos</code><a class="headerlink" href="#re.Match.pos" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El valor de <em>pos</em> que fue pasado al método <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> o <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> de un <a class="reference internal" href="#re-objects"><span class="std std-ref">objeto regex</span></a>.  Este es el índice de la cadena en la que el motor RE comenzó a buscar una coincidencia.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.Match.endpos">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">endpos</code><a class="headerlink" href="#re.Match.endpos" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El valor de <em>endpos</em> que se pasó al método <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> o <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> de un <a class="reference internal" href="#re-objects"><span class="std std-ref">objeto regex</span></a>.  Este es el índice de la cadena más allá de la cual el motor RE no irá.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.Match.lastindex">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">lastindex</code><a class="headerlink" href="#re.Match.lastindex" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El índice entero del último grupo de captura coincidente, o``None`` si no hay ningún grupo coincidente. Por ejemplo, las expresiones <code class="docutils literal notranslate"><span class="pre">(a)b</span></code>, <code class="docutils literal notranslate"><span class="pre">((a)(b))</span></code> y <code class="docutils literal notranslate"><span class="pre">((ab))</span></code> tendrán <code class="docutils literal notranslate"><span class="pre">lastindex</span> <span class="pre">==</span> <span class="pre">1</span></code> si se aplican a la cadena <code class="docutils literal notranslate"><span class="pre">'ab'</span></code>, mientras que la expresión <code class="docutils literal notranslate"><span class="pre">(a)(b)</span></code> tendrá <code class="docutils literal notranslate"><span class="pre">lastindex</span> <span class="pre">==</span> <span class="pre">2</span></code>, si se aplica a la misma cadena.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.Match.lastgroup">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">lastgroup</code><a class="headerlink" href="#re.Match.lastgroup" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El nombre del último grupo capturador coincidente, o``None`` si el grupo no tenía nombre, o si no había ningún grupo coincidente.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.Match.re">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">re</code><a class="headerlink" href="#re.Match.re" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El <a class="reference internal" href="#re-objects"><span class="std std-ref">objeto de expresión regular</span></a> cuyo método <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> o <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> produce esta instancia de coincidencia.</p>
</dd></dl>

<dl class="py attribute">
<dt id="re.Match.string">
<code class="sig-prename descclassname">Match.</code><code class="sig-name descname">string</code><a class="headerlink" href="#re.Match.string" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La cadena pasada a <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> o <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Se añadió el soporte de <a class="reference internal" href="copy.html#copy.copy" title="copy.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.copy()</span></code></a> y <a class="reference internal" href="copy.html#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a>.  Los objetos de coincidencia se consideran atómicos.</p>
</div>
</section>
<section id="regular-expression-examples">
<span id="re-examples"></span><h2>Ejemplos de expresiones regulares<a class="headerlink" href="#regular-expression-examples" title="Enlazar permanentemente con este título">¶</a></h2>
<section id="checking-for-a-pair">
<h3>Buscando un par<a class="headerlink" href="#checking-for-a-pair" title="Enlazar permanentemente con este título">¶</a></h3>
<p>En este ejemplo, se utilizará la siguiente función de ayuda para mostrar los objetos de coincidencia con un poco más de elegancia:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">displaymatch</span><span class="p">(</span><span class="n">match</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="s1">&#39;&lt;Match: </span><span class="si">%r</span><span class="s1">, groups=</span><span class="si">%r</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(),</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span>
</pre></div>
</div>
<p>Supongamos que se está escribiendo un programa de póquer en el que la mano de un jugador se representa como una cadena de 5 caracteres en la que cada carácter representa una carta, «a» para el as, «k» para el rey, «q» para la reina, «j» para la jota, «t» para el 10, y del » 2» al «9» representando la carta con ese valor.</p>
<p>Para ver si una cadena dada es una mano válida, se podría hacer lo siguiente:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">valid</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^[a2-9tjqk]</span><span class="si">{5}</span><span class="s2">$&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;akt5q&quot;</span><span class="p">))</span>  <span class="c1"># Valid.</span>
<span class="go">&quot;&lt;Match: &#39;akt5q&#39;, groups=()&gt;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;akt5e&quot;</span><span class="p">))</span>  <span class="c1"># Invalid.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;akt&quot;</span><span class="p">))</span>    <span class="c1"># Invalid.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;727ak&quot;</span><span class="p">))</span>  <span class="c1"># Valid.</span>
<span class="go">&quot;&lt;Match: &#39;727ak&#39;, groups=()&gt;&quot;</span>
</pre></div>
</div>
<p>Esa última mano, <code class="docutils literal notranslate"><span class="pre">&quot;727ak&quot;</span></code>, contenía un par, o dos de las mismas cartas de valor. Para igualar esto con una expresión regular, se podrían usar referencias inversas como tales:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*(.).*\1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;717ak&quot;</span><span class="p">))</span>     <span class="c1"># Pair of 7s.</span>
<span class="go">&quot;&lt;Match: &#39;717&#39;, groups=(&#39;7&#39;,)&gt;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;718ak&quot;</span><span class="p">))</span>     <span class="c1"># No pairs.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;354aa&quot;</span><span class="p">))</span>     <span class="c1"># Pair of aces.</span>
<span class="go">&quot;&lt;Match: &#39;354aa&#39;, groups=(&#39;a&#39;,)&gt;&quot;</span>
</pre></div>
</div>
<p>Para averiguar en qué carta consiste el par, se podría utilizar el método <a class="reference internal" href="#re.Match.group" title="re.Match.group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group()</span></code></a> del objeto de coincidencia de la siguiente manera:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*(.).*\1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;717ak&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;7&#39;</span>

<span class="go"># Error because re.match() returns None, which doesn&#39;t have a group() method:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;718ak&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;pyshell#23&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
    <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*(.).*\1&quot;</span><span class="p">,</span> <span class="s2">&quot;718ak&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;NoneType&#39; object has no attribute &#39;group&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;354aa&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
</pre></div>
</div>
</section>
<section id="simulating-scanf">
<h3>Simular scanf()<a class="headerlink" href="#simulating-scanf" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-39">Python no tiene actualmente un equivalente a <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code>.  Las expresiones regulares son generalmente más poderosas, aunque también más verbosas, que las cadenas de formato <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code>.  La tabla siguiente ofrece algunos mapeos más o menos equivalentes entre tokens de formato <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> y expresiones regulares.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 42%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Token <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code></p></th>
<th class="head"><p>Expresión regular</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%c</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%5c</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">.{5}</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%d</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?\d+</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%e</span></code>, <code class="docutils literal notranslate"><span class="pre">%E</span></code>, <code class="docutils literal notranslate"><span class="pre">%f</span></code>, <code class="docutils literal notranslate"><span class="pre">%g</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?(\d+(\.\d*)?|\.\d+)([eE][-+]?\d+)?</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%i</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?(0[xX][\dA-Fa-f]+|0[0-7]*|\d+)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%o</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?[0-7]+</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%s</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">\S+</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">%u</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">\d+</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">%x</span></code>, <code class="docutils literal notranslate"><span class="pre">%X</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">[-+]?(0[xX])?[\dA-Fa-f]+</span></code></p></td>
</tr>
</tbody>
</table>
<p>Para extraer el nombre de archivo y los números de una cadena como</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">sendmail</span> <span class="o">-</span> <span class="mi">0</span> <span class="n">errors</span><span class="p">,</span> <span class="mi">4</span> <span class="n">warnings</span>
</pre></div>
</div>
<p>se usaría un formato <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> como</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">s</span> <span class="o">-</span> <span class="o">%</span><span class="n">d</span> <span class="n">errors</span><span class="p">,</span> <span class="o">%</span><span class="n">d</span> <span class="n">warnings</span>
</pre></div>
</div>
<p>La expresión regular equivalente sería</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span>\<span class="n">S</span><span class="o">+</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span>\<span class="n">d</span><span class="o">+</span><span class="p">)</span> <span class="n">errors</span><span class="p">,</span> <span class="p">(</span>\<span class="n">d</span><span class="o">+</span><span class="p">)</span> <span class="n">warnings</span>
</pre></div>
</div>
</section>
<section id="search-vs-match">
<span id="id3"></span><h3>search() vs. match()<a class="headerlink" href="#search-vs-match" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Python offers different primitive operations based on regular expressions:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a> checks for a match only at the beginning of the string</p></li>
<li><p><a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a> checks for a match anywhere in the string
(this is what Perl does by default)</p></li>
<li><p><a class="reference internal" href="#re.fullmatch" title="re.fullmatch"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.fullmatch()</span></code></a> checks for entire string to be a match</p></li>
</ul>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>    <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>   <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(2, 3), match=&#39;c&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;p.*n&quot;</span><span class="p">,</span> <span class="s2">&quot;python&quot;</span><span class="p">)</span> <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(0, 6), match=&#39;python&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;r.*n&quot;</span><span class="p">,</span> <span class="s2">&quot;python&quot;</span><span class="p">)</span> <span class="c1"># No match</span>
</pre></div>
</div>
<p>Las expresiones regulares que comienzan con <code class="docutils literal notranslate"><span class="pre">'^'</span></code> pueden ser usadas con <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> para restringir la coincidencia al principio de la cadena:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>    <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;^c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>  <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;^a&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>  <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;a&#39;&gt;</span>
</pre></div>
</div>
<p>Notar, sin embargo, que en el modo <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> <a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a> sólo coincide al principio de la cadena, mientras que usando <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> con una expresión regular que comienza con <code class="docutils literal notranslate"><span class="pre">'^'</span></code> coincidirá al principio de cada línea.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;A</span><span class="se">\n</span><span class="s2">B</span><span class="se">\n</span><span class="s2">X&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>  <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;^X&quot;</span><span class="p">,</span> <span class="s2">&quot;A</span><span class="se">\n</span><span class="s2">B</span><span class="se">\n</span><span class="s2">X&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>  <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(4, 5), match=&#39;X&#39;&gt;</span>
</pre></div>
</div>
</section>
<section id="making-a-phonebook">
<h3>Haciendo una guía telefónica<a class="headerlink" href="#making-a-phonebook" title="Enlazar permanentemente con este título">¶</a></h3>
<p><a class="reference internal" href="#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a> divide una cadena en una lista delimitada por el patrón recibido.  El método es muy útil para convertir datos textuales en estructuras de datos que pueden ser fácilmente leídas y modificadas por Python, como se demuestra en el siguiente ejemplo en el que se crea una guía telefónica.</p>
<p>Primero, aquí está la información.  Normalmente puede venir de un archivo, aquí se usa la sintaxis de cadena de triple comilla</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Ross McFluff: 834.345.1254 155 Elm Street</span>
<span class="gp">...</span><span class="s2"></span>
<span class="gp">... </span><span class="s2">Ronald Heathmore: 892.345.3428 436 Finley Avenue</span>
<span class="gp">... </span><span class="s2">Frank Burger: 925.541.7625 662 South Dogwood Way</span>
<span class="gp">...</span><span class="s2"></span>
<span class="gp">...</span><span class="s2"></span>
<span class="gp">... </span><span class="s2">Heather Albrecht: 548.326.4584 919 Park Place&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Las entradas (<em>entries</em>) están separadas por una o más líneas nuevas. Ahora se convierte la cadena en una lista en la que cada línea no vacía tiene su propia entrada:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">entries</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">+&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entries</span>
<span class="go">[&#39;Ross McFluff: 834.345.1254 155 Elm Street&#39;,</span>
<span class="go">&#39;Ronald Heathmore: 892.345.3428 436 Finley Avenue&#39;,</span>
<span class="go">&#39;Frank Burger: 925.541.7625 662 South Dogwood Way&#39;,</span>
<span class="go">&#39;Heather Albrecht: 548.326.4584 919 Park Place&#39;]</span>
</pre></div>
</div>
<p>Finalmente, se divide cada entrada en una lista con nombre, apellido, número de teléfono y dirección.  Se utiliza el parámetro <code class="docutils literal notranslate"><span class="pre">maxsplit</span></code> (división máxima) de <a class="reference internal" href="#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a> porque la dirección tiene espacios dentro del patrón de división:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:? &quot;</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">]</span>
<span class="go">[[&#39;Ross&#39;, &#39;McFluff&#39;, &#39;834.345.1254&#39;, &#39;155 Elm Street&#39;],</span>
<span class="go">[&#39;Ronald&#39;, &#39;Heathmore&#39;, &#39;892.345.3428&#39;, &#39;436 Finley Avenue&#39;],</span>
<span class="go">[&#39;Frank&#39;, &#39;Burger&#39;, &#39;925.541.7625&#39;, &#39;662 South Dogwood Way&#39;],</span>
<span class="go">[&#39;Heather&#39;, &#39;Albrecht&#39;, &#39;548.326.4584&#39;, &#39;919 Park Place&#39;]]</span>
</pre></div>
</div>
<p>El patrón <code class="docutils literal notranslate"><span class="pre">:?</span></code> coincide con los dos puntos después del apellido, de manera que no aparezca en la lista de resultados.  Con <code class="docutils literal notranslate"><span class="pre">maxsplit</span></code> de <code class="docutils literal notranslate"><span class="pre">4</span></code>, se podría separar el número de casa del nombre de la calle:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:? &quot;</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">]</span>
<span class="go">[[&#39;Ross&#39;, &#39;McFluff&#39;, &#39;834.345.1254&#39;, &#39;155&#39;, &#39;Elm Street&#39;],</span>
<span class="go">[&#39;Ronald&#39;, &#39;Heathmore&#39;, &#39;892.345.3428&#39;, &#39;436&#39;, &#39;Finley Avenue&#39;],</span>
<span class="go">[&#39;Frank&#39;, &#39;Burger&#39;, &#39;925.541.7625&#39;, &#39;662&#39;, &#39;South Dogwood Way&#39;],</span>
<span class="go">[&#39;Heather&#39;, &#39;Albrecht&#39;, &#39;548.326.4584&#39;, &#39;919&#39;, &#39;Park Place&#39;]]</span>
</pre></div>
</div>
</section>
<section id="text-munging">
<h3>Mungear texto<a class="headerlink" href="#text-munging" title="Enlazar permanentemente con este título">¶</a></h3>
<p><a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a> reemplaza cada ocurrencia de un patrón con una cadena o el resultado de una función.  Este ejemplo demuestra el uso de <a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a> con una función para «mungear» (<em>munge</em>) el texto, o aleatorizar el orden de todos los caracteres en cada palabra de una frase excepto el primer y último carácter:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">repl</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">inner_word</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">inner_word</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">inner_word</span><span class="p">)</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;Professor Abdolmalek, please report your absences promptly.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w)(\w+)(\w)&quot;</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">&#39;Poefsrosr Aealmlobdk, pslaee reorpt your abnseces plmrptoy.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w)(\w+)(\w)&quot;</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">&#39;Pofsroser Aodlambelk, plasee reoprt yuor asnebces potlmrpy.&#39;</span>
</pre></div>
</div>
</section>
<section id="finding-all-adverbs">
<h3>Encontrar todos los adverbios<a class="headerlink" href="#finding-all-adverbs" title="Enlazar permanentemente con este título">¶</a></h3>
<p><a class="reference internal" href="#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a> coincide con <em>todas</em> las ocurrencias de un patrón, no sólo con la primera, como lo hace <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a>.  Por ejemplo, si un escritor quisiera encontrar todos los adverbios en algún texto, podría usar <a class="reference internal" href="#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a> de la siguiente manera:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;He was carefully disguised but captured quickly by police.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\w+ly\b&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">[&#39;carefully&#39;, &#39;quickly&#39;]</span>
</pre></div>
</div>
</section>
<section id="finding-all-adverbs-and-their-positions">
<h3>Encontrar todos los adverbios y sus posiciones<a class="headerlink" href="#finding-all-adverbs-and-their-positions" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Si uno quiere más información sobre todas las coincidencias de un patrón en lugar del texto coincidente, <a class="reference internal" href="#re.finditer" title="re.finditer"><code class="xref py py-func docutils literal notranslate"><span class="pre">finditer()</span></code></a> es útil ya que proporciona <a class="reference internal" href="#match-objects"><span class="std std-ref">objetos de coincidencia</span></a> en lugar de cadenas.  Continuando con el ejemplo anterior, si un escritor quisiera encontrar todos los adverbios <em>y sus posiciones</em> en algún texto, usaría <a class="reference internal" href="#re.finditer" title="re.finditer"><code class="xref py py-func docutils literal notranslate"><span class="pre">finditer()</span></code></a> de la siguiente manera:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;He was carefully disguised but captured quickly by police.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\w+ly\b&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
<span class="go">07-16: carefully</span>
<span class="go">40-47: quickly</span>
</pre></div>
</div>
</section>
<section id="raw-string-notation">
<h3>Notación de cadena <em>raw</em><a class="headerlink" href="#raw-string-notation" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La notación de cadena <em>raw</em> (<code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">&quot;text&quot;</span></code>) permite escribir expresiones regulares razonables.  Sin ella, para «escapar» cada barra inversa (<code class="docutils literal notranslate"><span class="pre">'\'</span></code>) en una expresión regular tendría que ser precedida por otra.  Por ejemplo, las dos siguientes líneas de código son funcionalmente idénticas:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\W(.)\1\W&quot;</span><span class="p">,</span> <span class="s2">&quot; ff &quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 4), match=&#39; ff &#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">W(.)</span><span class="se">\\</span><span class="s2">1</span><span class="se">\\</span><span class="s2">W&quot;</span><span class="p">,</span> <span class="s2">&quot; ff &quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 4), match=&#39; ff &#39;&gt;</span>
</pre></div>
</div>
<p>Cuando uno quiere igualar una barra inversa literal, debe escaparse en la expresión regular.  Con la notación de cadena <em>raw</em>, esto significa <code class="docutils literal notranslate"><span class="pre">r&quot;\\&quot;</span></code>.  Sin la notación de cadena, uno debe usar <code class="docutils literal notranslate"><span class="pre">&quot;\\\\&quot;</span></code>, haciendo que las siguientes líneas de código sean funcionalmente idénticas:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;\\&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;\\&#39;&gt;</span>
</pre></div>
</div>
</section>
<section id="writing-a-tokenizer">
<h3>Escribir un Tokenizador<a class="headerlink" href="#writing-a-tokenizer" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Un <a class="reference external" href="https://es.wikipedia.org/wiki/Analizador_léxico">tokenizador o analizador léxico</a> analiza una cadena para categorizar grupos de caracteres.  Este es un primer paso útil para escribir un compilador o intérprete.</p>
<p>Las categorías de texto se especifican con expresiones regulares.  La técnica consiste en combinarlas en una única expresión regular maestra y en hacer un bucle sobre las sucesivas coincidencias:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NamedTuple</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="k">class</span> <span class="nc">Token</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">line</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">column</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="n">code</span><span class="p">):</span>
    <span class="n">keywords</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;IF&#39;</span><span class="p">,</span> <span class="s1">&#39;THEN&#39;</span><span class="p">,</span> <span class="s1">&#39;ENDIF&#39;</span><span class="p">,</span> <span class="s1">&#39;FOR&#39;</span><span class="p">,</span> <span class="s1">&#39;NEXT&#39;</span><span class="p">,</span> <span class="s1">&#39;GOSUB&#39;</span><span class="p">,</span> <span class="s1">&#39;RETURN&#39;</span><span class="p">}</span>
    <span class="n">token_specification</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;NUMBER&#39;</span><span class="p">,</span>   <span class="sa">r</span><span class="s1">&#39;\d+(\.\d*)?&#39;</span><span class="p">),</span>  <span class="c1"># Integer or decimal number</span>
        <span class="p">(</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span>   <span class="sa">r</span><span class="s1">&#39;:=&#39;</span><span class="p">),</span>           <span class="c1"># Assignment operator</span>
        <span class="p">(</span><span class="s1">&#39;END&#39;</span><span class="p">,</span>      <span class="sa">r</span><span class="s1">&#39;;&#39;</span><span class="p">),</span>            <span class="c1"># Statement terminator</span>
        <span class="p">(</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span>       <span class="sa">r</span><span class="s1">&#39;[A-Za-z]+&#39;</span><span class="p">),</span>    <span class="c1"># Identifiers</span>
        <span class="p">(</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span>       <span class="sa">r</span><span class="s1">&#39;[+\-*/]&#39;</span><span class="p">),</span>      <span class="c1"># Arithmetic operators</span>
        <span class="p">(</span><span class="s1">&#39;NEWLINE&#39;</span><span class="p">,</span>  <span class="sa">r</span><span class="s1">&#39;\n&#39;</span><span class="p">),</span>           <span class="c1"># Line endings</span>
        <span class="p">(</span><span class="s1">&#39;SKIP&#39;</span><span class="p">,</span>     <span class="sa">r</span><span class="s1">&#39;[ \t]+&#39;</span><span class="p">),</span>       <span class="c1"># Skip over spaces and tabs</span>
        <span class="p">(</span><span class="s1">&#39;MISMATCH&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;.&#39;</span><span class="p">),</span>            <span class="c1"># Any other character</span>
    <span class="p">]</span>
    <span class="n">tok_regex</span> <span class="o">=</span> <span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;(?P&lt;</span><span class="si">%s</span><span class="s1">&gt;</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">pair</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">token_specification</span><span class="p">)</span>
    <span class="n">line_num</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">line_start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">mo</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">tok_regex</span><span class="p">,</span> <span class="n">code</span><span class="p">):</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">lastgroup</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
        <span class="n">column</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">-</span> <span class="n">line_start</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;NUMBER&#39;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">value</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;ID&#39;</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">keywords</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span><span class="p">:</span>
            <span class="n">line_start</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
            <span class="n">line_num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;SKIP&#39;</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;MISMATCH&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s1"> unexpected on line </span><span class="si">{</span><span class="n">line_num</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">Token</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">line_num</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span>

<span class="n">statements</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    IF quantity THEN</span>
<span class="s1">        total := total + price * quantity;</span>
<span class="s1">        tax := price * 0.05;</span>
<span class="s1">    ENDIF;</span>
<span class="s1">&#39;&#39;&#39;</span>

<span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">statements</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
</pre></div>
</div>
<p>El tokenizador produce el siguiente resultado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;IF&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;IF&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;quantity&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;THEN&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;THEN&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;total&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;:=&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;total&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">17</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">31</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;quantity&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">33</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;END&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">41</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;tax&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;:=&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;NUMBER&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;END&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">27</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ENDIF&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;ENDIF&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;END&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
<dl class="citation">
<dt class="label" id="frie09"><span class="brackets"><a class="fn-backref" href="#id1">Frie09</a></span></dt>
<dd><p>Friedl, Jeffrey. <em>Mastering Regular Expressions</em>. 3a ed., O’Reilly Media, 2009. La tercera edición del libro ya no abarca a Python en absoluto, pero la primera edición cubría la escritura de buenos patrones de expresiones regulares con gran detalle.</p>
</dd>
</dl>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> — Operaciones con expresiones regulares</a><ul>
<li><a class="reference internal" href="#regular-expression-syntax">Sintaxis de expresiones regulares</a></li>
<li><a class="reference internal" href="#module-contents">Contenidos del módulo</a><ul>
<li><a class="reference internal" href="#flags">Flags</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#exceptions">Exceptions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#regular-expression-objects">Objetos expresión regular</a></li>
<li><a class="reference internal" href="#match-objects">Objetos de coincidencia</a></li>
<li><a class="reference internal" href="#regular-expression-examples">Ejemplos de expresiones regulares</a><ul>
<li><a class="reference internal" href="#checking-for-a-pair">Buscando un par</a></li>
<li><a class="reference internal" href="#simulating-scanf">Simular scanf()</a></li>
<li><a class="reference internal" href="#search-vs-match">search() vs. match()</a></li>
<li><a class="reference internal" href="#making-a-phonebook">Haciendo una guía telefónica</a></li>
<li><a class="reference internal" href="#text-munging">Mungear texto</a></li>
<li><a class="reference internal" href="#finding-all-adverbs">Encontrar todos los adverbios</a></li>
<li><a class="reference internal" href="#finding-all-adverbs-and-their-positions">Encontrar todos los adverbios y sus posiciones</a></li>
<li><a class="reference internal" href="#raw-string-notation">Notación de cadena <em>raw</em></a></li>
<li><a class="reference internal" href="#writing-a-tokenizer">Escribir un Tokenizador</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="string.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code> — Operaciones comunes de cadena de caracteres</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="difflib.html"
                        title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code> — Funciones auxiliares para calcular deltas</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/re.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="difflib.html" title="difflib — Funciones auxiliares para calcular deltas"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="string.html" title="string — Operaciones comunes de cadena de caracteres"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La Biblioteca Estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="text.html" >Servicios de procesamiento de texto</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> — Operaciones con expresiones regulares</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 27, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>