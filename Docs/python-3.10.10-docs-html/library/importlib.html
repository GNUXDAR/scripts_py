
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>importlib — La implementación de import &#8212; documentación de Python - 3.10.10</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.10.10"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="Usando importlib.metadata" href="importlib.metadata.html" />
    <link rel="prev" title="runpy — Localización y ejecución de módulos Python" href="runpy.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/importlib.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> — La implementación de <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a><ul>
<li><a class="reference internal" href="#introduction">Introducción</a></li>
<li><a class="reference internal" href="#functions">Funciones</a></li>
<li><a class="reference internal" href="#module-importlib.abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code> – Clases base abstractas relacionadas con la importación</a></li>
<li><a class="reference internal" href="#module-importlib.resources"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.resources</span></code> – Recursos</a></li>
<li><a class="reference internal" href="#module-importlib.machinery"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.machinery</span></code> – Importadores y enlaces de ruta</a></li>
<li><a class="reference internal" href="#module-importlib.util"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code> – Código de utilidad para importadores</a></li>
<li><a class="reference internal" href="#examples">Ejemplos</a><ul>
<li><a class="reference internal" href="#importing-programmatically">Importar programáticamente</a></li>
<li><a class="reference internal" href="#checking-if-a-module-can-be-imported">Comprobando si se puede importar un módulo</a></li>
<li><a class="reference internal" href="#importing-a-source-file-directly">Importar un archivo fuente directamente</a></li>
<li><a class="reference internal" href="#implementing-lazy-imports">Implementar importaciones diferidas</a></li>
<li><a class="reference internal" href="#setting-up-an-importer">Configurar un importador</a></li>
<li><a class="reference internal" href="#approximating-importlib-import-module">Aproximando <code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="runpy.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code> — Localización y ejecución de módulos <em>Python</em></a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="importlib.metadata.html"
                        title="próximo capítulo">Usando <code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.metadata</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/importlib.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="importlib.metadata.html" title="Usando importlib.metadata"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="runpy.html" title="runpy — Localización y ejecución de módulos Python"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La Biblioteca Estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="modules.html" accesskey="U">Importando módulos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> — La implementación de <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-importlib">
<span id="importlib-the-implementation-of-import"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> — La implementación de <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code><a class="headerlink" href="#module-importlib" title="Enlazar permanentemente con este título">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
<p><strong>Código fuente:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/importlib/__init__.py">Lib/importlib/__init__.py</a></p>
<hr class="docutils" />
<section id="introduction">
<h2>Introducción<a class="headerlink" href="#introduction" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El propósito del paquete <a class="reference internal" href="#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> es doble. Uno es proveer la implementación de la declaración de <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>, (y así, por extensión, el método <a class="reference internal" href="functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> ) en el código fuente de Python. Esto provee una implementación de la <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> la cual es compatible con cualquier interprete de Python. También provee una implementación que es más fácil de comprender que otras implementaciones, en lenguajes diferentes a Python.</p>
<p>Dos, los componentes incluidos para implementar <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>  están expuestos en este paquete para que sea más fácil para los usuarios crear sus propios objetos (conocidos de forma genérica como <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a>) para participar en el proceso de importación.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><a class="reference internal" href="../reference/simple_stmts.html#import"><span class="std std-ref">La declaración import</span></a></dt><dd><p>La referencia en el lenguaje para la declaración de <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>.</p>
</dd>
<dt><a class="reference external" href="https://www.python.org/doc/essays/packages/">Especificaciones de paquetes</a></dt><dd><p>Especificaciones originales de los paquetes. Algunas semánticas han cambiado desde que este documento fue escrito (ejemplo, redirección de acuerdo a <code class="docutils literal notranslate"><span class="pre">None</span></code> en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>).</p>
</dd>
<dt>La función <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a></dt><dd><p>La declaración de <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> es una decoración sintáctica para esta función.</p>
</dd>
<dt><span class="target" id="index-0"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0235"><strong>PEP 235</strong></a></dt><dd><p>Importar en sistemas que no distinguen entre mayúsculas y minúsculas</p>
</dd>
<dt><span class="target" id="index-1"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0263"><strong>PEP 263</strong></a></dt><dd><p>Definiendo las codificaciones del código fuente de Python</p>
</dd>
<dt><span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a></dt><dd><p>Nuevos ganchos de importación</p>
</dd>
<dt>pep:<cite>328</cite></dt><dd><p>Importaciones: Multilíneas, y absolutos/relativos</p>
</dd>
<dt><span class="target" id="index-4"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0366"><strong>PEP 366</strong></a></dt><dd><p>Importaciones relativas, explicitas, del módulo principal</p>
</dd>
<dt><span class="target" id="index-5"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a></dt><dd><p>Paquetes implícitos en el espacio de nombres</p>
</dd>
<dt><span class="target" id="index-6"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0451"><strong>PEP 451</strong></a></dt><dd><p>Un tipo de ModuleSpec para el sistema de importación</p>
</dd>
<dt><span class="target" id="index-7"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0488"><strong>PEP 488</strong></a></dt><dd><p>Eliminación de archivos PYO</p>
</dd>
<dt><span class="target" id="index-8"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a></dt><dd><p>Inicialización de extensión de módulo en múltiples fases</p>
</dd>
<dt><span class="target" id="index-9"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0552"><strong>PEP 552</strong></a></dt><dd><p>Pycs determinísticos</p>
</dd>
<dt><span class="target" id="index-10"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3120"><strong>PEP 3120</strong></a></dt><dd><p>Usando UTF-8 como la codificación fuente por defecto</p>
</dd>
<dt><span class="target" id="index-11"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a></dt><dd><p>Repositorio de directorios PYC</p>
</dd>
</dl>
</div>
</section>
<section id="functions">
<h2>Funciones<a class="headerlink" href="#functions" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="py function">
<dt id="importlib.__import__">
<code class="sig-prename descclassname">importlib.</code><code class="sig-name descname">__import__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">globals</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">locals</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fromlist</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.__import__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una implementación de la función <a class="reference internal" href="functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> incorporada.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La importación programática los módulos debe usar <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a> en lugar de esta función.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.import_module">
<code class="sig-prename descclassname">importlib.</code><code class="sig-name descname">import_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">package</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.import_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Importar un módulo. El argumento llamado <em>name</em> especifica qué módulo importar en términos absolutos o relativos (ejemplo, puede ser <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code> o <code class="docutils literal notranslate"><span class="pre">..mod</span></code>). Si el nombre fuera especificado en términos relativos, entonces el argumento llamado <em>package</em> debe ser igual al nombre del paquete que será el ancla para resolver el nombre del paquete (ejemplo <code class="docutils literal notranslate"><span class="pre">import_module('..mod',</span> <span class="pre">'pkg.subpkg')</span></code> importará <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code>).</p>
<p>La función <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a> actúa como un envoltorio simplificador alrededor de <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.__import__()</span></code></a>.  Esto quiere decir que las semánticas de la función son derivadas de <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.__import__()</span></code></a>. La diferencia más importante entre las dos funciones es que <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a> retorna el paquete especificado o el módulo (ejemplo <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code>), mientras que <a class="reference internal" href="functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> retorna el paquete o módulo del nivel superior (ejemplo <code class="docutils literal notranslate"><span class="pre">pkg</span></code>).</p>
<p>Si está importando dinámicamente un módulo que se creó desde que el intérprete comenzó la ejecución (por ejemplo, creó un archivo fuente de Python), es posible que deba llamar a <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">invalidate_caches()</span></code></a> para que el nuevo módulo sea detectado por el sistema de importación.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Paquetes padres son importados automáticamente.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.find_loader">
<code class="sig-prename descclassname">importlib.</code><code class="sig-name descname">find_loader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">path</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.find_loader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Encuentra el cargador de un módulo, opcionalmente con el especificado en <em>path</em>.Si el módulo esta en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, entonces retorna el <cite>sys.modules[name].__loader__`</cite> (a menos que el cargador sea <code class="docutils literal notranslate"><span class="pre">None</span></code> o no haya uno especificado, en tal caso se lanza un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>).Si no se encuentra ahí, se hace una búsqueda usando <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>. Se retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si no se encuentra un cargador.</p>
<p>Un nombre con puntos no tiene sus ascendientes importados implícitamente, ya que eso requeriría cargarlo y eso podría no ser deseado. Para importar un sub-módulo correctamente debes importar todos los paquetes ascendientes del sub-módulo y pase el argumento correcto a <em>path</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Si el <code class="docutils literal notranslate"><span class="pre">__loader__</span></code> no está configurado, lanza un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>, igual a si el atributo fuera <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>Utilice <a class="reference internal" href="#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.find_spec()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.invalidate_caches">
<code class="sig-prename descclassname">importlib.</code><code class="sig-name descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.invalidate_caches" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Invalide los cache internos de ubicadores encontrados en <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>.Si un buscador implementa <code class="docutils literal notranslate"><span class="pre">invalidate_caches()</span></code> entonces será llamado para realizar la invalidación.Esta función debe ser llamada si cualquier módulo ha sido creado/instalado mientras tu programa esta siendo ejecutado para garantizar que todos los buscadores noten la existencia del nuevo módulo.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.reload">
<code class="sig-prename descclassname">importlib.</code><code class="sig-name descname">reload</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">module</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.reload" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Recarga un <em>modulo</em> previamente importado. El argumento debe ser un objeto módulo, por lo que debe haber sido importado exitosamente. Esto es útil cuando has editado el código fuente de un archivo usando un editor externo y deseas probar la nueva versión sin abandonar el interprete de Python. El valor retornado es el objeto módulo (que puede ser diferente si la reimportación crea un nuevo objeto en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>).</p>
<p>Cuando <a class="reference internal" href="#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">reload()</span></code></a> es ejecutada:</p>
<ul class="simple">
<li><p>El código de un módulo de Python es recompilado y el código del módulo reejecutado, definiendo un nuevo conjunto de objetos que son asignados a los nombres de los módulos en el diccionario, reusando el <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> que originalmente carga los módulos. El método <code class="docutils literal notranslate"><span class="pre">init</span></code> de los módulos de extension no es llamado de nuevo.</p></li>
<li><p>Al igual que con todos los demás objetos en Python, los objetos antiguos solo se recuperan después de que sus recuentos de referencias caen a cero.</p></li>
<li><p>Los nombres en el espacio de nombres del módulo se actualizan para señalar cualquier objeto nuevo o modificado.</p></li>
<li><p>Otras referencias a los objetos antiguos (como los nombres externos al módulo) no se vuelven a vincular para hacer referencia a los nuevos objetos y deben actualizarse en cada espacio de nombres donde se produzcan si se desea.</p></li>
</ul>
<p>Hay una serie de otras advertencias:</p>
<p>Cuando se vuelve a cargar un módulo, se conserva su diccionario (que contiene las variables globales del módulo). Las redefiniciones de nombres anularán las antiguas definiciones, por lo que generalmente esto no es un problema. Si la nueva versión de un módulo no define un nombre que fue definido por la versión anterior, la definición anterior permanece. Esta característica se puede utilizar en beneficio del módulo si mantiene una tabla global o caché de objetos — con una declaración <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> puede probar la presencia de la tabla y omitir su inicialización si lo desea:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">cache</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
<p>Por lo general, no es muy útil recargar módulos integrados o cargados dinámicamente. No se recomienda recargar <a class="reference internal" href="sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a>, <a class="reference internal" href="__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a>, <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> y otros módulos clave. En muchos casos, los módulos de extensión no están diseñados para inicializarse más de una vez y pueden fallar de manera arbitraria cuando se vuelven a cargar.</p>
<p>Si un módulo importa objetos de otro módulo usando <a class="reference internal" href="../reference/simple_stmts.html#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> … <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> …, al llamar a <a class="reference internal" href="#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">reload()</span></code></a> para el otro módulo no redefine los objetos importados de él — una forma de evitar esto es volver a ejecutar la instrucción <code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code>, otra es usar <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> y nombres calificados (<em>module.name</em>) en su lugar.</p>
<p>Si un módulo crea instancias de una clase, volver a cargar el módulo que define la clase no afecta las definiciones de método de las instancias — continúan usando la definición de clase anterior. Lo mismo ocurre con las clases derivadas.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span><a class="reference internal" href="exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> se lanza cuando el módulo que se está recargando carece de <a class="reference internal" href="#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="module-importlib.abc">
<span id="importlib-abc-abstract-base-classes-related-to-import"></span><h2><a class="reference internal" href="#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> – Clases base abstractas relacionadas con la importación<a class="headerlink" href="#module-importlib.abc" title="Enlazar permanentemente con este título">¶</a></h2>
<p><strong>Código fuente:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/importlib/abc.py">Lib/importlib/abc.py</a></p>
<hr class="docutils" />
<p>El módulo <a class="reference internal" href="#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> contiene todas las clases base abstractas principales utilizadas por <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>. También se proporcionan algunas subclases de las clases base abstractas centrales para ayudar a implementar los ABC centrales.</p>
<p>Jerarquía ABC:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">object</span>
 <span class="o">+--</span> <span class="n">Finder</span> <span class="p">(</span><span class="n">deprecated</span><span class="p">)</span>
 <span class="o">+--</span> <span class="n">MetaPathFinder</span>
 <span class="o">+--</span> <span class="n">PathEntryFinder</span>
 <span class="o">+--</span> <span class="n">Loader</span>
      <span class="o">+--</span> <span class="n">ResourceLoader</span> <span class="o">--------+</span>
      <span class="o">+--</span> <span class="n">InspectLoader</span>          <span class="o">|</span>
           <span class="o">+--</span> <span class="n">ExecutionLoader</span> <span class="o">--+</span>
                                 <span class="o">+--</span> <span class="n">FileLoader</span>
                                 <span class="o">+--</span> <span class="n">SourceLoader</span>
</pre></div>
</div>
<dl class="py class">
<dt id="importlib.abc.Finder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">Finder</code><a class="headerlink" href="#importlib.abc.Finder" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase base abstracta que representa <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.3: </span>Utilice <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaPathFinder</span></code></a> o <a class="reference internal" href="#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathEntryFinder</span></code></a> en su lugar.</p>
</div>
<dl class="py method">
<dt id="importlib.abc.Finder.find_module">
<em class="property">abstractmethod </em><code class="sig-name descname">find_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em>, <em class="sig-param"><span class="n">path</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Finder.find_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método abstracto para encontrar un <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> para el módulo especificado. Originalmente especificado en <span class="target" id="index-39"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>, este método estaba destinado a ser utilizado en <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> y en el subsistema de importación basado en rutas.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> cuando se llama en lugar de generar <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.10: </span>Implemente <a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaPathFinder.find_spec()</span></code></a> o <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">PathEntryFinder.find_spec()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.abc.MetaPathFinder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">MetaPathFinder</code><a class="headerlink" href="#importlib.abc.MetaPathFinder" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>An abstract base class representing a <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">meta path finder</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Ya no hereda de <a class="reference internal" href="#importlib.abc.Finder" title="importlib.abc.Finder"><code class="xref py py-class docutils literal notranslate"><span class="pre">Finder</span></code></a>.</p>
</div>
<dl class="py method">
<dt id="importlib.abc.MetaPathFinder.find_spec">
<code class="sig-name descname">find_spec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em>, <em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">target</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.find_spec" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método abstracto para encontrar un <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a> para el módulo especificado. Si se trata de una importación de nivel superior, el <em>path</em> será <code class="docutils literal notranslate"><span class="pre">None</span></code>. De lo contrario, esta es una búsqueda de un subpaquete o módulo y <em>path</em> será el valor de <a class="reference internal" href="../reference/import.html#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> del paquete principal. Si no se puede encontrar una especificación, se retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>. Cuando se pasa, <code class="docutils literal notranslate"><span class="pre">target</span></code> es un objeto de módulo que el buscador puede usar para hacer una suposición más informada sobre qué especificación retornar. <a class="reference internal" href="#importlib.util.spec_from_loader" title="importlib.util.spec_from_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.spec_from_loader()</span></code></a> puede ser útil para implementar <code class="docutils literal notranslate"><span class="pre">MetaPathFinders</span></code> concretos.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.MetaPathFinder.find_module">
<code class="sig-name descname">find_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em>, <em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.find_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método heredado para encontrar un <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> para el módulo especificado. Si se trata de una importación de nivel superior, el <em>path</em> será <code class="docutils literal notranslate"><span class="pre">None</span></code>. De lo contrario, esta es una búsqueda de un subpaquete o módulo y <em>path</em> será el valor de <a class="reference internal" href="../reference/import.html#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> del paquete principal. Si no se puede encontrar un cargador, se retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Si se define <a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>, se proporciona una funcionalidad compatible con versiones anteriores.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> cuando se llama en lugar de generar <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>. Puede usar <a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> para proporcionar funcionalidad.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>Use <a class="reference internal" href="#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.MetaPathFinder.invalidate_caches">
<code class="sig-name descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.invalidate_caches" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método opcional que, cuando se llama, debería invalidar cualquier caché interno utilizado por el buscador. Utilizado por <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.invalidate_caches()</span></code></a> al invalidar los cachés de todos los buscadores en <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> cuando se llama en lugar de <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code>.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.abc.PathEntryFinder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">PathEntryFinder</code><a class="headerlink" href="#importlib.abc.PathEntryFinder" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase base abstracta que representa un <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">buscador de entradas de ruta</span></a>. Aunque tiene algunas similitudes con <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaPathFinder</span></code></a>, <code class="docutils literal notranslate"><span class="pre">PathEntryFinder</span></code> está diseñado para usarse solo dentro del subsistema de importación basado en rutas proporcionado por <a class="reference internal" href="#importlib.machinery.PathFinder" title="importlib.machinery.PathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.PathFinder</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Ya no hereda de <a class="reference internal" href="#importlib.abc.Finder" title="importlib.abc.Finder"><code class="xref py py-class docutils literal notranslate"><span class="pre">Finder</span></code></a>.</p>
</div>
<dl class="py method">
<dt id="importlib.abc.PathEntryFinder.find_spec">
<code class="sig-name descname">find_spec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em>, <em class="sig-param"><span class="n">target</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.find_spec" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método abstracto para encontrar un <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a> para el módulo especificado. El buscador buscará el módulo solo dentro del <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">path entry</span></a> a la que está asignado. Si no se puede encontrar una especificación, se retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>. Cuando se pasa, <code class="docutils literal notranslate"><span class="pre">target</span></code> es un objeto de módulo que el buscador puede usar para hacer una suposición más informada sobre qué especificación retornar. <a class="reference internal" href="#importlib.util.spec_from_loader" title="importlib.util.spec_from_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.spec_from_loader()</span></code></a> puede ser útil para implementar <code class="docutils literal notranslate"><span class="pre">PathEntryFinders</span></code> concretos.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.PathEntryFinder.find_loader">
<code class="sig-name descname">find_loader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.find_loader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método heredado para encontrar un <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> para el módulo especificado. Retorna una tupla de 2 de <code class="docutils literal notranslate"><span class="pre">(loader,</span> <span class="pre">portion)</span></code> donde <code class="docutils literal notranslate"><span class="pre">portion</span></code> es una secuencia de ubicaciones del sistema de archivos que contribuyen a parte de un paquete de espacio de nombres. El cargador puede ser <code class="docutils literal notranslate"><span class="pre">None</span></code> mientras se especifica <code class="docutils literal notranslate"><span class="pre">portion</span></code> para indicar la contribución de las ubicaciones del sistema de archivos a un paquete de espacio de nombres. Se puede usar una lista vacía para <code class="docutils literal notranslate"><span class="pre">portion</span></code> para indicar que el cargador no es parte de un paquete de espacio de nombres. Si <code class="docutils literal notranslate"><span class="pre">loader</span></code> es <code class="docutils literal notranslate"><span class="pre">None</span></code> y <code class="docutils literal notranslate"><span class="pre">portion</span></code> es la lista vacía, entonces no se encontró ningún cargador o ubicación para un paquete de espacio de nombres (es decir, no se pudo encontrar nada para el módulo).</p>
<p>Si se define <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>, se proporciona una funcionalidad compatible con versiones anteriores.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Retorna <code class="docutils literal notranslate"><span class="pre">(None,</span> <span class="pre">[])</span></code> en lugar de lanzar <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>. Usa <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> cuando está disponible para proporcionar funcionalidad.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>Use <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.PathEntryFinder.find_module">
<code class="sig-name descname">find_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.find_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una implementación concreta de <a class="reference internal" href="#importlib.abc.Finder.find_module" title="importlib.abc.Finder.find_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Finder.find_module()</span></code></a> que es equivalente a <code class="docutils literal notranslate"><span class="pre">self.find_loader(fullname)[0]</span></code>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>Use <a class="reference internal" href="#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.PathEntryFinder.invalidate_caches">
<code class="sig-name descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.invalidate_caches" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método opcional que, cuando se llama, debería invalidar cualquier caché interno utilizado por el buscador. Usado por <a class="reference internal" href="#importlib.machinery.PathFinder.invalidate_caches" title="importlib.machinery.PathFinder.invalidate_caches"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.machinery.PathFinder.invalidate_caches()</span></code></a> al invalidar las cachés de todos los buscadores en caché.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.abc.Loader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">Loader</code><a class="headerlink" href="#importlib.abc.Loader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase base abstracta para un <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>. Consulte <span class="target" id="index-40"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> para obtener la definición exacta de cargador.</p>
<p>Los cargadores que deseen admitir la lectura de recursos deben implementar un método <code class="docutils literal notranslate"><span class="pre">get_resource_reader(fullname)</span></code> según lo especificado por <a class="reference internal" href="#importlib.abc.ResourceReader" title="importlib.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ResourceReader</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Introdujo el método opcional <code class="docutils literal notranslate"><span class="pre">get_resource_reader()</span></code>.</p>
</div>
<dl class="py method">
<dt id="importlib.abc.Loader.create_module">
<code class="sig-name descname">create_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">spec</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.create_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método que retorna el objeto de módulo que se utilizará al importar un módulo. Este método puede retornar <code class="docutils literal notranslate"><span class="pre">None</span></code>, lo que indica que se debe llevar a cabo la semántica de creación de módulos predeterminada.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>A partir de Python 3.6, este método no será opcional cuando se defina <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.Loader.exec_module">
<code class="sig-name descname">exec_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">module</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.exec_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método abstracto que ejecuta el módulo en su propio espacio de nombres cuando se importa o se vuelve a cargar un módulo. El módulo ya debería estar inicializado cuando se llama a <code class="docutils literal notranslate"><span class="pre">exec_module()</span></code>. Cuando existe este método, se debe definir <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span><a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a> también debe definirse.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.Loader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.load_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método heredado para cargar un módulo. Si el módulo no se puede cargar, se lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>; de lo contrario, se retorna el módulo cargado.</p>
<p>Si el módulo solicitado ya existe en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, ese módulo debe usarse y recargarse. De lo contrario, el cargador debe crear un nuevo módulo e insertarlo en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> antes de que comience la carga, para evitar la recursividad de la importación. Si el cargador insertó un módulo y la carga falla, el cargador debe eliminarlo de <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>; los módulos que ya están en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> antes de que el cargador comenzara a ejecutarse deben dejarse en paz (ver <a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_for_loader()</span></code></a>).</p>
<p>El cargador debe establecer varios atributos en el módulo. (Tenga en cuenta que algunos de estos atributos pueden cambiar cuando se recarga un módulo):</p>
<ul class="simple">
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a></dt><dd><p>El nombre del módulo.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a></dt><dd><p>La ruta hacia donde se almacenan los datos del módulo (no configurada para módulos integrados).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#cached__" title="__cached__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code></a></dt><dd><p>La ruta a la que se debe almacenar una versión compilada del módulo (no se establece cuando el atributo sería inapropiado).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a></dt><dd><p>Una lista de cadenas de caracteres que especifican la ruta de búsqueda dentro de un paquete. Este atributo no se establece en módulos.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a></dt><dd><p>The fully qualified name of the package under which the module was
loaded as a submodule (or the empty string for top-level modules).
For packages, it is the same as <a class="reference internal" href="../reference/import.html#name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a>.  The
<a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_for_loader()</span></code></a> decorator can handle the
details for <a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="../reference/import.html#loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a></dt><dd><p>El cargador utilizado para cargar el módulo. El decorador <a class="reference internal" href="#importlib.util.module_for_loader" title="importlib.util.module_for_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_for_loader()</span></code></a> puede manejar los detalles de <a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a>.</p>
</dd>
</dl>
</li>
</ul>
<p>Cuando <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> está disponible, se proporciona una funcionalidad compatible con versiones anteriores.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> cuando se llama en lugar de <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>. Funcionalidad proporcionada cuando <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> está disponible.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>La API recomendada para cargar un módulo es <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> (y <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>). Los cargadores deberían implementarlo en lugar de load_module(). La maquinaria de importación se encarga de todas las demás responsabilidades de load_module() cuando se implementa exec_module().</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.Loader.module_repr">
<code class="sig-name descname">module_repr</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">module</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.module_repr" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método heredado que, cuando se implementa, calcula y retorna la repr del módulo dado, como una cadena. El repr() predeterminado del tipo de módulo utilizará el resultado de este método según corresponda.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Hecho opcional en vez de un método abstracto (<em>abstractmethod</em>)</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>La maquinaria de importación ahora se encarga de esto automáticamente.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.abc.ResourceReader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">ResourceReader</code><a class="headerlink" href="#importlib.abc.ResourceReader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p><em>Reemplazada por TraversableResources</em></p>
<p>Un <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a> para proporcionar la capacidad de leer <em>resources</em>.</p>
<p>Desde la perspectiva de este ABC, un <em>resource</em> es un artefacto binario que se envía dentro de un paquete. Por lo general, esto es algo así como un archivo de datos que se encuentra junto al archivo <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> del paquete. El propósito de esta clase es ayudar a abstraer el acceso a dichos archivos de datos de modo que no importe si el paquete y sus archivos de datos se almacenan en un, por ejemplo, zip en comparación con el sistema de archivos.</p>
<p>Para cualquiera de los métodos de esta clase, se espera que un argumento <em>resource</em> sea un <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a> que representa conceptualmente solo un nombre de archivo. Esto significa que no se deben incluir rutas de subdirectorio en el argumento <em>resource</em>. Esto se debe a que la ubicación del paquete para el que está ubicado el lector actúa como el «directorio». Por lo tanto, la metáfora de los directorios y los nombres de los archivos son los paquetes y los recursos, respectivamente. Esta es también la razón por la que se espera que las instancias de esta clase se correlacionen directamente con un paquete específico (en lugar de representar potencialmente varios paquetes o un módulo).</p>
<p>Se espera que los cargadores que deseen admitir la lectura de recursos proporcionen un método llamado <code class="docutils literal notranslate"><span class="pre">get_resource_reader(fullname)</span></code> que retorna un objeto que implementa la interfaz de este ABC. Si el módulo especificado por fullname no es un paquete, este método debería devolver <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>. Un objeto compatible con este ABC solo debe retornarse cuando el módulo especificado es un paquete.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
<dl class="py method">
<dt id="importlib.abc.ResourceReader.open_resource">
<em class="property">abstractmethod </em><code class="sig-name descname">open_resource</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">resource</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.open_resource" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un, <a class="reference internal" href="../glossary.html#term-file-like-object"><span class="xref std std-term">file-like object</span></a> abierto para la lectura binaria del <em>resource</em>.</p>
<p>Si no se puede encontrar el recurso, se lanza <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileNotFoundError</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.ResourceReader.resource_path">
<em class="property">abstractmethod </em><code class="sig-name descname">resource_path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">resource</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.resource_path" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la ruta del sistema de archivos al <em>resource</em>.</p>
<p>Si el recurso no existe concretamente en el sistema de archivos, lanza <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileNotFoundError</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.ResourceReader.is_resource">
<em class="property">abstractmethod </em><code class="sig-name descname">is_resource</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.is_resource" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si el <em>name</em> nombrado se considera un recurso. <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileNotFoundError</span></code></a> se lanza si <em>name</em> no existe.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.ResourceReader.contents">
<em class="property">abstractmethod </em><code class="sig-name descname">contents</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.contents" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> de cadenas de caracteres sobre el contenido del paquete. Tenga en cuenta que no es necesario que todos los nombres retornados por el iterador sean recursos reales, por ejemplo, es aceptable retornar nombres para los que <a class="reference internal" href="#importlib.abc.ResourceReader.is_resource" title="importlib.abc.ResourceReader.is_resource"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_resource()</span></code></a> sería falso.</p>
<p>Al permitir que se retornen nombres que no son de recursos es para permitir situaciones en las que se conoce a priori cómo se almacenan un paquete y sus recursos y los nombres que no son de recursos serían útiles. Por ejemplo, se permite el retorno de nombres de subdirectorios para que cuando se sepa que el paquete y los recursos están almacenados en el sistema de archivos, esos nombres de subdirectorios se puedan usar directamente.</p>
<p>El método abstracto retorna un iterable de ningún elemento.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.abc.ResourceLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">ResourceLoader</code><a class="headerlink" href="#importlib.abc.ResourceLoader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase base abstracta para un <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> que implementa el protocolo opcional <span class="target" id="index-41"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> para cargar recursos arbitrarios desde el back-end de almacenamiento.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.7: </span>Este ABC está en desuso a favor de admitir la carga de recursos a través de <a class="reference internal" href="#importlib.abc.ResourceReader" title="importlib.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ResourceReader</span></code></a>.</p>
</div>
<dl class="py method">
<dt id="importlib.abc.ResourceLoader.get_data">
<em class="property">abstractmethod </em><code class="sig-name descname">get_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceLoader.get_data" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método abstracto para devolver los bytes de los datos ubicados en <em>path</em>. Los cargadores que tienen un back-end de almacenamiento similar a un archivo que permite almacenar datos arbitrarios pueden implementar este método abstracto para dar acceso directo a los datos almacenados. <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> se lanza si no se puede encontrar el <em>path</em>. Se espera que la <em>path</em> se construya utilizando el atributo <a class="reference internal" href="../reference/import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> de un módulo o un elemento de un paquete <a class="reference internal" href="../reference/import.html#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Lanza <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> en vez de <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.abc.InspectLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">InspectLoader</code><a class="headerlink" href="#importlib.abc.InspectLoader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase base abstracta para un <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> que implementa el protocolo opcional <span class="target" id="index-42"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> para cargadores que inspeccionan módulos.</p>
<dl class="py method">
<dt id="importlib.abc.InspectLoader.get_code">
<code class="sig-name descname">get_code</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.get_code" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el objeto código para un módulo, o <code class="docutils literal notranslate"><span class="pre">None</span></code> si el módulo no tiene un objeto código (como sería el caso, por ejemplo, para un módulo integrado). Lanza un <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> si el cargador no puede encontrar el módulo solicitado.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si bien el método tiene una implementación predeterminada, se sugiere que se anule si es posible para mejorar el rendimiento.</p>
</div>
<div class="versionchanged" id="index-16">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Ya no es un método abstracto y se proporciona una implementación concreta.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.InspectLoader.get_source">
<em class="property">abstractmethod </em><code class="sig-name descname">get_source</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.get_source" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método abstracto para retornar la fuente de un módulo. Se retorna como una cadena de caracteres de texto usando <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a>, traduciendo todos los separadores de línea reconocidos en caracteres <code class="docutils literal notranslate"><span class="pre">'</span>
<span class="pre">'</span></code>. Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si no hay una fuente disponible (por ejemplo, un módulo integrado). Lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> si el cargador no puede encontrar el módulo especificado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> en vez de <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.InspectLoader.is_package">
<code class="sig-name descname">is_package</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.is_package" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método opcional para retornar un valor verdadero si el módulo es un paquete, un valor falso en caso contrario. Se lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> si el <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">cargador</span></a> no puede encontrar el módulo.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> en vez de <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.InspectLoader.source_to_code">
<em class="property">static </em><code class="sig-name descname">source_to_code</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">path</span><span class="o">=</span><span class="default_value">'&lt;string&gt;'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.source_to_code" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Cree un objeto de código a partir de la fuente de Python.</p>
<p>El argumento <em>data</em> puede ser cualquier cosa que admita la función <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> (es decir, cadena de caracteres o bytes). El argumento <em>path</em> debe ser la «ruta» de donde se originó el código fuente, que puede ser un concepto abstracto (por ejemplo, ubicación en un archivo zip).</p>
<p>Con el objeto de código subsiguiente, uno puede ejecutarlo en un módulo ejecutando <code class="docutils literal notranslate"><span class="pre">exec(code,</span> <span class="pre">module.__dict__)</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Hace el método estático.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.InspectLoader.exec_module">
<code class="sig-name descname">exec_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">module</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.exec_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Implementación de <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.InspectLoader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.load_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Implementación de <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.load_module()</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>use <a class="reference internal" href="#importlib.abc.InspectLoader.exec_module" title="importlib.abc.InspectLoader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.abc.ExecutionLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">ExecutionLoader</code><a class="headerlink" href="#importlib.abc.ExecutionLoader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase base abstracta que hereda de <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">InspectLoader</span></code></a> que, cuando se implementa, ayuda a que un módulo se ejecute como un script. El ABC representa un protocolo opcional <span class="target" id="index-43"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>.</p>
<dl class="py method">
<dt id="importlib.abc.ExecutionLoader.get_filename">
<em class="property">abstractmethod </em><code class="sig-name descname">get_filename</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ExecutionLoader.get_filename" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método abstracto que retorna el valor de <a class="reference internal" href="../reference/import.html#file__" title="__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> para el módulo especificado. Si no hay una ruta disponible, se lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>.</p>
<p>Si el código fuente está disponible, entonces el método debe devolver la ruta al archivo fuente, independientemente de si se utilizó un código de bytes para cargar el módulo.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> en vez de <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.abc.FileLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">FileLoader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em>, <em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase base abstracta que hereda de <a class="reference internal" href="#importlib.abc.ResourceLoader" title="importlib.abc.ResourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResourceLoader</span></code></a> y <a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExecutionLoader</span></code></a>, proporcionando implementaciones concretas de <a class="reference internal" href="#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ResourceLoader.get_data()</span></code></a> y <a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a>.</p>
<p>El argumento <em>fullname</em> es un nombre completamente resuelto del módulo que el cargador debe manejar. El argumento <em>path</em> es la ruta al archivo del módulo.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<dl class="py attribute">
<dt id="importlib.abc.FileLoader.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#importlib.abc.FileLoader.name" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El nombre del módulo que puede manejar el cargador.</p>
</dd></dl>

<dl class="py attribute">
<dt id="importlib.abc.FileLoader.path">
<code class="sig-name descname">path</code><a class="headerlink" href="#importlib.abc.FileLoader.path" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Ruta al archivo del módulo.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.FileLoader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.load_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llama a super’s <code class="docutils literal notranslate"><span class="pre">load_module()</span></code>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>Utilice <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.FileLoader.get_filename">
<em class="property">abstractmethod </em><code class="sig-name descname">get_filename</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.get_filename" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="#importlib.abc.FileLoader.path" title="importlib.abc.FileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.FileLoader.get_data">
<em class="property">abstractmethod </em><code class="sig-name descname">get_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.get_data" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Lee <em>path</em> como un archivo binario y devuelve los bytes de él.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.abc.SourceLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">SourceLoader</code><a class="headerlink" href="#importlib.abc.SourceLoader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase base abstracta para implementar la carga de archivos fuente (y opcionalmente bytecode). La clase hereda tanto de <a class="reference internal" href="#importlib.abc.ResourceLoader" title="importlib.abc.ResourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResourceLoader</span></code></a> como de <a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExecutionLoader</span></code></a>, lo que requiere la implementación de:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ResourceLoader.get_data()</span></code></a></p></li>
<li><dl class="simple">
<dt><a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a></dt><dd><p>Solo debe devolver la ruta al archivo de origen; la carga sin fuente no es compatible.</p>
</dd>
</dl>
</li>
</ul>
<p>Los métodos abstractos definidos por esta clase son para agregar soporte de archivo de código de bytes opcional. No implementar estos métodos opcionales (o hacer que se lance <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>) hace que el cargador solo funcione con el código fuente. La implementación de los métodos permite que el cargador trabaje con archivos fuente <em>y</em> código de bytes; no permite la carga <em>sin fuente</em> donde solo se proporciona un código de bytes. Los archivos de código de bytes son una optimización para acelerar la carga al eliminar el paso de análisis del compilador de Python, por lo que no se expone ninguna API específica de código de bytes.</p>
<dl class="py method">
<dt id="importlib.abc.SourceLoader.path_stats">
<code class="sig-name descname">path_stats</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.path_stats" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Método abstracto opcional que devuelve un <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> que contiene metadatos sobre la ruta especificada. Las claves de diccionario admitidas son:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'mtime'</span></code> (obligatorio): un número entero o de punto flotante que representa la hora de modificación del código fuente;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'size'</span></code> (opcional): el tamaño en bytes del código fuente.</p></li>
</ul>
<p>Cualquier otra clave del diccionario se ignora para permitir futuras extensiones. Si no se puede manejar la ruta, se genera <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Lanza <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> en vez de <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.SourceLoader.path_mtime">
<code class="sig-name descname">path_mtime</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.path_mtime" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Método abstracto opcional que retorna la hora de modificación de la ruta especificada.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.3: </span>Este método está obsoleto en favor de <a class="reference internal" href="#importlib.abc.SourceLoader.path_stats" title="importlib.abc.SourceLoader.path_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">path_stats()</span></code></a>. No tiene que implementarlo, pero aún está disponible para fines de compatibilidad. Lanza <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> si la ruta no se puede manejar.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Lanza <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> en vez de <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.SourceLoader.set_data">
<code class="sig-name descname">set_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.set_data" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Método abstracto opcional que escribe los bytes especificados en una ruta de archivo. Los directorios intermedios que no existan se crearán automáticamente.</p>
<p>Cuando la escritura en la ruta falla porque la ruta es de solo lectura (<a class="reference internal" href="errno.html#errno.EACCES" title="errno.EACCES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errno.EACCES</span></code></a>/<a class="reference internal" href="exceptions.html#PermissionError" title="PermissionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PermissionError</span></code></a>), no propague la excepción.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Ya no lanza <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> cuando se llama.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.SourceLoader.get_code">
<code class="sig-name descname">get_code</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.get_code" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Implementación concreta de <a class="reference internal" href="#importlib.abc.InspectLoader.get_code" title="importlib.abc.InspectLoader.get_code"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.get_code()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.SourceLoader.exec_module">
<code class="sig-name descname">exec_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">module</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.exec_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Implementación concreta de <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.SourceLoader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.load_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Implementación concreta de <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.load_module()</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>Utilice <a class="reference internal" href="#importlib.abc.SourceLoader.exec_module" title="importlib.abc.SourceLoader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.SourceLoader.get_source">
<code class="sig-name descname">get_source</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.get_source" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Implementación concreta de <a class="reference internal" href="#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.get_source()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.SourceLoader.is_package">
<code class="sig-name descname">is_package</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.is_package" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Implementación concreta de <a class="reference internal" href="#importlib.abc.InspectLoader.is_package" title="importlib.abc.InspectLoader.is_package"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.is_package()</span></code></a>. Se determina que un módulo es un paquete si su ruta de archivo (proporcionada por <a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a>) es un archivo llamado <code class="docutils literal notranslate"><span class="pre">__init__</span></code> cuando se elimina la extensión del archivo <strong>y</strong> el nombre del módulo sí lo hace no termina en <code class="docutils literal notranslate"><span class="pre">__init__</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.abc.Traversable">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">Traversable</code><a class="headerlink" href="#importlib.abc.Traversable" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>An object with a subset of <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a> methods suitable for
traversing directories and opening files.</p>
<p>For a representation of the object on the file-system, use
<a class="reference internal" href="#importlib.resources.as_file" title="importlib.resources.as_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.resources.as_file()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
<dl class="py method">
<dt id="importlib.abc.Traversable.name">
<em class="property">abstractmethod </em><code class="sig-name descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.name" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>The base name of this object without any parent references.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.Traversable.iterdir">
<em class="property">abstractmethod </em><code class="sig-name descname">iterdir</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.iterdir" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Yield Traversable objects in self.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.Traversable.is_dir">
<em class="property">abstractmethod </em><code class="sig-name descname">is_dir</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.is_dir" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Return True if self is a directory.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.Traversable.is_file">
<em class="property">abstractmethod </em><code class="sig-name descname">is_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.is_file" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Return True if self is a file.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.Traversable.joinpath">
<em class="property">abstractmethod </em><code class="sig-name descname">joinpath</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">child</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.joinpath" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Return Traversable child in self.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.Traversable.__truediv__">
<em class="property">abstractmethod </em><code class="sig-name descname">__truediv__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">child</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.__truediv__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Return Traversable child in self.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.Traversable.open">
<em class="property">abstractmethod </em><code class="sig-name descname">open</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">'r'</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.open" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p><em>mode</em> may be “r” or “rb” to open as text or binary. Return a handle
suitable for reading (same as <a class="reference internal" href="pathlib.html#pathlib.Path.open" title="pathlib.Path.open"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pathlib.Path.open</span></code></a>).</p>
<p>When opening as text, accepts encoding parameters such as those
accepted by <a class="reference internal" href="io.html#io.TextIOWrapper" title="io.TextIOWrapper"><code class="xref py py-attr docutils literal notranslate"><span class="pre">io.TextIOWrapper</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.Traversable.read_bytes">
<code class="sig-name descname">read_bytes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.read_bytes" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Read contents of self as bytes.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.abc.Traversable.read_text">
<code class="sig-name descname">read_text</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">encoding</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.read_text" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Read contents of self as text.</p>
</dd></dl>

<p>Note: In Python 3.11 and later, this class is found in <code class="docutils literal notranslate"><span class="pre">importlib.resources.abc</span></code>.</p>
</dd></dl>

<dl class="py class">
<dt id="importlib.abc.TraversableResources">
<em class="property">class </em><code class="sig-prename descclassname">importlib.abc.</code><code class="sig-name descname">TraversableResources</code><a class="headerlink" href="#importlib.abc.TraversableResources" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>An abstract base class for resource readers capable of serving
the <code class="docutils literal notranslate"><span class="pre">files</span></code> interface. Subclasses ResourceReader and provides
concrete implementations of the ResourceReader’s abstract
methods. Therefore, any loader supplying TraversableResources
also supplies ResourceReader.</p>
<p>Se espera que los cargadores que deseen admitir la lectura de recursos implementen esta interfaz.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
<p>Note: In Python 3.11 and later, this class is found in <code class="docutils literal notranslate"><span class="pre">importlib.resources.abc</span></code>.</p>
</dd></dl>

</section>
<section id="module-importlib.resources">
<span id="importlib-resources-resources"></span><h2><a class="reference internal" href="#module-importlib.resources" title="importlib.resources: Package resource reading, opening, and access"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.resources</span></code></a> – Recursos<a class="headerlink" href="#module-importlib.resources" title="Enlazar permanentemente con este título">¶</a></h2>
<p><strong>Código fuente:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/importlib/resources.py">Lib/importlib/resources.py</a></p>
<hr class="docutils" />
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
<p>Este módulo aprovecha el sistema de importación de Python para proporcionar acceso a <em>resources</em> dentro de <em>packages</em>. Si puede importar un paquete, puede acceder a los recursos dentro de ese paquete. Los recursos se pueden abrir o leer, ya sea en modo binario o texto.</p>
<p>Los recursos son similares a los archivos dentro de los directorios, aunque es importante tener en cuenta que esto es solo una metáfora. Los recursos y paquetes <strong>no</strong> tienen que existir como archivos y directorios físicos en el sistema de archivos.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Este módulo proporciona una funcionalidad similar a <a class="reference external" href="https://setuptools.readthedocs.io/en/latest/pkg_resources.html">pkg_resources</a> <a class="reference external" href="http://setuptools.readthedocs.io/en/latest/pkg_resources.html#basic-resource-access">Acceso Básico a Recursos</a> sin la sobrecarga de rendimiento de ese paquete. Esto facilita la lectura de los recursos incluidos en los paquetes, con una semántica más estable y coherente.</p>
<p>El backport independiente de este módulo proporciona más información sobre <a class="reference external" href="http://importlib-resources.readthedocs.io/en/latest/using.html">usar importlib.resources</a> y <a class="reference external" href="http://importlib-resources.readthedocs.io/en/latest/migration.html">migrar desde pkg_resources a importlib.resources</a>.</p>
</div>
<p>Los cargadores que deseen admitir la lectura de recursos deben implementar un método <code class="docutils literal notranslate"><span class="pre">get_resource_reader(fullname)</span></code> según lo especificado por <a class="reference internal" href="#importlib.abc.ResourceReader" title="importlib.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ResourceReader</span></code></a>.</p>
<p>Se definen los siguientes tipos.</p>
<dl class="py data">
<dt id="importlib.resources.Package">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">Package</code><a class="headerlink" href="#importlib.resources.Package" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El tipo <code class="docutils literal notranslate"><span class="pre">Package</span></code> se define como <code class="docutils literal notranslate"><span class="pre">Union[str,</span> <span class="pre">ModuleType]</span></code>. Esto significa que cuando la función describe la aceptación de un <code class="docutils literal notranslate"><span class="pre">Package</span></code>, puede pasar una cadena de caracteres o un módulo. Los objetos de módulo deben tener un <code class="docutils literal notranslate"><span class="pre">__spec__.submodule_search_locations</span></code> que se pueda resolver que no sea <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py data">
<dt id="importlib.resources.Resource">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">Resource</code><a class="headerlink" href="#importlib.resources.Resource" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este tipo describe los nombres de los recursos que se pasan a las distintas funciones de este paquete. Esto se define como <code class="docutils literal notranslate"><span class="pre">Union[str,</span> <span class="pre">os.PathLike]</span></code>.</p>
</dd></dl>

<p>Están disponibles las siguientes funciones.</p>
<dl class="py function">
<dt id="importlib.resources.files">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">files</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">package</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.files" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Returns an <a class="reference internal" href="#importlib.abc.Traversable" title="importlib.abc.Traversable"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.Traversable</span></code></a> object
representing the resource container for the package (think directory)
and its resources (think files). A Traversable may contain other
containers (think subdirectories).</p>
<p><em>package</em> es un nombre o un objeto de módulo que cumple con los requisitos de <code class="docutils literal notranslate"><span class="pre">Package</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.resources.as_file">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">as_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">traversable</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.as_file" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Given a <a class="reference internal" href="#importlib.abc.Traversable" title="importlib.abc.Traversable"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.Traversable</span></code></a> object representing
a file, typically from <a class="reference internal" href="#importlib.resources.files" title="importlib.resources.files"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.resources.files()</span></code></a>, return
a context manager for use in a <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> statement.
The context manager provides a <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a> object.</p>
<p>Salir del gestor de contexto limpia cualquier archivo temporal creado cuando se extrajo el recurso de, por ejemplo, un archivo zip.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">as_file`</span> <span class="pre">cuando</span> <span class="pre">los</span> <span class="pre">métodos</span> <span class="pre">Traversable</span> <span class="pre">(``read_text</span></code>, etc) sean insuficientes y se requiera un archivo real en el sistema de archivos.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.resources.open_binary">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">open_binary</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">package</span></em>, <em class="sig-param"><span class="n">resource</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.open_binary" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Abra para lectura binaria el <em>resource</em> dentro del <em>package</em>.</p>
<p><em>package</em> es un nombre o un objeto de módulo que cumple con los requisitos de <code class="docutils literal notranslate"><span class="pre">Package</span></code>. <em>resource</em> es el nombre del recurso a abrir dentro de <em>package</em>; puede que no contenga separadores de ruta y puede que no tenga sub-recursos (es decir, no puede ser un directorio). Esta función retorna una instancia de <code class="docutils literal notranslate"><span class="pre">typing.BinaryIO</span></code>, un flujo de E/S binario abierto para lectura.</p>
</dd></dl>

<dl class="py function">
<dt id="importlib.resources.open_text">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">open_text</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">package</span></em>, <em class="sig-param"><span class="n">resource</span></em>, <em class="sig-param"><span class="n">encoding</span><span class="o">=</span><span class="default_value">'utf-8'</span></em>, <em class="sig-param"><span class="n">errors</span><span class="o">=</span><span class="default_value">'strict'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.open_text" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Se abre para leer el texto del <em>resource</em> dentro del <em>package</em>. De forma predeterminada, el recurso está abierto para lectura como UTF-8.</p>
<p><em>package</em> es un nombre o un objeto de módulo que cumple con los requisitos de <code class="docutils literal notranslate"><span class="pre">Package</span></code>. <em>resource</em> es el nombre del recurso a abrir dentro de <em>package</em>; puede que no contenga separadores de ruta y puede que no tenga sub-recursos (es decir, no puede ser un directorio). <em>encoding</em> y <em>errors</em> tienen el mismo significado que con la función integrada <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>.</p>
<p>Esta función retorna una instancia de <code class="docutils literal notranslate"><span class="pre">typing.TextIO</span></code>, un flujo de E/S de texto abierto para lectura.</p>
</dd></dl>

<dl class="py function">
<dt id="importlib.resources.read_binary">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">read_binary</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">package</span></em>, <em class="sig-param"><span class="n">resource</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.read_binary" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Lee y retorna el contenido del <em>resource</em> dentro del <em>package</em> como <code class="docutils literal notranslate"><span class="pre">bytes</span></code>.</p>
<p><em>package</em> es un nombre o un objeto de módulo que cumple con los requisitos de <code class="docutils literal notranslate"><span class="pre">Package</span></code>. <em>resource</em> es el nombre del recurso a abrir dentro de <em>package</em>; puede que no contenga separadores de ruta y puede que no tenga sub-recursos (es decir, no puede ser un directorio). Esta función retorna el contenido del recurso como <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt id="importlib.resources.read_text">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">read_text</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">package</span></em>, <em class="sig-param"><span class="n">resource</span></em>, <em class="sig-param"><span class="n">encoding</span><span class="o">=</span><span class="default_value">'utf-8'</span></em>, <em class="sig-param"><span class="n">errors</span><span class="o">=</span><span class="default_value">'strict'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.read_text" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Lee y retorna el contenido de <em>resource</em> dentro de <em>package</em> como un <code class="docutils literal notranslate"><span class="pre">str</span></code>. De forma predeterminada, los contenidos se leen como UTF-8 estricto.</p>
<p><em>package</em> es un nombre o un objeto de módulo que cumple con los requisitos de <code class="docutils literal notranslate"><span class="pre">Package</span></code>. <em>resource</em> es el nombre del recurso a abrir dentro de <em>package</em>; puede que no contenga separadores de ruta y puede que no tenga sub-recursos (es decir, no puede ser un directorio). <em>encoding</em> y <em>errors</em> tienen el mismo significado que con la función integrada <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>. Esta función retorna el contenido del recurso como <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt id="importlib.resources.path">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">package</span></em>, <em class="sig-param"><span class="n">resource</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.path" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la ruta al <em>resource</em> como una ruta real del sistema de archivos. Esta función retorna un administrador de contexto para usar en una declaración <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>. El administrador de contexto proporciona un objeto <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a>.</p>
<p>Salir del administrador de contexto limpia cualquier archivo temporal creado cuando el recurso necesita ser extraído, por ejemplo, un archivo zip.</p>
<p><em>package</em> es un nombre o un objeto de módulo que cumple con los requisitos de <code class="docutils literal notranslate"><span class="pre">Package</span></code>. <em>resource</em> es el nombre del recurso a abrir dentro de <em>package</em>; puede que no contenga separadores de ruta y puede que no tenga sub-recursos (es decir, no puede ser un directorio).</p>
</dd></dl>

<dl class="py function">
<dt id="importlib.resources.is_resource">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">is_resource</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">package</span></em>, <em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.is_resource" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si hay un recurso llamado <em>name</em> en el paquete; de lo contrario, <code class="docutils literal notranslate"><span class="pre">False</span></code>. ¡Recuerde que los directorios <em>no</em> son recursos! <em>package</em> es un nombre o un objeto de módulo que cumple con los requisitos de <code class="docutils literal notranslate"><span class="pre">Package</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="importlib.resources.contents">
<code class="sig-prename descclassname">importlib.resources.</code><code class="sig-name descname">contents</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">package</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.resources.contents" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un iterable sobre los elementos nombrados dentro del paquete. El iterable retorna recursos <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> (por ejemplo, archivos) y no-recursos (por ejemplo, directorios). El iterable no recurre a subdirectorios.</p>
<p><em>package</em> es un nombre o un objeto de módulo que cumple con los requisitos de <code class="docutils literal notranslate"><span class="pre">Package</span></code>.</p>
</dd></dl>

</section>
<section id="module-importlib.machinery">
<span id="importlib-machinery-importers-and-path-hooks"></span><h2><a class="reference internal" href="#module-importlib.machinery" title="importlib.machinery: Importers and path hooks"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.machinery</span></code></a> – Importadores y enlaces de ruta<a class="headerlink" href="#module-importlib.machinery" title="Enlazar permanentemente con este título">¶</a></h2>
<p><strong>Código fuente:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/importlib/machinery.py">Lib/importlib/machinery.py</a></p>
<hr class="docutils" />
<p>Este módulo contiene varios objetos que ayudan <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> buscar y cargar módulos.</p>
<dl class="py attribute">
<dt id="importlib.machinery.SOURCE_SUFFIXES">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">SOURCE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.SOURCE_SUFFIXES" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una lista de cadenas de caracteres que representan los sufijos de archivo reconocidos para los módulos de origen.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="importlib.machinery.DEBUG_BYTECODE_SUFFIXES">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">DEBUG_BYTECODE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.DEBUG_BYTECODE_SUFFIXES" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una lista de cadenas que representan los sufijos de archivo para módulos de código de bytes no optimizados.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.5: </span>Utilice <a class="reference internal" href="#importlib.machinery.BYTECODE_SUFFIXES" title="importlib.machinery.BYTECODE_SUFFIXES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BYTECODE_SUFFIXES</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">OPTIMIZED_BYTECODE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una lista de cadenas de caracteres que representan los sufijos de archivo para módulos de código de bytes optimizados.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.5: </span>Utilice <a class="reference internal" href="#importlib.machinery.BYTECODE_SUFFIXES" title="importlib.machinery.BYTECODE_SUFFIXES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">BYTECODE_SUFFIXES</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="importlib.machinery.BYTECODE_SUFFIXES">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">BYTECODE_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.BYTECODE_SUFFIXES" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una lista de cadenas de caracteres que representan los sufijos de archivo reconocidos para los módulos de código de bytes (incluido el punto inicial).</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>El valor ya no depende de <code class="docutils literal notranslate"><span class="pre">__debug__</span></code>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="importlib.machinery.EXTENSION_SUFFIXES">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">EXTENSION_SUFFIXES</code><a class="headerlink" href="#importlib.machinery.EXTENSION_SUFFIXES" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una lista de cadenas de caracteres que representan los sufijos de archivo reconocidos para los módulos de extensión.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.machinery.all_suffixes">
<code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">all_suffixes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.all_suffixes" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una lista combinada de cadenas de caracteres que representan todos los sufijos de archivo para módulos reconocidos por la maquinaria de importación estándar. Este es un ayudante para el código que simplemente necesita saber si una ruta del sistema de archivos potencialmente se refiere a un módulo sin necesidad de detalles sobre el tipo de módulo (por ejemplo, <a class="reference internal" href="inspect.html#inspect.getmodulename" title="inspect.getmodulename"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getmodulename()</span></code></a>).</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt id="importlib.machinery.BuiltinImporter">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">BuiltinImporter</code><a class="headerlink" href="#importlib.machinery.BuiltinImporter" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a> para módulos integrados. Todos los módulos integrados conocidos se enumeran en <a class="reference internal" href="sys.html#sys.builtin_module_names" title="sys.builtin_module_names"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.builtin_module_names</span></code></a>. Esta clase implementa los ABC <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> y <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader</span></code></a>.</p>
<p>Esta clase solo define los métodos de clase para aliviar la necesidad de instanciación.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Como parte de <span class="target" id="index-44"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a>, el importador integrado ahora implementa <code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.create_module()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></p>
</div>
</dd></dl>

<dl class="py class">
<dt id="importlib.machinery.FrozenImporter">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">FrozenImporter</code><a class="headerlink" href="#importlib.machinery.FrozenImporter" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a> para módulos congelados. Esta clase implementa los ABC <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> y <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader</span></code></a>.</p>
<p>Esta clase solo define los métodos de clase para aliviar la necesidad de instanciación.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Métodos obtenidos <code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="importlib.machinery.WindowsRegistryFinder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">WindowsRegistryFinder</code><a class="headerlink" href="#importlib.machinery.WindowsRegistryFinder" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p><a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">Finder</span></a> para los módulos declarados en el registro de Windows. Esta clase implementa el <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> ABC.</p>
<p>Esta clase solo define los métodos de clase para aliviar la necesidad de instanciación.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.6: </span>Utilice la configuración de <a class="reference internal" href="site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> en su lugar. Es posible que las versiones futuras de Python no habiliten este buscador de forma predeterminada.</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="importlib.machinery.PathFinder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">PathFinder</code><a class="headerlink" href="#importlib.machinery.PathFinder" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">Finder</span></a> para <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> y atributos del paquete <code class="docutils literal notranslate"><span class="pre">__path__</span></code>. Esta clase implementa el <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> ABC.</p>
<p>Esta clase solo define los métodos de clase para aliviar la necesidad de instanciación.</p>
<dl class="py method">
<dt id="importlib.machinery.PathFinder.find_spec">
<em class="property">classmethod </em><code class="sig-name descname">find_spec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em>, <em class="sig-param"><span class="n">path</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">target</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.find_spec" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Método de clase que intenta encontrar un <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a> para el módulo especificado por <em>fullname</em> en <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> o, si está definido, en <em>path</em>. Para cada entrada de ruta que se busca, se comprueba <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>. Si se encuentra un objeto que no es falso, se utiliza como <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a> para buscar el módulo que se está buscando. Si no se encuentra ninguna entrada en <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>, entonces <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> se busca un buscador para la entrada de ruta y, si se encuentra, se almacena en <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> junto con ser consultado sobre el módulo. Si nunca se encuentra ningún buscador, entonces <code class="docutils literal notranslate"><span class="pre">None</span></code> se almacena en el caché y se retorna.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Si el directorio de trabajo actual, representado por una cadena de caracteres vacía, ya no es válido, se retorna``None`` pero no se almacena ningún valor en <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.PathFinder.find_module">
<em class="property">classmethod </em><code class="sig-name descname">find_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em>, <em class="sig-param"><span class="n">path</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.find_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una envoltura heredada alrededor de <a class="reference internal" href="#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>Use <a class="reference internal" href="#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.PathFinder.invalidate_caches">
<em class="property">classmethod </em><code class="sig-name descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.invalidate_caches" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llama <a class="reference internal" href="#importlib.abc.PathEntryFinder.invalidate_caches" title="importlib.abc.PathEntryFinder.invalidate_caches"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder.invalidate_caches()</span></code></a> en todos los buscadores almacenados en <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> que definen el método. De lo contrario, las entradas en <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> establecidas en <code class="docutils literal notranslate"><span class="pre">None</span></code> se eliminan.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Se eliminan las entradas de <code class="docutils literal notranslate"><span class="pre">None</span></code> en <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>.</p>
</div>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Llama a objetos en <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> con el directorio de trabajo actual para <code class="docutils literal notranslate"><span class="pre">''</span></code> (es decir, la cadena de caracteres vacía).</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="importlib.machinery.FileFinder">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">FileFinder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">loader_details</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una implementación concreta de <a class="reference internal" href="#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder</span></code></a> que almacena en caché los resultados del sistema de archivos.</p>
<p>El argumento <em>path</em> es el directorio que el buscador se encarga de buscar.</p>
<p>El argumento <em>loader_details</em> es un número variable de tuplas de 2 elementos, cada una de las cuales contiene un cargador y una secuencia de sufijos de archivo que el cargador reconoce. Se espera que los cargadores sean invocables que acepten dos argumentos del nombre del módulo y la ruta al archivo encontrado.</p>
<p>El buscador almacenará en caché el contenido del directorio según sea necesario, haciendo llamadas estadísticas para cada búsqueda de módulo para verificar que la caché no esté desactualizada. Debido a que la obsolescencia de la caché se basa en la granularidad de la información de estado del sistema operativo del sistema de archivos, existe una condición de carrera potencial de buscar un módulo, crear un nuevo archivo y luego buscar el módulo que representa el nuevo archivo. Si las operaciones ocurren lo suficientemente rápido como para ajustarse a la granularidad de las llamadas estadísticas, la búsqueda del módulo fallará. Para evitar que esto suceda, cuando cree un módulo dinámicamente, asegúrese de llamar a <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.invalidate_caches()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<dl class="py attribute">
<dt id="importlib.machinery.FileFinder.path">
<code class="sig-name descname">path</code><a class="headerlink" href="#importlib.machinery.FileFinder.path" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La ruta en la que buscará el buscador.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.FileFinder.find_spec">
<code class="sig-name descname">find_spec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em>, <em class="sig-param"><span class="n">target</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.find_spec" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Intente encontrar la especificación para manejar <em>fullname</em> dentro de <a class="reference internal" href="#importlib.machinery.FileFinder.path" title="importlib.machinery.FileFinder.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.FileFinder.find_loader">
<code class="sig-name descname">find_loader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.find_loader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Intente encontrar el cargador para manejar <em>fullname</em> dentro de <a class="reference internal" href="#importlib.machinery.FileFinder.path" title="importlib.machinery.FileFinder.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.10: </span>Use <a class="reference internal" href="#importlib.machinery.FileFinder.find_spec" title="importlib.machinery.FileFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.FileFinder.invalidate_caches">
<code class="sig-name descname">invalidate_caches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.invalidate_caches" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Borrar el caché interno.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.FileFinder.path_hook">
<em class="property">classmethod </em><code class="sig-name descname">path_hook</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">loader_details</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.path_hook" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método de clase que devuelve un cierre para su uso en <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>. Una instancia de <a class="reference internal" href="#importlib.machinery.FileFinder" title="importlib.machinery.FileFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileFinder</span></code></a> es retornada por el cierre usando el argumento de ruta dado al cierre directamente y <em>loader_details</em> indirectamente.</p>
<p>Si el argumento del cierre no es un directorio existente, se lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.machinery.SourceFileLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">SourceFileLoader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em>, <em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una implementación concreta de <a class="reference internal" href="#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader</span></code></a> subclasificando <a class="reference internal" href="#importlib.abc.FileLoader" title="importlib.abc.FileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.FileLoader</span></code></a> y proporcionando algunas implementaciones concretas de otros métodos.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<dl class="py attribute">
<dt id="importlib.machinery.SourceFileLoader.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#importlib.machinery.SourceFileLoader.name" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El nombre del módulo que manejará este cargador.</p>
</dd></dl>

<dl class="py attribute">
<dt id="importlib.machinery.SourceFileLoader.path">
<code class="sig-name descname">path</code><a class="headerlink" href="#importlib.machinery.SourceFileLoader.path" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La ruta al archivo de origen.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.SourceFileLoader.is_package">
<code class="sig-name descname">is_package</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.is_package" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Devuelve <code class="docutils literal notranslate"><span class="pre">True</span></code> si <a class="reference internal" href="#importlib.machinery.SourceFileLoader.path" title="importlib.machinery.SourceFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a> parece ser para un paquete.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.SourceFileLoader.path_stats">
<code class="sig-name descname">path_stats</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.path_stats" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Implementación concreta de <a class="reference internal" href="#importlib.abc.SourceLoader.path_stats" title="importlib.abc.SourceLoader.path_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader.path_stats()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.SourceFileLoader.set_data">
<code class="sig-name descname">set_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.set_data" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Implementación concreta de <a class="reference internal" href="#importlib.abc.SourceLoader.set_data" title="importlib.abc.SourceLoader.set_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader.set_data()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.SourceFileLoader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.load_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Implementación concreta de <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> donde especificar el nombre del módulo a cargar es opcional.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.6: </span>Utilice <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.machinery.SourcelessFileLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">SourcelessFileLoader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em>, <em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una implementación concreta de <a class="reference internal" href="#importlib.abc.FileLoader" title="importlib.abc.FileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.FileLoader</span></code></a> que puede importar archivos de código de bytes (es decir, no existen archivos de código fuente).</p>
<p>Tenga en cuenta que el uso directo de archivos de código de bytes (y, por lo tanto, no de archivos de código fuente) impide que sus módulos sean utilizables por todas las implementaciones de Python o las nuevas versiones de Python que cambian el formato de código de bytes.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<dl class="py attribute">
<dt id="importlib.machinery.SourcelessFileLoader.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.name" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El nombre del módulo que manejará el cargador.</p>
</dd></dl>

<dl class="py attribute">
<dt id="importlib.machinery.SourcelessFileLoader.path">
<code class="sig-name descname">path</code><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.path" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La ruta al archivo de código de bytes.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.SourcelessFileLoader.is_package">
<code class="sig-name descname">is_package</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.is_package" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Determina si el módulo es un paquete basado en <a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.path" title="importlib.machinery.SourcelessFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.SourcelessFileLoader.get_code">
<code class="sig-name descname">get_code</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.get_code" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el objeto de código para <a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.name" title="importlib.machinery.SourcelessFileLoader.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a> creado a partir de <a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.path" title="importlib.machinery.SourcelessFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.SourcelessFileLoader.get_source">
<code class="sig-name descname">get_source</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.get_source" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Devuelve <code class="docutils literal notranslate"><span class="pre">None</span></code> ya que los archivos de código de bytes no tienen fuente cuando se usa este cargador.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.SourcelessFileLoader.load_module">
<code class="sig-name descname">load_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.load_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<p>Implementación concreta de <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> donde especificar el nombre del módulo a cargar es opcional.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.6: </span>Utilice <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="importlib.machinery.ExtensionFileLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">ExtensionFileLoader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em>, <em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una implementación concreta de <a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ExecutionLoader</span></code></a> para módulos de extensión.</p>
<p>El argumento <em>fullname</em> especifica el nombre del módulo que el cargador debe admitir. El argumento <em>path</em> es la ruta al archivo del módulo de extensión.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<dl class="py attribute">
<dt id="importlib.machinery.ExtensionFileLoader.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.name" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Nombre del módulo que admite el cargador.</p>
</dd></dl>

<dl class="py attribute">
<dt id="importlib.machinery.ExtensionFileLoader.path">
<code class="sig-name descname">path</code><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.path" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Ruta al módulo de extensión.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.ExtensionFileLoader.create_module">
<code class="sig-name descname">create_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">spec</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.create_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea el objeto de módulo a partir de la especificación dada de acuerdo con <span class="target" id="index-45"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.ExtensionFileLoader.exec_module">
<code class="sig-name descname">exec_module</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">module</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.exec_module" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Inicializa el objeto de módulo dado de acuerdo con <span class="target" id="index-46"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0489"><strong>PEP 489</strong></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.ExtensionFileLoader.is_package">
<code class="sig-name descname">is_package</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.is_package" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si la ruta del archivo apunta al módulo <code class="docutils literal notranslate"><span class="pre">__init__</span></code> de un paquete basado en <a class="reference internal" href="#importlib.machinery.EXTENSION_SUFFIXES" title="importlib.machinery.EXTENSION_SUFFIXES"><code class="xref py py-attr docutils literal notranslate"><span class="pre">EXTENSION_SUFFIXES</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.ExtensionFileLoader.get_code">
<code class="sig-name descname">get_code</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_code" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> ya que los módulos de extensión carecen de un objeto de código.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.ExtensionFileLoader.get_source">
<code class="sig-name descname">get_source</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_source" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> ya que los módulos de extensión no tienen código fuente.</p>
</dd></dl>

<dl class="py method">
<dt id="importlib.machinery.ExtensionFileLoader.get_filename">
<code class="sig-name descname">get_filename</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_filename" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <a class="reference internal" href="#importlib.machinery.ExtensionFileLoader.path" title="importlib.machinery.ExtensionFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="importlib.machinery.ModuleSpec">
<em class="property">class </em><code class="sig-prename descclassname">importlib.machinery.</code><code class="sig-name descname">ModuleSpec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">loader</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">origin</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">loader_state</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">is_package</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ModuleSpec" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una especificación para el estado relacionado con el sistema de importación de un módulo. Esto generalmente se expone como el atributo <code class="docutils literal notranslate"><span class="pre">__spec__</span></code> del módulo. En las descripciones siguientes, los nombres entre paréntesis dan el atributo correspondiente disponible directamente en el objeto del módulo, por ejemplo, <code class="docutils literal notranslate"><span class="pre">module.__spec__.origin</span> <span class="pre">==</span> <span class="pre">module.__file__</span></code>. Sin embargo, tenga en cuenta que, si bien los <em>values</em> suelen ser equivalentes, pueden diferir ya que no hay sincronización entre los dos objetos. Por lo tanto, es posible actualizar el <code class="docutils literal notranslate"><span class="pre">__path__</span></code> del módulo en tiempo de ejecución, y esto no se reflejará automáticamente en <code class="docutils literal notranslate"><span class="pre">__spec__.submodule_search_locations</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<dl class="py attribute">
<dt id="importlib.machinery.ModuleSpec.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.name" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__name__</span></code>)</p>
<p>A string for the fully qualified name of the module.</p>
<dl class="py attribute">
<dt id="importlib.machinery.ModuleSpec.loader">
<code class="sig-name descname">loader</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.loader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__loader__</span></code>)</p>
<p>El <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">Loader</span></a> que debe usarse al cargar el módulo. <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">Finders</span></a> siempre debe establecer esto.</p>
<dl class="py attribute">
<dt id="importlib.machinery.ModuleSpec.origin">
<code class="sig-name descname">origin</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.origin" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__file__</span></code>)</p>
<p>Nombre del lugar desde el que se carga el módulo, por ejemplo «incorporado» (<em>builtin</em>) para los módulos incorporados y el nombre de archivo para los módulos cargados desde la fuente. Normalmente se debe establecer «origen», pero puede ser <code class="docutils literal notranslate"><span class="pre">None</span></code> (el valor predeterminado), lo que indica que no está especificado (por ejemplo, para paquetes de espacio de nombres).</p>
<dl class="py attribute">
<dt id="importlib.machinery.ModuleSpec.submodule_search_locations">
<code class="sig-name descname">submodule_search_locations</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.submodule_search_locations" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__path__</span></code>)</p>
<p>Lista de cadenas de caracteres de dónde encontrar submódulos, si es un paquete (<code class="docutils literal notranslate"><span class="pre">None</span></code> de lo contrario).</p>
<dl class="py attribute">
<dt id="importlib.machinery.ModuleSpec.loader_state">
<code class="sig-name descname">loader_state</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.loader_state" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<p>Contenedor de datos adicionales específicos del módulo para usar durante la carga (o <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
<dl class="py attribute">
<dt id="importlib.machinery.ModuleSpec.cached">
<code class="sig-name descname">cached</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.cached" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__cached__</span></code>)</p>
<p>Cadena de caracteres para el lugar donde se debe almacenar el módulo compilado (o <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
<dl class="py attribute">
<dt id="importlib.machinery.ModuleSpec.parent">
<code class="sig-name descname">parent</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.parent" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<p>(<code class="docutils literal notranslate"><span class="pre">__package__</span></code>)</p>
<p>(Read-only) The fully qualified name of the package under which the module
should be loaded as a submodule (or the empty string for top-level modules).
For packages, it is the same as <a class="reference internal" href="../reference/import.html#name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a>.</p>
<dl class="py attribute">
<dt id="importlib.machinery.ModuleSpec.has_location">
<code class="sig-name descname">has_location</code><a class="headerlink" href="#importlib.machinery.ModuleSpec.has_location" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<p>Booleano que indica si el atributo «origen» del módulo se refiere a una ubicación cargable.</p>
</dd></dl>

</section>
<section id="module-importlib.util">
<span id="importlib-util-utility-code-for-importers"></span><h2><a class="reference internal" href="#module-importlib.util" title="importlib.util: Utility code for importers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code></a> – Código de utilidad para importadores<a class="headerlink" href="#module-importlib.util" title="Enlazar permanentemente con este título">¶</a></h2>
<p><strong>Código fuente:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/importlib/util.py">Lib/importlib/util.py</a></p>
<hr class="docutils" />
<p>Este módulo contiene los diversos objetos que ayudan en la construcción de un <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a>.</p>
<dl class="py attribute">
<dt id="importlib.util.MAGIC_NUMBER">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">MAGIC_NUMBER</code><a class="headerlink" href="#importlib.util.MAGIC_NUMBER" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Los bytes que representan el número de versión del código de bytes. Si necesita ayuda para cargar/escribir código de bytes, considere <a class="reference internal" href="#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.cache_from_source">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">cache_from_source</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">debug_override</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">optimization</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.cache_from_source" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la ruta <span class="target" id="index-47"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a>/<span class="target" id="index-48"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0488"><strong>PEP 488</strong></a> al archivo compilado por bytes asociado con la <em>path</em> de origen. Por ejemplo, si <em>path</em> es <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code>, el valor de retorno sería <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code> para Python 3.2. La cadena de caracteres <code class="docutils literal notranslate"><span class="pre">cpython-32</span></code> proviene de la etiqueta mágica actual (ver <code class="xref py py-func docutils literal notranslate"><span class="pre">get_tag()</span></code>; si <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.implementation.cache_tag</span></code> no está definido, se lanzará <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>).</p>
<p>El parámetro <em>optimization</em> se utiliza para especificar el nivel de optimización del archivo de código de bytes. Una cadena de caracteres vacía no representa optimización, por lo que <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code> con una <em>optimization</em> de <code class="docutils literal notranslate"><span class="pre">''</span></code> dará como resultado una ruta de código de bytes de <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code>. <code class="docutils literal notranslate"><span class="pre">None</span></code> hace que se utilice el nivel de optimización del intérprete. Se usa la representación de cadena de caracteres de cualquier otro valor, por lo que <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code> con una <em>optimization</em> de <code class="docutils literal notranslate"><span class="pre">2</span></code> conducirá a la ruta del código de bytes de <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc</span></code>. La representación de cadena de caracteres <em>optimization</em> solo puede ser alfanumérica, de lo contrario se lanza <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
<p>El parámetro <em>debug_override</em> está obsoleto y se puede usar para anular el valor del sistema para <code class="docutils literal notranslate"><span class="pre">__debug__</span></code>. Un valor <code class="docutils literal notranslate"><span class="pre">True</span></code> es el equivalente a establecer <em>optimization</em> en la cadena de caracteres vacía. Un valor <code class="docutils literal notranslate"><span class="pre">False</span></code> es lo mismo que establecer <em>optimization</em> en <code class="docutils literal notranslate"><span class="pre">1</span></code>. Si tanto <em>debug_override</em> como <em>optimization</em> no es <code class="docutils literal notranslate"><span class="pre">None</span></code>, entonces se lanza <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Se agregó el parámetro <em>optimization</em> y el parámetro <em>debug_override</em> quedó obsoleto.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Acepta un <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.source_from_cache">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">source_from_cache</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.source_from_cache" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Dado el <em>path</em> a un nombre de archivo <span class="target" id="index-49"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a>, retorna la ruta del archivo del código fuente asociado. Por ejemplo, si <em>path</em> es <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code>, la ruta retornada sería <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code>. <em>path</em> no necesita existir, sin embargo, si no se ajusta al formato <span class="target" id="index-50"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3147"><strong>PEP 3147</strong></a> o <span class="target" id="index-51"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0488"><strong>PEP 488</strong></a>, se lanza un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>. Si <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.implementation.cache_tag</span></code> no está definido, se lanza <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Acepta un <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.decode_source">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">decode_source</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">source_bytes</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.decode_source" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Decodifica los bytes dados que representan el código fuente y los retorna como una cadena de caracteres con nuevas líneas universales (como lo requiere <a class="reference internal" href="#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader.get_source()</span></code></a>).</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.resolve_name">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">resolve_name</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">package</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.resolve_name" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Resuelve un nombre de módulo relativo a uno absoluto.</p>
<p>Si <strong>name</strong> no tiene puntos iniciales, entonces <strong>name</strong> simplemente se retorna. Esto permite el uso como <code class="docutils literal notranslate"><span class="pre">importlib.util.resolve_name('sys',</span> <span class="pre">__spec__.parent)</span></code> sin hacer una verificación para ver si se necesita el argumento <strong>package</strong>.</p>
<p><a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> se lanza si <strong>name</strong> es un nombre de módulo relativo pero <strong>package</strong> es un valor falso (por ejemplo, <code class="docutils literal notranslate"><span class="pre">None</span></code> o la cadena de caracteres vacía). También se lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> un nombre relativo que escaparía del paquete que lo contiene (por ejemplo, solicitando <code class="docutils literal notranslate"><span class="pre">..bacon</span></code> desde el paquete <code class="docutils literal notranslate"><span class="pre">spam</span></code>).</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.9: </span>Para mejorar la coherencia con las declaraciones de importación, aumente <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> en lugar de <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> para intentos de importación relativa no válidos.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.find_spec">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">find_spec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">package</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.find_spec" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Busca el <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a> para un módulo, opcionalmente relativo al nombre del <strong>package</strong> especificado. Si el módulo está en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, se retorna <code class="docutils literal notranslate"><span class="pre">sys.modules[name].__spec__</span></code> (a menos que la especificación sea <code class="docutils literal notranslate"><span class="pre">None</span></code> o no esté establecida, en cuyo caso se lanza <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>). De lo contrario, se realiza una búsqueda utilizando <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>. Se retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si no se encuentra ninguna especificación.</p>
<p>Si <strong>name</strong> es para un submódulo (contiene un punto), el módulo principal se importa automáticamente.</p>
<p><strong>name</strong> y <strong>package</strong> funcionan igual que para <code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Lanza <a class="reference internal" href="exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> en lugar de <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> si <strong>package</strong> no es de hecho un paquete (es decir, carece de un atributo <a class="reference internal" href="../reference/import.html#path__" title="__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a>).</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.module_from_spec">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">module_from_spec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">spec</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.module_from_spec" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Cree un nuevo módulo basado en <strong>spec</strong> y <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spec.loader.create_module</span></code></a>.</p>
<p>Si <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spec.loader.create_module</span></code></a> no retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>, no se restablecerán los atributos preexistentes. Además, no se lanzará <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> si se activa mientras se accede a <strong>spec</strong> o se establece un atributo en el módulo.</p>
<p>Esta función es preferible a usar <a class="reference internal" href="types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a> para crear un nuevo módulo ya que <strong>spec</strong> se usa para establecer tantos atributos de importación controlados en el módulo como sea posible.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.module_for_loader">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">module_for_loader</code><a class="headerlink" href="#importlib.util.module_for_loader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> para <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> para manejar la selección del objeto de módulo adecuado para cargar. Se espera que el método decorado tenga una firma de llamada que tome dos argumentos posicionales (por ejemplo, <code class="docutils literal notranslate"><span class="pre">load_module(self,</span> <span class="pre">module)</span></code>) para los cuales el segundo argumento será el módulo <strong>object</strong> que usará el cargador. Tenga en cuenta que el decorador no funcionará con métodos estáticos debido a la suposición de dos argumentos.</p>
<p>El método decorado tomará el <strong>name</strong> del módulo que se cargará como se esperaba para un <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>. Si el módulo no se encuentra en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, se construye uno nuevo. Independientemente de la procedencia del módulo, <a class="reference internal" href="../reference/import.html#loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> se establece en <strong>self</strong> y <a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> se establece en función de lo que retorna <a class="reference internal" href="#importlib.abc.InspectLoader.is_package" title="importlib.abc.InspectLoader.is_package"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader.is_package()</span></code></a> (si está disponible) . Estos atributos se establecen incondicionalmente para admitir la recarga.</p>
<p>Si el método decorado lanza una excepción y se agrega un módulo a <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, entonces el módulo se eliminará para evitar que un módulo parcialmente inicializado quede en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>. Si el módulo ya estaba en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> entonces se deja solo.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span><a class="reference internal" href="../reference/import.html#loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> y <a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> se configuran automáticamente (cuando es posible).</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Establece <a class="reference internal" href="../reference/import.html#name__" title="__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a>, <a class="reference internal" href="../reference/import.html#loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> <a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> incondicionalmente para apoyar la recarga.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>La maquinaria de importación ahora realiza directamente toda la funcionalidad proporcionada por esta función.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.set_loader">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">set_loader</code><a class="headerlink" href="#importlib.util.set_loader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> para <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> para establecer el atributo <a class="reference internal" href="../reference/import.html#loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> en el módulo retornado. Si el atributo ya está configurado, el decorador no hace nada. Se asume que el primer argumento posicional del método envuelto (es decir, <code class="docutils literal notranslate"><span class="pre">self</span></code>) es lo que se debe establecer en <a class="reference internal" href="../reference/import.html#loader__" title="__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Establece <code class="docutils literal notranslate"><span class="pre">__loader__</span></code> si está configurado como <code class="docutils literal notranslate"><span class="pre">None</span></code>, como si el atributo no existiera.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>La maquinaria de importación se encarga de esto automáticamente.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.set_package">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">set_package</code><a class="headerlink" href="#importlib.util.set_package" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> para <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> para establecer el atributo <a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> en el módulo retornado. Si <a class="reference internal" href="../reference/import.html#package__" title="__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> está configurado y tiene un valor diferente a <code class="docutils literal notranslate"><span class="pre">None</span></code>, no se cambiará.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.4: </span>La maquinaria de importación se encarga de esto automáticamente.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.spec_from_loader">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">spec_from_loader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">loader</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">origin</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">is_package</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.spec_from_loader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una función de fábrica para crear una instancia de <a class="reference internal" href="#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code></a> basada en un cargador. Los parámetros tienen el mismo significado que para ModuleSpec. La función utiliza APIs disponibles de <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>, tal como <code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.is_package()</span></code>, para completar cualquier información que falte en la especificación.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.spec_from_file_location">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">spec_from_file_location</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">location</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">loader</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">submodule_search_locations</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.spec_from_file_location" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una función de fábrica para crear una instancia de <a class="reference internal" href="#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code></a> basada en la ruta a un archivo. La información que falte se completará en la especificación mediante el uso de las API de loader y la implicación de que el módulo estará basado en archivos.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Acepta un <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="importlib.util.source_hash">
<code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">source_hash</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">source_bytes</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.source_hash" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el hash de <em>source_bytes</em> como bytes. Un archivo <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> basado en hash incrusta <a class="reference internal" href="#importlib.util.source_hash" title="importlib.util.source_hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">source_hash()</span></code></a> del contenido del archivo fuente correspondiente en su encabezado.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt id="importlib.util.LazyLoader">
<em class="property">class </em><code class="sig-prename descclassname">importlib.util.</code><code class="sig-name descname">LazyLoader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">loader</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.LazyLoader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase que pospone la ejecución del cargador de un módulo hasta que el módulo tiene acceso a un atributo.</p>
<p>Esta clase <strong>solo</strong> funciona con cargadores que definen <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> ya que se requiere control sobre qué tipo de módulo se usa para el módulo. Por esas mismas razones, el método del cargador <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a> debe retornar <code class="docutils literal notranslate"><span class="pre">None</span></code> o un tipo para el cual su atributo <code class="docutils literal notranslate"><span class="pre">__class__</span></code> se puede mutar junto con no usar <a class="reference internal" href="../glossary.html#term-__slots__"><span class="xref std std-term">slots</span></a>. Finalmente, los módulos que sustituyen el objeto colocado en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.modules</span></code></a> no funcionarán ya que no hay forma de reemplazar correctamente las referencias del módulo en todo el intérprete de forma segura; <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> se genera si se detecta tal sustitución.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Para proyectos donde el tiempo de inicio es crítico, esta clase permite minimizar potencialmente el costo de cargar un módulo si nunca se usa. Para proyectos en los que el tiempo de inicio no es esencial, el uso de esta clase se desaconseja <strong>en gran medida</strong> debido a que los mensajes de error creados durante la carga se posponen y, por lo tanto, ocurren fuera de contexto.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Comenzó a llamar <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>, eliminando la advertencia de compatibilidad para <a class="reference internal" href="#importlib.machinery.BuiltinImporter" title="importlib.machinery.BuiltinImporter"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.BuiltinImporter</span></code></a> y <a class="reference internal" href="#importlib.machinery.ExtensionFileLoader" title="importlib.machinery.ExtensionFileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.ExtensionFileLoader</span></code></a>.</p>
</div>
<dl class="py method">
<dt id="importlib.util.LazyLoader.factory">
<em class="property">classmethod </em><code class="sig-name descname">factory</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">loader</span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.LazyLoader.factory" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>A class method which returns a callable that creates a lazy loader. This
is meant to be used in situations where the loader is passed by class
instead of by instance.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">suffixes</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SOURCE_SUFFIXES</span>
<span class="n">loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SourceFileLoader</span>
<span class="n">lazy_loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">LazyLoader</span><span class="o">.</span><span class="n">factory</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
<span class="n">finder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">FileFinder</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="p">(</span><span class="n">lazy_loader</span><span class="p">,</span> <span class="n">suffixes</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="examples">
<span id="importlib-examples"></span><h2>Ejemplos<a class="headerlink" href="#examples" title="Enlazar permanentemente con este título">¶</a></h2>
<section id="importing-programmatically">
<h3>Importar programáticamente<a class="headerlink" href="#importing-programmatically" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para importar un módulo mediante programación, use <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib</span>

<span class="n">itertools</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;itertools&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="checking-if-a-module-can-be-imported">
<h3>Comprobando si se puede importar un módulo<a class="headerlink" href="#checking-if-a-module-can-be-imported" title="Enlazar permanentemente con este título">¶</a></h3>
<p>If you need to find out if a module can be imported without actually doing the
import, then you should use <a class="reference internal" href="#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.find_spec()</span></code></a>.</p>
<p>Note that if <code class="docutils literal notranslate"><span class="pre">name</span></code> is a submodule (contains a dot),
<a class="reference internal" href="#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.find_spec()</span></code></a> will import the parent module.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># For illustrative purposes.</span>
<span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;itertools&#39;</span>

<span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> already in sys.modules&quot;</span><span class="p">)</span>
<span class="k">elif</span> <span class="p">(</span><span class="n">spec</span> <span class="o">:=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># If you chose to perform the actual import ...</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> has been imported&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;can&#39;t find the </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> module&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="importing-a-source-file-directly">
<h3>Importar un archivo fuente directamente<a class="headerlink" href="#importing-a-source-file-directly" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para importar un archivo fuente de Python directamente, use la siguiente receta (solo Python 3.5 y más reciente):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># For illustrative purposes.</span>
<span class="kn">import</span> <span class="nn">tokenize</span>
<span class="n">file_path</span> <span class="o">=</span> <span class="n">tokenize</span><span class="o">.</span><span class="vm">__file__</span>
<span class="n">module_name</span> <span class="o">=</span> <span class="n">tokenize</span><span class="o">.</span><span class="vm">__name__</span>

<span class="n">spec</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">spec_from_file_location</span><span class="p">(</span><span class="n">module_name</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>
<span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">module_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
<span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="implementing-lazy-imports">
<h3>Implementar importaciones diferidas<a class="headerlink" href="#implementing-lazy-imports" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El ejemplo de abajo muestra cómo implementar importaciones diferidas:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">lazy_import</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">spec</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">LazyLoader</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="o">=</span> <span class="n">loader</span>
<span class="gp">... </span>    <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
<span class="gp">... </span>    <span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">module</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lazy_typing</span> <span class="o">=</span> <span class="n">lazy_import</span><span class="p">(</span><span class="s2">&quot;typing&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#lazy_typing is a real module object,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#but it is not loaded in memory yet.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lazy_typing</span><span class="o">.</span><span class="n">TYPE_CHECKING</span>
<span class="go">False</span>
</pre></div>
</div>
</section>
<section id="setting-up-an-importer">
<h3>Configurar un importador<a class="headerlink" href="#setting-up-an-importer" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para personalizaciones profundas de la importación, normalmente desea implementar un <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importador</span></a>. Esto significa administrar tanto el lado <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> como <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> de las cosas. Para los buscadores, hay dos sabores para elegir según sus necesidades: un <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">meta path finder</span></a> o un <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a>. El primero es lo que pondrías en <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> mientras que el segundo es lo que creas usando un <a class="reference internal" href="../glossary.html#term-path-entry-hook"><span class="xref std std-term">path entry hook</span></a> en <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> que funciona con <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys</span> <span class="pre">.path</span></code> entradas para crear potencialmente un buscador. Este ejemplo le mostrará cómo registrar sus propios importadores para que import los utilice (para crear un importador para usted, lea la documentación de las clases apropiadas definidas dentro de este paquete):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.machinery</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># For illustrative purposes only.</span>
<span class="n">SpamMetaPathFinder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">PathFinder</span>
<span class="n">SpamPathEntryFinder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">FileFinder</span>
<span class="n">loader_details</span> <span class="o">=</span> <span class="p">(</span><span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SourceFileLoader</span><span class="p">,</span>
                  <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SOURCE_SUFFIXES</span><span class="p">)</span>

<span class="c1"># Setting up a meta path finder.</span>
<span class="c1"># Make sure to put the finder in the proper location in the list in terms of</span>
<span class="c1"># priority.</span>
<span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SpamMetaPathFinder</span><span class="p">)</span>

<span class="c1"># Setting up a path entry finder.</span>
<span class="c1"># Make sure to put the path hook in the proper location in the list in terms</span>
<span class="c1"># of priority.</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path_hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SpamPathEntryFinder</span><span class="o">.</span><span class="n">path_hook</span><span class="p">(</span><span class="n">loader_details</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="approximating-importlib-import-module">
<h3>Aproximando <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a><a class="headerlink" href="#approximating-importlib-import-module" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La importación en sí está implementada en código Python, lo que permite exponer la mayor parte de la maquinaria de importación a través de importlib. Lo siguiente ayuda a ilustrar las diversas API que importlib expone al proporcionar una implementación aproximada de <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> (Python 3.4 y más reciente para el uso de importlib, Python 3.6 y más reciente para otras partes del código).</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">import_module</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An approximate implementation of import.&quot;&quot;&quot;</span>
    <span class="n">absolute_name</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">resolve_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">absolute_name</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">path</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">absolute_name</span><span class="p">:</span>
        <span class="n">parent_name</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">child_name</span> <span class="o">=</span> <span class="n">absolute_name</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">parent_module</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="n">parent_name</span><span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">parent_module</span><span class="o">.</span><span class="n">__spec__</span><span class="o">.</span><span class="n">submodule_search_locations</span>
    <span class="k">for</span> <span class="n">finder</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="p">:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">absolute_name</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;No module named </span><span class="si">{</span><span class="n">absolute_name</span><span class="si">!r}</span><span class="s1">&#39;</span>
        <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">absolute_name</span><span class="p">)</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">absolute_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">parent_module</span><span class="p">,</span> <span class="n">child_name</span><span class="p">,</span> <span class="n">module</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">module</span>
</pre></div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> — La implementación de <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a><ul>
<li><a class="reference internal" href="#introduction">Introducción</a></li>
<li><a class="reference internal" href="#functions">Funciones</a></li>
<li><a class="reference internal" href="#module-importlib.abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code> – Clases base abstractas relacionadas con la importación</a></li>
<li><a class="reference internal" href="#module-importlib.resources"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.resources</span></code> – Recursos</a></li>
<li><a class="reference internal" href="#module-importlib.machinery"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.machinery</span></code> – Importadores y enlaces de ruta</a></li>
<li><a class="reference internal" href="#module-importlib.util"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code> – Código de utilidad para importadores</a></li>
<li><a class="reference internal" href="#examples">Ejemplos</a><ul>
<li><a class="reference internal" href="#importing-programmatically">Importar programáticamente</a></li>
<li><a class="reference internal" href="#checking-if-a-module-can-be-imported">Comprobando si se puede importar un módulo</a></li>
<li><a class="reference internal" href="#importing-a-source-file-directly">Importar un archivo fuente directamente</a></li>
<li><a class="reference internal" href="#implementing-lazy-imports">Implementar importaciones diferidas</a></li>
<li><a class="reference internal" href="#setting-up-an-importer">Configurar un importador</a></li>
<li><a class="reference internal" href="#approximating-importlib-import-module">Aproximando <code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="runpy.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code> — Localización y ejecución de módulos <em>Python</em></a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="importlib.metadata.html"
                        title="próximo capítulo">Usando <code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.metadata</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/importlib.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="importlib.metadata.html" title="Usando importlib.metadata"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="runpy.html" title="runpy — Localización y ejecución de módulos Python"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La Biblioteca Estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="modules.html" >Importando módulos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> — La implementación de <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 27, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>