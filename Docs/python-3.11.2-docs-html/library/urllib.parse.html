
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="urllib.parse — Analiza URL en componentes" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/urllib.parse.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Código fuente: Lib/urllib/parse.py Este modulo define una interfaz estándar para separar cadenas de texto del Localizador de recursos uniforme (más conocido por las siglas URL, del inglés Uniform R..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Código fuente: Lib/urllib/parse.py Este modulo define una interfaz estándar para separar cadenas de texto del Localizador de recursos uniforme (más conocido por las siglas URL, del inglés Uniform R..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>urllib.parse — Analiza URL en componentes &#8212; documentación de Python - 3.11.2</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=2d3badd06fe70b34b68db01f99471ce1624ffe4a" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.11.2"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="urllib.error — Clases de excepción lanzadas por urllib.request" href="urllib.error.html" />
    <link rel="prev" title="urllib.request — Biblioteca extensible para abrir URLs" href="urllib.request.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/urllib.parse.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.parse</span></code> — Analiza URL en componentes</a><ul>
<li><a class="reference internal" href="#url-parsing">Análisis de URL</a></li>
<li><a class="reference internal" href="#parsing-ascii-encoded-bytes">Análisis de bytes codificados ASCII</a></li>
<li><a class="reference internal" href="#structured-parse-results">Resultados del análisis estructurado</a></li>
<li><a class="reference internal" href="#url-quoting">Cita de URL</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="urllib.request.html"
                          title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> — Biblioteca extensible para abrir URLs</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="urllib.error.html"
                          title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.error</span></code> — Clases de excepción lanzadas por urllib.request</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/library/urllib.parse.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="urllib.error.html" title="urllib.error — Clases de excepción lanzadas por urllib.request"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="urllib.request.html" title="urllib.request — Biblioteca extensible para abrir URLs"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" accesskey="U">Protocolos y soporte de Internet</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.parse</span></code> — Analiza URL en componentes</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-urllib.parse">
<span id="urllib-parse-parse-urls-into-components"></span><h1><a class="reference internal" href="#module-urllib.parse" title="urllib.parse: Parse URLs into or assemble them from components."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.parse</span></code></a> — Analiza URL en componentes<a class="headerlink" href="#module-urllib.parse" title="Enlazar permanentemente con este título">¶</a></h1>
<p><strong>Código fuente:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.11/Lib/urllib/parse.py">Lib/urllib/parse.py</a></p>
<hr class="docutils" id="index-0" />
<p>Este modulo define una interfaz estándar para separar cadenas de texto del Localizador de recursos uniforme (más conocido por las siglas URL, del inglés <em>Uniform Resource Locator</em>) en componentes (esquema de dirección, ubicación de red, ruta de acceso, etc.), para poder combinar los componentes  nuevamente en una cadena de texto URL, y convertir una «URL relativa» a una URL absoluta a partir de una «URL base».</p>
<p>Este módulo ha sido diseñado para coincidir con el RFC de internet sobre localizadores de recursos uniformes relativos. Admite los siguientes esquemas URL: <code class="docutils literal notranslate"><span class="pre">file</span></code>, <code class="docutils literal notranslate"><span class="pre">ftp</span></code>, <code class="docutils literal notranslate"><span class="pre">gopher</span></code>, <code class="docutils literal notranslate"><span class="pre">hdl</span></code>, <code class="docutils literal notranslate"><span class="pre">http</span></code>, <code class="docutils literal notranslate"><span class="pre">https</span></code>, <code class="docutils literal notranslate"><span class="pre">imap</span></code>, <code class="docutils literal notranslate"><span class="pre">mailto</span></code>, <code class="docutils literal notranslate"><span class="pre">mms</span></code>, <code class="docutils literal notranslate"><span class="pre">news</span></code>, <code class="docutils literal notranslate"><span class="pre">nntp</span></code>, <code class="docutils literal notranslate"><span class="pre">prospero</span></code>, <code class="docutils literal notranslate"><span class="pre">rsync</span></code>, <code class="docutils literal notranslate"><span class="pre">rtsp</span></code>, <code class="docutils literal notranslate"><span class="pre">rtspu</span></code>, <code class="docutils literal notranslate"><span class="pre">sftp</span></code>, <code class="docutils literal notranslate"><span class="pre">shttp</span></code>, <code class="docutils literal notranslate"><span class="pre">sip</span></code>, <code class="docutils literal notranslate"><span class="pre">sips</span></code>, <code class="docutils literal notranslate"><span class="pre">snews</span></code>, <code class="docutils literal notranslate"><span class="pre">svn</span></code>, <code class="docutils literal notranslate"><span class="pre">svn+ssh</span></code>, <code class="docutils literal notranslate"><span class="pre">telnet</span></code>, <code class="docutils literal notranslate"><span class="pre">wais</span></code>, <code class="docutils literal notranslate"><span class="pre">ws</span></code>, <code class="docutils literal notranslate"><span class="pre">wss</span></code>.</p>
<p>El módulo <a class="reference internal" href="#module-urllib.parse" title="urllib.parse: Parse URLs into or assemble them from components."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.parse</span></code></a> define funciones que se dividen en dos categorías amplias: análisis de URL y cita de URL. Estos se tratan en detalle en las secciones siguientes.</p>
<section id="url-parsing">
<h2>Análisis de URL<a class="headerlink" href="#url-parsing" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las funciones de análisis de url se centran en dividir una cadena de dirección URL en sus componentes o en combinar componentes de dirección URL en una cadena de dirección URL.</p>
<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.urlparse">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">urlparse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">urlstring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scheme</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_fragments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urlparse" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Analiza una URL en seis componentes, retornando una <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">tupla nombrada</span></a> de 6 elementos.  Esto corresponde a la estructura general de una URL: <code class="docutils literal notranslate"><span class="pre">scheme://netloc/path;parameters?query#fragment</span></code>. Cada elemento de la tupla es una cadena de caracteres, posiblemente vacía. Los componentes no se dividen en piezas más pequeñas (por ejemplo, la ubicación de red es una sola cadena) y los caracteres % de escape no están expandidos. Los delimitadores como se muestra anteriormente no forman parte del resultado, excepto una barra diagonal inicial en el componente <em>path</em>, el cual es conservado si está presente.  Por ejemplo:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">urlparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urlparse</span><span class="p">(</span><span class="s2">&quot;scheme://netloc/path;parameters?query#fragment&quot;</span><span class="p">)</span>
<span class="go">ParseResult(scheme=&#39;scheme&#39;, netloc=&#39;netloc&#39;, path=&#39;/path;parameters&#39;, params=&#39;&#39;,</span>
<span class="go">            query=&#39;query&#39;, fragment=&#39;fragment&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="s2">&quot;http://docs.python.org:80/3/library/urllib.parse.html?&quot;</span>
<span class="gp">... </span>             <span class="s2">&quot;highlight=params#url-parsing&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span>
<span class="go">ParseResult(scheme=&#39;http&#39;, netloc=&#39;docs.python.org:80&#39;,</span>
<span class="go">            path=&#39;/3/library/urllib.parse.html&#39;, params=&#39;&#39;,</span>
<span class="go">            query=&#39;highlight=params&#39;, fragment=&#39;url-parsing&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">scheme</span>
<span class="go">&#39;http&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">netloc</span>
<span class="go">&#39;docs.python.org:80&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">hostname</span>
<span class="go">&#39;docs.python.org&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">port</span>
<span class="go">80</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">fragment</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">geturl</span><span class="p">()</span>
<span class="go">&#39;http://docs.python.org:80/3/library/urllib.parse.html?highlight=params&#39;</span>
</pre></div>
</div>
<p>Siguiendo las especificaciones de sintaxis en <span class="target" id="index-25"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1808.html"><strong>RFC 1808</strong></a>, urlparse reconoce un netloc sólo si es introducido correctamente por “//”.  De lo contrario, se supone que la entrada es una dirección URL relativa y, por lo tanto, comienza con un componente de ruta de acceso.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">urlparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urlparse</span><span class="p">(</span><span class="s1">&#39;//www.cwi.nl:80/</span><span class="si">%7E</span><span class="s1">guido/Python.html&#39;</span><span class="p">)</span>
<span class="go">ParseResult(scheme=&#39;&#39;, netloc=&#39;www.cwi.nl:80&#39;, path=&#39;/%7Eguido/Python.html&#39;,</span>
<span class="go">            params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urlparse</span><span class="p">(</span><span class="s1">&#39;www.cwi.nl/</span><span class="si">%7E</span><span class="s1">guido/Python.html&#39;</span><span class="p">)</span>
<span class="go">ParseResult(scheme=&#39;&#39;, netloc=&#39;&#39;, path=&#39;www.cwi.nl/%7Eguido/Python.html&#39;,</span>
<span class="go">            params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urlparse</span><span class="p">(</span><span class="s1">&#39;help/Python.html&#39;</span><span class="p">)</span>
<span class="go">ParseResult(scheme=&#39;&#39;, netloc=&#39;&#39;, path=&#39;help/Python.html&#39;, params=&#39;&#39;,</span>
<span class="go">            query=&#39;&#39;, fragment=&#39;&#39;)</span>
</pre></div>
</div>
<p>El argumento <em>scheme</em> proporciona el esquema de direccionamiento predeterminado, que solo se utilizará si la dirección URL no especifica uno.  Debe ser del mismo tipo (texto o bytes) que <em>urlstring</em>, excepto que el valor predeterminado <code class="docutils literal notranslate"><span class="pre">''</span></code>  siempre está permitido, y se convierte automáticamente a <code class="docutils literal notranslate"><span class="pre">b''</span></code> si aplica.</p>
<p>Si el argumento <em>allow_fragments</em> es falso, los identificadores de fragmento no son reconocidos. Sino que, son analizados como parte de la ruta, parámetros o componentes de la consulta y el <code class="xref py py-attr docutils literal notranslate"><span class="pre">fragment</span></code> es configurado como una cadena vacía en el valor retornado.</p>
<p>El valor retornado es un <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a>, lo que significa que se puede tener acceso a sus elementos por índice o como atributos con nombre, que son:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 24%" />
<col style="width: 9%" />
<col style="width: 34%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Atributo</p></th>
<th class="head"><p>Índice</p></th>
<th class="head"><p>Valor</p></th>
<th class="head"><p>Valor si no está presente</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">scheme</span></code></p></td>
<td><p>0</p></td>
<td><p>Especificador de esquema de URL</p></td>
<td><p>parámetro <em>scheme</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code></p></td>
<td><p>1</p></td>
<td><p>Parte de ubicación de red</p></td>
<td><p>cadena vacía</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></p></td>
<td><p>2</p></td>
<td><p>Hierarchical path</p></td>
<td><p>cadena vacía</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">params</span></code></p></td>
<td><p>3</p></td>
<td><p>Parámetros para el último elemento de ruta de acceso</p></td>
<td><p>cadena vacía</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">query</span></code></p></td>
<td><p>4</p></td>
<td><p>Componente de consulta</p></td>
<td><p>cadena vacía</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">fragment</span></code></p></td>
<td><p>5</p></td>
<td><p>Identificador de fragmento</p></td>
<td><p>cadena vacía</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">username</span></code></p></td>
<td></td>
<td><p>Nombre de usuario</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">password</span></code></p></td>
<td></td>
<td><p>Contraseña</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">hostname</span></code></p></td>
<td></td>
<td><p>Nombre de host (minúsculas)</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">port</span></code></p></td>
<td></td>
<td><p>Número de puerto como entero, si está presente</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
</tbody>
</table>
<p>La lectura del atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">port</span></code> lanzará un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> si se especifica un puerto no válido en la dirección URL.  Consulte la sección <a class="reference internal" href="#urlparse-result-object"><span class="std std-ref">Resultados del análisis estructurado</span></a> para obtener más información sobre el objeto de resultado.</p>
<p>Los corchetes no coincidentes en el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code> lanzarán un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
<p>Los caracteres del atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code> que se descomponen en la normalización de NFKC (según lo utilizado por la codificación IDNA) en cualquiera de <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code>, <code class="docutils literal notranslate"><span class="pre">#</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> o <code class="docutils literal notranslate"><span class="pre">:</span></code> lanzará un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>. Si la dirección URL se descompone antes del análisis, no se producirá ningún error.</p>
<p>Como es el caso con todas las tuplas con nombre, la subclase tiene algunos métodos y atributos adicionales que son particularmente útiles. Uno de estos métodos es <code class="xref py py-meth docutils literal notranslate"><span class="pre">_replace()</span></code>. El método <code class="xref py py-meth docutils literal notranslate"><span class="pre">_replace()</span></code> retornará un nuevo objeto ParseResult reemplazando los campos especificados por nuevos valores.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">urlparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="s1">&#39;//www.cwi.nl:80/</span><span class="si">%7E</span><span class="s1">guido/Python.html&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span>
<span class="go">ParseResult(scheme=&#39;&#39;, netloc=&#39;www.cwi.nl:80&#39;, path=&#39;/%7Eguido/Python.html&#39;,</span>
<span class="go">            params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">scheme</span><span class="o">=</span><span class="s1">&#39;http&#39;</span><span class="p">)</span>
<span class="go">ParseResult(scheme=&#39;http&#39;, netloc=&#39;www.cwi.nl:80&#39;, path=&#39;/%7Eguido/Python.html&#39;,</span>
<span class="go">            params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Se han añadido capacidades de análisis de URL IPv6.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>El fragmento ahora es analizado para todos los esquemas de URL (a menos que <em>allow_fragment</em> sea falso), de acuerdo con <span class="target" id="index-26"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3986.html"><strong>RFC 3986</strong></a>.  Anteriormente, existía una lista de permisos de esquemas que admitían fragmentos.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Los números de puerto fuera de rango ahora generan <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>, en lugar de retornar <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Los caracteres que afectan al análisis de netloc en la normalización de NFKC ahora lanzarán <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.parse_qs">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">parse_qs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_blank_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict_parsing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'utf-8'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'replace'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_num_fields</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">separator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'&amp;'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.parse_qs" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Analizar una cadena de consulta proporcionada como argumento de cadena (datos de tipo <em class="mimetype">application/x-www-form-urlencoded</em>).  Los datos se retornan como un diccionario.  Las claves de diccionario son los nombres de variable de consulta únicos y los valores son listas de valores para cada nombre.</p>
<p>El argumento opcional <em>keep_blank_values</em> es un indicador que indica si los valores en blanco de las consultas codificadas por porcentaje deben tratarse como cadenas en blanco. Un valor verdadero indica que los espacios en blanco deben conservarse como cadenas en blanco.  El valor falso predeterminado indica que los valores en blanco deben omitirse y tratarse como si no se hubieran incluido.</p>
<p>El argumento opcional <em>strict_parsing</em> es una marca que indica qué hacer con los errores de análisis.  Si es falso (valor predeterminado), los errores se omiten silenciosamente.  Si es verdadero, los errores generan una excepción <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
<p>Los parámetros opcionales <em>encoding</em> y <em>errors</em> especifican cómo descodificar secuencias codificadas porcentualmente en caracteres Unicode, tal como lo acepta el método <a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a>.</p>
<p>El argumento opcional <em>max_num_fields</em> es el número máximo de campos que se van a leer. Si se establece, se produce un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> si hay más de <em>max_num_fields</em> campos leídos.</p>
<p>El argumento opcional <em>separator</em> es el símbolo que se usa para separar los argumentos de la cadena de consulta. El valor por defecto es <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>.</p>
<p>Utilice la función <a class="reference internal" href="#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> (con el parámetro <code class="docutils literal notranslate"><span class="pre">doseq</span></code> establecido en <code class="docutils literal notranslate"><span class="pre">True</span></code>) para convertir dichos diccionarios en cadenas de consulta.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Agregue los parámetros <em>encoding</em> y <em>errors</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Añadido parámetro <em>max_num_fields</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Añadido parámetro <em>separator</em> con un valor por defecto de <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>. Versiones de Python anterior a Python 3.10 permitían el uso de <code class="docutils literal notranslate"><span class="pre">;</span></code> y <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> como separadores de la cadena de consulta. Esto ha sido cambiado para aceptar sólo una llave separadora, siendo <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> el separador por defecto.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.parse_qsl">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">parse_qsl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_blank_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict_parsing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'utf-8'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'replace'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_num_fields</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">separator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'&amp;'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.parse_qsl" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Analizar una cadena de consulta proporcionada como argumento de cadena (datos de tipo <em class="mimetype">application/x-www-form-urlencoded</em>).  Los datos se retornan como una lista de pares de nombre y valor.</p>
<p>El argumento opcional <em>keep_blank_values</em> es un indicador que indica si los valores en blanco de las consultas codificadas por porcentaje deben tratarse como cadenas en blanco. Un valor verdadero indica que los espacios en blanco deben conservarse como cadenas en blanco.  El valor falso predeterminado indica que los valores en blanco deben omitirse y tratarse como si no se hubieran incluido.</p>
<p>El argumento opcional <em>strict_parsing</em> es una marca que indica qué hacer con los errores de análisis.  Si es falso (valor predeterminado), los errores se omiten silenciosamente.  Si es verdadero, los errores generan una excepción <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
<p>Los parámetros opcionales <em>encoding</em> y <em>errors</em> especifican cómo descodificar secuencias codificadas porcentualmente en caracteres Unicode, tal como lo acepta el método <a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a>.</p>
<p>El argumento opcional <em>max_num_fields</em> es el número máximo de campos que se van a leer. Si se establece, se produce un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> si hay más de <em>max_num_fields</em> campos leídos.</p>
<p>El argumento opcional <em>separator</em> es el símbolo que se usa para separar los argumentos de la cadena de consulta. El valor por defecto es <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>.</p>
<p>Utilice la función <a class="reference internal" href="#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> para convertir dichas listas de pares en cadenas de consulta.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Agregue los parámetros <em>encoding</em> y <em>errors</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Añadido parámetro <em>max_num_fields</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Añadido parámetro <em>separator</em> con un valor por defecto de <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>. Versiones de Python anterior a Python 3.10 permitían el uso de <code class="docutils literal notranslate"><span class="pre">;</span></code> y <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> como separadores de la cadena de consulta. Esto ha sido cambiado para aceptar sólo una llave separadora, siendo <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> el separador por defecto.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.urlunparse">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">urlunparse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urlunparse" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Construir una URL a partir de una tupla retornada por <code class="docutils literal notranslate"><span class="pre">urlparse()</span></code>. El argumento <em>parts</em> puede ser iterable de seis elementos. Esto puede dar lugar a una dirección URL ligeramente diferente, pero equivalente, si la dirección URL que se analizó originalmente tenía delimitadores innecesarios (por ejemplo, un <code class="docutils literal notranslate"><span class="pre">?</span></code> con una consulta vacía; la RFC indica que son equivalentes).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.urlsplit">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">urlsplit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">urlstring</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scheme</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_fragments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urlsplit" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esto es similar a <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a>, pero no divide los parámetros de la dirección URL. Esto se debe utilizar generalmente en lugar de <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a> si se desea la sintaxis de URL más reciente que permite aplicar parámetros a cada segmento de la parte <em>path</em> de la dirección URL (consulte <span class="target" id="index-27"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2396.html"><strong>RFC 2396</strong></a>).  Se necesita una función independiente para separar los segmentos y parámetros de ruta.  Esta función retorna un 5-item <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">addressing</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">network</span> <span class="n">location</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">fragment</span> <span class="n">identifier</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>El valor retornado es un <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a>, se puede acceder a sus elementos por índice o como atributos con nombre:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 10%" />
<col style="width: 35%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Atributo</p></th>
<th class="head"><p>Índice</p></th>
<th class="head"><p>Valor</p></th>
<th class="head"><p>Valor si no está presente</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">scheme</span></code></p></td>
<td><p>0</p></td>
<td><p>Especificador de esquema de URL</p></td>
<td><p>parámetro <em>scheme</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code></p></td>
<td><p>1</p></td>
<td><p>Parte de ubicación de red</p></td>
<td><p>cadena vacía</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></p></td>
<td><p>2</p></td>
<td><p>Hierarchical path</p></td>
<td><p>cadena vacía</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">query</span></code></p></td>
<td><p>3</p></td>
<td><p>Componente de consulta</p></td>
<td><p>cadena vacía</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">fragment</span></code></p></td>
<td><p>4</p></td>
<td><p>Identificador de fragmento</p></td>
<td><p>cadena vacía</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">username</span></code></p></td>
<td></td>
<td><p>Nombre de usuario</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">password</span></code></p></td>
<td></td>
<td><p>Contraseña</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">hostname</span></code></p></td>
<td></td>
<td><p>Nombre de host (minúsculas)</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">port</span></code></p></td>
<td></td>
<td><p>Número de puerto como entero, si está presente</p></td>
<td><p><a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a></p></td>
</tr>
</tbody>
</table>
<p>La lectura del atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">port</span></code> lanzará un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> si se especifica un puerto no válido en la dirección URL.  Consulte la sección <a class="reference internal" href="#urlparse-result-object"><span class="std std-ref">Resultados del análisis estructurado</span></a> para obtener más información sobre el objeto de resultado.</p>
<p>Los corchetes no coincidentes en el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code> lanzarán un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
<p>Los caracteres del atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">netloc</span></code> que se descomponen en la normalización de NFKC (según lo utilizado por la codificación IDNA) en cualquiera de <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code>, <code class="docutils literal notranslate"><span class="pre">#</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> o <code class="docutils literal notranslate"><span class="pre">:</span></code> lanzará un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>. Si la dirección URL se descompone antes del análisis, no se producirá ningún error.</p>
<p>Siguiendo la especificación <a class="reference external" href="https://url.spec.whatwg.org/#concept-basic-url-parser">WHATWG spec</a> que actualiza RFC 3986, los caracteres ASCII nueva línea <code class="docutils literal notranslate"><span class="pre">\n</span></code>, <code class="docutils literal notranslate"><span class="pre">\r</span></code> y tab <code class="docutils literal notranslate"><span class="pre">\t</span></code> se eliminan de la URL.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Los números de puerto fuera de rango ahora generan <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>, en lugar de retornar <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Los caracteres que afectan al análisis de netloc en la normalización de NFKC ahora lanzarán <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Los caracteres ASCII de nueva línea y tab se eliminan de la URL.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.urlunsplit">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">urlunsplit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urlunsplit" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Combine los elementos de una tupla retornados por <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> en una URL completa como una cadena. El argumento <em>parts</em> puede ser iterable de cinco elementos. Esto puede dar lugar a una dirección URL ligeramente diferente, pero equivalente, si la dirección URL que se analizó originalmente tenía delimitadores innecesarios (por ejemplo, un ? con una consulta vacía; la RFC indica que son equivalentes).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.urljoin">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">urljoin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">url</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_fragments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urljoin" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Construya una URL completa («absoluta») combinando una «URL base» (<em>base</em>) con otra URL (<em>url</em>).  Informalmente, esto utiliza componentes de la dirección URL base, en particular el esquema de direccionamiento, la ubicación de red y (parte de) la ruta de acceso, para proporcionar los componentes que faltan en la dirección URL relativa.  Por ejemplo:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">urljoin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urljoin</span><span class="p">(</span><span class="s1">&#39;http://www.cwi.nl/</span><span class="si">%7E</span><span class="s1">guido/Python.html&#39;</span><span class="p">,</span> <span class="s1">&#39;FAQ.html&#39;</span><span class="p">)</span>
<span class="go">&#39;http://www.cwi.nl/%7Eguido/FAQ.html&#39;</span>
</pre></div>
</div>
<p>El argumento <em>allow_fragments</em> tiene el mismo significado y el valor predeterminado que para <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si <em>url</em> es una URL absoluta (es decir, comienza con <code class="docutils literal notranslate"><span class="pre">//</span></code> o <code class="docutils literal notranslate"><span class="pre">scheme://</span></code>), el nombre de host y/o esquema de <em>url</em> estará presente en el resultado.  Por ejemplo:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">urljoin</span><span class="p">(</span><span class="s1">&#39;http://www.cwi.nl/</span><span class="si">%7E</span><span class="s1">guido/Python.html&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s1">&#39;//www.python.org/</span><span class="si">%7E</span><span class="s1">guido&#39;</span><span class="p">)</span>
<span class="go">&#39;http://www.python.org/%7Eguido&#39;</span>
</pre></div>
</div>
<p>Si no desea ese comportamiento, preprocesa las partes <em>url</em> con <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> y <a class="reference internal" href="#urllib.parse.urlunsplit" title="urllib.parse.urlunsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlunsplit()</span></code></a>, eliminando posibles partes <em>esquema</em> y <em>netloc</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Comportamiento actualizado para coincidir con la semántica definida en <span class="target" id="index-28"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3986.html"><strong>RFC 3986</strong></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.urldefrag">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">urldefrag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urldefrag" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si <em>url</em> contiene un identificador de fragmento, retorne una versión modificada de <em>url</em> sin identificador de fragmento y el identificador de fragmento como una cadena independiente.  Si no hay ningún identificador de fragmento en <em>url</em>, retorne <em>url</em> sin modificar y una cadena vacía.</p>
<p>El valor retornado es un <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a>, se puede acceder a sus elementos por índice o como atributos con nombre:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 10%" />
<col style="width: 35%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Atributo</p></th>
<th class="head"><p>Índice</p></th>
<th class="head"><p>Valor</p></th>
<th class="head"><p>Valor si no está presente</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">url</span></code></p></td>
<td><p>0</p></td>
<td><p>URL sin fragmento</p></td>
<td><p>cadena vacía</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">fragment</span></code></p></td>
<td><p>1</p></td>
<td><p>Identificador de fragmento</p></td>
<td><p>cadena vacía</p></td>
</tr>
</tbody>
</table>
<p>Consulte la sección <a class="reference internal" href="#urlparse-result-object"><span class="std std-ref">Resultados del análisis estructurado</span></a> para obtener más información sobre el objeto de resultado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>El resultado es un objeto estructurado en lugar de una simple tupla de 2.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.unwrap">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">unwrap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.unwrap" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Extrae la url de una URL envuelta (es decir, una cadena de caracteres formateada como <code class="docutils literal notranslate"><span class="pre">&lt;URL:scheme://host/path&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;scheme://host/path&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">URL:scheme://host/path</span></code> or <code class="docutils literal notranslate"><span class="pre">scheme://host/path</span></code>). Si <em>url</em> no es una URL envuelta, se retorna sin cambios.</p>
</dd></dl>

</section>
<section id="parsing-ascii-encoded-bytes">
<span id="id1"></span><h2>Análisis de bytes codificados ASCII<a class="headerlink" href="#parsing-ascii-encoded-bytes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las funciones de análisis de URL se diseñaron originalmente para funcionar solo en cadenas de caracteres. En la práctica, es útil poder manipular las direcciones URL correctamente citadas y codificadas como secuencias de bytes ASCII. En consecuencia, las funciones de análisis de URL de este módulo funcionan en los objetos <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> y <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>, además de los objetos <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p>
<p>Si se pasan datos <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, el resultado también contendrá solo los datos <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>. Si se pasan datos <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> o <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>, el resultado contendrá solo los datos <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
<p>Si intenta mezclar datos <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> con <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> o <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> en una sola llamada de función, se producirá un <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>, mientras que al intentar pasar valores de bytes no ASCII se desencadenará <a class="reference internal" href="exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code></a>.</p>
<p>Para admitir una conversión más sencilla de objetos de resultado entre <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> y <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, todos los valores retornados de las funciones de análisis de URL proporcionan un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> (cuando el resultado contiene <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> data) o un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> (cuando el resultado contiene datos <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>). Las firmas de estos métodos coinciden con las de los métodos correspondientes <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> y <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> (excepto que la codificación predeterminada es <code class="docutils literal notranslate"><span class="pre">'ascii</span></code>” en lugar de <code class="docutils literal notranslate"><span class="pre">'utf-8</span></code>”). Cada uno produce un valor de un tipo correspondiente que contiene datos <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> (para los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code>) o <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> (para <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> métodos).</p>
<p>Las aplicaciones que necesitan operar en direcciones URL potencialmente citadas incorrectamente que pueden contener datos no ASCII tendrán que realizar su propia decodificación de bytes a caracteres antes de invocar los métodos de análisis de URL.</p>
<p>El comportamiento descrito en esta sección solo se aplica a las funciones de análisis de URL. Las funciones de citación de URL utilizan sus propias reglas al producir o consumir secuencias de bytes como se detalla en la documentación de las funciones de citación de URL individuales.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Las funciones de análisis de URL ahora aceptan secuencias de bytes codificadas en ASCII</p>
</div>
</section>
<section id="structured-parse-results">
<span id="urlparse-result-object"></span><h2>Resultados del análisis estructurado<a class="headerlink" href="#structured-parse-results" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los objetos resultantes de las funciones <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a>, <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> y <a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code class="xref py py-func docutils literal notranslate"><span class="pre">urldefrag()</span></code></a> son subclases del tipo <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>. Estas subclases agregan los atributos enumerados en la documentación para esas funciones, el soporte de codificación y decodificación descrito en la sección anterior, así como un método adicional:</p>
<dl class="py method">
<dt class="sig sig-object py" id="urllib.parse.urllib.parse.SplitResult.geturl">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.SplitResult.</span></span><span class="sig-name descname"><span class="pre">geturl</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urllib.parse.SplitResult.geturl" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la versión re-combinada de la dirección URL original como una cadena. Esto puede diferir de la dirección URL original en que el esquema se puede normalizar a minúsculas y los componentes vacíos pueden descartarse. En concreto, se quitarán los parámetros vacíos, las consultas y los identificadores de fragmento.</p>
<p>Para los resultados <a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code class="xref py py-func docutils literal notranslate"><span class="pre">urldefrag()</span></code></a>, solo se eliminarán los identificadores de fragmento vacíos. Para los resultados <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> y <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a>, todos los cambios observados se realizarán en la URL retornada por este método.</p>
<p>El resultado de este método permanece inalterado si se pasa de nuevo a través de la función de análisis original:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">urlsplit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;HTTP://www.Python.org/doc/#&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span> <span class="o">=</span> <span class="n">urlsplit</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span><span class="o">.</span><span class="n">geturl</span><span class="p">()</span>
<span class="go">&#39;http://www.Python.org/doc/&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span> <span class="o">=</span> <span class="n">urlsplit</span><span class="p">(</span><span class="n">r1</span><span class="o">.</span><span class="n">geturl</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span><span class="o">.</span><span class="n">geturl</span><span class="p">()</span>
<span class="go">&#39;http://www.Python.org/doc/&#39;</span>
</pre></div>
</div>
</dd></dl>

<p>Las clases siguientes proporcionan las implementaciones de los resultados del análisis estructurado cuando se opera en objetos <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>:</p>
<dl class="py class">
<dt class="sig sig-object py" id="urllib.parse.DefragResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">DefragResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.DefragResult" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Clase concreta para los resultados de <a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code class="xref py py-func docutils literal notranslate"><span class="pre">urldefrag()</span></code></a> que contienen datos <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>. El método <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> retorna una instancia <a class="reference internal" href="#urllib.parse.DefragResultBytes" title="urllib.parse.DefragResultBytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">DefragResultBytes</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.parse.ParseResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">ParseResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scheme</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">netloc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">query</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.ParseResult" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Clase concreta para los resultados de <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a> que contiene <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> data. El método <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> retorna una instancia <a class="reference internal" href="#urllib.parse.ParseResultBytes" title="urllib.parse.ParseResultBytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParseResultBytes</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.parse.SplitResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">SplitResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scheme</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">netloc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">query</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.SplitResult" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Clase concreta para los resultados de <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> que contiene <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> data. El método <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> retorna una instancia <a class="reference internal" href="#urllib.parse.SplitResultBytes" title="urllib.parse.SplitResultBytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">SplitResultBytes</span></code></a>.</p>
</dd></dl>

<p>Las clases siguientes proporcionan las implementaciones de los resultados del análisis cuando se opera en objetos <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> o <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>:</p>
<dl class="py class">
<dt class="sig sig-object py" id="urllib.parse.DefragResultBytes">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">DefragResultBytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.DefragResultBytes" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Clase concreta para los resultados de <a class="reference internal" href="#urllib.parse.urldefrag" title="urllib.parse.urldefrag"><code class="xref py py-func docutils literal notranslate"><span class="pre">urldefrag()</span></code></a> que contienen datos <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. El método <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> retorna una instancia <a class="reference internal" href="#urllib.parse.DefragResult" title="urllib.parse.DefragResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">DefragResult</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.parse.ParseResultBytes">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">ParseResultBytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scheme</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">netloc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">query</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.ParseResultBytes" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Clase concreta para los resultados <a class="reference internal" href="#urllib.parse.urlparse" title="urllib.parse.urlparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlparse()</span></code></a> que contienen datos <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. El método <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> retorna una instancia <a class="reference internal" href="#urllib.parse.ParseResult" title="urllib.parse.ParseResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParseResult</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="urllib.parse.SplitResultBytes">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">SplitResultBytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scheme</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">netloc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">query</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fragment</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.SplitResultBytes" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Clase concreta para los resultados de <a class="reference internal" href="#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> que contienen datos <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. El método <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> retorna una instancia <a class="reference internal" href="#urllib.parse.SplitResult" title="urllib.parse.SplitResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">SplitResult</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

</section>
<section id="url-quoting">
<h2>Cita de URL<a class="headerlink" href="#url-quoting" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las funciones de citación de URL se centran en tomar datos del programa y hacerlos seguros para su uso como componentes URL citando caracteres especiales y codificando adecuadamente texto no ASCII. También admiten la inversión de estas operaciones para volver a crear los datos originales a partir del contenido de un componente de dirección URL si esa tarea aún no está cubierta por las funciones de análisis de URL anteriores.</p>
<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.quote">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">quote</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'/'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.quote" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Reemplaza caracteres especiales en <em>string</em> con la secuencia de escape <code class="docutils literal notranslate"><span class="pre">%xx</span></code>. Las letras, los dígitos y los caracteres <code class="docutils literal notranslate"><span class="pre">'_.-~'</span></code> nunca se citan. De forma predeterminada, esta función está pensada para citar la sección de ruta de acceso de la dirección URL. El parámetro opcional <em>safe</em> especifica caracteres ASCII adicionales que no se deben citar — su valor predeterminado es <code class="docutils literal notranslate"><span class="pre">'/'</span></code>.</p>
<p><em>string</em> puede ser un objeto <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> o <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Se ha movido de <span class="target" id="index-29"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2396.html"><strong>RFC 2396</strong></a> a <span class="target" id="index-30"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3986.html"><strong>RFC 3986</strong></a> para citar cadenas URL. Ahora se incluye «~» en el conjunto de caracteres reservados.</p>
</div>
<p>Los parámetros opcionales <em>encoding</em> y <em>errors</em> especifican cómo tratar con caracteres no ASCII, tal como lo acepta el método <a class="reference internal" href="stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a>. <em>encoding</em> por defecto es <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>. <em>errors</em> tiene como valor predeterminado <code class="docutils literal notranslate"><span class="pre">'strict'</span></code>, lo que significa que los caracteres no admitidos generan un <a class="reference internal" href="exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeEncodeError</span></code></a>. <em>encoding</em> y <em>errors</em> no se deben proporcionar si <em>string</em> es <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> o se genera <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<p>Tenga en cuenta que <code class="docutils literal notranslate"><span class="pre">quote(string,</span> <span class="pre">safe,</span> <span class="pre">encoding,</span> <span class="pre">errors)</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">quote_from_bytes(string.encode(encoding,</span> <span class="pre">errors),</span> <span class="pre">safe)</span></code>.</p>
<p>Ejemplo: <code class="docutils literal notranslate"><span class="pre">quote('/El</span> <span class="pre">Niño/')</span></code> produce <code class="docutils literal notranslate"><span class="pre">'/El%20Ni%C3%B1o/'</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.quote_plus">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">quote_plus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.quote_plus" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Como <a class="reference internal" href="#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a>, pero también reemplaza espacios con signos más, como se requiere para citar valores de formularios HTML al momento de construir una cadena de consulta que será parte de una URL. Los signos más en la cadena de caracteres original se escapan, a no ser que se incluyan en <em>safe</em>. Además el valor de <em>safe</em> no es <cite>/</cite> por defecto.</p>
<p>Ejemplo: <code class="docutils literal notranslate"><span class="pre">quote_plus('/El</span> <span class="pre">Niño/')</span></code> produce <code class="docutils literal notranslate"><span class="pre">'%2FEl+Ni%C3%B1o%2F'</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.quote_from_bytes">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">quote_from_bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bytes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'/'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.quote_from_bytes" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Como <a class="reference internal" href="#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a>, pero acepta un objeto <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> en lugar de un <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, y no realiza la codificación de cadena a bytes.</p>
<p>Ejemplo: <code class="docutils literal notranslate"><span class="pre">quote_from_bytes(b'a&amp;\xef')</span></code> produce <code class="docutils literal notranslate"><span class="pre">'a%26%EF'</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.unquote">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">unquote</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'utf-8'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'replace'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.unquote" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Reemplaza secuencias de escape <code class="docutils literal notranslate"><span class="pre">%xx</span></code> con los caracteres individuales correspondientes. Los parámetros opcionales <em>encoding</em> y <em>errors</em> especifican cómo descodificar secuencias codificadas porcentualmente a caracteres Unicode, tal como lo acepta el método <a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a>.</p>
<p><em>string</em> puede ser un objeto <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> o <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
<p><em>encoding</em> por defecto es <code class="docutils literal notranslate"><span class="pre">'utf-8</span></code>”. <em>errors</em> por defecto es <code class="docutils literal notranslate"><span class="pre">'replace</span></code>”, lo que significa que las secuencias no válidas se reemplazan por un carácter de marcador de posición.</p>
<p>Ejemplo: <code class="docutils literal notranslate"><span class="pre">unquote('/El%20Ni%C3%B1o/')</span></code> produce <code class="docutils literal notranslate"><span class="pre">'/El</span> <span class="pre">Niño/'</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.9: </span>El parámetro <em>string</em> admite bytes y cadenas de caracteres (anteriormente sólo cadenas de caracteres).</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.unquote_plus">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">unquote_plus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'utf-8'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'replace'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.unquote_plus" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Como <a class="reference internal" href="#urllib.parse.unquote" title="urllib.parse.unquote"><code class="xref py py-func docutils literal notranslate"><span class="pre">unquote()</span></code></a>, pero también reemplaza los signos más por espacios, como es requerido al decodificar valores de formularios HTML.</p>
<p><em>string</em> debe ser <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p>
<p>Ejemplo: <code class="docutils literal notranslate"><span class="pre">unquote_plus('/El+Ni%C3%B1o/')</span></code> produce <code class="docutils literal notranslate"><span class="pre">'/El</span> <span class="pre">Niño/'</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.unquote_to_bytes">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">unquote_to_bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.unquote_to_bytes" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Reemplaza los escapes <code class="docutils literal notranslate"><span class="pre">%xx</span></code> por sus equivalentes de un solo octeto y retorna un objeto <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
<p><em>string</em> puede ser un objeto <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> o <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
<p>Si es un <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, los caracteres no ASCII sin escapar en <em>string</em> se codifican en bytes UTF-8.</p>
<p>Ejemplo: <code class="docutils literal notranslate"><span class="pre">unquote_to_bytes('a%26%EF')</span></code> produce <code class="docutils literal notranslate"><span class="pre">b'a&amp;\xef'</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="urllib.parse.urlencode">
<span class="sig-prename descclassname"><span class="pre">urllib.parse.</span></span><span class="sig-name descname"><span class="pre">urlencode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">query</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doseq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quote_via</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">quote_plus</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.parse.urlencode" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierta un objeto de asignación o una secuencia de tuplas de dos elementos, que pueden contener objetos <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> o <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, en una cadena de texto ASCII codificada porcentualmente.  Si la cadena resultante se va a utilizar como una operación <em>data</em> para post con la función <code class="xref py py-func docutils literal notranslate"><span class="pre">URLlib.request.urlopen()</span></code>, entonces debe codificarse en bytes, de lo contrario resultaría en un <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<p>La cadena resultante es una serie de pares <code class="docutils literal notranslate"><span class="pre">key=value</span></code> separados por caracteres <code class="docutils literal notranslate"><span class="pre">'&amp;'</span></code>, donde tanto <em>key</em> como <em>value</em> se citan mediante la función <em>quote_via</em>.  De forma predeterminada, <a class="reference internal" href="#urllib.parse.quote_plus" title="urllib.parse.quote_plus"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote_plus()</span></code></a> se utiliza para citar los valores, lo que significa que los espacios se citan como un carácter <code class="docutils literal notranslate"><span class="pre">'+'</span></code> y “/” los caracteres se codifican como <code class="docutils literal notranslate"><span class="pre">%2F</span></code>, que sigue el estándar para las solicitudes GET (<code class="docutils literal notranslate"><span class="pre">application/x-www-form-urlencoded</span></code>).  Una función alternativa que se puede pasar como <em>quote_via</em> es <a class="reference internal" href="#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a>, que codificará espacios como <code class="docutils literal notranslate"><span class="pre">%20</span></code> y no codificará caracteres “/”.  Para obtener el máximo control de lo que se cita, utilice <code class="docutils literal notranslate"><span class="pre">quote</span></code> y especifique un valor para <em>safe</em>.</p>
<p>Cuando se utiliza una secuencia de tuplas de dos elementos como argumento <em>query</em>, el primer elemento de cada tupla es una clave y el segundo es un valor. El valor en sí mismo puede ser una secuencia y, en ese caso, si el parámetro opcional <em>doseq</em> se evalúa como <code class="docutils literal notranslate"><span class="pre">True</span></code>, se generan pares individuales <code class="docutils literal notranslate"><span class="pre">key=value</span></code> separados por <code class="docutils literal notranslate"><span class="pre">'&amp;'</span></code> para cada elemento de la secuencia de valores de la clave.  El orden de los parámetros de la cadena codificada coincidirá con el orden de las tuplas de parámetros de la secuencia.</p>
<p>Los parámetros <em>safe</em>, <em>encoding</em> y <em>errors</em> se pasan a <em>quote_via</em> (los parámetros <em>encoding</em> y <em>errors</em> solo se pasan cuando un elemento de consulta es <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>).</p>
<p>Para revertir este proceso de codificación, en este módulo se proporcionan <a class="reference internal" href="#urllib.parse.parse_qs" title="urllib.parse.parse_qs"><code class="xref py py-func docutils literal notranslate"><span class="pre">parse_qs()</span></code></a> y <a class="reference internal" href="#urllib.parse.parse_qsl" title="urllib.parse.parse_qsl"><code class="xref py py-func docutils literal notranslate"><span class="pre">parse_qsl()</span></code></a> para analizar cadenas de consulta en estructuras de datos de Python.</p>
<p>Consulte <a class="reference internal" href="urllib.request.html#urllib-examples"><span class="std std-ref">urllib examples</span></a> para averiguar cómo se puede utilizar el método  <a class="reference internal" href="#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> para generar una cadena de consulta para una dirección URL o datos para POST.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>El parámetro <em>query</em> admite bytes y objetos de cadena.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5: </span><em>quote_via</em>.</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><a class="reference external" href="https://url.spec.whatwg.org/">WHATWG</a> -  URL estándar actual</dt><dd><p>Grupo de trabajo para el estándar URL que define URLs, dominio, dirección IP, formato <em>application/x-www-form-urlencoded</em> y su API.</p>
</dd>
<dt><span class="target" id="index-31"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3986.html"><strong>RFC 3986</strong></a> - Identificadores uniformes de recursos</dt><dd><p>Este es el estándar actual (STD66). Cualquier cambio en el módulo urllib.parse debe ajustarse a esto. Se podrían observar ciertas desviaciones, que son principalmente para fines de compatibilidad con versiones anteriores y para ciertos requisitos de análisis de facto como se observa comúnmente en los principales navegadores.</p>
</dd>
<dt><span class="target" id="index-32"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2732.html"><strong>RFC 2732</strong></a> - Formato de direcciones IPv6 literales en URL.</dt><dd><p>Esto especifica los requisitos de análisis de las direcciones URL IPv6.</p>
</dd>
<dt><span class="target" id="index-33"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2396.html"><strong>RFC 2396</strong></a> - Identificadores uniformes de recursos (URI): Sintaxis genérica</dt><dd><p>Documento que describe los requisitos sintácticos genéricos para los nombres de recursos uniformes (URL) y los localizadores uniformes de recursos (URL).</p>
</dd>
<dt><span class="target" id="index-34"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2368.html"><strong>RFC 2368</strong></a> - El esquema mailto URL.</dt><dd><p>Análisis de requisitos para esquemas de URL de correo a correo.</p>
</dd>
<dt><span class="target" id="index-35"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1808.html"><strong>RFC 1808</strong></a> - Localizadores uniformes de recursos relativos</dt><dd><p>Esta solicitud de comentarios incluye las reglas para unirse a una URL absoluta y relativa, incluyendo un buen número de «Ejemplos anormales» que rigen el tratamiento de los casos fronterizos.</p>
</dd>
<dt><span class="target" id="index-36"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1738.html"><strong>RFC 1738</strong></a> - Localizadores uniformes de recursos (URL)</dt><dd><p>Esto especifica la sintaxis formal y la semántica de las direcciones URL absolutas.</p>
</dd>
</dl>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.parse</span></code> — Analiza URL en componentes</a><ul>
<li><a class="reference internal" href="#url-parsing">Análisis de URL</a></li>
<li><a class="reference internal" href="#parsing-ascii-encoded-bytes">Análisis de bytes codificados ASCII</a></li>
<li><a class="reference internal" href="#structured-parse-results">Resultados del análisis estructurado</a></li>
<li><a class="reference internal" href="#url-quoting">Cita de URL</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="urllib.request.html"
                          title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> — Biblioteca extensible para abrir URLs</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="urllib.error.html"
                          title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.error</span></code> — Clases de excepción lanzadas por urllib.request</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/library/urllib.parse.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="urllib.error.html" title="urllib.error — Clases de excepción lanzadas por urllib.request"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="urllib.request.html" title="urllib.request — Biblioteca extensible para abrir URLs"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" >Protocolos y soporte de Internet</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.parse</span></code> — Analiza URL en componentes</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 23, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>