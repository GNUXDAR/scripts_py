
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Novedades de Python 2.5 &#8212; documentación de Python - 3.10.10</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.10.10"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="Novedades en Python 2.4" href="2.4.html" />
    <link rel="prev" title="Qué hay de nuevo en Python 2.6" href="2.6.html" />
    <link rel="canonical" href="https://docs.python.org/3/whatsnew/2.5.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#">Novedades de Python 2.5</a><ul>
<li><a class="reference internal" href="#pep-308-conditional-expressions">PEP 308: Expresiones condicionales</a></li>
<li><a class="reference internal" href="#pep-309-partial-function-application">PEP 309: Aplicación parcial de funciones</a></li>
<li><a class="reference internal" href="#pep-314-metadata-for-python-software-packages-v1-1">PEP 314: Metadatos para paquetes de software Python v1.1</a></li>
<li><a class="reference internal" href="#pep-328-absolute-and-relative-imports">PEP 328: Importaciones absolutas y relativas</a></li>
<li><a class="reference internal" href="#pep-338-executing-modules-as-scripts">PEP 338: Ejecutando Módulos como Scripts</a></li>
<li><a class="reference internal" href="#pep-341-unified-try-except-finally">PEP 341: Try/except/finally unificados</a></li>
<li><a class="reference internal" href="#pep-342-new-generator-features">PEP 342: Nuevas funciones del generador</a></li>
<li><a class="reference internal" href="#pep-343-the-with-statement">PEP 343: La declaración «con</a><ul>
<li><a class="reference internal" href="#writing-context-managers">Redacción de Gestores de Contexto</a></li>
<li><a class="reference internal" href="#the-contextlib-module">El módulo contextlib</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-352-exceptions-as-new-style-classes">PEP 352: Las excepciones como clases de nuevo estilo</a></li>
<li><a class="reference internal" href="#pep-353-using-ssize-t-as-the-index-type">PEP 353: Uso de ssize_t como tipo de índice</a></li>
<li><a class="reference internal" href="#pep-357-the-index-method">PEP 357: El método “__index__”</a></li>
<li><a class="reference internal" href="#other-language-changes">Otros cambios lingüísticos</a><ul>
<li><a class="reference internal" href="#interactive-interpreter-changes">Cambios en el intérprete interactivo</a></li>
<li><a class="reference internal" href="#optimizations">Optimizaciones</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-improved-and-removed-modules">Módulos nuevos, mejorados y eliminados</a><ul>
<li><a class="reference internal" href="#the-ctypes-package">El paquete ctypes</a></li>
<li><a class="reference internal" href="#the-elementtree-package">El paquete ElementTree</a></li>
<li><a class="reference internal" href="#the-hashlib-package">El paquete hashlib</a></li>
<li><a class="reference internal" href="#the-sqlite3-package">El paquete sqlite3</a></li>
<li><a class="reference internal" href="#the-wsgiref-package">El paquete wsgiref</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-and-c-api-changes">Cambios en la API de construcción y C</a><ul>
<li><a class="reference internal" href="#port-specific-changes">Cambios específicos en los puertos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#porting-to-python-2-5">Adaptación a Python 2.5</a></li>
<li><a class="reference internal" href="#acknowledgements">Agradecimientos</a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="2.6.html"
                        title="capítulo anterior">Qué hay de nuevo en Python 2.6</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="2.4.html"
                        title="próximo capítulo">Novedades en Python 2.4</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/whatsnew/2.5.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="2.4.html" title="Novedades en Python 2.4"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="2.6.html" title="Qué hay de nuevo en Python 2.6"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Qué hay de nuevo en Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Novedades de Python 2.5</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-2-5">
<h1>Novedades de Python 2.5<a class="headerlink" href="#what-s-new-in-python-2-5" title="Enlazar permanentemente con este título">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Autor</dt>
<dd class="field-odd"><p>A.M. Kuchling</p>
</dd>
</dl>
<p>This article explains the new features in Python 2.5.  The final release of
Python 2.5 is scheduled for August 2006; <span class="target" id="index-0"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0356"><strong>PEP 356</strong></a> describes the planned
release schedule.  Python 2.5 was released on September 19, 2006.</p>
<p>The changes in Python 2.5 are an interesting mix of language and library
improvements. The library enhancements will be more important to Python’s user
community, I think, because several widely useful packages were added.  New
modules include ElementTree for XML processing (<code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree</span></code>),
the SQLite database module (<code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite</span></code>), and the <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>
module for calling C functions.</p>
<p>Los cambios en el lenguaje son de mediana importancia.  Se han añadido algunas características nuevas y agradables, pero la mayoría de ellas no son características que vaya a utilizar todos los días. Las expresiones condicionales fueron finalmente añadidas al lenguaje usando una nueva sintaxis; ver sección <a class="reference internal" href="#pep-308"><span class="std std-ref">PEP 308: Expresiones condicionales</span></a>.  La nueva sentencia “<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>” facilitará la escritura de código de limpieza (sección <a class="reference internal" href="#pep-343"><span class="std std-ref">PEP 343: La declaración «con</span></a>).  Ahora se pueden pasar valores a los generadores (sección <a class="reference internal" href="#pep-342"><span class="std std-ref">PEP 342: Nuevas funciones del generador</span></a>).  Las importaciones son ahora visibles como absolutas o relativas (sección <a class="reference internal" href="#pep-328"><span class="std std-ref">PEP 328: Importaciones absolutas y relativas</span></a>).  Se han mejorado algunos casos de manejo de excepciones (sección <a class="reference internal" href="#pep-341"><span class="std std-ref">PEP 341: Try/except/finally unificados</span></a>).  Todas estas mejoras merecen la pena, pero son mejoras de una u otra característica específica del lenguaje; ninguna de ellas es una modificación amplia de la semántica de Python.</p>
<p>Además de las adiciones al lenguaje y a la biblioteca, se han realizado otras mejoras y correcciones de errores en todo el árbol de código fuente.  Una búsqueda en los registros de cambios del SVN revela que se aplicaron 353 parches y se corrigieron 458 errores entre Python 2.4 y 2.5.  (Es probable que ambas cifras estén subestimadas)</p>
<p>Este artículo no pretende ser una especificación completa de las nuevas características; en su lugar, los cambios se introducen brevemente utilizando ejemplos útiles.  Para obtener todos los detalles, siempre debes consultar la documentación de Python 2.5 en <a class="reference external" href="https://docs.python.org">https://docs.python.org</a>. Si quieres entender la implementación completa y los fundamentos del diseño, consulta el PEP de una nueva característica en particular.</p>
<p>Son bienvenidos los comentarios, las sugerencias y los informes de errores para este documento; por favor, envíelos por correo electrónico al autor o abra un error en el rastreador de errores de Python.</p>
<section id="pep-308-conditional-expressions">
<span id="pep-308"></span><h2>PEP 308: Expresiones condicionales<a class="headerlink" href="#pep-308-conditional-expressions" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Durante mucho tiempo, la gente ha solicitado una forma de escribir expresiones condicionales, que son expresiones que devuelven el valor A o el valor B dependiendo de si un valor booleano es verdadero o falso.  Una expresión condicional le permite escribir una única sentencia de asignación que tiene el mismo efecto que la siguiente:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">condition</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">true_value</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">false_value</span>
</pre></div>
</div>
<p>Ha habido interminables y tediosas discusiones sobre la sintaxis tanto en python-dev como en comp.lang.python.  Incluso se llevó a cabo una votación en la que se descubrió que la mayoría de los votantes querían expresiones condicionales de alguna forma, pero no había ninguna sintaxis que fuera preferida por una clara mayoría. Los candidatos incluían <code class="docutils literal notranslate"><span class="pre">cond</span> <span class="pre">?</span> <span class="pre">true_v</span> <span class="pre">:</span> <span class="pre">false_v</span></code>, <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">cond</span> <span class="pre">then</span> <span class="pre">true_v</span> <span class="pre">else</span> <span class="pre">false_v</span></code>, y otras 16 variaciones.</p>
<p>Guido van Rossum eligió finalmente una sintaxis sorprendente:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">true_value</span> <span class="k">if</span> <span class="n">condition</span> <span class="k">else</span> <span class="n">false_value</span>
</pre></div>
</div>
<p>La evaluación sigue siendo perezosa como en las expresiones booleanas existentes, por lo que el orden de evaluación salta un poco.  La expresión <em>condición</em> del medio se evalúa primero, y la expresión <em>valor_verdadero</em> se evalúa sólo si la condición es verdadera.  Del mismo modo, la expresión <em>valor_falso</em> sólo se evalúa cuando la condición es falsa.</p>
<p>Esta sintaxis puede parecer extraña y retrógrada; ¿por qué la condición va en el <em>medio</em> de la expresión, y no en la parte delantera como en <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">?</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">y</span></code> de C?  La decisión se comprobó aplicando la nueva sintaxis a los módulos de la biblioteca estándar y viendo cómo se leía el código resultante.  En muchos casos en los que se utiliza una expresión condicional, un valor parece ser el «caso común» y otro valor es un «caso excepcional», utilizado sólo en las raras ocasiones en las que no se cumple la condición.  La sintaxis condicional hace que este patrón sea un poco más obvio:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">contents</span> <span class="o">=</span> <span class="p">((</span><span class="n">doc</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">doc</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Leo la afirmación anterior en el sentido de que «aquí se asigna a <em>contents</em> un valor de <code class="docutils literal notranslate"><span class="pre">doc+'\n'</span></code>; a veces <em>doc</em> está vacío, en cuyo caso especial se devuelve una cadena vacía»   Dudo que use expresiones condicionales muy a menudo donde no hay un caso común y no común claro.</p>
<p>Hubo alguna discusión sobre si el lenguaje debería requerir rodear las expresiones condicionales con paréntesis.  Se tomó la decisión de <em>no</em> requerir paréntesis en la gramática del lenguaje Python, pero como una cuestión de estilo creo que siempre deberías usarlos. Considere estas dos declaraciones:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># First version -- no parens</span>
<span class="n">level</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">logging</span> <span class="k">else</span> <span class="mi">0</span>

<span class="c1"># Second version -- with parens</span>
<span class="n">level</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">logging</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>En la primera versión, creo que el ojo de un lector podría agrupar la sentencia en “nivel = 1”, “si registro”, “si no 0”, y pensar que la condición decide si se realiza la asignación a <em>nivel</em>.  La segunda versión se lee mejor, en mi opinión, porque deja claro que la asignación se realiza siempre y que se está eligiendo entre dos valores.</p>
<p>Otra razón para incluir los paréntesis: algunas combinaciones extrañas de comprensiones de listas y lambdas podrían parecer expresiones condicionales incorrectas. Véase <span class="target" id="index-61"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0308"><strong>PEP 308</strong></a> para algunos ejemplos.  Si pone paréntesis alrededor de sus expresiones condicionales, no se encontrará con este caso.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-62"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0308"><strong>PEP 308</strong></a> - Expresiones condicionales</dt><dd><p>PEP escrito por Guido van Rossum y Raymond D. Hettinger; implementado por Thomas Wouters.</p>
</dd>
</dl>
</div>
</section>
<section id="pep-309-partial-function-application">
<span id="pep-309"></span><h2>PEP 309: Aplicación parcial de funciones<a class="headerlink" href="#pep-309-partial-function-application" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El módulo <a class="reference internal" href="../library/functools.html#module-functools" title="functools: Higher-order functions and operations on callable objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">functools</span></code></a> está destinado a contener herramientas para la programación de estilo funcional.</p>
<p>Una herramienta útil de este módulo es la función <code class="xref py py-func docutils literal notranslate"><span class="pre">partial()</span></code>. Para los programas escritos en un estilo funcional, a veces querrá construir variantes de funciones existentes que tengan algunos de los parámetros rellenados.  Considere una función Python <code class="docutils literal notranslate"><span class="pre">f(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code>; podría crear una nueva función <code class="docutils literal notranslate"><span class="pre">g(b,</span> <span class="pre">c)</span></code> que fuera equivalente a <code class="docutils literal notranslate"><span class="pre">f(1,</span> <span class="pre">b,</span> <span class="pre">c)</span></code>.  Esto se llama «aplicación parcial de funciones».</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">parcial()</span></code> toma los argumentos <code class="docutils literal notranslate"><span class="pre">(function,</span> <span class="pre">arg1,</span> <span class="pre">arg2,</span> <span class="pre">...</span> <span class="pre">kwarg1=valor1,</span> <span class="pre">kwarg2=valor2)</span></code>.  El objeto resultante es invocable, por lo que puedes llamarlo para invocar la <em>función</em> con los argumentos rellenados.</p>
<p>He aquí un pequeño pero realista ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">functools</span>

<span class="k">def</span> <span class="nf">log</span> <span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">subsystem</span><span class="p">):</span>
    <span class="s2">&quot;Write the contents of &#39;message&#39; to the specified subsystem.&quot;</span>
    <span class="nb">print</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">subsystem</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
    <span class="o">...</span>

<span class="n">server_log</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">subsystem</span><span class="o">=</span><span class="s1">&#39;server&#39;</span><span class="p">)</span>
<span class="n">server_log</span><span class="p">(</span><span class="s1">&#39;Unable to open socket&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Aquí hay otro ejemplo, de un programa que utiliza PyGTK.  Aquí se está construyendo dinámicamente un menú emergente sensible al contexto.  El callback proporcionado para la opción de menú es una versión parcialmente aplicada del método <code class="xref py py-meth docutils literal notranslate"><span class="pre">open_item()</span></code>, donde se ha proporcionado el primer argumento</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="k">class</span> <span class="nc">Application</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">open_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
       <span class="o">...</span>
    <span class="k">def</span> <span class="nf">init</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">open_func</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">open_item</span><span class="p">,</span> <span class="n">item_path</span><span class="p">)</span>
        <span class="n">popup_menu</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="s2">&quot;Open&quot;</span><span class="p">,</span> <span class="n">open_func</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Otra función del módulo <a class="reference internal" href="../library/functools.html#module-functools" title="functools: Higher-order functions and operations on callable objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">functools</span></code></a> es la función <code class="docutils literal notranslate"><span class="pre">update_wrapper(wrapper,</span> <span class="pre">wrapped)</span></code> que le ayuda a escribir decoradores con un buen comportamiento. <code class="xref py py-func docutils literal notranslate"><span class="pre">update_wrapper()</span></code> copia el nombre, el módulo y el atributo docstring a una función wrapper para que las trazas dentro de la función envuelta sean más fáciles de entender.  Por ejemplo, puedes escribir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s1">&#39;Calling decorated function&#39;</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
    <span class="n">functools</span><span class="o">.</span><span class="n">update_wrapper</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">wraps()</span></code> es un decorador que se puede utilizar dentro de sus propios decoradores para copiar la información de la función envuelta.  Una versión alternativa del ejemplo anterior sería:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s1">&#39;Calling decorated function&#39;</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-63"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0309"><strong>PEP 309</strong></a> - Aplicación parcial de funciones</dt><dd><p>PEP propuesto y escrito por Peter Harris; implementado por Hye-Shik Chang y Nick Coghlan, con adaptaciones de Raymond Hettinger.</p>
</dd>
</dl>
</div>
</section>
<section id="pep-314-metadata-for-python-software-packages-v1-1">
<span id="pep-314"></span><h2>PEP 314: Metadatos para paquetes de software Python v1.1<a class="headerlink" href="#pep-314-metadata-for-python-software-packages-v1-1" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Se ha añadido a Distutils un sencillo soporte de dependencias.  La función <code class="xref py py-func docutils literal notranslate"><span class="pre">setup()</span></code> ahora tiene parámetros de palabras clave <code class="docutils literal notranslate"><span class="pre">requires</span></code>, <code class="docutils literal notranslate"><span class="pre">provides</span></code> y <code class="docutils literal notranslate"><span class="pre">obsoletes</span></code>.  Cuando se construye una distribución de origen utilizando el comando <code class="docutils literal notranslate"><span class="pre">sdist</span></code>, la información de las dependencias se registrará en el archivo <code class="file docutils literal notranslate"><span class="pre">PKG-INFO</span></code>.</p>
<p>Otro nuevo parámetro de palabra clave es <code class="docutils literal notranslate"><span class="pre">download_url</span></code>, que debe establecerse como una URL para el código fuente del paquete.  Esto significa que ahora es posible buscar una entrada en el índice de paquetes, determinar las dependencias de un paquete y descargar los paquetes necesarios.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">VERSION</span> <span class="o">=</span> <span class="s1">&#39;1.0&#39;</span>
<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;PyPackage&#39;</span><span class="p">,</span>
      <span class="n">version</span><span class="o">=</span><span class="n">VERSION</span><span class="p">,</span>
      <span class="n">requires</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;numarray&#39;</span><span class="p">,</span> <span class="s1">&#39;zlib (&gt;=1.1.4)&#39;</span><span class="p">],</span>
      <span class="n">obsoletes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;OldPackage&#39;</span><span class="p">]</span>
      <span class="n">download_url</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/pypackage/dist/pkg-</span><span class="si">%s</span><span class="s1">.tar.gz&#39;</span>
                    <span class="o">%</span> <span class="n">VERSION</span><span class="p">),</span>
     <span class="p">)</span>
</pre></div>
</div>
<p>Otra nueva mejora en el índice de paquetes de Python en <a class="reference external" href="https://pypi.org">https://pypi.org</a> es el almacenamiento de archivos fuente y binarios de un paquete.  El nuevo comando <strong class="command">upload</strong> de Distutils subirá un paquete al repositorio.</p>
<p>Antes de poder subir un paquete, debes ser capaz de construir una distribución usando el comando <strong class="command">sdist</strong> de Distutils.  Una vez que funcione, puedes ejecutar <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">upload</span></code> para añadir tu paquete al archivo PyPI.  Opcionalmente puedes firmar el paquete con GPG suministrando las opciones <code class="xref std std-option docutils literal notranslate"><span class="pre">--sign</span></code> y <code class="xref std std-option docutils literal notranslate"><span class="pre">--identity</span></code>.</p>
<p>La carga de paquetes fue implementada por Martin von Löwis y Richard Jones.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-64"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0314"><strong>PEP 314</strong></a> - Metadatos para paquetes de software Python v1.1</dt><dd><p>PEP propuesto y redactado por A.M. Kuchling, Richard Jones y Fred Drake; aplicado por Richard Jones y Fred Drake.</p>
</dd>
</dl>
</div>
</section>
<section id="pep-328-absolute-and-relative-imports">
<span id="pep-328"></span><h2>PEP 328: Importaciones absolutas y relativas<a class="headerlink" href="#pep-328-absolute-and-relative-imports" title="Enlazar permanentemente con este título">¶</a></h2>
<p>La parte más sencilla de <span class="target" id="index-65"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a> se implementó en Python 2.4: los paréntesis podían utilizarse ahora para encerrar los nombres importados de un módulo utilizando la sentencia <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span> <span class="pre">...</span></code>, facilitando la importación de muchos nombres diferentes.</p>
<p>La parte más complicada se ha implementado en Python 2.5: la importación de un módulo puede especificarse para utilizar importaciones absolutas o relativas al paquete.  El plan es hacer que las importaciones absolutas sean el valor por defecto en futuras versiones de Python.</p>
<p>Digamos que tienes un directorio de paquetes como este:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">pkg</span><span class="o">/</span>
<span class="n">pkg</span><span class="o">/</span><span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
<span class="n">pkg</span><span class="o">/</span><span class="n">main</span><span class="o">.</span><span class="n">py</span>
<span class="n">pkg</span><span class="o">/</span><span class="n">string</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>Esto define un paquete llamado <code class="xref py py-mod docutils literal notranslate"><span class="pre">pkg</span></code> que contiene los submódulos <code class="xref py py-mod docutils literal notranslate"><span class="pre">pkg.main</span></code> y <code class="xref py py-mod docutils literal notranslate"><span class="pre">pkg.string</span></code>.</p>
<p>Considera el código del módulo <code class="file docutils literal notranslate"><span class="pre">main.py</span></code>.  ¿Qué ocurre si ejecuta la sentencia <code class="docutils literal notranslate"><span class="pre">importar</span> <span class="pre">cadena</span></code>?  En Python 2.4 y anteriores, primero buscará en el directorio del paquete para realizar una importación relativa, encuentra <code class="file docutils literal notranslate"><span class="pre">pkg/string.py</span></code>, importa el contenido de ese archivo como el módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">pkg.string</span></code>, y ese módulo se vincula al nombre <code class="docutils literal notranslate"><span class="pre">string</span></code> en el espacio de nombres del módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">pkg.main</span></code>.</p>
<p>Eso está bien si <code class="xref py py-mod docutils literal notranslate"><span class="pre">pkg.string</span></code> era lo que querías.  ¿Pero qué pasa si quieres el módulo estándar de Python <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a>?  No hay una forma limpia de ignorar <code class="xref py py-mod docutils literal notranslate"><span class="pre">pkg.string</span></code> y buscar el módulo estándar; generalmente tienes que mirar el contenido de <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>, lo cual es ligeramente sucio.    El paquete <code class="xref py py-mod docutils literal notranslate"><span class="pre">py.std</span></code> de Holger Krekel proporciona una forma más ordenada de realizar importaciones desde la biblioteca estándar, <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">py;</span> <span class="pre">py.std.string.join()</span></code>, pero ese paquete no está disponible en todas las instalaciones de Python.</p>
<p>La lectura de código que depende de importaciones relativas también es menos clara, porque un lector puede confundirse sobre qué módulo, <code class="xref py py-mod docutils literal notranslate"><span class="pre">cadena</span></code> o <code class="xref py py-mod docutils literal notranslate"><span class="pre">cadena.pkg</span></code>, se pretende utilizar.  Los usuarios de Python aprendieron pronto a no duplicar los nombres de los módulos de la biblioteca estándar en los nombres de los submódulos de sus paquetes, pero no puedes protegerte de que el nombre de tu submódulo se utilice para un nuevo módulo añadido en una futura versión de Python.</p>
<p>En Python 2.5, puedes cambiar el comportamiento de <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> a importaciones absolutas usando una directiva <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">absolute_import</span></code>.  Este comportamiento de importación absoluta será el predeterminado en una versión futura (probablemente Python 2.7).  Una vez que las importaciones absolutas sean el valor por defecto, <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">string</span></code> siempre encontrará la versión de la biblioteca estándar. Se sugiere que los usuarios comiencen a usar importaciones absolutas tanto como sea posible, así que es preferible comenzar a escribir <code class="docutils literal notranslate"><span class="pre">de</span> <span class="pre">pkg</span> <span class="pre">import</span> <span class="pre">string</span></code> en su código.</p>
<p>Las importaciones relativas siguen siendo posibles añadiendo un punto inicial al nombre del módulo cuando se utiliza la forma <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import names from pkg.string</span>
<span class="kn">from</span> <span class="nn">.string</span> <span class="kn">import</span> <span class="n">name1</span><span class="p">,</span> <span class="n">name2</span>
<span class="c1"># Import pkg.string</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">string</span>
</pre></div>
</div>
<p>Esto importa el módulo <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a> relativo al paquete actual, así que en <code class="xref py py-mod docutils literal notranslate"><span class="pre">pkg.main</span></code> esto importará <em>nombre1</em> y <em>nombre2</em> de <code class="xref py py-mod docutils literal notranslate"><span class="pre">pkg.string</span></code>. Los puntos iniciales adicionales realizan la importación relativa empezando por el padre del paquete actual.  Por ejemplo, el código en el módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">A.B.C</span></code> puede hacer:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">D</span>                 <span class="c1"># Imports A.B.D</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">E</span>                <span class="c1"># Imports A.E</span>
<span class="kn">from</span> <span class="nn">..F</span> <span class="kn">import</span> <span class="n">G</span>               <span class="c1"># Imports A.F.G</span>
</pre></div>
</div>
<p>Los puntos suspensivos no pueden usarse con la forma <code class="docutils literal notranslate"><span class="pre">importar</span> <span class="pre">nombre</span> <span class="pre">de</span> <span class="pre">modelo</span></code> de la sentencia import, sólo con la forma <code class="docutils literal notranslate"><span class="pre">de</span> <span class="pre">...</span> <span class="pre">import</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-66"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a> - Importaciones: Multilínea y Absoluto/Relativo</dt><dd><p>PEP escrito por Aahz; implementado por Thomas Wouters.</p>
</dd>
<dt><a class="reference external" href="https://pylib.readthedocs.io/">https://pylib.readthedocs.io/</a></dt><dd><p>La biblioteca py de Holger Krekel, que contiene el paquete <code class="xref py py-mod docutils literal notranslate"><span class="pre">py.std</span></code>.</p>
</dd>
</dl>
</div>
</section>
<section id="pep-338-executing-modules-as-scripts">
<span id="pep-338"></span><h2>PEP 338: Ejecutando Módulos como Scripts<a class="headerlink" href="#pep-338-executing-modules-as-scripts" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El conmutador <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a> añadido en Python 2.4 para ejecutar un módulo como un script ganó algunas habilidades más.  En lugar de estar implementado en código C dentro del intérprete de Python, el interruptor ahora utiliza una implementación en un nuevo módulo, <a class="reference internal" href="../library/runpy.html#module-runpy" title="runpy: Locate and run Python modules without importing them first."><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code></a>.</p>
<p>El módulo <a class="reference internal" href="../library/runpy.html#module-runpy" title="runpy: Locate and run Python modules without importing them first."><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code></a> implementa un mecanismo de importación más sofisticado de forma que ahora es posible ejecutar módulos en un paquete como <code class="xref py py-mod docutils literal notranslate"><span class="pre">pychecker.checker</span></code>. El módulo también soporta mecanismos de importación alternativos como el módulo <a class="reference internal" href="../library/zipimport.html#module-zipimport" title="zipimport: Support for importing Python modules from ZIP archives."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipimport</span></code></a>.  Esto significa que puede añadir la ruta de un archivo .zip a <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> y luego utilizar el modificador <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a> para ejecutar el código del archivo.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-67"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0338"><strong>PEP 338</strong></a> - Ejecución de módulos como scripts</dt><dd><p>PEP escrito e implementado por Nick Coghlan.</p>
</dd>
</dl>
</div>
</section>
<section id="pep-341-unified-try-except-finally">
<span id="pep-341"></span><h2>PEP 341: Try/except/finally unificados<a class="headerlink" href="#pep-341-unified-try-except-finally" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Hasta la versión 2.5 de Python, la sentencia <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> tenía dos variantes. Podías usar un bloque <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> para asegurarte de que el código se ejecutaba siempre, o uno o más bloques <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> para capturar excepciones específicas.  No podías combinar ambos bloques <code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code> y un bloque <code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code>, porque generar el bytecode correcto para la versión combinada era complicado y no estaba claro cuál debía ser la semántica de la sentencia combinada.</p>
<p>Guido van Rossum pasó algún tiempo trabajando con Java, que sí soporta el equivalente de combinar bloques <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> y un bloque <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a>, y esto aclaró lo que debería significar la declaración.  En Python 2.5, ahora se puede escribir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">block</span><span class="o">-</span><span class="mi">1</span> <span class="o">...</span>
<span class="k">except</span> <span class="n">Exception1</span><span class="p">:</span>
    <span class="n">handler</span><span class="o">-</span><span class="mi">1</span> <span class="o">...</span>
<span class="k">except</span> <span class="n">Exception2</span><span class="p">:</span>
    <span class="n">handler</span><span class="o">-</span><span class="mi">2</span> <span class="o">...</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">else</span><span class="o">-</span><span class="n">block</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">final</span><span class="o">-</span><span class="n">block</span>
</pre></div>
</div>
<p>Se ejecuta el código del <em>bloque-1</em>.  Si el código lanza una excepción, se comprueban los distintos bloques <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a>: si la excepción es de clase <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception1</span></code>, se ejecuta <em>handler-1</em>; en caso contrario, si es de clase <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception2</span></code>, se ejecuta <em>handler-2</em>, y así sucesivamente.  Si no se produce ninguna excepción, se ejecuta el bloque <em>else</em>.</p>
<p>No importa lo que haya sucedido previamente, el <em>bloque final</em> se ejecuta una vez que el bloque de código se ha completado y se han manejado las excepciones planteadas. Incluso si hay un error en un manejador de excepciones o en el <em>bloque else</em> y se lanza una nueva excepción, el código del <em>bloque final</em> se sigue ejecutando.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-68"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0341"><strong>PEP 341</strong></a> - Unificar try-except y try-finally</dt><dd><p>PEP escrito por Georg Brandl; implementación por Thomas Lee.</p>
</dd>
</dl>
</div>
</section>
<section id="pep-342-new-generator-features">
<span id="pep-342"></span><h2>PEP 342: Nuevas funciones del generador<a class="headerlink" href="#pep-342-new-generator-features" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Python 2.5 añade una forma sencilla de pasar valores <em>a</em> un generador. Tal y como se introdujo en Python 2.3, los generadores sólo producen salida; una vez que se invoca el código de un generador para crear un iterador, no hay forma de pasar ninguna información nueva a la función cuando se reanuda su ejecución.  A veces, la capacidad de pasar alguna información sería útil.  Las soluciones más ingeniosas para esto incluyen hacer que el código del generador mire a una variable global y luego cambie el valor de la variable global, o pasar algún objeto mutable que los llamadores luego modifiquen.</p>
<p>Para refrescar la memoria de los generadores básicos, he aquí un ejemplo sencillo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">counter</span> <span class="p">(</span><span class="n">maximum</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maximum</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">i</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Cuando se llama a <code class="docutils literal notranslate"><span class="pre">contador(10)</span></code>, el resultado es un iterador que devuelve los valores de 0 a 9.  Al encontrar la sentencia <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>, el iterador devuelve el valor proporcionado y suspende la ejecución de la función, preservando las variables locales. La ejecución se reanuda en la siguiente llamada al método <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a> del iterador, retomando después de la sentencia <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code>.</p>
<p>En Python 2.3, <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> era una declaración; no devolvía ningún valor.  En 2.5, <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> es ahora una expresión, que devuelve un valor que se puede asignar a una variable o que se puede operar de otra manera:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>Te recomiendo que siempre pongas paréntesis alrededor de una expresión <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> cuando estés haciendo algo con el valor devuelto, como en el ejemplo anterior. Los paréntesis no siempre son necesarios, pero es más fácil añadirlos siempre en lugar de tener que recordar cuándo son necesarios.</p>
<p>(<span class="target" id="index-69"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0342"><strong>PEP 342</strong></a> explica las reglas exactas, que consisten en que una expresión <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>debe ir siempre entre paréntesis, excepto cuando ocurre en la expresión de nivel superior en el lado derecho de una asignación.  Esto significa que puedes escribir <code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">=</span> <span class="pre">yield</span> <span class="pre">i</span></code> pero tienes que usar paréntesis cuando hay una operación, como en <code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">=</span> <span class="pre">(yield</span> <span class="pre">i)</span> <span class="pre">+</span> <span class="pre">12</span></code>)</p>
<p>Los valores se envían a un generador llamando a su método <code class="docutils literal notranslate"><span class="pre">send(value)</span></code>.  El código del generador se reanuda y la expresión <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> devuelve el <em>valor</em> especificado.  Si se llama al método regular <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a>, la expresión <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> devuelve <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>.</p>
<p>Aquí está el ejemplo anterior, modificado para permitir cambiar el valor del contador interno.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">counter</span> <span class="p">(</span><span class="n">maximum</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maximum</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">i</span><span class="p">)</span>
        <span class="c1"># If value provided, change counter</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Y aquí hay un ejemplo de cambio de contador:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">it</span> <span class="o">=</span> <span class="n">counter</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">it</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;t.py&quot;</span>, line <span class="m">15</span>, in <span class="n">?</span>
    <span class="nb">print</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<p><a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> normalmente devolverá <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>, por lo que siempre debes comprobar este caso.  No utilices su valor en las expresiones sin más, a menos que estés seguro de que el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code> será el único utilizado para reanudar tu función generadora.</p>
<p>Además de <code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code>, hay otros dos nuevos métodos en los generadores:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">throw(type,</span> <span class="pre">value=None,</span> <span class="pre">traceback=None)</span></code> se utiliza para lanzar una excepción dentro del generador; la excepción es lanzada por la expresión <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> donde la ejecución del generador se pausa.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code> lanza una nueva excepción <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> dentro del generador para terminar la iteración.  Al recibir esta excepción, el código del generador debe lanzar <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> o <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>.  Capturar la excepción <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> y devolver un valor es ilegal y provocará un <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>; si la función lanza alguna otra excepción, esa excepción se propaga a quien la llama. <code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code> también será llamado por el recolector de basura de Python cuando el generador sea recolectado.</p>
<p>Si necesitas ejecutar código de limpieza cuando se produce un <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a>, te sugiero que utilices un conjunto <code class="docutils literal notranslate"><span class="pre">try:</span> <span class="pre">...</span> <span class="pre">finally:</span></code> en lugar de atrapar <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a>.</p>
</li>
</ul>
<p>El efecto acumulativo de estos cambios es que los generadores pasan de ser productores unidireccionales de información a ser tanto productores como consumidores.</p>
<p>Los generadores también se convierten en <em>corutinas</em>, una forma más generalizada de subrutinas. Las subrutinas se introducen en un punto y se salen en otro (la parte superior de la función, y una declaración <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a>), pero las coroutines pueden introducirse, salirse y reanudarse en muchos puntos diferentes (las declaraciones <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>). Tendremos que descubrir patrones para usar coroutines de forma efectiva en Python.</p>
<p>La adición del método <code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code> tiene un efecto secundario que no es obvio. <code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code> es llamado cuando un generador es recogido por la basura, lo que significa que el código del generador tiene una última oportunidad de ejecutarse antes de que el generador sea destruido. Esta última oportunidad significa que ahora se puede garantizar que las sentencias <code class="docutils literal notranslate"><span class="pre">intentar...finalmente</span></code> en los generadores funcionen; la cláusula <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> ahora siempre tendrá una oportunidad de ejecutarse.  Por lo tanto, se ha eliminado la restricción sintáctica que impedía mezclar sentencias <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> con un conjunto <code class="docutils literal notranslate"><span class="pre">try...finally</span></code>.  Esto parece una trivialidad menor del lenguaje, pero el uso de generadores y <code class="docutils literal notranslate"><span class="pre">try...finally</span></code> es realmente necesario para implementar la sentencia <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> descrita por <span class="target" id="index-70"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0343"><strong>PEP 343</strong></a>.  Veré esta nueva sentencia en la siguiente sección.</p>
<p>Otro efecto aún más esotérico de este cambio: antes, el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">gi_frame</span></code> de un generador era siempre un objeto frame. Ahora es posible que <code class="xref py py-attr docutils literal notranslate"><span class="pre">gi_frame</span></code> sea <code class="docutils literal notranslate"><span class="pre">None</span></code> una vez que el generador se ha agotado.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl>
<dt><span class="target" id="index-71"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0342"><strong>PEP 342</strong></a> - Coroutines mediante generadores mejorados</dt><dd><p>PEP escrito por Guido van Rossum y Phillip J. Eby; implementado por Phillip J. Eby.  Incluye ejemplos de algunos usos más sofisticados de los generadores como coroutines.</p>
<p>Versiones anteriores de estas características fueron propuestas en <span class="target" id="index-72"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0288"><strong>PEP 288</strong></a> por Raymond Hettinger y <span class="target" id="index-73"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0325"><strong>PEP 325</strong></a> por Samuele Pedroni.</p>
</dd>
<dt><a class="reference external" href="https://en.wikipedia.org/wiki/Coroutine">https://en.wikipedia.org/wiki/Coroutine</a></dt><dd><p>La entrada de Wikipedia para las coroutines.</p>
</dd>
<dt><a class="reference external" href="https://web.archive.org/web/20160321211320/http://www.sidhe.org/~dan/blog/archives/000178.html">https://web.archive.org/web/20160321211320/http://www.sidhe.org/~dan/blog/archives/000178.html</a></dt><dd><p>Una explicación de las coroutines desde el punto de vista de Perl, escrita por Dan Sugalski.</p>
</dd>
</dl>
</div>
</section>
<section id="pep-343-the-with-statement">
<span id="pep-343"></span><h2>PEP 343: La declaración «con<a class="headerlink" href="#pep-343-the-with-statement" title="Enlazar permanentemente con este título">¶</a></h2>
<p>La sentencia “<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>” aclara el código que antes utilizaba bloques <code class="docutils literal notranslate"><span class="pre">try...finally</span></code>” para asegurar que se ejecuta el código de limpieza.  En esta sección, hablaré de la sentencia tal y como se utiliza habitualmente.  En la siguiente sección, examinaré los detalles de la implementación y mostraré cómo escribir objetos para usar con esta sentencia.</p>
<p>La declaración “<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>” es una nueva estructura de flujo de control cuya estructura básica es:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">expression</span> <span class="p">[</span><span class="k">as</span> <span class="n">variable</span><span class="p">]:</span>
    <span class="k">with</span><span class="o">-</span><span class="n">block</span>
</pre></div>
</div>
<p>La expresión se evalúa y debe dar como resultado un objeto que soporte el protocolo de gestión de contextos (es decir, que tenga los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code>).</p>
<p>El <code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code> del objeto es llamado antes de que se ejecute <em>with-block</em> y por lo tanto puede ejecutar código de configuración. También puede devolver un valor ligado al nombre <em>variable</em>, si se da.  (Observe cuidadosamente que a <em>variable</em> no se le asigna el resultado de la <em>expresión</em>)</p>
<p>Una vez finalizada la ejecución del <em>with-block</em>, se llama al método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code> del objeto, incluso si el bloque lanzó una excepción, y por lo tanto puede ejecutar código de limpieza.</p>
<p>Para habilitar la declaración en Python 2.5, debe añadir la siguiente directiva a su módulo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">with_statement</span>
</pre></div>
</div>
<p>La declaración siempre estará habilitada en Python 2.6.</p>
<p>Algunos objetos estándar de Python soportan ahora el protocolo de gestión de contextos y pueden utilizarse con la sentencia “<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>””. Los objetos de archivo son un ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="nb">print</span> <span class="n">line</span>
        <span class="o">...</span> <span class="n">more</span> <span class="n">processing</span> <span class="n">code</span> <span class="o">...</span>
</pre></div>
</div>
<p>Después de que esta sentencia se haya ejecutado, el objeto archivo en <em>f</em> se habrá cerrado automáticamente, incluso si el bucle <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> lanzó una excepción a mitad del bloque.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En este caso, <em>f</em> es el mismo objeto creado por <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>, porque <code class="xref py py-meth docutils literal notranslate"><span class="pre">file.__enter__()</span></code> devuelve <em>self</em>.</p>
</div>
<p>Los bloqueos y las variables de condición del módulo <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> también soportan la sentencia “<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>”:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
    <span class="c1"># Critical section of code</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>El bloqueo se adquiere antes de que se ejecute el bloque y siempre se libera una vez que el bloque se ha completado.</p>
<p>La nueva función <code class="xref py py-func docutils literal notranslate"><span class="pre">localcontext()</span></code> del módulo <a class="reference internal" href="../library/decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic  Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> facilita el guardado y la restauración del contexto decimal actual, que encapsula las características de precisión y redondeo deseadas para los cálculos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">Context</span><span class="p">,</span> <span class="n">localcontext</span>

<span class="c1"># Displays with default precision of 28 digits</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;578&#39;</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">v</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>

<span class="k">with</span> <span class="n">localcontext</span><span class="p">(</span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">16</span><span class="p">)):</span>
    <span class="c1"># All code in this block uses a precision of 16 digits.</span>
    <span class="c1"># The original context is restored on exiting the block.</span>
    <span class="nb">print</span> <span class="n">v</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
</pre></div>
</div>
<section id="writing-context-managers">
<span id="new-25-context-managers"></span><h3>Redacción de Gestores de Contexto<a class="headerlink" href="#writing-context-managers" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Bajo el capó, la sentencia “<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>” es bastante complicada. La mayoría de la gente sólo utilizará “<code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code>” en compañía de objetos existentes y no necesita conocer estos detalles, así que puedes saltarte el resto de esta sección si quieres.  Los autores de nuevos objetos necesitarán entender los detalles de la implementación subyacente y deberían seguir leyendo.</p>
<p>Una explicación de alto nivel del protocolo de gestión del contexto es:</p>
<ul class="simple">
<li><p>La expresión se evalúa y debe dar como resultado un objeto llamado «gestor de contexto».  El gestor de contexto debe tener métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code>.</p></li>
<li><p>Se llama al método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code> del gestor de contexto.  El valor devuelto se asigna a <em>VAR</em>.  Si no está presente la cláusula <code class="docutils literal notranslate"><span class="pre">'as</span> <span class="pre">VAR'</span></code>, el valor simplemente se descarta.</p></li>
<li><p>Se ejecuta el código en <em>BLOQUE</em>.</p></li>
<li><p>Si <em>BLOCK</em> lanza una excepción, se llama a <code class="docutils literal notranslate"><span class="pre">__exit__(type,</span> <span class="pre">value,</span> <span class="pre">traceback)</span></code> con los detalles de la excepción, los mismos valores devueltos por <a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>.  El valor de retorno del método controla si la excepción se vuelve a lanzar: cualquier valor falso vuelve a lanzar la excepción, y <code class="docutils literal notranslate"><span class="pre">True</span></code> resultará en suprimirla.  Sólo en raras ocasiones querrá suprimir la excepción, porque si lo hace el autor del código que contiene la declaración “<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>” nunca se dará cuenta de que algo ha ido mal.</p></li>
<li><p>Si <em>BLOCK</em> no lanzó una excepción, el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code> sigue siendo llamado, pero <em>type</em>, <em>value</em>, y <em>traceback</em> son todos <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
</ul>
<p>Pensemos en un ejemplo.  No presentaré un código detallado, sino que sólo esbozaré los métodos necesarios para una base de datos que soporte transacciones.</p>
<p>(Para quienes no estén familiarizados con la terminología de las bases de datos: un conjunto de cambios en la base de datos se agrupa en una transacción.  Las transacciones pueden ser confirmadas, lo que significa que todos los cambios se escriben en la base de datos, o revertidas, lo que significa que todos los cambios se descartan y la base de datos no se modifica.  Consulte cualquier libro de texto sobre bases de datos para obtener más información)</p>
<p>Supongamos que hay un objeto que representa una conexión a la base de datos. Nuestro objetivo será permitir que el usuario escriba código como este:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">db_connection</span> <span class="o">=</span> <span class="n">DatabaseConnection</span><span class="p">()</span>
<span class="k">with</span> <span class="n">db_connection</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;insert into ...&#39;</span><span class="p">)</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;delete from ...&#39;</span><span class="p">)</span>
    <span class="c1"># ... more operations ...</span>
</pre></div>
</div>
<p>La transacción debe ser confirmada si el código en el bloque se ejecuta sin problemas o revertida si hay una excepción. Aquí está la interfaz básica para <code class="xref py py-class docutils literal notranslate"><span class="pre">DatabaseConnection</span></code> que voy a asumir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DatabaseConnection</span><span class="p">:</span>
    <span class="c1"># Database interface</span>
    <span class="k">def</span> <span class="nf">cursor</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Returns a cursor object and starts a new transaction&quot;</span>
    <span class="k">def</span> <span class="nf">commit</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Commits current transaction&quot;</span>
    <span class="k">def</span> <span class="nf">rollback</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Rolls back current transaction&quot;</span>
</pre></div>
</div>
<p>El método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code> es bastante sencillo, ya que sólo hay que iniciar una nueva transacción.  Para esta aplicación el objeto cursor resultante sería un resultado útil, por lo que el método lo devolverá.  El usuario puede entonces añadir <code class="docutils literal notranslate"><span class="pre">as</span> <span class="pre">cursor</span></code> a su sentencia “<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>” para ligar el cursor a un nombre de variable.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DatabaseConnection</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__enter__</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Code to start a new transaction</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cursor</span>
</pre></div>
</div>
<p>El método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code> es el más complicado porque es donde hay que hacer la mayor parte del trabajo.  El método tiene que comprobar si se produjo una excepción.  Si no hubo ninguna excepción, la transacción es confirmada.  La transacción es revertida si hubo una excepción.</p>
<p>En el código de abajo, la ejecución simplemente caerá al final de la función, devolviendo el valor por defecto de <code class="docutils literal notranslate"><span class="pre">None</span></code>.  <code class="docutils literal notranslate"><span class="pre">None</span></code> es falso, por lo que la excepción se volverá a lanzar automáticamente.  Si lo desea, puede ser más explícito y añadir una declaración <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> en el lugar marcado.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DatabaseConnection</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__exit__</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># No exception, so commit</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Exception occurred, so rollback.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
            <span class="c1"># return False</span>
</pre></div>
</div>
</section>
<section id="the-contextlib-module">
<span id="contextlibmod"></span><h3>El módulo contextlib<a class="headerlink" href="#the-contextlib-module" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El nuevo módulo <a class="reference internal" href="../library/contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code></a> proporciona algunas funciones y un decorador que son útiles para escribir objetos para usar con la sentencia “<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>”.</p>
<p>El decorador se llama <code class="xref py py-func docutils literal notranslate"><span class="pre">contextmanager()</span></code>, y permite escribir una única función generadora en lugar de definir una nueva clase.  El generador debe producir exactamente un valor.  El código hasta la palabra clave <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> se ejecutará como el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code>, y el valor producido será el valor de retorno del método que se vinculará a la variable en la cláusula <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> de la sentencia <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code>, si existe.  El código después de <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> se ejecutará en el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code>.  Cualquier excepción lanzada en el bloque será lanzada por la sentencia <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code>.</p>
<p>Nuestro ejemplo de base de datos de la sección anterior podría escribirse utilizando este decorador como:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">db_transaction</span> <span class="p">(</span><span class="n">connection</span><span class="p">):</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">cursor</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
        <span class="k">raise</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

<span class="n">db</span> <span class="o">=</span> <span class="n">DatabaseConnection</span><span class="p">()</span>
<span class="k">with</span> <span class="n">db_transaction</span><span class="p">(</span><span class="n">db</span><span class="p">)</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>El módulo <a class="reference internal" href="../library/contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code></a> también tiene una función <code class="docutils literal notranslate"><span class="pre">anidada(mgr1,</span> <span class="pre">mgr2,</span> <span class="pre">...)</span></code> que combina varios gestores de contexto para que no sea necesario escribir sentencias “<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>” anidadas.  En este ejemplo, la única sentencia “<code class="xref std std-keyword docutils literal notranslate"><span class="pre">with`</span></code> inicia una transacción de base de datos y adquiere un bloqueo de hilo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="k">with</span> <span class="n">nested</span> <span class="p">(</span><span class="n">db_transaction</span><span class="p">(</span><span class="n">db</span><span class="p">),</span> <span class="n">lock</span><span class="p">)</span> <span class="k">as</span> <span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">locked</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Por último, la función <code class="docutils literal notranslate"><span class="pre">closing(object)</span></code> devuelve el <em>objeto</em> para que pueda ser vinculado a una variable, y llama a <code class="docutils literal notranslate"><span class="pre">object.close</span></code> al final del bloque.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib</span><span class="o">,</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">closing</span>

<span class="k">with</span> <span class="n">closing</span><span class="p">(</span><span class="n">urllib</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.yahoo.com&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-74"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0343"><strong>PEP 343</strong></a> - La declaración «con»</dt><dd><p>PEP escrito por Guido van Rossum y Nick Coghlan; implementado por Mike Bland, Guido van Rossum y Neal Norwitz.  El PEP muestra el código generado para una sentencia “<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>”, que puede ser útil para aprender cómo funciona la sentencia.</p>
</dd>
</dl>
<p>La documentación del módulo <a class="reference internal" href="../library/contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code></a>.</p>
</div>
</section>
</section>
<section id="pep-352-exceptions-as-new-style-classes">
<span id="pep-352"></span><h2>PEP 352: Las excepciones como clases de nuevo estilo<a class="headerlink" href="#pep-352-exceptions-as-new-style-classes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las clases de excepción ahora pueden ser clases de nuevo estilo, no sólo clases clásicas, y la clase incorporada <a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a> y todas las excepciones incorporadas estándar (<a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a>, <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>, etc.) son ahora clases de nuevo estilo.</p>
<p>La jerarquía de herencia de las excepciones se ha reordenado un poco. En 2.5, las relaciones de herencia son:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ne">BaseException</span>       <span class="c1"># New in Python 2.5</span>
<span class="o">|-</span> <span class="ne">KeyboardInterrupt</span>
<span class="o">|-</span> <span class="ne">SystemExit</span>
<span class="o">|-</span> <span class="ne">Exception</span>
   <span class="o">|-</span> <span class="p">(</span><span class="nb">all</span> <span class="n">other</span> <span class="n">current</span> <span class="n">built</span><span class="o">-</span><span class="ow">in</span> <span class="n">exceptions</span><span class="p">)</span>
</pre></div>
</div>
<p>Esta reorganización se hizo porque la gente a menudo quiere atrapar todas las excepciones que indican errores del programa. <a class="reference internal" href="../library/exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> y <a class="reference internal" href="../library/exceptions.html#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemExit</span></code></a> no son errores, sin embargo, y por lo general representan una acción explícita como el usuario pulsando <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Control</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd></kbd> o el código llamando a <a class="reference internal" href="../library/sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a>.  Una simple <code class="docutils literal notranslate"><span class="pre">except:</span></code> atrapará todas las excepciones, por lo que comúnmente se necesita listar <a class="reference internal" href="../library/exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> y <a class="reference internal" href="../library/exceptions.html#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemExit</span></code></a> para volver a lanzarlas.  El patrón habitual es:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">except</span> <span class="p">(</span><span class="ne">KeyboardInterrupt</span><span class="p">,</span> <span class="ne">SystemExit</span><span class="p">):</span>
    <span class="k">raise</span>
<span class="k">except</span><span class="p">:</span>
    <span class="c1"># Log error...</span>
    <span class="c1"># Continue running program...</span>
</pre></div>
</div>
<p>En Python 2.5, ahora puedes escribir <code class="docutils literal notranslate"><span class="pre">except</span> <span class="pre">Exception</span></code> para conseguir el mismo resultado, capturando todas las excepciones que suelen indicar errores pero dejando <a class="reference internal" href="../library/exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> y <a class="reference internal" href="../library/exceptions.html#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemExit</span></code></a> en paz.  Como en versiones anteriores, un <code class="docutils literal notranslate"><span class="pre">except:</span></code> desnudo sigue capturando todas las excepciones.</p>
<p>El objetivo de Python 3.0 es requerir que cualquier clase lanzada como excepción derive de <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a> o de algún descendiente de <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a>, y las futuras versiones de la serie Python 2.x pueden empezar a imponer esta restricción. Por lo tanto, sugiero que empieces a hacer que todas tus clases de excepción deriven de <a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a> ahora.  Se ha sugerido que la forma desnuda <code class="docutils literal notranslate"><span class="pre">except:</span></code> sea eliminada en Python 3.0, pero Guido van Rossum no ha decidido si hacerlo o no.</p>
<p>El lanzamiento de cadenas como excepciones, como en la declaración <code class="docutils literal notranslate"><span class="pre">raise</span> <span class="pre">&quot;Error</span> <span class="pre">occurred&quot;</span></code>, está obsoleto en Python 2.5 y provocará una advertencia.  El objetivo es poder eliminar la función de excepción de cadena en algunas versiones.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-75"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0352"><strong>PEP 352</strong></a> - Superclase necesaria para las excepciones</dt><dd><p>PEP escrito por Brett Cannon y Guido van Rossum; implementado por Brett Cannon.</p>
</dd>
</dl>
</div>
</section>
<section id="pep-353-using-ssize-t-as-the-index-type">
<span id="pep-353"></span><h2>PEP 353: Uso de ssize_t como tipo de índice<a class="headerlink" href="#pep-353-using-ssize-t-as-the-index-type" title="Enlazar permanentemente con este título">¶</a></h2>
<p>A wide-ranging change to Python’s C API, using a new  <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> type
definition instead of <code class="xref c c-expr docutils literal notranslate"><span class="pre">int</span></code>,  will permit the interpreter to handle more
data on 64-bit platforms. This change doesn’t affect Python’s capacity on 32-bit
platforms.</p>
<p>Various pieces of the Python interpreter used C’s <code class="xref c c-expr docutils literal notranslate"><span class="pre">int</span></code> type to store
sizes or counts; for example, the number of items in a list or tuple were stored
in an <code class="xref c c-expr docutils literal notranslate"><span class="pre">int</span></code>.  The C compilers for most 64-bit platforms still define
<code class="xref c c-expr docutils literal notranslate"><span class="pre">int</span></code> as a 32-bit type, so that meant that lists could only hold up to
<code class="docutils literal notranslate"><span class="pre">2**31</span> <span class="pre">-</span> <span class="pre">1</span></code> = 2147483647 items. (There are actually a few different
programming models that 64-bit C compilers can use – see
<a class="reference external" href="https://unix.org/version2/whatsnew/lp64_wp.html">https://unix.org/version2/whatsnew/lp64_wp.html</a> for a discussion – but the
most commonly available model leaves <code class="xref c c-expr docutils literal notranslate"><span class="pre">int</span></code> as 32 bits.)</p>
<p>Un límite de 2147483647 elementos no importa realmente en una plataforma de 32 bits porque te quedarás sin memoria antes de alcanzar el límite de longitud. Cada elemento de la lista requiere espacio para un puntero, que es de 4 bytes, más espacio para un <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> que representa el elemento.  2147483647*4 ya son más bytes de los que puede contener un espacio de direcciones de 32 bits.</p>
<p>It’s possible to address that much memory on a 64-bit platform, however.  The
pointers for a list that size would only require 16 GiB of space, so it’s not
unreasonable that Python programmers might construct lists that large.
Therefore, the Python interpreter had to be changed to use some type other than
<code class="xref c c-expr docutils literal notranslate"><span class="pre">int</span></code>, and this will be a 64-bit type on 64-bit platforms.  The change
will cause incompatibilities on 64-bit machines, so it was deemed worth making
the transition now, while the number of 64-bit users is still relatively small.
(In 5 or 10 years, we may <em>all</em> be on 64-bit machines, and the transition would
be more painful then.)</p>
<p>Este cambio afecta en mayor medida a los autores de módulos de extensión de C.   Las cadenas de Python y los tipos contenedores como las listas y las tuplas utilizan ahora <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> para almacenar su tamaño.   Funciones como <a class="reference internal" href="../c-api/list.html#c.PyList_Size" title="PyList_Size"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyList_Size()</span></code></a> ahora devuelven <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>.  Por lo tanto, el código de los módulos de extensión puede necesitar cambiar algunas variables a <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>.</p>
<p>The <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> and <a class="reference internal" href="../c-api/arg.html#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a> functions have a new
conversion code, <code class="docutils literal notranslate"><span class="pre">n</span></code>, for <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>.   <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>”s
<code class="docutils literal notranslate"><span class="pre">s#</span></code> and <code class="docutils literal notranslate"><span class="pre">t#</span></code> still output <code class="xref c c-expr docutils literal notranslate"><span class="pre">int</span></code> by default, but you can define the
macro  <code class="xref c c-macro docutils literal notranslate"><span class="pre">PY_SSIZE_T_CLEAN</span></code> before including <code class="file docutils literal notranslate"><span class="pre">Python.h</span></code>  to make
them return <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>.</p>
<p><span class="target" id="index-76"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0353"><strong>PEP 353</strong></a> tiene una sección sobre directrices de conversión que los autores de extensiones deberían leer para aprender a soportar plataformas de 64 bits.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-77"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0353"><strong>PEP 353</strong></a> - Uso de ssize_t como tipo de índice</dt><dd><p>PEP escrito y aplicado por Martin von Löwis.</p>
</dd>
</dl>
</div>
</section>
<section id="pep-357-the-index-method">
<span id="pep-357"></span><h2>PEP 357: El método “__index__”<a class="headerlink" href="#pep-357-the-index-method" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los desarrolladores de NumPy tenían un problema que sólo podía resolverse añadiendo un nuevo método especial, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code>.  Cuando se utiliza la notación de trozos, como en <code class="docutils literal notranslate"><span class="pre">[start:stop:step]</span></code>, los valores de los índices <em>start</em>, <em>stop</em> y <em>step</em> deben ser todos enteros o enteros largos.  NumPy define una variedad de tipos de enteros especializados que corresponden a enteros sin signo y con signo de 8, 16, 32 y 64 bits, pero no había forma de señalar que estos tipos pudieran usarse como índices de trozos.</p>
<p>El rebanado no puede utilizar el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code> existente porque ese método también se utiliza para implementar la coerción a enteros.  Si el rebanado utilizara <code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code>, los números de punto flotante también se convertirían en índices de rebanada legales y eso es claramente un comportamiento indeseable.</p>
<p>En su lugar, se ha añadido un nuevo método especial llamado <code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code>.  No toma argumentos y devuelve un entero que da el índice de corte a utilizar.  Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__index__</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
</pre></div>
</div>
<p>El valor devuelto debe ser un entero de Python o un entero largo. El intérprete comprobará que el tipo devuelto es correcto, y lanza un <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> si no se cumple este requisito.</p>
<p>Se ha añadido la correspondiente ranura <code class="xref py py-attr docutils literal notranslate"><span class="pre">nb_index</span></code> a la estructura <a class="reference internal" href="../c-api/typeobj.html#c.PyNumberMethods" title="PyNumberMethods"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyNumberMethods</span></code></a> de nivel C para que las extensiones C puedan implementar este protocolo. El código de la extensión puede utilizar <code class="docutils literal notranslate"><span class="pre">PyNumber_Index(obj)</span></code> para llamar a la función <code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code> y obtener su resultado.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-78"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0357"><strong>PEP 357</strong></a> - Permitir el uso de cualquier objeto para rebanar</dt><dd><p>PEP escrito e implementado por Travis Oliphant.</p>
</dd>
</dl>
</div>
</section>
<section id="other-language-changes">
<span id="other-lang"></span><h2>Otros cambios lingüísticos<a class="headerlink" href="#other-language-changes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Estos son todos los cambios que Python 2.5 introduce en el núcleo del lenguaje Python.</p>
<ul>
<li><p>El tipo <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> tiene un nuevo gancho para permitir que las subclases proporcionen un valor por defecto cuando una clave no está contenida en el diccionario. Cuando no se encuentre una clave, se llamará al método <code class="docutils literal notranslate"><span class="pre">missing__(key)</span></code> del diccionario.  Este hook se utiliza para implementar la nueva clase <code class="xref py py-class docutils literal notranslate"><span class="pre">defaultdict</span></code> en el módulo <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a>.  El siguiente ejemplo define un diccionario que devuelve cero para cualquier clave que falte:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">zerodict</span> <span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__missing__</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">zerodict</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="nb">print</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>   <span class="c1"># Prints 1, 2</span>
<span class="nb">print</span> <span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>   <span class="c1"># Prints 0, 0</span>
</pre></div>
</div>
</li>
<li><p>Tanto las cadenas de 8 bits como las de Unicode tienen nuevos métodos <code class="docutils literal notranslate"><span class="pre">partition(sep)</span></code> y <code class="docutils literal notranslate"><span class="pre">rpartition(sep)</span></code> que simplifican un caso de uso común.</p>
<p>El método <code class="docutils literal notranslate"><span class="pre">find(S)</span></code> se utiliza a menudo para obtener un índice que luego se utiliza para cortar la cadena y obtener las piezas que están antes y después del separador. El método <code class="docutils literal notranslate"><span class="pre">partition(sep)</span></code> condensa este patrón en una sola llamada al método que devuelve una tripleta que contiene la subcadena antes del separador, el propio separador y la subcadena después del separador.  Si no se encuentra el separador, el primer elemento de la tupla es la cadena completa y los otros dos elementos están vacíos.  <code class="docutils literal notranslate"><span class="pre">rpartition(sep)</span></code> también devuelve una tupla de 3 elementos, pero empieza a buscar desde el final de la cadena; la <code class="docutils literal notranslate"><span class="pre">r</span></code> significa «al revés».</p>
<p>Algunos ejemplos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="s1">&#39;http://www.python.org&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;://&#39;</span><span class="p">)</span>
<span class="go">(&#39;http&#39;, &#39;://&#39;, &#39;www.python.org&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="s1">&#39;file:/usr/share/doc/index.html&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;://&#39;</span><span class="p">)</span>
<span class="go">(&#39;file:/usr/share/doc/index.html&#39;, &#39;&#39;, &#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;Subject: a quick question&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
<span class="go">(u&#39;Subject&#39;, u&#39;:&#39;, u&#39; a quick question&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;www.python.org&#39;</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="go">(&#39;www.python&#39;, &#39;.&#39;, &#39;org&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;www.python.org&#39;</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
<span class="go">(&#39;&#39;, &#39;&#39;, &#39;www.python.org&#39;)</span>
</pre></div>
</div>
<p>(Implementado por Fredrik Lundh tras una sugerencia de Raymond Hettinger)</p>
</li>
<li><p>Los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">startswith()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">endswith()</span></code> de los tipos de cadena aceptan ahora tuplas de cadenas para su comprobación.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">is_image_file</span> <span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">((</span><span class="s1">&#39;.gif&#39;</span><span class="p">,</span> <span class="s1">&#39;.jpg&#39;</span><span class="p">,</span> <span class="s1">&#39;.tiff&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>(Implementado por Georg Brandl tras una sugerencia de Tom Lynn)</p>
</li>
<li><p>Las funciones incorporadas <a class="reference internal" href="../library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a> y <a class="reference internal" href="../library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a> han ganado un parámetro de palabra clave <code class="docutils literal notranslate"><span class="pre">key</span></code> análogo al argumento <code class="docutils literal notranslate"><span class="pre">key</span></code> de <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code>.  Este parámetro proporciona una función que toma un único argumento y es llamada para cada valor de la lista; <a class="reference internal" href="../library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>/<a class="reference internal" href="../library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a> devolverá el elemento con el valor de retorno más pequeño/más grande de esta función. Por ejemplo, para encontrar la cadena más larga de una lista, puede hacer:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;medium&#39;</span><span class="p">,</span> <span class="s1">&#39;longest&#39;</span><span class="p">,</span> <span class="s1">&#39;short&#39;</span><span class="p">]</span>
<span class="c1"># Prints &#39;longest&#39;</span>
<span class="nb">print</span> <span class="nb">max</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>
<span class="c1"># Prints &#39;short&#39;, because lexicographically &#39;short&#39; has the largest value</span>
<span class="nb">print</span> <span class="nb">max</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
</pre></div>
</div>
<p>(Contribución de Steven Bethard y Raymond Hettinger)</p>
</li>
<li><p>Dos nuevas funciones incorporadas, <a class="reference internal" href="../library/functions.html#any" title="any"><code class="xref py py-func docutils literal notranslate"><span class="pre">any()</span></code></a> y <a class="reference internal" href="../library/functions.html#all" title="all"><code class="xref py py-func docutils literal notranslate"><span class="pre">all()</span></code></a>, evalúan si un iterador contiene algún valor verdadero o falso. <a class="reference internal" href="../library/functions.html#any" title="any"><code class="xref py py-func docutils literal notranslate"><span class="pre">any()</span></code></a> devuelve <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> si cualquier valor devuelto por el iterador es verdadero; en caso contrario devolverá <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>. <a class="reference internal" href="../library/functions.html#all" title="all"><code class="xref py py-func docutils literal notranslate"><span class="pre">all()</span></code></a> devuelve <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> sólo si todos los valores devueltos por el iterador se evalúan como verdaderos. (Sugerido por Guido van Rossum, e implementado por Raymond Hettinger)</p></li>
<li><p>El resultado del método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> de una clase puede ser ahora un entero largo o un entero normal.  Si se devuelve un entero largo, se toma el hash de ese valor.  En versiones anteriores se requería que el valor del hash fuera un entero regular, pero en 2.5 el built-in <a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> se cambió para devolver siempre números no negativos, y los usuarios parecen utilizar a menudo <code class="docutils literal notranslate"><span class="pre">id(self)</span></code> en los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> (aunque esto se desaconseja).</p>
</li>
<li><p>ASCII es ahora la codificación por defecto para los módulos.  Ahora es un error de sintaxis si un módulo contiene literales de cadena con caracteres de 8 bits pero no tiene una declaración de codificación.  En Python 2.4 esto provocaba una advertencia, no un error de sintaxis.  Vea en <span class="target" id="index-79"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0263"><strong>PEP 263</strong></a> cómo declarar la codificación de un módulo; por ejemplo, puede añadir una línea como ésta cerca de la parte superior del fichero fuente:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># -*- coding: latin1 -*-</span>
</pre></div>
</div>
</li>
<li><p>Una nueva advertencia, <a class="reference internal" href="../library/exceptions.html#UnicodeWarning" title="UnicodeWarning"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeWarning</span></code></a>, se activa cuando se intenta comparar una cadena Unicode y una cadena de 8 bits que no se puede convertir a Unicode utilizando la codificación ASCII por defecto.   El resultado de la comparación es falso:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">chr</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span> <span class="o">==</span> <span class="n">unichr</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>   <span class="c1"># Can&#39;t convert chr(128) to Unicode</span>
<span class="go">__main__:1: UnicodeWarning: Unicode equal comparison failed</span>
<span class="go">  to convert both arguments to Unicode - interpreting them</span>
<span class="go">  as being unequal</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">chr</span><span class="p">(</span><span class="mi">127</span><span class="p">)</span> <span class="o">==</span> <span class="n">unichr</span><span class="p">(</span><span class="mi">127</span><span class="p">)</span>   <span class="c1"># chr(127) can be converted</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Anteriormente, esto lanzaba una excepción <a class="reference internal" href="../library/exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code></a>, pero en 2.5 esto podía dar lugar a problemas desconcertantes al acceder a un diccionario.  Si se buscaba <code class="docutils literal notranslate"><span class="pre">unichr(128)</span></code> y se utilizaba <code class="docutils literal notranslate"><span class="pre">chr(128)</span></code> como clave, se producía una excepción <a class="reference internal" href="../library/exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code></a>.  Otros cambios en la versión 2.5 hicieron que esta excepción se lanzara en lugar de ser suprimida por el código de <code class="file docutils literal notranslate"><span class="pre">dictobject.c</span></code> que implementa los diccionarios.</p>
<p>Lanzar una excepción para tal comparación es estrictamente correcto, pero el cambio podría haber roto el código, así que en su lugar se introdujo <a class="reference internal" href="../library/exceptions.html#UnicodeWarning" title="UnicodeWarning"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeWarning</span></code></a>.</p>
<p>(Implementado por Marc-André Lemburg.)</p>
</li>
<li><p>Un error que a veces cometen los programadores de Python es olvidarse de incluir un módulo <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> en el directorio de un paquete. Depurar este error puede ser confuso, y normalmente requiere ejecutar Python con el modificador <a class="reference internal" href="../using/cmdline.html#cmdoption-1"><code class="xref std std-option docutils literal notranslate"><span class="pre">-v</span></code></a> para registrar todas las rutas buscadas. En Python 2.5, una nueva advertencia <a class="reference internal" href="../library/exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportWarning</span></code></a> se activa cuando una importación habría recogido un directorio como paquete pero no se encontró ningún <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code>.  Esta advertencia se ignora silenciosamente por defecto; proporcione la opción <a class="reference internal" href="../using/cmdline.html#cmdoption-W"><code class="xref std std-option docutils literal notranslate"><span class="pre">-Wd</span></code></a> cuando ejecute el ejecutable de Python para mostrar el mensaje de advertencia. (Implementado por Thomas Wouters)&lt;/-W&gt;</p></li>
<li><p>La lista de clases base en una definición de clase ahora puede estar vacía.   Como ejemplo, esto es ahora legal:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>(Implementado por Brett Cannon.)</p>
</li>
</ul>
<section id="interactive-interpreter-changes">
<span id="interactive"></span><h3>Cambios en el intérprete interactivo<a class="headerlink" href="#interactive-interpreter-changes" title="Enlazar permanentemente con este título">¶</a></h3>
<p>En el intérprete interactivo, <code class="docutils literal notranslate"><span class="pre">quit</span></code> y <code class="docutils literal notranslate"><span class="pre">exit</span></code> han sido durante mucho tiempo cadenas para que los nuevos usuarios obtengan un mensaje algo útil cuando intenten salir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">quit</span>
<span class="go">&#39;Use Ctrl-D (i.e. EOF) to exit.&#39;</span>
</pre></div>
</div>
<p>En Python 2.5, <code class="docutils literal notranslate"><span class="pre">quit</span></code> y <code class="docutils literal notranslate"><span class="pre">exit</span></code> son ahora objetos que siguen produciendo representaciones de cadena de sí mismos, pero también son invocables. Los novatos que prueben <code class="docutils literal notranslate"><span class="pre">quit()</span></code> o <code class="docutils literal notranslate"><span class="pre">exit()</span></code> ahora saldrán del intérprete como se espera.  (Implementado por Georg Brandl.)</p>
<p>El ejecutable de Python ahora acepta las opciones largas estándar <a class="reference internal" href="../using/cmdline.html#cmdoption-help"><code class="xref std std-option docutils literal notranslate"><span class="pre">--help</span></code></a> y <a class="reference internal" href="../using/cmdline.html#cmdoption-version"><code class="xref std std-option docutils literal notranslate"><span class="pre">--version</span></code></a>; en Windows, también acepta la opción <a class="reference internal" href="../using/cmdline.html#cmdoption-0"><code class="xref std std-option docutils literal notranslate"><span class="pre">/?</span></code></a> para mostrar un mensaje de ayuda. (Implementado por Georg Brandl)</p>
</section>
<section id="optimizations">
<span id="opts"></span><h3>Optimizaciones<a class="headerlink" href="#optimizations" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Varias de las optimizaciones se desarrollaron en el sprint NeedForSpeed, un evento celebrado en Reikiavik, Islandia, del 21 al 28 de mayo de 2006. El sprint se centró en las mejoras de velocidad de la implementación de CPython y fue financiado por EWT LLC con el apoyo local de CCP Games.  Las optimizaciones añadidas en este sprint están especialmente marcadas en la siguiente lista.</p>
<ul class="simple">
<li><p>Cuando se introdujeron en Python 2.4, los tipos incorporados <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> y <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> se construyeron sobre el tipo diccionario de Python.   En 2.5 la estructura de datos interna se ha personalizado para implementar conjuntos, y como resultado los conjuntos utilizarán un tercio menos de memoria y son algo más rápidos. (Implementado por Raymond Hettinger)</p></li>
<li><p>Se ha mejorado la velocidad de algunas operaciones Unicode, como la búsqueda de subcadenas, la división de cadenas y la codificación y decodificación de mapas de caracteres. (Las mejoras en la búsqueda de subcadenas y la división fueron añadidas por Fredrik Lundh y Andrew Dalke en el sprint NeedForSpeed. Los mapas de caracteres fueron mejorados por Walter Dörwald y Martin von Löwis)</p>
</li>
<li><p>La función <code class="docutils literal notranslate"><span class="pre">long(str,</span> <span class="pre">base)</span></code> es ahora más rápida en cadenas de dígitos largos porque se calculan menos resultados intermedios.  El máximo es para cadenas de alrededor de 800-1000 dígitos, donde la función es 6 veces más rápida. (Aportado por Alan McIntyre y comprometido en el sprint NeedForSpeed)</p>
</li>
<li><p>Ahora es ilegal mezclar la iteración sobre un fichero con <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">line</span> <span class="pre">in</span> <span class="pre">file</span></code> y llamar a los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code>/<a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a>/<code class="xref py py-meth docutils literal notranslate"><span class="pre">readlines()</span></code> del objeto fichero.  La iteración utiliza un buffer interno y los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">read*()</span></code> no utilizan ese buffer.   En su lugar, devolverán los datos que siguen al buffer, haciendo que los datos aparezcan desordenados.  Mezclar la iteración y estos métodos provocará ahora un <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> del método <code class="xref py py-meth docutils literal notranslate"><span class="pre">read*()</span></code>. (Implementado por Thomas Wouters)</p>
</li>
<li><p>El módulo <a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> ahora compila cadenas de formato de estructura en una representación interna y almacena en caché esta representación, lo que supone una mejora del 20% s. (Contribuido por Bob Ippolito en el sprint NeedForSpeed)</p></li>
<li><p>El módulo <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> obtuvo un 1 o 2% s de velocidad al cambiar a las funciones asignadoras de Python en lugar de las <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> y <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code> del sistema. (Contribuido por Jack Diederich en el sprint NeedForSpeed)</p></li>
<li><p>El optimizador de la mirilla del generador de código realiza ahora un simple plegado de constantes en las expresiones.  Si escribes algo como <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">2+3</span></code>, el generador de código hará la aritmética y producirá el código correspondiente a <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">5</span></code>.  (Propuesto e implementado por Raymond Hettinger)</p></li>
<li><p>Las llamadas a funciones son ahora más rápidas porque los objetos de código guardan ahora el último fotograma terminado (un «fotograma zombi») en un campo interno del objeto de código, reutilizándolo la próxima vez que se invoque el objeto de código.  (Parche original de Michael Hudson, modificado por Armin Rigo y Richard Jones; confirmado en el sprint NeedForSpeed)  Los objetos marco son también ligeramente más pequeños, lo que puede mejorar la localidad de la caché y reducir un poco el uso de la memoria.  (Contribución de Neal Norwitz)</p>
</li>
<li><p>Las excepciones incorporadas en Python son ahora clases de nuevo estilo, un cambio que acelera considerablemente la instanciación.  El manejo de excepciones en Python 2.5 es, por tanto, un 30% f más rápido que en 2.4. (Contribución de Richard Jones, Georg Brandl y Sean Reifschneider en el sprint NeedForSpeed)</p></li>
<li><p>La importación ahora almacena en caché las rutas intentadas, registrando si existen o no para que el intérprete haga menos llamadas a <code class="xref c c-func docutils literal notranslate"><span class="pre">open()</span></code> y <code class="xref c c-func docutils literal notranslate"><span class="pre">stat()</span></code> al iniciar. (Contribución de Martin von Löwis y Georg Brandl)</p>
</li>
</ul>
</section>
</section>
<section id="new-improved-and-removed-modules">
<span id="modules"></span><h2>Módulos nuevos, mejorados y eliminados<a class="headerlink" href="#new-improved-and-removed-modules" title="Enlazar permanentemente con este título">¶</a></h2>
<p>La biblioteca estándar ha recibido muchas mejoras y correcciones de errores en Python 2.5. Aquí hay una lista parcial de los cambios más notables, ordenados alfabéticamente por el nombre del módulo. Consulte el archivo <code class="file docutils literal notranslate"><span class="pre">Misc/NEWS</span></code> en el árbol de fuentes para obtener una lista más completa de los cambios, o busque en los registros de SVN para obtener todos los detalles.</p>
<ul>
<li><p>El módulo <a class="reference internal" href="../library/audioop.html#module-audioop" title="audioop: Manipulate raw audio data. (obsoleto)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code></a> soporta ahora la codificación a-LAW, y se ha mejorado el código para la codificación u-LAW.  (Contribución de Lars Immisch)</p></li>
<li><p>El módulo <a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> ha ganado soporte para códecs incrementales.  La función <code class="xref py py-func docutils literal notranslate"><span class="pre">codec.lookup()</span></code> devuelve ahora una instancia de <code class="xref py py-class docutils literal notranslate"><span class="pre">CodecInfo</span></code> en lugar de una tupla. Las instancias de <code class="xref py py-class docutils literal notranslate"><span class="pre">CodecInfo</span></code> se comportan como una cuádruple tupla para preservar la compatibilidad con versiones anteriores, pero también tienen los atributos <code class="xref py py-attr docutils literal notranslate"><span class="pre">encode</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">decode</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">incrementalencoder</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">incrementaldecoder</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">streamwriter</span></code> y <code class="xref py py-attr docutils literal notranslate"><span class="pre">streamreader</span></code>.  Los códecs incrementales pueden recibir la entrada y producir la salida en varios trozos; la salida es la misma que si la entrada completa fuera alimentada por el códec no incremental. Consulte la documentación del módulo <a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> para más detalles. (Diseñado e implementado por Walter Dörwald)</p>
</li>
<li><p>El módulo <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> ha ganado un nuevo tipo, <code class="xref py py-class docutils literal notranslate"><span class="pre">defaultdict</span></code>, que subclasifica el tipo estándar <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>.  El nuevo tipo se comporta principalmente como un diccionario pero construye un valor por defecto cuando una clave no está presente, añadiéndolo automáticamente al diccionario para el valor de la clave solicitada.</p>
<p>El primer argumento del constructor de <code class="xref py py-class docutils literal notranslate"><span class="pre">defaultdict</span></code> es una función de fábrica que se llama cada vez que se solicita una clave pero no se encuentra. Esta función de fábrica no recibe argumentos, por lo que puede utilizar constructores de tipo incorporado como <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-func docutils literal notranslate"><span class="pre">list()</span></code></a> o <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>.  Por ejemplo, puedes hacer un índice de palabras basado en su letra inicial así:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">words</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Nel mezzo del cammin di nostra vita</span>
<span class="s2">mi ritrovai per una selva oscura</span>
<span class="s2">che la diritta via era smarrita&quot;&quot;&quot;</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

<span class="n">index</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

<span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
    <span class="n">init_letter</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">index</span><span class="p">[</span><span class="n">init_letter</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
<p>Al imprimir <code class="docutils literal notranslate"><span class="pre">index</span></code> se obtiene la siguiente salida:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">defaultdict</span><span class="p">(</span><span class="o">&lt;</span><span class="nb">type</span> <span class="s1">&#39;list&#39;</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;cammin&#39;</span><span class="p">,</span> <span class="s1">&#39;che&#39;</span><span class="p">],</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;era&#39;</span><span class="p">],</span>
        <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;del&#39;</span><span class="p">,</span> <span class="s1">&#39;di&#39;</span><span class="p">,</span> <span class="s1">&#39;diritta&#39;</span><span class="p">],</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;mezzo&#39;</span><span class="p">,</span> <span class="s1">&#39;mi&#39;</span><span class="p">],</span>
        <span class="s1">&#39;l&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;la&#39;</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;oscura&#39;</span><span class="p">],</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;nel&#39;</span><span class="p">,</span> <span class="s1">&#39;nostra&#39;</span><span class="p">],</span>
        <span class="s1">&#39;p&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;per&#39;</span><span class="p">],</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;selva&#39;</span><span class="p">,</span> <span class="s1">&#39;smarrita&#39;</span><span class="p">],</span>
        <span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;ritrovai&#39;</span><span class="p">],</span> <span class="s1">&#39;u&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;una&#39;</span><span class="p">],</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;vita&#39;</span><span class="p">,</span> <span class="s1">&#39;via&#39;</span><span class="p">]}</span>
</pre></div>
</div>
<p>(Contribución de Guido van Rossum.)</p>
</li>
<li><p>El tipo de cola doble <code class="xref py py-class docutils literal notranslate"><span class="pre">deque</span></code> suministrado por el módulo <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> tiene ahora un método <code class="docutils literal notranslate"><span class="pre">remove(value)</span></code> que elimina la primera aparición de <em>value</em> en la cola, lanzando <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> si no se encuentra el valor. (Contribución de Raymond Hettinger)</p></li>
<li><p>Nuevo módulo: El módulo <a class="reference internal" href="../library/contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code></a> contiene funciones de ayuda para usar con la nueva sentencia “<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>”.  Consulte la sección <a class="reference internal" href="#contextlibmod"><span class="std std-ref">El módulo contextlib</span></a> para obtener más información sobre este módulo.</p></li>
<li><p>Nuevo módulo: El módulo <a class="reference internal" href="../library/profile.html#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a> es una implementación en C del módulo existente <a class="reference internal" href="../library/profile.html#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a> que tiene una sobrecarga mucho menor. La interfaz del módulo es la misma que la de <a class="reference internal" href="../library/profile.html#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>: se ejecuta <code class="docutils literal notranslate"><span class="pre">cProfile.run('main()')</span></code> para perfilar una función, se pueden guardar los datos del perfil en un archivo, etc.  Todavía no se sabe si el perfilador Hotshot, que también está escrito en C pero no coincide con la interfaz del módulo <a class="reference internal" href="../library/profile.html#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>, seguirá manteniéndose en futuras versiones de Python.  (Contribución de Armin Rigo.)</p>
<p>Además, el módulo <a class="reference internal" href="../library/profile.html#module-pstats" title="pstats: Statistics object for use with the profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pstats</span></code></a> para analizar los datos medidos por el perfilador ahora soporta dirigir la salida a cualquier objeto archivo suministrando un argumento <em>stream</em> al constructor <code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code>. (Contribución de Skip Montanaro)</p>
</li>
<li><p>The <a class="reference internal" href="../library/csv.html#module-csv" title="csv: Write and read tabular data to and from delimited files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">csv</span></code></a> module, which parses files in comma-separated value format,
received several enhancements and a number of bugfixes.  You can now set the
maximum size in bytes of a field by calling the
<code class="docutils literal notranslate"><span class="pre">csv.field_size_limit(new_limit)</span></code> function; omitting the <em>new_limit</em>
argument will return the currently set limit.  The <code class="xref py py-class docutils literal notranslate"><span class="pre">reader</span></code> class now has
a <code class="xref py py-attr docutils literal notranslate"><span class="pre">line_num</span></code> attribute that counts the number of physical lines read from
the source; records can span multiple physical lines, so <code class="xref py py-attr docutils literal notranslate"><span class="pre">line_num</span></code> is not
the same as the number of records read.</p>
<p>El analizador CSV es ahora más estricto con los campos entrecomillados de varias líneas. Anteriormente, si una línea terminaba dentro de un campo entre comillas sin un carácter de nueva línea final, se insertaba una nueva línea en el campo devuelto. Este comportamiento causaba problemas cuando se leían archivos que contenían caracteres de retorno de carro dentro de los campos, por lo que se cambió el código para devolver el campo sin insertar nuevas líneas. Como consecuencia, si las nuevas líneas incrustadas dentro de los campos son importantes, la entrada debe dividirse en líneas de manera que se conserven los caracteres de nueva línea.</p>
<p>(Contribución de Skip Montanaro y Andrew McNamara)</p>
</li>
<li><p>La clase <a class="reference internal" href="../library/datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a> del módulo <a class="reference internal" href="../library/datetime.html#module-datetime" title="datetime: Basic date and time types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">datetime</span></code></a> tiene ahora un método <code class="docutils literal notranslate"><span class="pre">strptime(string,</span> <span class="pre">format)</span></code> para analizar cadenas de fechas, aportado por Josh Spoerri. Utiliza los mismos caracteres de formato que <a class="reference internal" href="../library/time.html#time.strptime" title="time.strptime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.strptime()</span></code></a> y <a class="reference internal" href="../library/time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.strftime()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>

<span class="n">ts</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="s1">&#39;10:13:15 2006-03-07&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;%H:%M:%S %Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>El método <code class="xref py py-meth docutils literal notranslate"><span class="pre">SequenceMatcher.get_matching_blocks()</span></code> del módulo <a class="reference internal" href="../library/difflib.html#module-difflib" title="difflib: Helpers for computing differences between objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code></a> garantiza ahora la devolución de una lista mínima de bloques que describen subsecuencias coincidentes.  Anteriormente, el algoritmo rompía ocasionalmente un bloque de elementos coincidentes en dos entradas de la lista. (Mejora realizada por Tim Peters)</p></li>
<li><p>El módulo <a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> ha ganado una opción <code class="docutils literal notranslate"><span class="pre">SKIP</span></code> que impide que un ejemplo se ejecute en absoluto.  Esto está pensado para los fragmentos de código que son ejemplos de uso destinados al lector y que no son realmente casos de prueba.</p>
<p>Se ha añadido un parámetro <em>encoding</em> a la función <code class="xref py py-func docutils literal notranslate"><span class="pre">testfile()</span></code> y a la clase <code class="xref py py-class docutils literal notranslate"><span class="pre">DocFileSuite</span></code> para especificar la codificación del archivo.  Esto facilita el uso de caracteres no ASCII en las pruebas contenidas en un docstring. (Contribución de Bjorn Tillenius)</p>
</li>
<li><p>El paquete <a class="reference internal" href="../library/email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> ha sido actualizado a la versión 4.0. (Contribución de Barry Warsaw.)</p>
</li>
<li id="index-20"><p>El módulo <a class="reference internal" href="../library/fileinput.html#module-fileinput" title="fileinput: Loop over standard input or a list of files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">fileinput</span></code></a> se ha hecho más flexible. Ahora se soportan los nombres de archivo Unicode, y se ha añadido un parámetro <em>mode</em> que por defecto es <code class="docutils literal notranslate"><span class="pre">&quot;r&quot;</span></code> a la función <a class="reference internal" href="../library/functions.html#input" title="input"><code class="xref py py-func docutils literal notranslate"><span class="pre">input()</span></code></a> para permitir la apertura de archivos en modo binario o <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a>.  Otro nuevo parámetro, <em>openhook</em>, permite utilizar una función distinta de <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> para abrir los ficheros de entrada.  Una vez que se itera sobre el conjunto de archivos, el nuevo <code class="xref py py-meth docutils literal notranslate"><span class="pre">fileno()</span></code> del objeto <code class="xref py py-class docutils literal notranslate"><span class="pre">FileInput</span></code> devuelve el descriptor de archivo del archivo actualmente abierto. (Contribuido por Georg Brandl.)</p></li>
<li><p>En el módulo <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a>, la nueva función <code class="xref py py-func docutils literal notranslate"><span class="pre">get_count()</span></code> devuelve una 3-tupla que contiene los recuentos de recolección actuales para las tres generaciones de GC.  Se trata de información contable para el recolector de basura; cuando estos recuentos alcanzan un umbral especificado, se realiza un barrido de recolección de basura.  La función <a class="reference internal" href="../library/gc.html#gc.collect" title="gc.collect"><code class="xref py py-func docutils literal notranslate"><span class="pre">gc.collect()</span></code></a> existente ahora toma un argumento opcional <em>generación</em> de 0, 1 o 2 para especificar qué generación recoger. (Contribución de Barry Warsaw)</p></li>
<li><p>Las funciones <code class="xref py py-func docutils literal notranslate"><span class="pre">nsmallest()</span></code> y <code class="xref py py-func docutils literal notranslate"><span class="pre">nlargest()</span></code> del módulo <a class="reference internal" href="../library/heapq.html#module-heapq" title="heapq: Heap queue algorithm (a.k.a. priority queue)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">heapq</span></code></a> soportan ahora un parámetro de palabra clave <code class="docutils literal notranslate"><span class="pre">key</span></code> similar al proporcionado por las funciones <a class="reference internal" href="../library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>/<a class="reference internal" href="../library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a> y los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code>.  Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">heapq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;short&quot;</span><span class="p">,</span> <span class="s1">&#39;medium&#39;</span><span class="p">,</span> <span class="s1">&#39;longest&#39;</span><span class="p">,</span> <span class="s1">&#39;longer still&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heapq</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>  <span class="c1"># Return two lowest elements, lexicographically</span>
<span class="go">[&#39;longer still&#39;, &#39;longest&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heapq</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>   <span class="c1"># Return two shortest elements</span>
<span class="go">[&#39;short&#39;, &#39;medium&#39;]</span>
</pre></div>
</div>
<p>(Contribución de Raymond Hettinger.)</p>
</li>
<li><p>La función <a class="reference internal" href="../library/itertools.html#itertools.islice" title="itertools.islice"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.islice()</span></code></a> ahora acepta <code class="docutils literal notranslate"><span class="pre">None</span></code> para los argumentos de inicio y paso.  Esto la hace más compatible con los atributos de los objetos slice, por lo que ahora se puede escribir lo siguiente:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>     <span class="c1"># Create slice object</span>
<span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
</pre></div>
</div>
<p>(Contribución de Raymond Hettinger.)</p>
</li>
<li><p>Se ha modificado la función <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> del módulo <a class="reference internal" href="../library/locale.html#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">locale</span></code></a> y se han añadido dos nuevas funciones, <code class="xref py py-func docutils literal notranslate"><span class="pre">format_string()</span></code> y <code class="xref py py-func docutils literal notranslate"><span class="pre">currency()</span></code>.</p>
<p>El parámetro <em>val</em> de la función <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> podía ser antes una cadena siempre que no apareciera más de un especificador %char; ahora el parámetro debe ser exactamente un especificador %char sin texto alrededor.  También se ha añadido un parámetro opcional <em>monetario</em> que, si es <code class="docutils literal notranslate"><span class="pre">Verdadero</span></code>, utilizará las reglas de la configuración regional para formatear la moneda al colocar un separador entre grupos de tres dígitos.</p>
<p>Para formatear cadenas con múltiples especificadores %char, utilice la nueva función <code class="xref py py-func docutils literal notranslate"><span class="pre">format_string()</span></code> que funciona como <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> pero que también permite mezclar especificadores %char con texto arbitrario.</p>
<p>También se ha añadido una nueva función <code class="xref py py-func docutils literal notranslate"><span class="pre">currency()</span></code> que formatea un número de acuerdo con la configuración local actual.</p>
<p>(Contribución de Georg Brandl.)</p>
</li>
<li><p>El módulo <a class="reference internal" href="../library/mailbox.html#module-mailbox" title="mailbox: Manipulate mailboxes in various formats"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mailbox</span></code></a> ha sido reestructurado de forma masiva para añadir la capacidad de modificar los buzones además de leerlos.  Un nuevo conjunto de clases que incluyen <code class="xref py py-class docutils literal notranslate"><span class="pre">mbox</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">MH</span></code>, y <code class="xref py py-class docutils literal notranslate"><span class="pre">Maildir</span></code> se utilizan para leer buzones, y tienen un método <code class="docutils literal notranslate"><span class="pre">add(message)</span></code> para añadir mensajes, <code class="docutils literal notranslate"><span class="pre">remove(key)</span></code> para eliminar mensajes, y <code class="xref py py-meth docutils literal notranslate"><span class="pre">lock()</span></code>/<code class="xref py py-meth docutils literal notranslate"><span class="pre">unlock()</span></code> para bloquear/desbloquear el buzón. El siguiente ejemplo convierte un buzón con formato maildir en uno con formato mbox:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">mailbox</span>

<span class="c1"># &#39;factory=None&#39; uses email.Message.Message as the class representing</span>
<span class="c1"># individual messages.</span>
<span class="n">src</span> <span class="o">=</span> <span class="n">mailbox</span><span class="o">.</span><span class="n">Maildir</span><span class="p">(</span><span class="s1">&#39;maildir&#39;</span><span class="p">,</span> <span class="n">factory</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="n">dest</span> <span class="o">=</span> <span class="n">mailbox</span><span class="o">.</span><span class="n">mbox</span><span class="p">(</span><span class="s1">&#39;/tmp/mbox&#39;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
    <span class="n">dest</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</pre></div>
</div>
<p>(Contribución de Gregory K. Johnson.  La financiación fue proporcionada por el Summer of Code 2005 de Google)</p>
</li>
<li><p>Nuevo módulo: el módulo <a class="reference internal" href="../library/msilib.html#module-msilib" title="msilib: Creation of Microsoft Installer files, and CAB files. (obsoleto) (Windows)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">msilib</span></code></a> permite crear archivos <code class="file docutils literal notranslate"><span class="pre">.msi</span></code> de Microsoft Installer y archivos CAB.  También se incluye soporte para la lectura de la base de datos <code class="file docutils literal notranslate"><span class="pre">.msi</span></code>. (Contribución de Martin von Löwis)</p></li>
<li><p>El módulo <a class="reference internal" href="../library/nis.html#module-nis" title="nis: Interface to Sun's NIS (Yellow Pages) library. (obsoleto) (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nis</span></code></a> soporta ahora el acceso a dominios distintos del dominio por defecto del sistema proporcionando un argumento <em>dominio</em> a las funciones <a class="reference internal" href="../library/nis.html#nis.match" title="nis.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">nis.match()</span></code></a> y <a class="reference internal" href="../library/nis.html#nis.maps" title="nis.maps"><code class="xref py py-func docutils literal notranslate"><span class="pre">nis.maps()</span></code></a>. (Contribución de Ben Bell)</p></li>
<li><p>Las funciones <a class="reference internal" href="../library/operator.html#module-operator" title="operator: Functions corresponding to the standard operators."><code class="xref py py-mod docutils literal notranslate"><span class="pre">operator</span></code></a> del módulo <code class="xref py py-func docutils literal notranslate"><span class="pre">itemgetter()</span></code> y <code class="xref py py-func docutils literal notranslate"><span class="pre">attrgetter()</span></code> ahora soportan múltiples campos.   Una llamada como <code class="docutils literal notranslate"><span class="pre">operator.attrgetter('a',</span> <span class="pre">'b')</span></code> devolverá una función que recupera los atributos <code class="xref py py-attr docutils literal notranslate"><span class="pre">a</span></code> y <code class="xref py py-attr docutils literal notranslate"><span class="pre">b</span></code>.  La combinación de esta nueva función con el parámetro <code class="docutils literal notranslate"><span class="pre">key</span></code> del método <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code> permite ordenar fácilmente las listas utilizando varios campos. (Contribución de Raymond Hettinger)</p></li>
<li><p>El módulo <a class="reference internal" href="../library/optparse.html#module-optparse" title="optparse: Command-line option parsing library. (obsoleto)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">optparse</span></code></a> se ha actualizado a la versión 1.5.1 de la biblioteca Optik. La clase <code class="xref py py-class docutils literal notranslate"><span class="pre">OptionParser</span></code> obtuvo un atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">epilog</span></code>, una cadena que se imprimirá después del mensaje de ayuda, y un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">destroy()</span></code> para romper los ciclos de referencia creados por el objeto. (Contribuido por Greg Ward.)</p></li>
<li><p>El módulo <a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a> ha sufrido varios cambios.  La variable <code class="xref py py-attr docutils literal notranslate"><span class="pre">stat_float_times</span></code> ahora está predeterminada a true, lo que significa que <a class="reference internal" href="../library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a> ahora devolverá los valores de tiempo como flotantes.  (Esto no significa necesariamente que <a class="reference internal" href="../library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a> devolverá tiempos con una precisión de fracciones de segundo; no todos los sistemas soportan dicha precisión)</p>
<p>Se han añadido las constantes <a class="reference internal" href="../library/os.html#os.SEEK_SET" title="os.SEEK_SET"><code class="xref py py-attr docutils literal notranslate"><span class="pre">os.SEEK_SET</span></code></a>, <a class="reference internal" href="../library/os.html#os.SEEK_CUR" title="os.SEEK_CUR"><code class="xref py py-attr docutils literal notranslate"><span class="pre">os.SEEK_CUR</span></code></a> y <a class="reference internal" href="../library/os.html#os.SEEK_END" title="os.SEEK_END"><code class="xref py py-attr docutils literal notranslate"><span class="pre">os.SEEK_END</span></code></a>, que son los parámetros de la función <a class="reference internal" href="../library/os.html#os.lseek" title="os.lseek"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.lseek()</span></code></a>.  Dos nuevas constantes para el bloqueo son <a class="reference internal" href="../library/os.html#os.O_SHLOCK" title="os.O_SHLOCK"><code class="xref py py-attr docutils literal notranslate"><span class="pre">os.O_SHLOCK</span></code></a> y <a class="reference internal" href="../library/os.html#os.O_EXLOCK" title="os.O_EXLOCK"><code class="xref py py-attr docutils literal notranslate"><span class="pre">os.O_EXLOCK</span></code></a>.</p>
<p>Se han añadido dos nuevas funciones, <code class="xref py py-func docutils literal notranslate"><span class="pre">wait3()</span></code> y <code class="xref py py-func docutils literal notranslate"><span class="pre">wait4()</span></code>.  Son similares a la función <code class="xref py py-func docutils literal notranslate"><span class="pre">waitpid()</span></code> que espera la salida de un proceso hijo y devuelve una tupla con el ID del proceso y su estado de salida, pero <code class="xref py py-func docutils literal notranslate"><span class="pre">wait3()</span></code> y <code class="xref py py-func docutils literal notranslate"><span class="pre">wait4()</span></code> devuelven información adicional.  <code class="xref py py-func docutils literal notranslate"><span class="pre">wait3()</span></code> no toma un ID de proceso como entrada, por lo que espera a que cualquier proceso hijo salga y devuelve una tupla de <em>id de proceso</em>, <em>estado de salida</em>, <em>uso de recursos</em> tal y como se devuelve desde la función <a class="reference internal" href="../library/resource.html#resource.getrusage" title="resource.getrusage"><code class="xref py py-func docutils literal notranslate"><span class="pre">resource.getrusage()</span></code></a>. <code class="docutils literal notranslate"><span class="pre">wait4(pid)</span></code> toma un ID de proceso. (Contribuido por Chad J. Schroeder.)</p>
<p>En FreeBSD, la función <a class="reference internal" href="../library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a> devuelve ahora tiempos con resolución de nanosegundos, y el objeto devuelto tiene ahora <code class="xref py py-attr docutils literal notranslate"><span class="pre">st_gen</span></code> y <code class="xref py py-attr docutils literal notranslate"><span class="pre">st_birthtime</span></code>. El atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">st_flags</span></code> también está disponible, si la plataforma lo soporta. (Contribución de Antti Louko y Diego Pettenò)</p>
</li>
<li><p>El depurador de Python proporcionado por el módulo <a class="reference internal" href="../library/pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a> puede ahora almacenar listas de comandos a ejecutar cuando se alcanza un punto de ruptura y se detiene la ejecución.  Una vez creado el punto de interrupción nº 1, introduzca <code class="docutils literal notranslate"><span class="pre">comandos</span> <span class="pre">1</span></code> e introduzca una serie de comandos a ejecutar, terminando la lista con <code class="docutils literal notranslate"><span class="pre">end</span></code>.  La lista de comandos puede incluir comandos que reanuden la ejecución, como <code class="docutils literal notranslate"><span class="pre">continue</span></code> o <code class="docutils literal notranslate"><span class="pre">next</span></code>. (Contribución de Grégoire Dooms.)</p>
</li>
<li><p>Los módulos <a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> y <code class="xref py py-mod docutils literal notranslate"><span class="pre">cPickle</span></code> ya no aceptan un valor de retorno de <code class="docutils literal notranslate"><span class="pre">None</span></code> del método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code>; el método debe devolver una tupla de argumentos.  La capacidad de devolver <code class="docutils literal notranslate"><span class="pre">None</span></code> fue obsoleta en Python 2.4, así que esto completa la eliminación de la función.</p></li>
<li><p>El módulo <a class="reference internal" href="../library/pkgutil.html#module-pkgutil" title="pkgutil: Utilities for the import system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pkgutil</span></code></a>, que contiene varias funciones de utilidad para encontrar paquetes, fue mejorado para soportar los ganchos de importación de <span class="target" id="index-80"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a> y ahora también funciona para paquetes almacenados en archivos con formato ZIP. (Contribución de Phillip J. Eby)</p></li>
<li><p>El conjunto de pruebas pybench de Marc-André Lemburg se incluye ahora en el directorio <code class="file docutils literal notranslate"><span class="pre">Tools/pybench</span></code>.  El conjunto de pruebas pybench es una mejora del programa <code class="file docutils literal notranslate"><span class="pre">pystone.py</span></code> de uso común, ya que pybench proporciona una medición más detallada de la velocidad del intérprete.  Calcula el tiempo de determinadas operaciones como las llamadas a funciones, el corte de tuplas, las búsquedas de métodos y las operaciones numéricas, en lugar de realizar muchas operaciones diferentes y reducir el resultado a un único número como hace <code class="file docutils literal notranslate"><span class="pre">pystone.py</span></code>.</p></li>
<li><p>El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">pyexpat</span></code> utiliza ahora la versión 2.0 del analizador sintáctico Expat. (Contribución de Trent Mick)</p></li>
<li><p>La clase <a class="reference internal" href="../library/queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> proporcionada por el módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">Queue</span></code> ha ganado dos nuevos métodos. <code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code> bloquea hasta que todos los elementos de la cola han sido recuperados y todo el trabajo de procesamiento de los elementos ha sido completado.  Los hilos de trabajo llaman al otro método nuevo, <code class="xref py py-meth docutils literal notranslate"><span class="pre">task_done()</span></code>, para indicar que el procesamiento de un elemento ha finalizado.  (Contribución de Raymond Hettinger)</p></li>
<li><p>Los antiguos módulos <code class="xref py py-mod docutils literal notranslate"><span class="pre">regex</span></code> y <code class="xref py py-mod docutils literal notranslate"><span class="pre">regsub</span></code>, obsoletos desde Python 2.0, han sido finalmente eliminados.   Otros módulos eliminados: <code class="xref py py-mod docutils literal notranslate"><span class="pre">statcache</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">tzparse</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">whrandom</span></code>.</p></li>
<li><p>También se ha eliminado el directorio <code class="file docutils literal notranslate"><span class="pre">lib-old</span></code>, que incluye módulos antiguos como <code class="xref py py-mod docutils literal notranslate"><span class="pre">dircmp</span></code> y <code class="xref py py-mod docutils literal notranslate"><span class="pre">ni</span></code>. <code class="file docutils literal notranslate"><span class="pre">lib-old</span></code> no estaba en el directorio por defecto <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>, así que a menos que tus programas añadan explícitamente el directorio a <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>, esta eliminación no debería afectar a tu código.</p></li>
<li><p>El módulo <a class="reference internal" href="../library/rlcompleter.html#module-rlcompleter" title="rlcompleter: Python identifier completion, suitable for the GNU readline library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">rlcompleter</span></code></a> ya no depende de la importación del módulo <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a> y, por lo tanto, ahora funciona en plataformas no Unix. (Parche de Robert Kiendl.)</p>
</li>
<li><p>Las clases <code class="xref py py-mod docutils literal notranslate"><span class="pre">SimpleXMLRPCServer</span></code> y <code class="xref py py-mod docutils literal notranslate"><span class="pre">DocXMLRPCServer</span></code> tienen ahora un atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">rpc_paths</span></code> que restringe las operaciones XML-RPC a un conjunto limitado de rutas URL; por defecto sólo se permiten <code class="docutils literal notranslate"><span class="pre">'/'</span></code> y <code class="docutils literal notranslate"><span class="pre">'/RPC2'</span></code>.  Establecer <code class="xref py py-attr docutils literal notranslate"><span class="pre">rpc_paths</span></code> como <code class="docutils literal notranslate"><span class="pre">None</span></code> o una tupla vacía desactiva esta comprobación de rutas.</p>
</li>
<li><p>El módulo <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> ahora soporta sockets <code class="xref py py-const docutils literal notranslate"><span class="pre">AF_NETLINK</span></code> en Linux, gracias a un parche de Philippe Biondi.   Los sockets Netlink son un mecanismo específico de Linux para las comunicaciones entre un proceso en el espacio del usuario y el código del kernel; hay un artículo introductorio sobre ellos en <a class="reference external" href="https://www.linuxjournal.com/article/7356">https://www.linuxjournal.com/article/7356</a>. En el código Python, las direcciones de netlink se representan como una tupla de 2 enteros, <code class="docutils literal notranslate"><span class="pre">(pid,</span> <span class="pre">group_mask)</span></code>.</p>
<p>Dos nuevos métodos en objetos socket, <code class="docutils literal notranslate"><span class="pre">recv_into(buffer)</span></code> y <code class="docutils literal notranslate"><span class="pre">recvrom_into(buffer)</span></code>, almacenan los datos recibidos en un objeto que soporta el protocolo de buffer en lugar de devolver los datos como una cadena.  Esto significa que puedes poner los datos directamente en un array o en un archivo mapeado en memoria.</p>
<p>Los objetos Socket también han ganado métodos de acceso <code class="xref py py-meth docutils literal notranslate"><span class="pre">getfamily()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">gettype()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">getproto()</span></code> para recuperar los valores de familia, tipo y protocolo del socket.</p>
</li>
<li><p>Nuevo módulo: el módulo <a class="reference internal" href="../library/spwd.html#module-spwd" title="spwd: The shadow password database (getspnam() and friends). (obsoleto) (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">spwd</span></code></a> proporciona funciones para acceder a la base de datos de contraseñas en la sombra en sistemas que soportan contraseñas en la sombra.</p></li>
<li><p>El módulo <a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> es ahora más rápido porque compila cadenas de formato en objetos <code class="xref py py-class docutils literal notranslate"><span class="pre">Struct</span></code> con métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">pack()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">unpack()</span></code>.  Esto es similar a cómo el módulo <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> permite crear objetos de expresión regular compilados.  Puede seguir utilizando las funciones <code class="xref py py-func docutils literal notranslate"><span class="pre">pack()</span></code> y <code class="xref py py-func docutils literal notranslate"><span class="pre">unpack()</span></code> a nivel de módulo; éstas crearán objetos <code class="xref py py-class docutils literal notranslate"><span class="pre">Struct</span></code> y los almacenarán en caché.  O puede utilizar directamente las instancias de <code class="xref py py-class docutils literal notranslate"><span class="pre">Struct</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">Struct</span><span class="p">(</span><span class="s1">&#39;ih3s&#39;</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="mi">1972</span><span class="p">,</span> <span class="mi">187</span><span class="p">,</span> <span class="s1">&#39;abc&#39;</span><span class="p">)</span>
<span class="n">year</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>También puedes empaquetar y desempaquetar datos hacia y desde objetos buffer directamente usando los métodos <code class="docutils literal notranslate"><span class="pre">pack_into(buffer,</span> <span class="pre">offset,</span> <span class="pre">v1,</span> <span class="pre">v2,</span> <span class="pre">...)</span></code> y <code class="docutils literal notranslate"><span class="pre">unpack_from(buffer,</span> <span class="pre">offset)</span></code>.  Esto te permite almacenar datos directamente en un array o en un archivo mapeado en memoria.</p>
<p>(<code class="xref py py-class docutils literal notranslate"><span class="pre">Struct</span></code> objects fueron implementados por Bob Ippolito en el sprint NeedForSpeed.  El soporte para los objetos buffer fue añadido por Martin Blais, también en el sprint NeedForSpeed)</p>
</li>
<li><p>Los desarrolladores de Python cambiaron de CVS a Subversion durante el proceso de desarrollo de la versión 2.5.  La información sobre la versión exacta de construcción está disponible como la variable <code class="docutils literal notranslate"><span class="pre">sys.subversion</span></code>, una 3-tupla de <code class="docutils literal notranslate"><span class="pre">(nombre</span> <span class="pre">del</span> <span class="pre">intérprete,</span> <span class="pre">nombre</span> <span class="pre">de</span> <span class="pre">la</span> <span class="pre">rama,</span> <span class="pre">rango</span> <span class="pre">de</span> <span class="pre">revisión)</span></code>.  Por ejemplo, en el momento de escribir esto, mi copia de 2.5 informaba de <code class="docutils literal notranslate"><span class="pre">('CPython',</span> <span class="pre">'trunk',</span> <span class="pre">'45313:45315')</span></code>.</p>
<p>Esta información también está disponible para las extensiones de C a través de la función <a class="reference internal" href="../c-api/init.html#c.Py_GetBuildInfo" title="Py_GetBuildInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetBuildInfo()</span></code></a> que devuelve una cadena de información de compilación como esta <code class="docutils literal notranslate"><span class="pre">&quot;trunk:45355:45356M,</span> <span class="pre">Apr</span> <span class="pre">13</span> <span class="pre">2006,</span> <span class="pre">07:42:19&quot;</span></code>.   (Contribuido por Barry Warsaw.)</p>
</li>
<li><p>Otra nueva función, <a class="reference internal" href="../library/sys.html#sys._current_frames" title="sys._current_frames"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys._current_frames()</span></code></a>, devuelve los marcos de pila actuales para todos los hilos en ejecución como un diccionario que asigna los identificadores de los hilos al marco de pila superior actualmente activo en ese hilo en el momento en que se llama a la función.  (Contribuido por Tim Peters.)</p></li>
<li><p>La clase <code class="xref py py-class docutils literal notranslate"><span class="pre">TarFile</span></code> del módulo <a class="reference internal" href="../library/tarfile.html#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> tiene ahora un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">extractall()</span></code> que extrae todos los miembros del archivo en el directorio de trabajo actual.  También es posible establecer un directorio diferente como destino de la extracción, y desempaquetar sólo un subconjunto de los miembros del archivo.</p>
<p>La compresión utilizada para un archivo tar abierto en modo stream puede ahora ser autodetectada utilizando el modo <code class="docutils literal notranslate"><span class="pre">'r|*'</span></code>. (Contribución de Lars Gustäbel)</p>
</li>
<li><p>El módulo <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> permite ahora establecer el tamaño de la pila utilizado cuando se crean nuevos hilos. La función <code class="docutils literal notranslate"><span class="pre">stack_size([*size*])</span></code> devuelve el tamaño de pila actualmente configurado, y suministrando el parámetro opcional <em>size</em> establece un nuevo valor.  No todas las plataformas soportan el cambio del tamaño de la pila, pero Windows, POSIX threading y OS/2 lo hacen. (Contribución de Andrew MacIntyre)</p>
</li>
<li><p>El módulo <a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code></a> ha sido actualizado para utilizar la versión 4.1.0 de la base de datos de caracteres Unicode.  La versión 3.2.0 es requerida por algunas especificaciones, por lo que sigue estando disponible como <a class="reference internal" href="../library/unicodedata.html#unicodedata.ucd_3_2_0" title="unicodedata.ucd_3_2_0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unicodedata.ucd_3_2_0</span></code></a>.</p></li>
<li><p>Nuevo módulo: el módulo <a class="reference internal" href="../library/uuid.html#module-uuid" title="uuid: UUID objects (universally unique identifiers) according to RFC 4122"><code class="xref py py-mod docutils literal notranslate"><span class="pre">uuid</span></code></a> genera identificadores únicos universales (UUID) de acuerdo con <span class="target" id="index-81"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4122.html"><strong>RFC 4122</strong></a>.  El RFC define varias versiones diferentes de UUID que se generan a partir de una cadena inicial, de propiedades del sistema o de forma puramente aleatoria.  Este módulo contiene una clase <code class="xref py py-class docutils literal notranslate"><span class="pre">UUID</span></code> y funciones llamadas <code class="xref py py-func docutils literal notranslate"><span class="pre">uuid1()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">uuid3()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">uuid4()</span></code>, y <code class="xref py py-func docutils literal notranslate"><span class="pre">uuid5()</span></code> para generar diferentes versiones de UUID.  (Los UUID de la versión 2 no se especifican en <span class="target" id="index-82"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4122.html"><strong>RFC 4122</strong></a> y no están soportados por este módulo)</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">uuid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># make a UUID based on the host ID and current time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid1</span><span class="p">()</span>
<span class="go">UUID(&#39;a8098c1a-f86e-11da-bd1a-00112444be1e&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># make a UUID using an MD5 hash of a namespace UUID and a name</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid3</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">NAMESPACE_DNS</span><span class="p">,</span> <span class="s1">&#39;python.org&#39;</span><span class="p">)</span>
<span class="go">UUID(&#39;6fa459ea-ee8a-3ca4-894e-db77e160355e&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># make a random UUID</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()</span>
<span class="go">UUID(&#39;16fd2706-8baf-433b-82eb-8c7fada847da&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># make a UUID using a SHA-1 hash of a namespace UUID and a name</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid5</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">NAMESPACE_DNS</span><span class="p">,</span> <span class="s1">&#39;python.org&#39;</span><span class="p">)</span>
<span class="go">UUID(&#39;886313e1-3b8a-5372-9b90-0c9aee199e5d&#39;)</span>
</pre></div>
</div>
<p>(Contribución de Ka-Ping Yee.)</p>
</li>
<li><p>Los tipos <a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weakref</span></code></a> del módulo <code class="xref py py-class docutils literal notranslate"><span class="pre">WeakKeyDictionary</span></code> y <code class="xref py py-class docutils literal notranslate"><span class="pre">WeakValueDictionary</span></code> han obtenido nuevos métodos para iterar sobre las referencias débiles contenidas en el diccionario. Se han añadido los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">iterkeyrefs()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">keyrefs()</span></code> a <code class="xref py py-class docutils literal notranslate"><span class="pre">WeakKeyDictionary</span></code>, y <code class="xref py py-meth docutils literal notranslate"><span class="pre">itervaluerefs()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">valuerefs()</span></code> a <code class="xref py py-class docutils literal notranslate"><span class="pre">WeakValueDictionary</span></code>.  (Contribución de Fred L. Drake, Jr.)</p></li>
<li><p>El módulo <a class="reference internal" href="../library/webbrowser.html#module-webbrowser" title="webbrowser: Easy-to-use controller for web browsers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">webbrowser</span></code></a> ha recibido una serie de mejoras. Ahora se puede utilizar como un script con <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">webbrowser</span></code>, tomando una URL como argumento; hay una serie de interruptores para controlar el comportamiento (<code class="xref std std-option docutils literal notranslate"><span class="pre">-n</span></code> para una nueva ventana del navegador, <code class="xref std std-option docutils literal notranslate"><span class="pre">-t</span></code> para una nueva pestaña).  Se han añadido nuevas funciones a nivel de módulo, <code class="xref py py-func docutils literal notranslate"><span class="pre">open_new()</span></code> y <code class="xref py py-func docutils literal notranslate"><span class="pre">open_new_tab()</span></code>, para soportar esto.  La función <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> del módulo soporta una característica adicional, un parámetro <em>autoraise</em> que señala si se debe levantar la ventana abierta cuando sea posible. Se añadieron varios navegadores adicionales a la lista de soportados, como Firefox, Opera, Konqueror y elinks.  (Contribución de Oleg Broytmann y Georg Brandl)</p>
</li>
<li><p>El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpclib</span></code> ahora soporta la devolución de objetos <a class="reference internal" href="../library/datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a> para el tipo de fecha XML-RPC.  Proporcione <code class="docutils literal notranslate"><span class="pre">use_datetime=True</span></code> a la función <code class="xref py py-func docutils literal notranslate"><span class="pre">loads()</span></code> o a la clase <code class="xref py py-class docutils literal notranslate"><span class="pre">Unmarshaller</span></code> para activar esta característica. (Contribución de Skip Montanaro)</p>
</li>
<li><p>El módulo <a class="reference internal" href="../library/zipfile.html#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a> ahora soporta la versión ZIP64 del formato, lo que significa que un archivo .zip ahora puede ser mayor de 4 GiB y puede contener archivos individuales mayores de 4 GiB.  (Contribución de Ronald Oussoren)</p>
</li>
<li><p>Los objetos <a class="reference internal" href="../library/zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-class docutils literal notranslate"><span class="pre">zlib</span></code></a> y <code class="xref py py-class docutils literal notranslate"><span class="pre">Decompress</span></code> del módulo <a class="reference internal" href="../library/zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> soportan ahora un método <a class="reference internal" href="../library/copy.html#module-copy" title="copy: Shallow and deep copy operations."><code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code></a> que realiza una copia del estado interno del objeto y devuelve un nuevo objeto <code class="xref py py-class docutils literal notranslate"><span class="pre">Compress</span></code> o <code class="xref py py-class docutils literal notranslate"><span class="pre">Decompress</span></code>. (Contribución de Chris AtLee)</p>
</li>
</ul>
<section id="the-ctypes-package">
<span id="module-ctypes"></span><h3>El paquete ctypes<a class="headerlink" href="#the-ctypes-package" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El paquete <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>, escrito por Thomas Heller, se ha añadido a la biblioteca estándar. <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> permite llamar a funciones arbitrarias en bibliotecas compartidas o DLL.  Los usuarios veteranos recordarán el módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">dl</span></code>, que proporciona funciones para cargar bibliotecas compartidas y llamar a las funciones que contienen. El paquete <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> es mucho más sofisticado.</p>
<p>Para cargar una biblioteca compartida o DLL, debes crear una instancia de la clase <code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code> y proporcionar el nombre o la ruta de la biblioteca compartida o DLL. Una vez hecho esto, puedes llamar a funciones arbitrarias accediendo a ellas como atributos del objeto <code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">ctypes</span>

<span class="n">libc</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">CDLL</span><span class="p">(</span><span class="s1">&#39;libc.so.6&#39;</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Line of output</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Type constructors for the various C types are provided: <code class="xref py py-func docutils literal notranslate"><span class="pre">c_int()</span></code>,
<code class="xref py py-func docutils literal notranslate"><span class="pre">c_float()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">c_double()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">c_char_p()</span></code> (equivalent to <code class="xref c c-expr docutils literal notranslate"><span class="pre">char</span><span class="pre">*</span></code>), and so forth.  Unlike Python’s types, the C versions are all mutable; you
can assign to their <code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> attribute to change the wrapped value.  Python
integers and strings will be automatically converted to the corresponding C
types, but for other types you  must call the correct type constructor.  (And I
mean <em>must</em>;  getting it wrong will often result in the interpreter crashing
with a segmentation fault.)</p>
<p>No debería usar <code class="xref py py-func docutils literal notranslate"><span class="pre">c_char_p()</span></code> con una cadena de Python cuando la función C vaya a modificar el área de memoria, porque se supone que las cadenas de Python son inmutables; romper esta regla causará errores desconcertantes.  Cuando necesite un área de memoria modificable, utilice <code class="xref py py-func docutils literal notranslate"><span class="pre">create_string_buffer()</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;this is a string&quot;</span>
<span class="n">buf</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">create_string_buffer</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">libc</span><span class="o">.</span><span class="n">strfry</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
</pre></div>
</div>
<p>Se supone que las funciones en C devuelven números enteros, pero se puede establecer el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> del objeto de la función para cambiar esto:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">atof</span><span class="p">(</span><span class="s1">&#39;2.71828&#39;</span><span class="p">)</span>
<span class="go">-1783957616</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">atof</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">atof</span><span class="p">(</span><span class="s1">&#39;2.71828&#39;</span><span class="p">)</span>
<span class="go">2.71828</span>
</pre></div>
</div>
<p><a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> also provides a wrapper for Python’s C API  as the
<code class="docutils literal notranslate"><span class="pre">ctypes.pythonapi</span></code> object.  This object does <em>not</em>  release the global
interpreter lock before calling a function, because the lock must be held when
calling into the interpreter’s code.   There’s a <code class="xref py py-class docutils literal notranslate"><span class="pre">py_object()</span></code> type
constructor that will create a  <code class="xref c c-expr docutils literal notranslate"><a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><span class="pre">PyObject</span></a><span class="pre">*</span></code> pointer.  A simple usage:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">ctypes</span>

<span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">ctypes</span><span class="o">.</span><span class="n">pythonapi</span><span class="o">.</span><span class="n">PyObject_SetItem</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">py_object</span><span class="p">(</span><span class="n">d</span><span class="p">),</span>
          <span class="n">ctypes</span><span class="o">.</span><span class="n">py_object</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">),</span>  <span class="n">ctypes</span><span class="o">.</span><span class="n">py_object</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="c1"># d is now {&#39;abc&#39;, 1}.</span>
</pre></div>
</div>
<p>No olvides usar <code class="xref py py-class docutils literal notranslate"><span class="pre">py_object()</span></code>; si se omite acabas con un fallo de segmentación.</p>
<p><a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> existe desde hace tiempo, pero la gente sigue escribiendo y distribuyendo módulos de extensión codificados a mano porque no se puede confiar en que <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> esté presente. Quizás los desarrolladores empiecen a escribir envoltorios de Python sobre una biblioteca a la que se accede a través de <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> en lugar de módulos de extensión, ahora que <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> está incluido en el núcleo de Python.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><a class="reference external" href="https://web.archive.org/web/20180410025338/http://starship.python.net/crew/theller/ctypes/">https://web.archive.org/web/20180410025338/http://starship.python.net/crew/theller/ctypes/</a></dt><dd><p>The pre-stdlib ctypes web page, with a tutorial, reference, and FAQ.</p>
</dd>
</dl>
<p>La documentación del módulo <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>.</p>
</div>
</section>
<section id="the-elementtree-package">
<span id="module-etree"></span><h3>El paquete ElementTree<a class="headerlink" href="#the-elementtree-package" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Un subconjunto de la biblioteca ElementTree de Fredrik Lundh para el procesamiento de XML se ha añadido a la biblioteca estándar como <code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree</span></code>.  Los módulos disponibles son <code class="xref py py-mod docutils literal notranslate"><span class="pre">ElementTree</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">ElementPath</span></code> y <code class="xref py py-mod docutils literal notranslate"><span class="pre">ElementInclude</span></code> de ElementTree 1.2.6.    También se incluye el módulo acelerador <code class="xref py py-mod docutils literal notranslate"><span class="pre">cElementTree</span></code>.</p>
<p>The rest of this section will provide a brief overview of using ElementTree.
Full documentation for ElementTree is available at
<a class="reference external" href="https://web.archive.org/web/20201124024954/http://effbot.org/zone/element-index.htm">https://web.archive.org/web/20201124024954/http://effbot.org/zone/element-index.htm</a>.</p>
<p>ElementTree representa un documento XML como un árbol de nodos de elementos. El contenido de texto del documento se almacena como los atributos <code class="xref py py-attr docutils literal notranslate"><span class="pre">text</span></code> y <code class="xref py py-attr docutils literal notranslate"><span class="pre">tail</span></code> de (Esta es una de las principales diferencias entre ElementTree y el Modelo de Objetos del Documento; en el DOM hay muchos tipos diferentes de nodo, incluyendo <code class="xref py py-class docutils literal notranslate"><span class="pre">TextNode</span></code>)</p>
<p>La función de análisis más utilizada es <code class="xref py py-func docutils literal notranslate"><span class="pre">parse()</span></code>, que toma una cadena (se supone que contiene un nombre de archivo) o un objeto similar a un archivo y devuelve una instancia de <code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xml.etree</span> <span class="kn">import</span> <span class="n">ElementTree</span> <span class="k">as</span> <span class="n">ET</span>

<span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;ex-1.xml&#39;</span><span class="p">)</span>

<span class="n">feed</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span>
          <span class="s1">&#39;http://planet.python.org/rss10.xml&#39;</span><span class="p">)</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">feed</span><span class="p">)</span>
</pre></div>
</div>
<p>Una vez que tengas una instancia de <code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code>, puedes llamar a su método <code class="xref py py-meth docutils literal notranslate"><span class="pre">getroot()</span></code> para obtener el nodo raíz de <code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code>.</p>
<p>También hay una función <code class="xref py py-func docutils literal notranslate"><span class="pre">XML()</span></code> que toma un literal de cadena y devuelve un nodo <code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code> (no un <code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code>).   Esta función proporciona una forma ordenada de incorporar fragmentos XML, acercándose a la comodidad de un literal XML:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">svg</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">XML</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;&lt;svg width=&quot;10px&quot; version=&quot;1.0&quot;&gt;</span>
<span class="s2">             &lt;/svg&gt;&quot;&quot;&quot;</span><span class="p">)</span>
<span class="n">svg</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="s1">&#39;320px&#39;</span><span class="p">)</span>
<span class="n">svg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem1</span><span class="p">)</span>
</pre></div>
</div>
<p>Cada elemento XML admite algunos métodos de acceso tipo diccionario y otros tipo lista.  Las operaciones tipo diccionario se utilizan para acceder a los valores de los atributos, y las operaciones tipo lista se utilizan para acceder a los nodos hijos.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 41%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operación</p></th>
<th class="head"><p>Resultado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">elem[n]</span></code></p></td>
<td><p>Devuelve el elemento hijo enésimo.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">elem[m:n]</span></code></p></td>
<td><p>Devuelve la lista de m’s a n’s elementos hijos.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">len(elem)</span></code></p></td>
<td><p>Devuelve el número de elementos hijos.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">lista(elem)</span></code></p></td>
<td><p>Devuelve la lista de elementos hijos.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">elem.append(elem2)</span></code></p></td>
<td><p>Añade <em>elemento2</em> como hijo.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">elem.insert(index,</span> <span class="pre">elem2)</span></code></p></td>
<td><p>Inserta <em>elemento2</em> en el lugar especificado.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">elem[n]</span></code></p></td>
<td><p>Elimina el elemento hijo enésimo.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">elem.keys()</span></code></p></td>
<td><p>Devuelve la lista de nombres de atributos.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">elem.get(name)</span></code></p></td>
<td><p>Devuelve el valor del atributo <em>nombre</em>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">elem.set(nombre,</span> <span class="pre">valor)</span></code></p></td>
<td><p>Establece el nuevo valor del atributo <em>nombre</em>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">elem.attrib</span></code></p></td>
<td><p>Recupera el diccionario que contiene los atributos.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">elem.attrib[name]</span></code></p></td>
<td><p>Borra el atributo <em>nombre</em>.</p></td>
</tr>
</tbody>
</table>
<p>Los comentarios y las instrucciones de procesamiento también se representan como nodos <code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code>.  Para comprobar si un nodo es un comentario o unas instrucciones de procesamiento:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">elem</span><span class="o">.</span><span class="n">tag</span> <span class="ow">is</span> <span class="n">ET</span><span class="o">.</span><span class="n">Comment</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">elif</span> <span class="n">elem</span><span class="o">.</span><span class="n">tag</span> <span class="ow">is</span> <span class="n">ET</span><span class="o">.</span><span class="n">ProcessingInstruction</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Para generar una salida XML, debes llamar al método <code class="xref py py-meth docutils literal notranslate"><span class="pre">ElementTree.write()</span></code>. Al igual que <code class="xref py py-func docutils literal notranslate"><span class="pre">parse()</span></code>, puede tomar una cadena o un objeto tipo archivo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Encoding is US-ASCII</span>
<span class="n">tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;output.xml&#39;</span><span class="p">)</span>

<span class="c1"># Encoding is UTF-8</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;output.xml&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>(Atención: la codificación por defecto utilizada para la salida es ASCII.  Para el trabajo general de XML, donde el nombre de un elemento puede contener caracteres Unicode arbitrarios, ASCII no es una codificación muy útil porque lanzará una excepción si el nombre de un elemento contiene cualquier carácter con valores superiores a 127.  Por lo tanto, es mejor especificar una codificación diferente, como UTF-8, que puede manejar cualquier carácter Unicode)</p>
<p>Esta sección es sólo una descripción parcial de las interfaces de ElementTree. Por favor, lee la documentación oficial del paquete para más detalles.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><a class="reference external" href="https://web.archive.org/web/20201124024954/http://effbot.org/zone/element-index.htm">https://web.archive.org/web/20201124024954/http://effbot.org/zone/element-index.htm</a></dt><dd><p>Documentación oficial de ElementTree.</p>
</dd>
</dl>
</div>
</section>
<section id="the-hashlib-package">
<span id="module-hashlib"></span><h3>El paquete hashlib<a class="headerlink" href="#the-hashlib-package" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Se ha añadido un nuevo módulo <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a>, escrito por Gregory P. Smith, para sustituir a los módulos <code class="xref py py-mod docutils literal notranslate"><span class="pre">md5</span></code> y <code class="xref py py-mod docutils literal notranslate"><span class="pre">sha</span></code>. <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> añade soporte para hashes seguros adicionales (SHA-224, SHA-256, SHA-384 y SHA-512). Cuando está disponible, el módulo utiliza OpenSSL para implementaciones rápidas de algoritmos optimizados para la plataforma.</p>
<p>Los antiguos módulos <code class="xref py py-mod docutils literal notranslate"><span class="pre">md5</span></code> y <code class="xref py py-mod docutils literal notranslate"><span class="pre">sha</span></code> siguen existiendo como envoltorios de hashlib para preservar la compatibilidad hacia atrás.  La interfaz del nuevo módulo es muy parecida a la de los módulos antiguos, pero no es idéntica. La diferencia más significativa es que las funciones constructoras para crear nuevos objetos hashing tienen un nombre diferente</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Old versions</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">md5</span><span class="o">.</span><span class="n">md5</span><span class="p">()</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">md5</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>

<span class="c1"># New version</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">()</span>

<span class="c1"># Old versions</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">sha</span><span class="o">.</span><span class="n">sha</span><span class="p">()</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">sha</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>

<span class="c1"># New version</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha1</span><span class="p">()</span>

<span class="c1"># Hash that weren&#39;t previously available</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha224</span><span class="p">()</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha256</span><span class="p">()</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha384</span><span class="p">()</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha512</span><span class="p">()</span>

<span class="c1"># Alternative form</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;md5&#39;</span><span class="p">)</span>          <span class="c1"># Provide algorithm as a string</span>
</pre></div>
</div>
<p>Una vez que se ha creado un objeto hash, sus métodos son los mismos que antes: <code class="docutils literal notranslate"><span class="pre">actualizar(cadena)</span></code> convierte la cadena especificada en el estado de resumen actual, <code class="xref py py-meth docutils literal notranslate"><span class="pre">digest()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">hexdigest()</span></code> devuelven el valor de resumen como una cadena binaria o una cadena de dígitos hexadecimales, y <code class="xref py py-meth docutils literal notranslate"><span class="pre">copiar()</span></code> devuelve un nuevo objeto hash con el mismo estado de resumen.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>La documentación del módulo <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a>.</p>
</div>
</section>
<section id="the-sqlite3-package">
<span id="module-sqlite"></span><h3>El paquete sqlite3<a class="headerlink" href="#the-sqlite3-package" title="Enlazar permanentemente con este título">¶</a></h3>
<p>The pysqlite module (<a class="reference external" href="https://www.pysqlite.org">https://www.pysqlite.org</a>), a wrapper for the SQLite embedded
database, has been added to the standard library under the package name
<a class="reference internal" href="../library/sqlite3.html#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a>.</p>
<p>SQLite es una biblioteca en C que proporciona una base de datos ligera basada en disco que no requiere un proceso de servidor independiente y permite acceder a la base de datos utilizando una variante no estándar del lenguaje de consulta SQL. Algunas aplicaciones pueden utilizar SQLite para el almacenamiento interno de datos.  También es posible crear un prototipo de una aplicación utilizando SQLite y luego portar el código a una base de datos más grande como PostgreSQL u Oracle.</p>
<p>pysqlite fue escrito por Gerhard Häring y proporciona una interfaz SQL que cumple con la especificación DB-API 2.0 descrita por <span class="target" id="index-83"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0249"><strong>PEP 249</strong></a>.</p>
<p>Si estás compilando el código fuente de Python tú mismo, ten en cuenta que el árbol de código fuente no incluye el código de SQLite, sólo el módulo envolvente. Necesitarás tener las librerías y cabeceras de SQLite instaladas antes de compilar Python, y el proceso de construcción compilará el módulo cuando las cabeceras necesarias estén disponibles.</p>
<p>Para utilizar el módulo, primero hay que crear un objeto <code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code> que represente la base de datos.  Aquí los datos se almacenarán en el archivo <code class="file docutils literal notranslate"><span class="pre">/tmp/example</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;/tmp/example&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>También puede suministrar el nombre especial <code class="docutils literal notranslate"><span class="pre">:memory:</span></code> para crear una base de datos en la RAM.</p>
<p>Una vez que tengas una <code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code>, puedes crear un objeto <code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code> y llamar a su método <code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code> para realizar comandos SQL:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

<span class="c1"># Create table</span>
<span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;create table stocks</span>
<span class="s1">(date text, trans text, symbol text,</span>
<span class="s1"> qty real, price real)&#39;&#39;&#39;</span><span class="p">)</span>

<span class="c1"># Insert a row of data</span>
<span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;insert into stocks</span>
<span class="s2">          values (&#39;2006-01-05&#39;,&#39;BUY&#39;,&#39;RHAT&#39;,100,35.14)&quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Normalmente tus operaciones SQL necesitarán usar valores de variables de Python.  No deberías montar tu consulta usando las operaciones de cadena de Python porque hacerlo es inseguro; hace que tu programa sea vulnerable a un ataque de inyección SQL.</p>
<p>En su lugar, utilice la sustitución de parámetros de la DB-API.  Ponga <code class="docutils literal notranslate"><span class="pre">?</span></code> como marcador de posición donde quiera usar un valor, y luego proporcione una tupla de valores como segundo argumento al método <code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code> del cursor.  (Otros módulos de base de datos pueden utilizar un marcador de posición diferente, como <code class="docutils literal notranslate"><span class="pre">%s</span></code> o <code class="docutils literal notranslate"><span class="pre">:1</span></code>) Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Never do this -- insecure!</span>
<span class="n">symbol</span> <span class="o">=</span> <span class="s1">&#39;IBM&#39;</span>
<span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;... where symbol = &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">symbol</span><span class="p">)</span>

<span class="c1"># Do this instead</span>
<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">symbol</span><span class="p">,)</span>
<span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;select * from stocks where symbol=?&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

<span class="c1"># Larger example</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">((</span><span class="s1">&#39;2006-03-28&#39;</span><span class="p">,</span> <span class="s1">&#39;BUY&#39;</span><span class="p">,</span> <span class="s1">&#39;IBM&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mf">45.00</span><span class="p">),</span>
          <span class="p">(</span><span class="s1">&#39;2006-04-05&#39;</span><span class="p">,</span> <span class="s1">&#39;BUY&#39;</span><span class="p">,</span> <span class="s1">&#39;MSOFT&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mf">72.00</span><span class="p">),</span>
          <span class="p">(</span><span class="s1">&#39;2006-04-06&#39;</span><span class="p">,</span> <span class="s1">&#39;SELL&#39;</span><span class="p">,</span> <span class="s1">&#39;IBM&#39;</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mf">53.00</span><span class="p">),</span>
         <span class="p">):</span>
    <span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;insert into stocks values (?,?,?,?,?)&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Para recuperar datos después de ejecutar una sentencia SELECT, puede tratar el cursor como un iterador, llamar al método <code class="xref py py-meth docutils literal notranslate"><span class="pre">fetchone()</span></code> del cursor para recuperar una sola fila que coincida, o llamar a <code class="xref py py-meth docutils literal notranslate"><span class="pre">fetchall()</span></code> para obtener una lista de las filas que coincidan.</p>
<p>Este ejemplo utiliza la forma del iterador:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;select * from stocks order by price&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
<span class="gp">... </span>   <span class="nb">print</span> <span class="n">row</span>
<span class="gp">...</span>
<span class="go">(u&#39;2006-01-05&#39;, u&#39;BUY&#39;, u&#39;RHAT&#39;, 100, 35.140000000000001)</span>
<span class="go">(u&#39;2006-03-28&#39;, u&#39;BUY&#39;, u&#39;IBM&#39;, 1000, 45.0)</span>
<span class="go">(u&#39;2006-04-06&#39;, u&#39;SELL&#39;, u&#39;IBM&#39;, 500, 53.0)</span>
<span class="go">(u&#39;2006-04-05&#39;, u&#39;BUY&#39;, u&#39;MSOFT&#39;, 1000, 72.0)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Para más información sobre el dialecto SQL soportado por SQLite, consulte <a class="reference external" href="https://www.sqlite.org">https://www.sqlite.org</a>.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><a class="reference external" href="https://www.pysqlite.org">https://www.pysqlite.org</a></dt><dd><p>La página web de pysqlite.</p>
</dd>
<dt><a class="reference external" href="https://www.sqlite.org">https://www.sqlite.org</a></dt><dd><p>La página web de SQLite; la documentación describe la sintaxis y los tipos de datos disponibles para el dialecto SQL soportado.</p>
</dd>
</dl>
<p>La documentación del módulo <a class="reference internal" href="../library/sqlite3.html#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a>.</p>
<dl class="simple">
<dt><span class="target" id="index-84"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0249"><strong>PEP 249</strong></a> - Especificación de la API de la base de datos 2.0</dt><dd><p>PEP escrito por Marc-André Lemburg.</p>
</dd>
</dl>
</div>
</section>
<section id="the-wsgiref-package">
<span id="module-wsgiref"></span><h3>El paquete wsgiref<a class="headerlink" href="#the-wsgiref-package" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La Interfaz de Pasarela del Servidor Web (WSGI) v1.0 define una interfaz estándar entre los servidores web y las aplicaciones web de Python y se describe en <span class="target" id="index-85"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0333"><strong>PEP 333</strong></a>. El paquete <a class="reference internal" href="../library/wsgiref.html#module-wsgiref" title="wsgiref: WSGI Utilities and Reference Implementation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">wsgiref</span></code></a> es una implementación de referencia de la especificación WSGI.</p>
<p>El paquete incluye un servidor HTTP básico que ejecutará una aplicación WSGI; este servidor es útil para la depuración pero no está pensado para su uso en producción.  La configuración de un servidor sólo requiere unas pocas líneas de código:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">wsgiref</span> <span class="kn">import</span> <span class="n">simple_server</span>

<span class="n">wsgi_app</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">host</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<span class="n">port</span> <span class="o">=</span> <span class="mi">8000</span>
<span class="n">httpd</span> <span class="o">=</span> <span class="n">simple_server</span><span class="o">.</span><span class="n">make_server</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">wsgi_app</span><span class="p">)</span>
<span class="n">httpd</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><a class="reference external" href="https://web.archive.org/web/20160331090247/http://wsgi.readthedocs.org/en/latest/">https://web.archive.org/web/20160331090247/http://wsgi.readthedocs.org/en/latest/</a></dt><dd><p>Un sitio web central para los recursos relacionados con WSGI.</p>
</dd>
<dt><span class="target" id="index-86"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0333"><strong>PEP 333</strong></a> - Interfaz del servidor web Python v1.0</dt><dd><p>PEP escrito por Phillip J. Eby.</p>
</dd>
</dl>
</div>
</section>
</section>
<section id="build-and-c-api-changes">
<span id="build-api"></span><h2>Cambios en la API de construcción y C<a class="headerlink" href="#build-and-c-api-changes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los cambios en el proceso de construcción de Python y en la API de C incluyen:</p>
<ul>
<li><p>El árbol de fuentes de Python fue convertido de CVS a Subversion, en un complejo procedimiento de migración que fue supervisado y llevado a cabo de forma impecable por Martin von Löwis.  El procedimiento se desarrolló como <span class="target" id="index-87"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0347"><strong>PEP 347</strong></a>.</p></li>
<li><p>Coverity, una empresa que comercializa una herramienta de análisis de código fuente llamada Prevent, proporcionó los resultados de su examen del código fuente de Python.  El análisis encontró alrededor de 60 errores que fueron rápidamente corregidos.  Muchos de los errores eran problemas de recuento, que a menudo se producen en el código de gestión de errores.  Consulte las estadísticas en <a class="reference external" href="https://scan.coverity.com">https://scan.coverity.com</a>.</p></li>
<li><p>The largest change to the C API came from <span class="target" id="index-29"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0353"><strong>PEP 353</strong></a>, which modifies the
interpreter to use a <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> type definition instead of
<code class="xref c c-expr docutils literal notranslate"><span class="pre">int</span></code>.  See the earlier section <a class="reference internal" href="#pep-353"><span class="std std-ref">PEP 353: Uso de ssize_t como tipo de índice</span></a> for a discussion of this
change.</p></li>
<li><p>El diseño del compilador de código de bytes ha cambiado mucho, ya no genera código de bytes recorriendo el árbol de análisis sintáctico.  En su lugar, el árbol de análisis se convierte en un árbol de sintaxis abstracta (o AST), y es el árbol de sintaxis abstracta el que se recorre para producir el código de bytes.</p>
<p>Es posible que el código Python obtenga objetos AST utilizando el built-in <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> y especificando <code class="docutils literal notranslate"><span class="pre">_ast.PyCF_ONLY_AST</span></code> como valor del parámetro <em>flags</em>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">_ast</span> <span class="kn">import</span> <span class="n">PyCF_ONLY_AST</span>
<span class="n">ast</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;a=0</span>
<span class="s2">for i in range(10):</span>
<span class="s2">    a += i</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;string&gt;&quot;</span><span class="p">,</span> <span class="s1">&#39;exec&#39;</span><span class="p">,</span> <span class="n">PyCF_ONLY_AST</span><span class="p">)</span>

<span class="n">assignment</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">for_loop</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Todavía no se ha escrito ninguna documentación oficial para el código AST, pero <span class="target" id="index-88"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0339"><strong>PEP 339</strong></a> discute el diseño.  Para empezar a conocer el código, lea la definición de los distintos nodos AST en <code class="file docutils literal notranslate"><span class="pre">Parser/Python.asdl</span></code>.  Un script de Python lee este archivo y genera un conjunto de definiciones de estructuras C en <code class="file docutils literal notranslate"><span class="pre">Include/Python-ast.h</span></code>.  Las funciones <code class="xref c c-func docutils literal notranslate"><span class="pre">PyParser_ASTFromString()</span></code> y <code class="xref c c-func docutils literal notranslate"><span class="pre">PyParser_ASTFromFile()</span></code>, definidas en <code class="file docutils literal notranslate"><span class="pre">Include/pythonrun.h</span></code>, toman el código fuente de Python como entrada y devuelven la raíz de un AST que representa el contenido. Este AST puede convertirse en un objeto de código mediante <code class="xref c c-func docutils literal notranslate"><span class="pre">PyAST_Compile()</span></code>.  Para más información, lea el código fuente, y luego haga preguntas en python-dev.</p>
<p>El código de la AST fue desarrollado bajo la dirección de Jeremy Hylton, e implementado por (en orden alfabético) Brett Cannon, Nick Coghlan, Grant Edwards, John Ehresman, Kurt Kaiser, Neal Norwitz, Tim Peters, Armin Rigo y Neil Schemenauer, además de los participantes en varios sprints de la AST en conferencias como la PyCon.</p>
</li>
<li><p>Se aplicó el parche de Evan Jones a obmalloc, descrito por primera vez en una charla en la PyCon DC 2005.  Python 2.4 asignaba objetos pequeños en arenas de 256K, pero nunca liberaba arenas.  Con este parche, Python liberará arenas cuando estén vacías.  El efecto neto es que en algunas plataformas, cuando se asignan muchos objetos, el uso de la memoria de Python puede realmente caer cuando se borran y la memoria puede ser devuelta al sistema operativo.  (Implementado por Evan Jones, y reelaborado por Tim Peters)</p>
<p>Tenga en cuenta que este cambio significa que los módulos de extensión deben ser más cuidadosos al asignar memoria.  La API de Python tiene muchas funciones diferentes para asignar memoria que se agrupan en familias.  Por ejemplo, <a class="reference internal" href="../c-api/memory.html#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a>, <a class="reference internal" href="../c-api/memory.html#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Realloc()</span></code></a>, y <a class="reference internal" href="../c-api/memory.html#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a> son una familia que asigna memoria en bruto, mientras que <a class="reference internal" href="../c-api/memory.html#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a>, <a class="reference internal" href="../c-api/memory.html#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Realloc()</span></code></a>, y <a class="reference internal" href="../c-api/memory.html#c.PyObject_Free" title="PyObject_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Free()</span></code></a> son otra familia que se supone que se utiliza para crear objetos de Python.</p>
<p>Anteriormente estas diferentes familias se reducían a las funciones <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> y <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code> de la plataforma.  Esto significaba que no importaba si te equivocabas y asignabas memoria con la función <code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem()</span></code> pero la liberabas con la función <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject()</span></code></a>.  Con los cambios de la versión 2.5 en obmalloc, estas familias hacen ahora cosas diferentes y los desajustes probablemente darán lugar a un fallo de seguridad.  Deberías probar cuidadosamente tus módulos de extensión C con Python 2.5.</p>
</li>
<li><p>Los tipos de conjuntos incorporados tienen ahora una API oficial en C.  Llame a <a class="reference internal" href="../c-api/set.html#c.PySet_New" title="PySet_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySet_New()</span></code></a> y <a class="reference internal" href="../c-api/set.html#c.PyFrozenSet_New" title="PyFrozenSet_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrozenSet_New()</span></code></a> para crear un nuevo conjunto, <a class="reference internal" href="../c-api/set.html#c.PySet_Add" title="PySet_Add"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySet_Add()</span></code></a> y <a class="reference internal" href="../c-api/set.html#c.PySet_Discard" title="PySet_Discard"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySet_Discard()</span></code></a> para añadir y eliminar elementos, y <a class="reference internal" href="../c-api/set.html#c.PySet_Contains" title="PySet_Contains"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySet_Contains()</span></code></a> y <a class="reference internal" href="../c-api/set.html#c.PySet_Size" title="PySet_Size"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySet_Size()</span></code></a> para examinar el estado del conjunto. (Contribución de Raymond Hettinger)</p></li>
<li><p>El código C puede ahora obtener información sobre la revisión exacta del intérprete de Python llamando a la función <a class="reference internal" href="../c-api/init.html#c.Py_GetBuildInfo" title="Py_GetBuildInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetBuildInfo()</span></code></a> que devuelve una cadena de información de compilación como esta <code class="docutils literal notranslate"><span class="pre">&quot;trunk:45355:45356M,</span> <span class="pre">Apr</span> <span class="pre">13</span> <span class="pre">2006,</span> <span class="pre">07:42:19&quot;</span></code>.   (Contribuido por Barry Warsaw.)</p></li>
<li><p>Se pueden utilizar dos nuevas macros para indicar las funciones C que son locales al fichero actual, de modo que se pueda utilizar una convención de llamada más rápida. <code class="docutils literal notranslate"><span class="pre">Py_LOCAL(type)</span></code> declara que la función devuelve un valor del <em>tipo</em> especificado y utiliza un calificador de llamada rápida. <code class="docutils literal notranslate"><span class="pre">Py_LOCAL_INLINE(type)</span></code> hace lo mismo y también solicita que la función sea inline.  Si <code class="xref c c-func docutils literal notranslate"><span class="pre">PY_LOCAL_AGGRESSIVE()</span></code> se define antes de que se incluya <code class="file docutils literal notranslate"><span class="pre">python.h</span></code>, se habilita un conjunto de optimizaciones más agresivas para el módulo; debería comparar los resultados para averiguar si estas optimizaciones realmente hacen el código más rápido.  (Contribuido por Fredrik Lundh en el sprint NeedForSpeed)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PyErr_NewException(name,</span> <span class="pre">base,</span> <span class="pre">dict)</span></code> ahora puede aceptar una tupla de clases base como su argumento <em>base</em>.  (Contribuido por Georg Brandl.)</p></li>
<li><p>La función <code class="xref c c-func docutils literal notranslate"><span class="pre">PyErr_Warn()</span></code> para emitir avisos está ahora obsoleta en favor de <code class="docutils literal notranslate"><span class="pre">PyErr_WarnEx(category,</span> <span class="pre">message,</span> <span class="pre">stacklevel)</span></code> que permite especificar el número de marcos de pila que separan esta función y la que la llama.  Un <em>stacklevel</em> de 1 es la función que llama a <a class="reference internal" href="../c-api/exceptions.html#c.PyErr_WarnEx" title="PyErr_WarnEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyErr_WarnEx()</span></code></a>, 2 es la función que está por encima, y así sucesivamente.  (Añadido por Neal Norwitz.)</p></li>
<li><p>El intérprete de CPython sigue estando escrito en C, pero el código ahora puede ser compilado con un compilador de C++ sin errores.   (Implementado por Anthony Baxter, Martin von Löwis, Skip Montanaro)</p></li>
<li><p>Se ha eliminado la función <code class="xref c c-func docutils literal notranslate"><span class="pre">PyRange_New()</span></code>.  Nunca se documentó, nunca se utilizó en el código del núcleo, y tenía una comprobación de errores peligrosamente laxa.  En el improbable caso de que sus extensiones la utilizaran, puede sustituirla por algo como lo siguiente:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">range</span> <span class="o">=</span> <span class="n">PyObject_CallFunction</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">PyRange_Type</span><span class="p">,</span> <span class="s2">&quot;lll&quot;</span><span class="p">,</span>
                              <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
<section id="port-specific-changes">
<span id="ports"></span><h3>Cambios específicos en los puertos<a class="headerlink" href="#port-specific-changes" title="Enlazar permanentemente con este título">¶</a></h3>
<ul class="simple">
<li><p>MacOS X (10.3 y superior): la carga dinámica de módulos utiliza ahora la función <code class="xref c c-func docutils literal notranslate"><span class="pre">dlopen()</span></code> en lugar de funciones específicas de MacOS.</p></li>
<li><p>MacOS X: se ha añadido una opción <code class="xref std std-option docutils literal notranslate"><span class="pre">--enable-universalsdk</span></code> al script <strong class="program">configure</strong> que compila el intérprete como un binario universal capaz de funcionar tanto en procesadores PowerPC como Intel. (Contribución de Ronald Oussoren; <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2573">bpo-2573</a>.)</p></li>
<li><p>Windows: <code class="file docutils literal notranslate"><span class="pre">.dll</span></code> ya no se admite como extensión de nombre de archivo para los módulos de extensión. <code class="file docutils literal notranslate"><span class="pre">.pyd</span></code> es ahora la única extensión de nombre de archivo que se buscará.</p></li>
</ul>
</section>
</section>
<section id="porting-to-python-2-5">
<span id="porting"></span><h2>Adaptación a Python 2.5<a class="headerlink" href="#porting-to-python-2-5" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Esta sección enumera los cambios descritos anteriormente que pueden requerir cambios en su código:</p>
<ul class="simple">
<li><p>ASCII es ahora la codificación por defecto para los módulos.  Ahora es un error de sintaxis si un módulo contiene literales de cadena con caracteres de 8 bits pero no tiene una declaración de codificación.  En Python 2.4 esto provocaba una advertencia, no un error de sintaxis.</p></li>
<li><p>Anteriormente, el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">gi_frame</span></code> de un generador era siempre un objeto frame.  Debido a los cambios de <span class="target" id="index-89"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0342"><strong>PEP 342</strong></a> descritos en la sección <a class="reference internal" href="#pep-342"><span class="std std-ref">PEP 342: Nuevas funciones del generador</span></a>, ahora es posible que <code class="xref py py-attr docutils literal notranslate"><span class="pre">gi_frame</span></code> sea <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p>Una nueva advertencia, <a class="reference internal" href="../library/exceptions.html#UnicodeWarning" title="UnicodeWarning"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeWarning</span></code></a>, se lanza cuando se intenta comparar una cadena Unicode y una cadena de 8 bits que no puede ser convertida a Unicode utilizando la codificación ASCII por defecto.  Anteriormente estas comparaciones lanzaban una excepción <a class="reference internal" href="../library/exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code></a>.</p></li>
<li><p>Biblioteca: el módulo <a class="reference internal" href="../library/csv.html#module-csv" title="csv: Write and read tabular data to and from delimited files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">csv</span></code></a> es ahora más estricto con los campos citados en varias líneas. Si sus archivos contienen nuevas líneas incrustadas dentro de los campos, la entrada debe dividirse en líneas de manera que se conserven los caracteres de nueva línea.</p></li>
<li><p>Biblioteca: la función <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> del módulo <a class="reference internal" href="../library/locale.html#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">locale</span></code></a> aceptaba antes cualquier cadena siempre que no apareciera más de un especificador %char.  En Python 2.5, el argumento debe ser exactamente un especificador %char sin texto alrededor.</p></li>
<li><p>Biblioteca: Los módulos <a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> y <code class="xref py py-mod docutils literal notranslate"><span class="pre">cPickle</span></code> ya no aceptan un valor de retorno de <code class="docutils literal notranslate"><span class="pre">None</span></code> del método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code>; el método debe devolver una tupla de argumentos.  Los módulos tampoco aceptan ya el parámetro obsoleto de la palabra clave <em>bin</em>.</p></li>
<li><p>Biblioteca: Las clases <code class="xref py py-mod docutils literal notranslate"><span class="pre">SimpleXMLRPCServer</span></code> y <code class="xref py py-mod docutils literal notranslate"><span class="pre">DocXMLRPCServer</span></code> tienen ahora un atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">rpc_paths</span></code> que restringe las operaciones XML-RPC a un conjunto limitado de rutas URL; por defecto sólo se permiten <code class="docutils literal notranslate"><span class="pre">'/'</span></code> y <code class="docutils literal notranslate"><span class="pre">'/RPC2'</span></code>. Establecer <code class="xref py py-attr docutils literal notranslate"><span class="pre">rpc_paths</span></code> como <code class="docutils literal notranslate"><span class="pre">None</span></code> o una tupla vacía desactiva esta comprobación de rutas.</p></li>
<li><p>C API: Many functions now use <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>  instead of <code class="xref c c-expr docutils literal notranslate"><span class="pre">int</span></code> to
allow processing more data on 64-bit machines.  Extension code may need to make
the same change to avoid warnings and to support 64-bit machines.  See the
earlier section <a class="reference internal" href="#pep-353"><span class="std std-ref">PEP 353: Uso de ssize_t como tipo de índice</span></a> for a discussion of this change.</p></li>
<li><p>C API:  The obmalloc changes mean that  you must be careful to not mix usage
of the <code class="docutils literal notranslate"><span class="pre">PyMem_*</span></code> and <code class="docutils literal notranslate"><span class="pre">PyObject_*</span></code> families of functions. Memory
allocated with  one family’s <code class="docutils literal notranslate"><span class="pre">*_Malloc</span></code> must be  freed with the
corresponding family’s <code class="docutils literal notranslate"><span class="pre">*_Free</span></code> function.</p></li>
</ul>
</section>
<section id="acknowledgements">
<h2>Agradecimientos<a class="headerlink" href="#acknowledgements" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El autor desea agradecer a las siguientes personas sus sugerencias, correcciones y ayuda en varios borradores de este artículo: Georg Brandl, Nick Coghlan, Phillip J. Eby, Lars Gustäbel, Raymond Hettinger, Ralf W. Grosse-Kunstleve, Kent Johnson, Iain Lowe, Martin von Löwis, Fredrik Lundh, Andrew McNamara, Skip Montanaro, Gustavo Niemeyer, Paul Prescod, James Pryor, Mike Rovner, Scott Weikart, Barry Warsaw, Thomas Wouters.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#">Novedades de Python 2.5</a><ul>
<li><a class="reference internal" href="#pep-308-conditional-expressions">PEP 308: Expresiones condicionales</a></li>
<li><a class="reference internal" href="#pep-309-partial-function-application">PEP 309: Aplicación parcial de funciones</a></li>
<li><a class="reference internal" href="#pep-314-metadata-for-python-software-packages-v1-1">PEP 314: Metadatos para paquetes de software Python v1.1</a></li>
<li><a class="reference internal" href="#pep-328-absolute-and-relative-imports">PEP 328: Importaciones absolutas y relativas</a></li>
<li><a class="reference internal" href="#pep-338-executing-modules-as-scripts">PEP 338: Ejecutando Módulos como Scripts</a></li>
<li><a class="reference internal" href="#pep-341-unified-try-except-finally">PEP 341: Try/except/finally unificados</a></li>
<li><a class="reference internal" href="#pep-342-new-generator-features">PEP 342: Nuevas funciones del generador</a></li>
<li><a class="reference internal" href="#pep-343-the-with-statement">PEP 343: La declaración «con</a><ul>
<li><a class="reference internal" href="#writing-context-managers">Redacción de Gestores de Contexto</a></li>
<li><a class="reference internal" href="#the-contextlib-module">El módulo contextlib</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-352-exceptions-as-new-style-classes">PEP 352: Las excepciones como clases de nuevo estilo</a></li>
<li><a class="reference internal" href="#pep-353-using-ssize-t-as-the-index-type">PEP 353: Uso de ssize_t como tipo de índice</a></li>
<li><a class="reference internal" href="#pep-357-the-index-method">PEP 357: El método “__index__”</a></li>
<li><a class="reference internal" href="#other-language-changes">Otros cambios lingüísticos</a><ul>
<li><a class="reference internal" href="#interactive-interpreter-changes">Cambios en el intérprete interactivo</a></li>
<li><a class="reference internal" href="#optimizations">Optimizaciones</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-improved-and-removed-modules">Módulos nuevos, mejorados y eliminados</a><ul>
<li><a class="reference internal" href="#the-ctypes-package">El paquete ctypes</a></li>
<li><a class="reference internal" href="#the-elementtree-package">El paquete ElementTree</a></li>
<li><a class="reference internal" href="#the-hashlib-package">El paquete hashlib</a></li>
<li><a class="reference internal" href="#the-sqlite3-package">El paquete sqlite3</a></li>
<li><a class="reference internal" href="#the-wsgiref-package">El paquete wsgiref</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-and-c-api-changes">Cambios en la API de construcción y C</a><ul>
<li><a class="reference internal" href="#port-specific-changes">Cambios específicos en los puertos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#porting-to-python-2-5">Adaptación a Python 2.5</a></li>
<li><a class="reference internal" href="#acknowledgements">Agradecimientos</a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="2.6.html"
                        title="capítulo anterior">Qué hay de nuevo en Python 2.6</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="2.4.html"
                        title="próximo capítulo">Novedades en Python 2.4</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/whatsnew/2.5.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="2.4.html" title="Novedades en Python 2.4"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="2.6.html" title="Qué hay de nuevo en Python 2.6"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Qué hay de nuevo en Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Novedades de Python 2.5</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 27, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>