
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>unittest — Infraestructura de tests unitarios &#8212; documentación de Python - 3.10.10</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.10.10"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="unittest.mock — Biblioteca de objetos simulados" href="unittest.mock.html" />
    <link rel="prev" title="doctest – Prueba ejemplos interactivos de Python" href="doctest.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/unittest.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code> — Infraestructura de tests unitarios</a><ul>
<li><a class="reference internal" href="#basic-example">Ejemplo sencillo</a></li>
<li><a class="reference internal" href="#command-line-interface">Interfaz de línea de comandos</a><ul>
<li><a class="reference internal" href="#command-line-options">Opciones de la línea de órdenes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#test-discovery">Descubrimiento de pruebas</a></li>
<li><a class="reference internal" href="#organizing-test-code">Organización del código de pruebas</a></li>
<li><a class="reference internal" href="#re-using-old-test-code">Reutilización de código de prueba anterior</a></li>
<li><a class="reference internal" href="#skipping-tests-and-expected-failures">Omitir tests y fallos esperados</a></li>
<li><a class="reference internal" href="#distinguishing-test-iterations-using-subtests">Distinguiendo iteraciones de tests empleando subtests</a></li>
<li><a class="reference internal" href="#classes-and-functions">Clases y funciones</a><ul>
<li><a class="reference internal" href="#test-cases">Casos de test</a><ul>
<li><a class="reference internal" href="#deprecated-aliases">Alias obsoletos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#grouping-tests">Agrupando tests</a></li>
<li><a class="reference internal" href="#loading-and-running-tests">Cargando y ejecutando tests</a><ul>
<li><a class="reference internal" href="#load-tests-protocol">load_tests protocolo</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#class-and-module-fixtures">Instalaciones para clases y módulos</a><ul>
<li><a class="reference internal" href="#setupclass-and-teardownclass">setUpClass y tearDownClass</a></li>
<li><a class="reference internal" href="#setupmodule-and-teardownmodule">setUpModule y tearDownModule</a></li>
</ul>
</li>
<li><a class="reference internal" href="#signal-handling">Manejo de señales</a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="doctest.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code> – Prueba ejemplos interactivos de Python</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="unittest.mock.html"
                        title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest.mock</span></code> — Biblioteca de objetos simulados</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/unittest.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="unittest.mock.html" title="unittest.mock — Biblioteca de objetos simulados"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="doctest.html" title="doctest – Prueba ejemplos interactivos de Python"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La Biblioteca Estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" accesskey="U">Herramientas de desarrollo</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code> — Infraestructura de tests unitarios</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-unittest">
<span id="unittest-unit-testing-framework"></span><h1><a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> — Infraestructura de tests unitarios<a class="headerlink" href="#module-unittest" title="Enlazar permanentemente con este título">¶</a></h1>
<p><strong>Código fuente:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/unittest/__init__.py">Lib/unittest/__init__.py</a></p>
<hr class="docutils" />
<p>(Si ya estás familiarizado con los conceptos básicos de realización de tests, puedes saltar a <a class="reference internal" href="#assert-methods"><span class="std std-ref">la lista de métodos de aserción</span></a>.)</p>
<p>La infraestructura de tests unitarios <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> se inspiró en primera instancia en JUnit y ofrece aspectos similares a las principales estructuras de tests unitarios más importantes de otros lenguajes.  Da soporte a automatización de tests, inicialización compartida, código de cierre de los tests, agregación de los tests en colecciones e independencia de los tests de la infraestructura que los reporta.</p>
<p>Para conseguir esto, <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> da soporte a ciertos conceptos importantes de una forma orientada a objetos:</p>
<dl class="simple">
<dt>configuración de prueba (<em>fixture</em>)</dt><dd><p>Un <em class="dfn">test fixture</em> representa los preparativos para realizar una o más pruebas y las acciones de limpieza asociadas. Esto puede incluir, por ejemplo, la creación de bases de datos temporales, directorios o el arranque de procesos del servidor.</p>
</dd>
<dt>caso de prueba</dt><dd><p>Un <em class="dfn">test case</em> es la unidad mínima de prueba. Verifica la respuesta específica a un juego particular de entradas. <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> proporciona una clase base, <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>, que se puede utilizar para crear nuevos casos de uso.</p>
</dd>
<dt>conjunto de pruebas</dt><dd><p>Un <em class="dfn">test suite</em> es una colección de casos de prueba, juegos de prueba o ambos. Se usa para agrupar pruebas que se han de ejecutar juntas.</p>
</dd>
<dt>ejecutor de pruebas</dt><dd><p>Un <em class="dfn">test runner</em> es un componente que dirige la ejecución de las pruebas y proporciona un resultado. El ejecutor puede disponer de una interfaz gráfica, de texto o devolver un valor especial que indique el resultado de la ejecución de las pruebas.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt>Módulo <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a></dt><dd><p>Otro módulo de soporte a pruebas con una solución muy diferente.</p>
</dd>
<dt><a class="reference external" href="https://web.archive.org/web/20150315073817/http://www.xprogramming.com/testfram.htm">Simple Smalltalk Testing: With Patterns</a></dt><dd><p>El documento original de Kent Beck sobre infraestructuras de prueba mediante el patrón que utiliza <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>.</p>
</dd>
<dt><a class="reference external" href="https://docs.pytest.org/">pytest</a></dt><dd><p>Una infraestructura de pruebas unitarias de otro proveedor con una sintaxis más ligera de escritura de pruebas, por ejemplo: <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">func(10)</span> <span class="pre">==</span> <span class="pre">42</span></code>.</p>
</dd>
<dt><a class="reference external" href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy">The Python Testing Tools Taxonomy</a></dt><dd><p>Una lista extensa de herramientas de prueba para Python incluyendo infraestructuras de pruebas funcionales y librerías de objetos sucedáneos.</p>
</dd>
<dt><a class="reference external" href="http://lists.idyll.org/listinfo/testing-in-python">Testing in Python Mailing List</a></dt><dd><p>Grupo especializado en debate sobre las pruebas y las herramientas de prueba de Python.</p>
</dd>
</dl>
<p>El script <code class="file docutils literal notranslate"><span class="pre">Tools/unittestgui/unittestgui.py</span></code> de la distribución de fuentes de Python es una herramienta gráfica para el descubrimiento y ejecución de pruebas. Está orientado sobre todo a principiantes en el tema de pruebas. Para entornos de producción se recomienda que las pruebas sean dirigidas por un sistema de integración continua como <a class="reference external" href="https://buildbot.net/">Buildbot</a>, <a class="reference external" href="https://jenkins.io/">Jenkins</a> o  <a class="reference external" href="http://hudson-ci.org/">Hudson</a>.</p>
</div>
<section id="basic-example">
<span id="unittest-minimal-example"></span><h2>Ejemplo sencillo<a class="headerlink" href="#basic-example" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El módulo <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> proporciona un conjunto de herramientas para construir y ejecutar pruebas. Esta sección demuestra que un pequeño subconjunto de las herramientas es suficiente para satisfacer las necesidades de la mayoría.</p>
<p>He aquí un breve script para probar estros tres métodos de cadena:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">TestStringMethods</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">test_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="s1">&#39;FOO&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_isupper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="s1">&#39;FOO&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertFalse</span><span class="p">(</span><span class="s1">&#39;Foo&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">test_split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;hello world&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span> <span class="p">[</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">])</span>
        <span class="c1"># check that s.split fails when the separator is not a string</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">):</span>
            <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>Para crear un caso de prueba se genera una subclase de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestCase</span></code></a>. Las tres pruebas se definen con métodos cuyos nombres comienzan por las letras <code class="docutils literal notranslate"><span class="pre">test</span></code>. Esta convención sobre nombres indica al ejecutor de pruebas qué métodos representan pruebas.</p>
<p>El quid de cada test es la llamada a  <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> para verificar un resultado esperado; <a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTrue()</span></code></a> o <a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertFalse()</span></code></a> para verificar una condición; o <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a> para asegurar que se lanza una excepción específica. Se utilizan estos métodos en lugar de la sentencia <a class="reference internal" href="../reference/simple_stmts.html#assert"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code></a> para que el ejecutor de pruebas pueda acumular todos los resultados de la prueba de cara a realizar un informe.</p>
<p>Los métodos <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> y <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> permiten definir instrucciones que han de ser ejecutadas antes y después, respectivamente, de cada método de prueba. Se describen con mas detalle en la sección <a class="reference internal" href="#organizing-tests"><span class="std std-ref">Organización del código de pruebas</span></a>.</p>
<p>El bloque final muestra un modo sencillo de ejecutar las pruebas. <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.main()</span></code></a> proporciona una interfaz de línea de órdenes para el script de prueba. Cuando se ejecuta desde la línea de órdenes, el script anterior produce una salida como:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Ran</span> <span class="mi">3</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mf">0.000</span><span class="n">s</span>

<span class="n">OK</span>
</pre></div>
</div>
<p>Si se le pasa una opción <code class="docutils literal notranslate"><span class="pre">-v</span></code> al script de prueba, se establecerá un nivel mayor de detalle del proceso de <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.main()</span></code></a> y se obtendrá la siguiente salida:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_isupper</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">TestStringMethods</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>
<span class="n">test_split</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">TestStringMethods</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>
<span class="n">test_upper</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">TestStringMethods</span><span class="p">)</span> <span class="o">...</span> <span class="n">ok</span>

<span class="o">----------------------------------------------------------------------</span>
<span class="n">Ran</span> <span class="mi">3</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mf">0.001</span><span class="n">s</span>

<span class="n">OK</span>
</pre></div>
</div>
<p>Los ejemplos anteriores muestra las características más usuales de <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>, que son suficientes para solventar las necesidades cotidianas de pruebas. El resto de la documentación explora el juego completo de características, que abundan en los mismos principios.</p>
</section>
<section id="command-line-interface">
<span id="unittest-command-line-interface"></span><h2>Interfaz de línea de comandos<a class="headerlink" href="#command-line-interface" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Se puede usar el módulo <cite>unittest</cite> desde la línea de órdenes para ejecutar pruebas de módulos, clases o hasta métodos de prueba individuales:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">test_module1</span> <span class="n">test_module2</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">test_module</span><span class="o">.</span><span class="n">TestClass</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">test_module</span><span class="o">.</span><span class="n">TestClass</span><span class="o">.</span><span class="n">test_method</span>
</pre></div>
</div>
<p>Se puede pasar una lista con cualquier combinación de nombres de módulo, así como clases o métodos completamente cualificados.</p>
<p>Se puede especificar los módulos de prueba por ruta de fichero también:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">tests</span><span class="o">/</span><span class="n">test_something</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>Esto permite usar el completado automático de nombre de fichero de la shell para especificar el módulo de pruebas. El fichero especificado aún debe ser susceptible de importarse como módulo. La ruta se convierte en nombre de módulo eliminando “.py” y convirtiendo el separador de directorios por “.”. Si se desea ejecutar un fichero de prueba que no se puede importar como módulo, se ha de ejecutar el fichero directamente.</p>
<p>Se pueden ejecutar las pruebas con más nivel de detalle (mayor verbosidad) pasando el parámetro <cite>-v</cite>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="o">-</span><span class="n">v</span> <span class="n">test_module</span>
</pre></div>
</div>
<p>Cuando se ejecuta sin argumentos, se inicia <a class="reference internal" href="#unittest-test-discovery"><span class="std std-ref">Descubrimiento de pruebas</span></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span>
</pre></div>
</div>
<p>Para obtener una lista de todas las opciones de línea de órdenes:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="o">-</span><span class="n">h</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>En versiones anteriores sólo era posible ejecutar métodos de prueba individuales, pero no módulos ni clases.</p>
</div>
<section id="command-line-options">
<h3>Opciones de la línea de órdenes<a class="headerlink" href="#command-line-options" title="Enlazar permanentemente con este título">¶</a></h3>
<p><strong class="program">unittest</strong> da soporte a las siguientes opciones de línea de órdenes:</p>
<dl class="std cmdoption">
<dt id="cmdoption-unittest-b">
<span id="cmdoption-unittest-buffer"></span><code class="sig-name descname">-b</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--buffer</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-unittest-b" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Los flujos de datos de salida estándar y error estándar se acumulan en un búfer durante la ejecución de pruebas. La salida de las pruebas correctas se descarta. La salida de las pruebas que fallan o devuelven un error se añade a los mensajes de fallo.</p>
</dd></dl>

<dl class="std cmdoption">
<dt id="cmdoption-unittest-c">
<span id="cmdoption-unittest-catch"></span><code class="sig-name descname">-c</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--catch</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-unittest-c" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La pulsación de <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Control</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd></kbd> durante la ejecución de pruebas espera a que termine la prueba en curso y da un informe de los resultados hasta ese momento. Una segunda pulsación de <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Control</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd></kbd> lanza la excepción <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> usual.</p>
<p>Consultar  en <a class="reference internal" href="#signal-handling">Gestión de señales</a> las funciones que proporcionan esta funcionalidad.</p>
</dd></dl>

<dl class="std cmdoption">
<dt id="cmdoption-unittest-f">
<span id="cmdoption-unittest-failfast"></span><code class="sig-name descname">-f</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--failfast</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-unittest-f" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Finaliza la ejecución tras el primer error o fallo.</p>
</dd></dl>

<dl class="std cmdoption">
<dt id="cmdoption-unittest-k">
<code class="sig-name descname">-k</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-unittest-k" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Only run test methods and classes that match the pattern or substring.
This option may be used multiple times, in which case all test cases that
match any of the given patterns are included.</p>
<p>Los patrones que contengan un comodín (<code class="docutils literal notranslate"><span class="pre">*</span></code>) se comprueban contra el nombre de la prueba usando <a class="reference internal" href="fnmatch.html#fnmatch.fnmatchcase" title="fnmatch.fnmatchcase"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fnmatch.fnmatchcase()</span></code></a>; si no lo contienen, se usa una comprobación de contenido simple sensible a mayúsculas.</p>
<p>Los patrones se comprueban contra el nombre del método completamente cualificado como lo importa el cargador de pruebas.</p>
<p>Por ejemplo, <code class="docutils literal notranslate"><span class="pre">-k</span> <span class="pre">foo</span></code> coincide con <code class="docutils literal notranslate"><span class="pre">foo_tests.SomeTest.test_something</span></code> y con <code class="docutils literal notranslate"><span class="pre">bar_tests.SomeTest.test_foo</span></code>, pero no con <code class="docutils literal notranslate"><span class="pre">bar_tests.FooTest.test_something</span></code>.</p>
</dd></dl>

<dl class="std cmdoption">
<dt id="cmdoption-unittest-locals">
<code class="sig-name descname">--locals</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-unittest-locals" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Mostrar las variables locales en las trazas.</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2: </span>Se añadieron las opciones de línea de órdenes <code class="docutils literal notranslate"><span class="pre">-b</span></code>, <code class="docutils literal notranslate"><span class="pre">-c</span></code> y <code class="docutils literal notranslate"><span class="pre">-f</span></code>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5: </span>La opción de línea de órdenes <code class="docutils literal notranslate"><span class="pre">--locals</span></code>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7: </span>La opción de línea de órdenes <code class="docutils literal notranslate"><span class="pre">-k</span></code>.</p>
</div>
<p>La línea de órdenes también se puede usar para descubrimiento de pruebas, para ejecutar todas las pruebas de un proyecto o un subconjunto de éstas.</p>
</section>
</section>
<section id="test-discovery">
<span id="unittest-test-discovery"></span><h2>Descubrimiento de pruebas<a class="headerlink" href="#test-discovery" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
<p>Unittest da soporte al descubrimiento de pruebas simples. Para ser compatible con el descubrimiento de pruebas, todos los ficheros de prueba deben ser <a class="reference internal" href="../tutorial/modules.html#tut-modules"><span class="std std-ref">módulos</span></a> o <a class="reference internal" href="../tutorial/modules.html#tut-packages"><span class="std std-ref">paquetes</span></a> (incluyendo <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">paquetes nominales</span></a>) importables desde el directorio superior del proyecto (por lo que sus nombres han de ser <a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><span class="std std-ref">identificadores</span></a> válidos).</p>
<p>El descubrimiento de pruebas está implementado en <a class="reference internal" href="#unittest.TestLoader.discover" title="unittest.TestLoader.discover"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestLoader.discover()</span></code></a>, pero también se puede usar desde la línea de órdenes. La línea de órdenes básica es:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">project_directory</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">discover</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Como atajo, <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">unittest</span></code> es el equivalente de <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">unittest</span> <span class="pre">discover</span></code>. Si se desea pasar argumentos al descubrimiento de pruebas, hay que pasar la sub-orden <code class="docutils literal notranslate"><span class="pre">discover</span></code> explícitamente.</p>
</div>
<p>La sub-orden <code class="docutils literal notranslate"><span class="pre">discover</span></code> cuenta con las siguientes opciones:</p>
<dl class="std cmdoption">
<dt id="cmdoption-unittest-discover-v">
<span id="cmdoption-unittest-discover-verbose"></span><code class="sig-name descname">-v</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--verbose</code><code class="sig-prename descclassname"></code><a class="headerlink" href="#cmdoption-unittest-discover-v" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Salida verbosa</p>
</dd></dl>

<dl class="std cmdoption">
<dt id="cmdoption-unittest-discover-s">
<span id="cmdoption-unittest-discover-start-directory"></span><code class="sig-name descname">-s</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--start-directory</code><code class="sig-prename descclassname"> directory</code><a class="headerlink" href="#cmdoption-unittest-discover-s" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Directorio de inicio para el descubrimiento (<code class="docutils literal notranslate"><span class="pre">.</span></code> si se omite)</p>
</dd></dl>

<dl class="std cmdoption">
<dt id="cmdoption-unittest-discover-p">
<span id="cmdoption-unittest-discover-pattern"></span><code class="sig-name descname">-p</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--pattern</code><code class="sig-prename descclassname"> pattern</code><a class="headerlink" href="#cmdoption-unittest-discover-p" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Patrón para la búsqueda de ficheros de prueba (<code class="docutils literal notranslate"><span class="pre">test*.py</span></code> si se omite)</p>
</dd></dl>

<dl class="std cmdoption">
<dt id="cmdoption-unittest-discover-t">
<span id="cmdoption-unittest-discover-top-level-directory"></span><code class="sig-name descname">-t</code><code class="sig-prename descclassname"></code><code class="sig-prename descclassname">, </code><code class="sig-name descname">--top-level-directory</code><code class="sig-prename descclassname"> directory</code><a class="headerlink" href="#cmdoption-unittest-discover-t" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Directorio superior del proyecto (el directorio inicial si se omite)</p>
</dd></dl>

<p>Las opciones <a class="reference internal" href="#cmdoption-unittest-discover-s"><code class="xref std std-option docutils literal notranslate"><span class="pre">-s</span></code></a>, <a class="reference internal" href="#cmdoption-unittest-discover-p"><code class="xref std std-option docutils literal notranslate"><span class="pre">-p</span></code></a>, y <a class="reference internal" href="#cmdoption-unittest-discover-t"><code class="xref std std-option docutils literal notranslate"><span class="pre">-t</span></code></a> se pueden pasar por posición en el orden mostrado. Las siguientes líneas de órdenes son equivalentes:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">discover</span> <span class="o">-</span><span class="n">s</span> <span class="n">project_directory</span> <span class="o">-</span><span class="n">p</span> <span class="s2">&quot;*_test.py&quot;</span>
<span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">discover</span> <span class="n">project_directory</span> <span class="s2">&quot;*_test.py&quot;</span>
</pre></div>
</div>
<p>Además de pasar una ruta, es posible pasar el nombre de un paquete, por ejemplo <code class="docutils literal notranslate"><span class="pre">myproject.subpackage.test</span></code>, como directorio de inicio. El nombre de paquete proporcionado será importado y su ubicación en el sistema de archivos será utilizada como directorio de inicio.</p>
<div class="admonition caution">
<p class="admonition-title">Prudencia</p>
<p>El descubrimiento de pruebas carga las pruebas importándolas. Una vez que el descubrimiento ha encontrado todos los ficheros de prueba a partir del directorio inicial, especificado, convierte las rutas en nombres de paquetes a importar. Por ejemplo, <code class="file docutils literal notranslate"><span class="pre">foo/bar/baz.py</span></code> será importado como <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>.</p>
<p>Si hay un paquete instalado globalmente y se intenta hacer un descubrimiento sobre una copia diferente a la instalada del paquete, <em>podría</em> ocurrir que se importe la versión incorrecta. Si ocurre esto, el descubrimiento lanza una advertencia y abandona.</p>
<p>Si se proporciona el directorio de inicio como nombre de paquete en lugar de ruta a un directorio, el descubrimiento asume que la ubicación importada es la deseada, así que no se da la advertencia descrita.</p>
</div>
<p>Los módulos y paquetes de prueba pueden personalizar la carta y descubrimiento de pruebas mediante el <a class="reference internal" href="#load-tests-protocol">protocolo load_tests</a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>El descubrimiento de pruebas admite <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">paquetes nominales</span></a> para el directorio de inicio. Tenga en cuenta que también se necesita el directorio de nivel superior. (por ejemplo, <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">unittest</span> <span class="pre">discover</span> <span class="pre">-s</span> <span class="pre">root/namespace</span> <span class="pre">-t</span> <span class="pre">root</span></code>).</p>
</div>
</section>
<section id="organizing-test-code">
<span id="organizing-tests"></span><h2>Organización del código de pruebas<a class="headerlink" href="#organizing-test-code" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los bloques de construcción básicos de las pruebas unitarias son los <em class="dfn">test cases</em>, escenarios simples que se han de configurar y cuya corrección hay que comprobar. En <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>, los casos de prueba están representados por instancias de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestCase</span></code></a>. Para crear nuevos casos de prueba, hay que escribir subclases de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> o usar <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionTestCase</span></code></a>.</p>
<p>El código de pruebas de una instancia de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> debería ser completamente autónomo, de tal modo que se pueda ejecutar aisladamente o en una combinación arbitraria con otras clases de prueba.</p>
<p>La subclase más simple de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> se limita a implementar un método test (o un método que empiece por <code class="docutils literal notranslate"><span class="pre">test</span></code>) para realizar código de prueba específico:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">DefaultWidgetSizeTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_default_widget_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s1">&#39;The widget&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
</pre></div>
</div>
<p>Adviértase que para probar algo, usamos uno de los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">assert*()</span></code> proporcionados por la clase base <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>. Si la prueba no tiene éxito, se lanzará una excepción con un mensaje explicativo y <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> identificará el caso como <em class="dfn">failure</em>. Cualquier otra excepción se considerará un <em class="dfn">errors</em>.</p>
<p>Las pruebas pueden ser muchas y su preparación puede ser repetitiva. Por suerte, se puede «sacar factor común» a la preparación implementando un método <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a>, al que la infraestructura de prueba llamará para cada prueba que se ejecute:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">WidgetTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s1">&#39;The widget&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_default_widget_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span>
                         <span class="s1">&#39;incorrect default size&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_widget_resize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">150</span><span class="p">),</span>
                         <span class="s1">&#39;wrong size after resize&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>El orden en que se ejecutan las diversas pruebas se determina por orden alfabético de los nombres de métodos de prueba.</p>
</div>
<p>Si el método <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> lanza una excepción mientras se ejecuta la prueba, la infraestructura considerará que la prueba ha sufrido un error y no se ejecutará el método de prueba propiamente dicho.</p>
<p>Análogamente, se puede proporcionar un método <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> que haga limpieza después de que se ejecute el método de prueba:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">WidgetTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">(</span><span class="s1">&#39;The widget&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widget</span><span class="o">.</span><span class="n">dispose</span><span class="p">()</span>
</pre></div>
</div>
<p>Si <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> se ejecuta sin errores, <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> se ejecutará tanto si el método de prueba tuvo éxito como si no.</p>
<p>Un entorno de trabajo así para el código de pruebas se llama <em class="dfn">test fixture</em> . Se crea una nueva instancia de TestCase como juego de datos de prueba que se utiliza para cada método de prueba. De este modo, <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a>, <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> se llamarán una vez por prueba.</p>
<p>Se recomienda usar implementaciones de <cite>TestCase</cite> para agrupar las pruebas de acuerdo con las características probadas. <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> proporciona una mecanismo para esto: el <em class="dfn">test suite</em>, representado por la clase <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> de <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>. En la mayor parte de los casos, llamar a <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.main()</span></code></a> hará lo correcto y recolectará todos los casos de prueba del módulo para su ejecución.</p>
<p>Sin embargo, si se desea personalizar la construcción del paquete de pruebas, se puede hacer:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">suite</span><span class="p">():</span>
    <span class="n">suite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestSuite</span><span class="p">()</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s1">&#39;test_default_widget_size&#39;</span><span class="p">))</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">WidgetTestCase</span><span class="p">(</span><span class="s1">&#39;test_widget_resize&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">suite</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">runner</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TextTestRunner</span><span class="p">()</span>
    <span class="n">runner</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">suite</span><span class="p">())</span>
</pre></div>
</div>
<p>Se puede poner las definiciones de los casos de prueba y de los paquetes de prueba en los mismos módulos que el código que prueban.(tal como <code class="file docutils literal notranslate"><span class="pre">widget.py</span></code>), pero sacarlos a un módulo aparte como <code class="file docutils literal notranslate"><span class="pre">test_widget.py</span></code> tiene diversas ventajas:</p>
<ul class="simple">
<li><p>El módulo de pruebas se puede ejecutar aisladamente desde la línea de órdenes.</p></li>
<li><p>El código de pruebas se puede separar con más facilidad del código de producción.</p></li>
<li><p>Disminuye la tentación de cambiar el código de prueba para ajustarse al código bajo prueba.</p></li>
<li><p>El código de pruebas debería modificarse con mucha menor frecuencia que el código bajo prueba.</p></li>
<li><p>Es más sencillo refactorizar el código bajo prueba.</p></li>
<li><p>El código para probar módulos escritos en C ha de estar en módulos aparte, así que ¿por qué no mantener la consistencia?</p></li>
<li><p>Si cambia la estrategia de prueba, no hay razón para cambiar el código fuente principal.</p></li>
</ul>
</section>
<section id="re-using-old-test-code">
<span id="legacy-unit-tests"></span><h2>Reutilización de código de prueba anterior<a class="headerlink" href="#re-using-old-test-code" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Habrá personas que tengan código de prueba previo que deseen ejecutar desde <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>, sin conversión previa de cada antigua función de prueba a una subclase de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>.</p>
<p>Por esto, <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> proporciona una clase <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionTestCase</span></code></a>. Se puede utilizar esta subclase de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> para envolver una función de prueba existente. Se pueden proporcionar también funciones de preparación y desmontaje.</p>
<p>Dada la siguiente función de prueba:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">testSomething</span><span class="p">():</span>
    <span class="n">something</span> <span class="o">=</span> <span class="n">makeSomething</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">something</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="c1"># ...</span>
</pre></div>
</div>
<p>se puede crear una instancia de caso de prueba de la siguiente manera, con métodos opcionales de preparación y desmontaje:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">testcase</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">FunctionTestCase</span><span class="p">(</span><span class="n">testSomething</span><span class="p">,</span>
                                     <span class="n">setUp</span><span class="o">=</span><span class="n">makeSomethingDB</span><span class="p">,</span>
                                     <span class="n">tearDown</span><span class="o">=</span><span class="n">deleteSomethingDB</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Aunque se puede usar <a class="reference internal" href="#unittest.FunctionTestCase" title="unittest.FunctionTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionTestCase</span></code></a> para convertir rápidamente unas pruebas existentes a un sistema basado en <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>, no es una vía recomendada. Tomarse el tiempo de construir subclases bien construidas de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> hará las futuras refactorizaciones de pruebas futura considerablemente más fácil.</p>
</div>
<p>En algunos casos, los tests existentes pueden haber sido escritos usando el módulo <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a>. En ese caso, <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> tiene una clase <code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestSuite</span></code> que puede construir automáticamente instancias de <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestSuite</span></code></a> partiendo de los test basados en <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a>.</p>
</section>
<section id="skipping-tests-and-expected-failures">
<span id="unittest-skipping"></span><h2>Omitir tests y fallos esperados<a class="headerlink" href="#skipping-tests-and-expected-failures" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
<p>Unittest soporta omitir métodos individuales de tests e incluso clases completas de tests. Además, soporta marcar un test como un «fallo esperado», un test que está roto y va a fallar, pero no debería ser contado como fallo en <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a>.</p>
<p>Omitir un test es solo cuestión de emplear el <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> <a class="reference internal" href="#unittest.skip" title="unittest.skip"><code class="xref py py-func docutils literal notranslate"><span class="pre">skip()</span></code></a> o una de sus variantes condicionales, llamando a <a class="reference internal" href="#unittest.TestCase.skipTest" title="unittest.TestCase.skipTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.skipTest()</span></code></a> dentro de <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> o en un método de test, o lanzando <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> directamente.</p>
<p>La omisión más básica tiene la siguiente forma:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s2">&quot;demonstrating skipping&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_nothing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fail</span><span class="p">(</span><span class="s2">&quot;shouldn&#39;t happen&quot;</span><span class="p">)</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">skipIf</span><span class="p">(</span><span class="n">mylib</span><span class="o">.</span><span class="n">__version__</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                     <span class="s2">&quot;not supported in this library version&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_format</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Tests that work for only a certain version of the library.</span>
        <span class="k">pass</span>

    <span class="nd">@unittest</span><span class="o">.</span><span class="n">skipUnless</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;win&quot;</span><span class="p">),</span> <span class="s2">&quot;requires Windows&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_windows_support</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># windows specific testing code</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">test_maybe_skipped</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">external_resource_available</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipTest</span><span class="p">(</span><span class="s2">&quot;external resource not available&quot;</span><span class="p">)</span>
        <span class="c1"># test code that depends on the external resource</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>Esta es la salida de ejecutar el ejemplo superior en modo verboso:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_format</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;not supported in this library version&#39;</span>
<span class="n">test_nothing</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;demonstrating skipping&#39;</span>
<span class="n">test_maybe_skipped</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;external resource not available&#39;</span>
<span class="n">test_windows_support</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">MyTestCase</span><span class="p">)</span> <span class="o">...</span> <span class="n">skipped</span> <span class="s1">&#39;requires Windows&#39;</span>

<span class="o">----------------------------------------------------------------------</span>
<span class="n">Ran</span> <span class="mi">4</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mf">0.005</span><span class="n">s</span>

<span class="n">OK</span> <span class="p">(</span><span class="n">skipped</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>Las clases pueden ser omitidas igual que los métodos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s2">&quot;showing class skipping&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MySkippedTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_not_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p><a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.setUp()</span></code></a> puede omitir también el test. Esto es útil cuando un recurso que necesita ser puesto a punto no está disponible.</p>
<p>Los fallos esperados emplean el decorador <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal notranslate"><span class="pre">expectedFailure()</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ExpectedFailureTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="nd">@unittest</span><span class="o">.</span><span class="n">expectedFailure</span>
    <span class="k">def</span> <span class="nf">test_fail</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;broken&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Es fácil lanzar tus propios decoradores que omitan haciendo un decorador que llame a <a class="reference internal" href="#unittest.skip" title="unittest.skip"><code class="xref py py-func docutils literal notranslate"><span class="pre">skip()</span></code></a>  en el test cuando quiere ser omitido. Este decorador omite el test a menos que el objeto pasado tenga un cierto atributo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">skipUnlessHasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">func</span><span class="p">:</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">unittest</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{!r}</span><span class="s2"> doesn&#39;t have </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
</pre></div>
</div>
<p>Los siguientes decoradores y la excepción implementan la omisión de tests y los fallos esperados:</p>
<dl class="py function">
<dt id="unittest.skip">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">skip</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">reason</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.skip" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Omitir incondicionalmente el test decorado. <em>reason</em> debe describir porqué el test está siendo omitido.</p>
</dd></dl>

<dl class="py function">
<dt id="unittest.skipIf">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">skipIf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">condition</span></em>, <em class="sig-param"><span class="n">reason</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.skipIf" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Omitir el test decorado si <em>condition</em> es verdadero.</p>
</dd></dl>

<dl class="py function">
<dt id="unittest.skipUnless">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">skipUnless</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">condition</span></em>, <em class="sig-param"><span class="n">reason</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.skipUnless" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Omitir el test decorado a menos que <em>condition</em> sea verdadero.</p>
</dd></dl>

<dl class="py function">
<dt id="unittest.expectedFailure">
<code class="sig-prename descclassname">&#64;</code><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">expectedFailure</code><a class="headerlink" href="#unittest.expectedFailure" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Marca el test como un fallo esperado.  Si falla el test o hay errores en la función de test misma (en lugar de en alguno de los métodos <em class="dfn">test fixture</em>) será considerado un éxito. Si el test pasa, será considerado un fallo.</p>
</dd></dl>

<dl class="py exception">
<dt id="unittest.SkipTest">
<em class="property">exception </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">SkipTest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">reason</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.SkipTest" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta excepción es lanzada para omitir un test.</p>
<p>Normalmente puedes usar directamente <a class="reference internal" href="#unittest.TestCase.skipTest" title="unittest.TestCase.skipTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.skipTest()</span></code></a> o uno de los decoradores de omisión en vez de lanzar esta excepción.</p>
</dd></dl>

<p>Los tests omitidos no ejecutarán <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> o <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a>. Las clases omitidas no ejecutarán <a class="reference internal" href="#unittest.TestCase.setUpClass" title="unittest.TestCase.setUpClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code></a> o <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a>. Los módulos omitidos no ejecutarán <code class="xref py py-func docutils literal notranslate"><span class="pre">setUpModule()</span></code> o <code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code>.</p>
</section>
<section id="distinguishing-test-iterations-using-subtests">
<span id="subtests"></span><h2>Distinguiendo iteraciones de tests empleando subtests<a class="headerlink" href="#distinguishing-test-iterations-using-subtests" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<p>Cuando hay diferencias muy pequeñas entre tus tests, por ejemplo algunos parámetros, unittest te permite distinguirlos dentro del cuerpo de un método de test empleando el administrador de contexto <a class="reference internal" href="#unittest.TestCase.subTest" title="unittest.TestCase.subTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subTest()</span></code></a> .</p>
<p>Por ejemplo, el siguiente test:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NumbersTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">test_even</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test that numbers between 0 and 5 are all even.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">subTest</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>producirá la siguiente salida:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;subtests.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">32</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>

<span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;subtests.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">32</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>

<span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;subtests.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">32</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Sin usar un subtest, la ejecución se pararía después del primer fallo, y el error sería más difícil de diagnosticar porque el valor de  <code class="docutils literal notranslate"><span class="pre">i</span></code> no se mostraría:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">======================================================================</span>
<span class="n">FAIL</span><span class="p">:</span> <span class="n">test_even</span> <span class="p">(</span><span class="n">__main__</span><span class="o">.</span><span class="n">NumbersTest</span><span class="p">)</span>
<span class="o">----------------------------------------------------------------------</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;subtests.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">32</span><span class="p">,</span> <span class="ow">in</span> <span class="n">test_even</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="ne">AssertionError</span><span class="p">:</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>
</pre></div>
</div>
</section>
<section id="classes-and-functions">
<span id="unittest-contents"></span><h2>Clases y funciones<a class="headerlink" href="#classes-and-functions" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Esta sección describe en detalle la API de <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>.</p>
<section id="test-cases">
<span id="testcase-objects"></span><h3>Casos de test<a class="headerlink" href="#test-cases" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py class">
<dt id="unittest.TestCase">
<em class="property">class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">TestCase</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">methodName</span><span class="o">=</span><span class="default_value">'runTest'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Las instancias de la clase  <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> representan las unidades lógicas de test en el universo de <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>. Esta clase está pensada para ser utilizada como clase base, con los test específicos siendo implementados por subclases concretas. Esta clase implementa la interfaz que necesita el ejecutor de tests para permitirle llevar a cabo los tests, y métodos que el código de test puede utilizar para chequear y reportar distintos tipos de fallo.</p>
<p>Cada instancia de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>  ejecutará un solo método base: el método llamado <em>methodName</em>. En la mayoría de usos de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>, no tendrás que cambiar el <em>methodName</em>  ni reimplementar el método por defecto  <code class="docutils literal notranslate"><span class="pre">runTest()</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span><a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> puede instancias con éxito sin dar un <em>methodName</em>.  Esto permite experimentar de manera sencilla con <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>  en el intérprete interactivo.</p>
</div>
<p>Las instancias de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>  proveen tres grupos de métodos: un grupo empleado para ejecutar el test, otro usado para que la implementación del test chequee condiciones y reporte fallos, y algunos métodos de indagación que permiten recopilar información sobre el test en si mismo.</p>
<p>Los métodos en el primer grupo (ejecutando el test) son:</p>
<dl class="py method">
<dt id="unittest.TestCase.setUp">
<code class="sig-name descname">setUp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.setUp" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Método llamado para preparar el banco de test. Es invocado inmediatamente antes de llamar al método de test; cualquier excepción lanzada por este método que no sea <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> o <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> será considerada un error en vez de un fallo del test. La implementación por defecto no hace nada.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.tearDown">
<code class="sig-name descname">tearDown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.tearDown" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Método llamado inmediatamente después de que se haya llamado el método de prueba y se haya registrado el resultado.  Se llama así aunque el método de ensayo haya planteado una excepción, por lo que la aplicación en las subclases puede tener que ser especialmente cuidadosa en cuanto a la comprobación del estado interno.  Cualquier excepción, que no sea  <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> o  <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>, planteada por este método se considerará un error adicional en lugar de un fallo de la prueba (aumentando así el número total de errores reportados). Este método sólo se llamará si <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> tiene éxito, independientemente del resultado del método de prueba. La implementación por defecto no hace nada.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.setUpClass">
<code class="sig-name descname">setUpClass</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.setUpClass" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método de clase llamado antes de que los tests en una clase individual sean ejecutados. <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code> es llamado con la clase como el único argumento y debe ser decorada como <a class="reference internal" href="functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">setUpClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Vea  <a class="reference internal" href="#class-and-module-fixtures">Class and Module Fixtures</a> para más detalles.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.tearDownClass">
<code class="sig-name descname">tearDownClass</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.tearDownClass" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un método de clase llamado después de que se hayan realizado tests en una clase individual. <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code> se llama con la clase como único argumento y debe ser decorado como un <a class="reference internal" href="functions.html#classmethod" title="classmethod"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classmethod()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">tearDownClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Vea  <a class="reference internal" href="#class-and-module-fixtures">Class and Module Fixtures</a> para más detalles.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">result</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.run" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Ejecutar la prueba, recogiendo el resultado en el objeto  <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a>  pasado como <em>result</em>.  Si se omite <em>result</em> o <code class="docutils literal notranslate"><span class="pre">None</span></code>, se crea un objeto resultado temporal (llamando al método <a class="reference internal" href="#unittest.TestCase.defaultTestResult" title="unittest.TestCase.defaultTestResult"><code class="xref py py-meth docutils literal notranslate"><span class="pre">defaultTestResult()</span></code></a>) y se emplea ese. El objeto resultante se devuelve al invocador de <a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a>.</p>
<p>El mismo efecto puede conseguirse simplemente llamando a la instancia <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Las versiones previas de <code class="docutils literal notranslate"><span class="pre">run</span></code> no retornaban el resultado. Tampoco lo hacía la llamada a una instancia.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.skipTest">
<code class="sig-name descname">skipTest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">reason</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.skipTest" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llamar a esto durante un método de prueba o <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> se salta el test actual.  Ver  <a class="reference internal" href="#unittest-skipping"><span class="std std-ref">Omitir tests y fallos esperados</span></a> para más información.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.subTest">
<code class="sig-name descname">subTest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">params</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.subTest" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un gestor de contexto que ejecuta el bloque de código adjunto como un subtest.  <em>msg</em> y <em>params</em> son valores opcionales y arbitrarios que se muestran cuando falla un subtest, permitiéndole identificarlos claramente.</p>
<p>Un caso de test puede contener cualquier número de declaraciones de subtest, y pueden anidarse arbitrariamente.</p>
<p>Ver <a class="reference internal" href="#subtests"><span class="std std-ref">Distinguiendo iteraciones de tests empleando subtests</span></a> para más información.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.debug">
<code class="sig-name descname">debug</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.debug" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Realice el test sin recoger el resultado.  Esto permite que las excepciones planteadas por el test se propaguen al invocado, y puede utilizarse para apoyar la ejecución de tests bajo un depurador.</p>
</dd></dl>

<p id="assert-methods">La clase <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> proporciona varios métodos de afirmación para comprobar y reportar fallos.  En la siguiente tabla se enumeran los métodos más utilizados (consulte las tablas siguientes para ver más métodos de afirmación):</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 48%" />
<col style="width: 34%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Método</p></th>
<th class="head"><p>Comprueba que</p></th>
<th class="head"><p>Nuevo en</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotEqual" title="unittest.TestCase.assertNotEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">!=</span> <span class="pre">b</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTrue(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bool(x)</span> <span class="pre">is</span> <span class="pre">True</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertFalse(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bool(x)</span> <span class="pre">is</span> <span class="pre">False</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertIs" title="unittest.TestCase.assertIs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIs(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">is</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertIsNot" title="unittest.TestCase.assertIsNot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsNot(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertIsNone" title="unittest.TestCase.assertIsNone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsNone(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">None</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertIsNotNone" title="unittest.TestCase.assertIsNotNone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsNotNone(x)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertIn" title="unittest.TestCase.assertIn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIn(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">in</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotIn" title="unittest.TestCase.assertNotIn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotIn(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertIsInstance" title="unittest.TestCase.assertIsInstance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsInstance(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">isinstance(a,</span> <span class="pre">b)</span></code></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotIsInstance" title="unittest.TestCase.assertNotIsInstance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotIsInstance(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">isinstance(a,</span> <span class="pre">b)</span></code></p></td>
<td><p>3.2</p></td>
</tr>
</tbody>
</table>
<p>Todos los métodos de aserción aceptan un argumento <em>msg</em> que, si se especifica, se utiliza como mensaje de error en caso de fallo (véase también <a class="reference internal" href="#unittest.TestCase.longMessage" title="unittest.TestCase.longMessage"><code class="xref py py-data docutils literal notranslate"><span class="pre">longMessage</span></code></a>). Tenga en cuenta que el argumento de la palabra clave <em>msg</em> puede pasarse a <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a>, <a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex()</span></code></a>, <a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns()</span></code></a>, <a class="reference internal" href="#unittest.TestCase.assertWarnsRegex" title="unittest.TestCase.assertWarnsRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarnsRegex()</span></code></a> sólo cuando se utilizan como gestor de contexto.</p>
<dl class="py method">
<dt id="unittest.TestCase.assertEqual">
<code class="sig-name descname">assertEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertEqual" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Testea que <em>first</em> y <em>second</em> son iguales. Si los valores no comparan como iguales, el test fallará.</p>
<p>Además, si <em>first</em> y <em>second</em> son exactamente del mismo tipo y uno de lista, tuple, dict, set, frozenset o str o cualquier tipo que una subclase registre con <a class="reference internal" href="#unittest.TestCase.addTypeEqualityFunc" title="unittest.TestCase.addTypeEqualityFunc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addTypeEqualityFunc()</span></code></a> se llamará a la función de igualdad específica del tipo para generar un mensaje de error por defecto más útil (véase también la <a class="reference internal" href="#type-specific-methods"><span class="std std-ref">lista de métodos específicos del tipo</span></a>).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.1: </span>Añadida la llamada automática de la función de igualdad de tipo específico.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span><a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertMultiLineEqual()</span></code></a> añadido como la función por defecto para igualdad de tipos cuando se comparan cadenas.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertNotEqual">
<code class="sig-name descname">assertNotEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotEqual" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Testea que <em>first</em> y <em>second</em> no son iguales.  Si los valores son iguales, el test fallará.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertTrue">
<code class="sig-name descname">assertTrue</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">expr</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertTrue" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="unittest.TestCase.assertFalse">
<code class="sig-name descname">assertFalse</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">expr</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertFalse" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Testea que <em>expr</em> es verdadero (o falso).</p>
<p>Note que esto es equivalente a <code class="docutils literal notranslate"><span class="pre">bool(expr)</span> <span class="pre">is</span> <span class="pre">True</span></code> y no a <code class="docutils literal notranslate"><span class="pre">expr</span> <span class="pre">is</span> <span class="pre">True</span></code> (use <code class="docutils literal notranslate"><span class="pre">assertIs(expr,</span> <span class="pre">True)</span></code> para lo último).  Este método también debe evitarse cuando se disponga de métodos más específicos (por ejemplo, <code class="docutils literal notranslate"><span class="pre">assertEqual(a,</span> <span class="pre">b)</span></code> en lugar de <code class="docutils literal notranslate"><span class="pre">assertTrue(a</span> <span class="pre">==</span> <span class="pre">b)</span></code>), porque proporcionan un mejor mensaje de error en caso de fallo.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertIs">
<code class="sig-name descname">assertIs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIs" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="unittest.TestCase.assertIsNot">
<code class="sig-name descname">assertIsNot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsNot" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Testea si <em>first</em> y <em>second</em> son (o no) el mismo objeto.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertIsNone">
<code class="sig-name descname">assertIsNone</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">expr</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsNone" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="unittest.TestCase.assertIsNotNone">
<code class="sig-name descname">assertIsNotNone</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">expr</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsNotNone" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Testea que <em>expr</em>  es (o no es) <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertIn">
<code class="sig-name descname">assertIn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">member</span></em>, <em class="sig-param"><span class="n">container</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIn" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="unittest.TestCase.assertNotIn">
<code class="sig-name descname">assertNotIn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">member</span></em>, <em class="sig-param"><span class="n">container</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotIn" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Testea que <em>member</em> está (o no está) en <em>container</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertIsInstance">
<code class="sig-name descname">assertIsInstance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">cls</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertIsInstance" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="unittest.TestCase.assertNotIsInstance">
<code class="sig-name descname">assertNotIsInstance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">cls</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotIsInstance" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Testea que <em>obj</em> es (o no es) una instancia de <em>cls</em> (que puede ser una clase o una tupla de clases, de la misma forma que soporta <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a>). Para chequear por el tipo exacto, use <a class="reference internal" href="#unittest.TestCase.assertIs" title="unittest.TestCase.assertIs"><code class="xref py py-func docutils literal notranslate"><span class="pre">assertIs(type(obj),</span> <span class="pre">cls)</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<p>Es también posible chequear la producción de excepciones, advertencias y mensajes de log usando los siguientes métodos:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 53%" />
<col style="width: 36%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Método</p></th>
<th class="head"><p>Comprueba que</p></th>
<th class="head"><p>Nuevo en</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises(exc,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></code> lanza <em>exc</em></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex(exc,</span> <span class="pre">r,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></code> lanza <em>exc</em> y el mensaje coincide con regex <em>r</em></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns(warn,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></code> lanza <em>warn</em></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertWarnsRegex" title="unittest.TestCase.assertWarnsRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarnsRegex(warn,</span> <span class="pre">r,</span> <span class="pre">fun,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">fun(*args,</span> <span class="pre">**kwds)</span></code> lanza <em>warn</em> y el mensaje coincide con regex <em>r</em></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertLogs" title="unittest.TestCase.assertLogs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLogs(logger,</span> <span class="pre">level)</span></code></a></p></td>
<td><p>El bloque <code class="docutils literal notranslate"><span class="pre">with</span></code> vuelca sus logs a <em>logger</em> con el <em>level</em> mínimo</p></td>
<td><p>3.4</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertLogs" title="unittest.TestCase.assertLogs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLogs(logger,</span> <span class="pre">level)</span></code></a></p></td>
<td><dl class="simple">
<dt>El bloque <code class="docutils literal notranslate"><span class="pre">with</span></code> no ingresa</dt><dd><p>El bloque <code class="docutils literal notranslate"><span class="pre">with</span></code> vuelca sus logs a <em>logger</em> con el <em>level</em> mínimo</p>
</dd>
</dl>
</td>
<td><p>3.10</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="unittest.TestCase.assertRaises">
<code class="sig-name descname">assertRaises</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">exception</span></em>, <em class="sig-param"><span class="n">callable</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertRaises" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt>
<code class="sig-name descname">assertRaises</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">exception</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span></dt>
<dd><p>Testea que se lanza una excepción cuando se llama a <em>callable</em> con cualquier argumento posicional o de palabra clave que también se pasa a  <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a>. El test pasa si se lanza <em>exception</em>, es un error si se lanza otra excepción, o falla si no se lanza ninguna excepción. Para tener en cuenta cualquiera de un grupo de excepciones, una tupla que contenga las clases de excepción puede ser pasada como <em>exception</em>.</p>
<p>Si sólo se dan los argumentos de <em>exception</em> y posiblemente <em>msg</em>, retorna un administrador de contexto para que el código testado pueda ser escrito en línea en lugar de como una función:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="n">SomeException</span><span class="p">):</span>
    <span class="n">do_something</span><span class="p">()</span>
</pre></div>
</div>
<p>Cuando se emplea como un administrador de contexto, <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a> acepta el argumento por palabra clave adicional  <em>msg</em>.</p>
<p>El gestor de contexto almacenará el objeto de excepción capturado en su atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">exception</span></code> .  Esto puede ser útil si la intención es realizar comprobaciones adicionales sobre la excepción planteada:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="n">SomeException</span><span class="p">)</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
    <span class="n">do_something</span><span class="p">()</span>

<span class="n">the_exception</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">exception</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">the_exception</span><span class="o">.</span><span class="n">error_code</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.1: </span>Añadió la capacidad de usar <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a> como gestor de contexto.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Añadido el atributo  <code class="xref py py-attr docutils literal notranslate"><span class="pre">exception</span></code> .</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Añadido el argumento por palabra clave <em>msg</em> cuando se emplea un gestor de contexto.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertRaisesRegex">
<code class="sig-name descname">assertRaisesRegex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">exception</span></em>, <em class="sig-param"><span class="n">regex</span></em>, <em class="sig-param"><span class="n">callable</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertRaisesRegex" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt>
<code class="sig-name descname">assertRaisesRegex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">exception</span></em>, <em class="sig-param"><span class="n">regex</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span></dt>
<dd><p>Como <a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a> pero también testea que <em>regex</em> coincide en la representación de la cadena de la excepción planteada.  <em>regex</em> puede ser un objeto de expresión regular o una cadena que contiene una expresión regular adecuada para ser usada por <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a>.  Ejemplos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">assertRaisesRegex</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;invalid literal for.*XYZ&#39;$&quot;</span><span class="p">,</span>
                       <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;XYZ&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>o:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaisesRegex</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="s1">&#39;literal&#39;</span><span class="p">):</span>
   <span class="nb">int</span><span class="p">(</span><span class="s1">&#39;XYZ&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1: </span>Añadido bajo el nombre de <code class="docutils literal notranslate"><span class="pre">assertRaisesRegexp</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Renombrado a  <a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex()</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Añadido el argumento por palabra clave <em>msg</em> cuando se emplea un gestor de contexto.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertWarns">
<code class="sig-name descname">assertWarns</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">warning</span></em>, <em class="sig-param"><span class="n">callable</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertWarns" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt>
<code class="sig-name descname">assertWarns</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">warning</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span></dt>
<dd><p>Testea que una advertencia se activa cuando se llama a <em>callable</em> con cualquier argumento posicional o de palabra clave que también se pasa a <a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns()</span></code></a>. El test pasa si se activa el <em>warning</em> y falla si no lo hace.  Cualquier excepción es un error. Para considerar cualquiera de un grupo de advertencias, una tupla que contenga las clases de advertencia puede ser pasada como <em>warnings</em>.</p>
<p>Si sólo se dan los argumentos de <em>advertencia</em> y  <em>msg</em>, retorna un gestor de contexto para que el código testado pueda ser escrito en línea en lugar de como una función:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertWarns</span><span class="p">(</span><span class="n">SomeWarning</span><span class="p">):</span>
    <span class="n">do_something</span><span class="p">()</span>
</pre></div>
</div>
<p>Cuando se usa como gestor de contexto, <a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns()</span></code></a>  acepta el argumento de palabra clave adicional <em>msg</em>.</p>
<p>El gestor de contexto almacenará el objeto de advertencia capturado en su atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">warning</span></code>, y la línea del código que disparó las advertencias en los atributos  <code class="xref py py-attr docutils literal notranslate"><span class="pre">filename</span></code>  y <code class="xref py py-attr docutils literal notranslate"><span class="pre">lineno</span></code> . Esto puede ser útil si la intención es realizar comprobaciones adicionales sobre la advertencia capturada:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertWarns</span><span class="p">(</span><span class="n">SomeWarning</span><span class="p">)</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
    <span class="n">do_something</span><span class="p">()</span>

<span class="bp">self</span><span class="o">.</span><span class="n">assertIn</span><span class="p">(</span><span class="s1">&#39;myfile.py&#39;</span><span class="p">,</span> <span class="n">cm</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span> <span class="n">cm</span><span class="o">.</span><span class="n">lineno</span><span class="p">)</span>
</pre></div>
</div>
<p>Este método funciona independientemente de los filtros de aviso que estén en su lugar cuando se llame.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Añadido el argumento por palabra clave <em>msg</em> cuando se emplea un gestor de contexto.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertWarnsRegex">
<code class="sig-name descname">assertWarnsRegex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">warning</span></em>, <em class="sig-param"><span class="n">regex</span></em>, <em class="sig-param"><span class="n">callable</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertWarnsRegex" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt>
<code class="sig-name descname">assertWarnsRegex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">warning</span></em>, <em class="sig-param"><span class="n">regex</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span></dt>
<dd><p>Como <a class="reference internal" href="#unittest.TestCase.assertWarns" title="unittest.TestCase.assertWarns"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertWarns()</span></code></a> pero también testea que <em>regex</em> coincide en el mensaje del aviso disparado.  <em>regex</em> puede ser un objeto de expresión regular o una cadena que contiene una expresión regular adecuada para ser usada por <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a>.  Ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">assertWarnsRegex</span><span class="p">(</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
                      <span class="sa">r</span><span class="s1">&#39;legacy_function\(\) is deprecated&#39;</span><span class="p">,</span>
                      <span class="n">legacy_function</span><span class="p">,</span> <span class="s1">&#39;XYZ&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>o:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertWarnsRegex</span><span class="p">(</span><span class="ne">RuntimeWarning</span><span class="p">,</span> <span class="s1">&#39;unsafe frobnicating&#39;</span><span class="p">):</span>
    <span class="n">frobnicate</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Añadido el argumento por palabra clave <em>msg</em> cuando se emplea un gestor de contexto.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertLogs">
<code class="sig-name descname">assertLogs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">logger</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertLogs" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un gestor de contexto para comprobar que al menos un mensaje está registrado en el <em>logger</em> o en uno de sus hijos, con al menos el <em>level</em> dado.</p>
<p>Si se da, <em>logger</em> debería ser un objeto <a class="reference internal" href="logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Logger</span></code></a> o un <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> dando el nombre de un logger.  El valor por defecto es el root logger, que captará todos los mensajes.</p>
<p>Si se da, <em>level</em> debe ser un nivel de logging numérico o su equivalente en cadena (por ejemplo, o bien <code class="docutils literal notranslate"><span class="pre">”ERROR”</span></code> o <code class="xref py py-attr docutils literal notranslate"><span class="pre">logging.ERROR</span></code>).  El valor por defecto es <code class="xref py py-attr docutils literal notranslate"><span class="pre">logging.INFO</span></code>.</p>
<p>El test pasa si al menos un mensaje emitido dentro del bloque <code class="docutils literal notranslate"><span class="pre">with</span></code>  coincide con las condiciones de <em>logger</em> y <em>level</em>, de lo contrario falla.</p>
<p>El objeto devuelto por el gestor de contexto es un ayudante de grabación que lleva un registro de los mensajes de registro que coinciden.  Tiene dos atributos:</p>
<dl class="py attribute">
<dt id="unittest.TestCase.records">
<code class="sig-name descname">records</code><a class="headerlink" href="#unittest.TestCase.records" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una lista de objetos <a class="reference internal" href="logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.LogRecord</span></code></a> de los mensajes de log coincidentes.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestCase.output">
<code class="sig-name descname">output</code><a class="headerlink" href="#unittest.TestCase.output" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una lista de objetos <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> con la salida forrajeada en los mensajes coincidentes.</p>
</dd></dl>

<p>Ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertLogs</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s1">&#39;INFO&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">cm</span><span class="p">:</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;first message&#39;</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;foo.bar&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;second message&#39;</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;INFO:foo:first message&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;ERROR:foo.bar:second message&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertNoLogs">
<code class="sig-name descname">assertNoLogs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">logger</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNoLogs" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un gestor de contexto para comprobar que al menos un mensaje está registrado en el <em>logger</em> o en uno de sus hijos, con al menos el <em>level</em> dado.</p>
<p>Si se da, <em>logger</em> debería ser un objeto <a class="reference internal" href="logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">logging.Logger</span></code></a> o un <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> dándole el nombre de un logger.  El valor por defecto es el root logger, que captará todos los mensajes.</p>
<p>Si se da, <em>level</em> debe ser un nivel de logging numérico o su equivalente en cadena (por ejemplo, o bien <code class="docutils literal notranslate"><span class="pre">”ERROR”</span></code> o <code class="xref py py-attr docutils literal notranslate"><span class="pre">logging.ERROR</span></code>).  El valor por defecto es <code class="xref py py-attr docutils literal notranslate"><span class="pre">logging.INFO</span></code>.</p>
<p>A diferencia de <a class="reference internal" href="#unittest.TestCase.assertLogs" title="unittest.TestCase.assertLogs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLogs()</span></code></a>, el gestor de contexto no devolverá nada.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</dd></dl>

<p>Hay también otros métodos empleados para realizar comprobaciones más específicas, tales como:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 46%" />
<col style="width: 38%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Método</p></th>
<th class="head"><p>Comprueba que</p></th>
<th class="head"><p>Nuevo en</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertAlmostEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">round(a-b,</span> <span class="pre">7)</span> <span class="pre">==</span> <span class="pre">0</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotAlmostEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">round(a-b,</span> <span class="pre">7)</span> <span class="pre">!=</span> <span class="pre">0</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertGreater" title="unittest.TestCase.assertGreater"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertGreater(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertGreaterEqual" title="unittest.TestCase.assertGreaterEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertGreaterEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertLess" title="unittest.TestCase.assertLess"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLess(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertLessEqual" title="unittest.TestCase.assertLessEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLessEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertRegex" title="unittest.TestCase.assertRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRegex(s,</span> <span class="pre">r)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">r.search(s)</span></code></p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex(s,</span> <span class="pre">r)</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">r.search(s)</span></code></p></td>
<td><p>3.2</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertCountEqual" title="unittest.TestCase.assertCountEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertCountEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p><em>a</em> y <em>b</em> tienen los mismos elementos y en el mismo número, sin importar su orden.</p></td>
<td><p>3.2</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="unittest.TestCase.assertAlmostEqual">
<code class="sig-name descname">assertAlmostEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">places</span><span class="o">=</span><span class="default_value">7</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">delta</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertAlmostEqual" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="unittest.TestCase.assertNotAlmostEqual">
<code class="sig-name descname">assertNotAlmostEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">places</span><span class="o">=</span><span class="default_value">7</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">delta</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotAlmostEqual" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Testea que <em>first</em> y <em>second</em> son aproximadamente (o no aproximadamente) iguales calculando su diferencia, redondeando al número dado de puntos <em>places</em> decimales (por defecto 7), y comparado a cero. Nótese que estos métodos redondean los valores al número dado de <em>puntos decimales</em> (por ejemplo como la función <a class="reference internal" href="functions.html#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a>) y no <em>cifras significativas</em>.</p>
<p>Si se suministra <em>delta</em> en vez de <em>places</em> que entonces la diferencia entre <em>first</em> y <em>second</em> deba ser menor o igual a (o mayor que) <em>delta</em>.</p>
<p>Suministrar tanto <em>delta</em> como <em>places</em> lanza un <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertAlmostEqual()</span></code></a> considera automáticamente casi iguales a los objetos que se comparan igual. <a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotAlmostEqual()</span></code></a> falla automáticamente si los objetos comparan iguales.  Añadido el argumento de palabra clave <em>delta</em>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertGreater">
<code class="sig-name descname">assertGreater</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertGreater" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="unittest.TestCase.assertGreaterEqual">
<code class="sig-name descname">assertGreaterEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertGreaterEqual" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="unittest.TestCase.assertLess">
<code class="sig-name descname">assertLess</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertLess" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="unittest.TestCase.assertLessEqual">
<code class="sig-name descname">assertLessEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertLessEqual" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Prueba que <em>first</em> es respectivamente &gt;, &gt;=, &lt; o &lt;= que <em>second</em> dependiendo del nombre del método.  Si no, el test fallará:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">assertGreaterEqual</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">AssertionError: &quot;3&quot; unexpectedly not greater than or equal to &quot;4&quot;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertRegex">
<code class="sig-name descname">assertRegex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">text</span></em>, <em class="sig-param"><span class="n">regex</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertRegex" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="unittest.TestCase.assertNotRegex">
<code class="sig-name descname">assertNotRegex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">text</span></em>, <em class="sig-param"><span class="n">regex</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertNotRegex" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Testea que una búsqueda <em>regex</em> coincide (o no coincide) con el <em>text</em>.  En caso de fallo, el mensaje de error incluirá el patrón y el <em>text</em> (o el patrón y la parte de <em>text</em> que coincida inesperadamente).  <em>regex</em> puede ser un objeto de expresión regular o una cadena que contiene una expresión regular adecuada para ser utilizada por <a class="reference internal" href="re.html#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1: </span>Añadido bajo el nombre de <code class="docutils literal notranslate"><span class="pre">assertRegexpMatches</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>El método <code class="docutils literal notranslate"><span class="pre">assertRegexpMatches()</span></code> ha sido renombrado a <a class="reference internal" href="#unittest.TestCase.assertRegex" title="unittest.TestCase.assertRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRegex()</span></code></a>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2: </span><a class="reference internal" href="#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex()</span></code></a>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5: </span>El nombre <code class="docutils literal notranslate"><span class="pre">assertNotRegexpMatches</span></code> es un alias obsoleto para  <a class="reference internal" href="#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertCountEqual">
<code class="sig-name descname">assertCountEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertCountEqual" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Testea que la secuencia <em>first</em> contiene los mismos elementos que <em>second</em>, independientemente de su orden. Cuando no lo hagan, se generará un mensaje de error con las diferencias entre las secuencias.</p>
<p>Los elementos duplicados <em>no</em> son ignorados cuando se comparan <em>first</em> y <em>second</em>. Verifica si cada elemento tiene la misma cuenta en ambas secuencias. Equivalente a: <code class="docutils literal notranslate"><span class="pre">assertEqual(Counter(list(first)),</span> <span class="pre">Counter(list(second)))</span></code> pero funciona también con secuencias de objetos que no son hashable.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<p id="type-specific-methods">El método <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> envía la comprobación de igualdad de los objetos del mismo tipo a diferentes métodos específicos de tipo.  Estos métodos ya están implementados para la mayoría de los tipos incorporados, pero también es posible registrar nuevos métodos usando <a class="reference internal" href="#unittest.TestCase.addTypeEqualityFunc" title="unittest.TestCase.addTypeEqualityFunc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addTypeEqualityFunc()</span></code></a>:</p>
<dl class="py method">
<dt id="unittest.TestCase.addTypeEqualityFunc">
<code class="sig-name descname">addTypeEqualityFunc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">typeobj</span></em>, <em class="sig-param"><span class="n">function</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.addTypeEqualityFunc" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Registra un método específico de tipo llamado por <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> para comprobar si dos objetos del mismo <em>typeobj</em> (no subclases) comparan como iguales.  <em>function</em> debe tomar dos argumentos posicionales y un tercer argumento de palabra clave msg=None tal y como lo hace <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>.  Debe lanzar   <a class="reference internal" href="#unittest.TestCase.failureException" title="unittest.TestCase.failureException"><code class="xref py py-data docutils literal notranslate"><span class="pre">self.failureException(msg)</span></code></a> cuando se detecta una desigualdad entre los dos primeros parámetros, posiblemente proporcionando información útil y explicando las desigualdades en detalle en el mensaje de error.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
</dd></dl>

<p>La lista de métodos específicos de tipo utilizados automáticamente por <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> se resumen en la siguiente tabla.  Tenga en cuenta que normalmente no es necesario invocar estos métodos directamente.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 49%" />
<col style="width: 35%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Método</p></th>
<th class="head"><p>Usado para comparar</p></th>
<th class="head"><p>Nuevo en</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertMultiLineEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>strings</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertSequenceEqual" title="unittest.TestCase.assertSequenceEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertSequenceEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>sequences</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertListEqual" title="unittest.TestCase.assertListEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertListEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>lists</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertTupleEqual" title="unittest.TestCase.assertTupleEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTupleEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>tuples</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertSetEqual" title="unittest.TestCase.assertSetEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertSetEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>sets or frozensets</p></td>
<td><p>3.1</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertDictEqual" title="unittest.TestCase.assertDictEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertDictEqual(a,</span> <span class="pre">b)</span></code></a></p></td>
<td><p>dicts</p></td>
<td><p>3.1</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="unittest.TestCase.assertMultiLineEqual">
<code class="sig-name descname">assertMultiLineEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertMultiLineEqual" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Testea que la cadena multilínea <em>first</em> es igual a la cadena <em>second</em>. Cuando no sea igual, una diferencia de las dos cadenas que resalte las diferencias se incluirá en el mensaje de error. Este método se utiliza por defecto cuando se comparan cadenas con <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertSequenceEqual">
<code class="sig-name descname">assertSequenceEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">seq_type</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertSequenceEqual" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Testea que dos secuencias son iguales.  Si se suministra un <em>seq_type</em>, tanto <em>first</em> como  <em>second</em> deben ser instancias de <em>seq_type</em> o se lanzará un fallo.  Si las secuencias son diferentes se construye un mensaje de error que muestra la diferencia entre las dos.</p>
<p>Este método no es llamado directamente por <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>, pero se usa para implementar <a class="reference internal" href="#unittest.TestCase.assertListEqual" title="unittest.TestCase.assertListEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertListEqual()</span></code></a> y <a class="reference internal" href="#unittest.TestCase.assertTupleEqual" title="unittest.TestCase.assertTupleEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTupleEqual()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertListEqual">
<code class="sig-name descname">assertListEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertListEqual" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="unittest.TestCase.assertTupleEqual">
<code class="sig-name descname">assertTupleEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertTupleEqual" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Testea que dos listas o tuplas son iguales.  Si no es así, se construye un mensaje de error que muestra sólo las diferencias entre las dos.  También se lanza un error si alguno de los parámetros es del tipo equivocado. Estos métodos se utilizan por defecto cuando se comparan listas o tuplas con <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertSetEqual">
<code class="sig-name descname">assertSetEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertSetEqual" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Testea que dos conjuntos son iguales.  Si no es así, se construye un mensaje de error que enumera las diferencias entre los conjuntos.  Este método se utiliza por defecto cuando se comparan los conjuntos o frozensets con <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>.</p>
<p>Falla si cualquiera de <em>first</em> o <em>second</em> no tiene un método de <code class="xref py py-meth docutils literal notranslate"><span class="pre">set.difference()</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.assertDictEqual">
<code class="sig-name descname">assertDictEqual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em>, <em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.assertDictEqual" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Testea que dos diccionarios son iguales.  Si no es así, se construye un mensaje de error que muestra las diferencias en los diccionarios. Este método se usará por defecto para comparar los diccionarios en las llamadas a <a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
</dd></dl>

<p id="other-methods-and-attrs">Finalmente, <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> proporciona los siguientes métodos y atributos:</p>
<dl class="py method">
<dt id="unittest.TestCase.fail">
<code class="sig-name descname">fail</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.fail" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Señala un fallo del test incondicionalmente, con <em>msg</em> o  <code class="docutils literal notranslate"><span class="pre">None</span></code> para el mensaje de error.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestCase.failureException">
<code class="sig-name descname">failureException</code><a class="headerlink" href="#unittest.TestCase.failureException" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este atributo de clase da la excepción lanzada por el método de test.  Si un marco de pruebas necesita utilizar una excepción especializada, posiblemente para llevar información adicional, debe subclasificar esta excepción para «jugar limpio» con el marco.  El valor inicial de este atributo es <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestCase.longMessage">
<code class="sig-name descname">longMessage</code><a class="headerlink" href="#unittest.TestCase.longMessage" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este atributo de clase determina lo que ocurre cuando se pasa un mensaje de fallo personalizado como el argumento msg a una llamada assertXYY que falla. <code class="docutils literal notranslate"><span class="pre">True</span></code> es el valor por defecto. En este caso, el mensaje personalizado se añade al final del mensaje de fallo estándar. Cuando se establece en <code class="docutils literal notranslate"><span class="pre">False</span></code>, el mensaje personalizado reemplaza al mensaje estándar.</p>
<p>La configuración de la clase puede ser anulada en los métodos de test individuales asignando un atributo de instancia, self.longMessage, a <code class="docutils literal notranslate"><span class="pre">True</span></code> o <code class="docutils literal notranslate"><span class="pre">False</span></code> antes de llamar a los métodos assert.</p>
<p>La configuración de la clase se reajusta antes de cada llamada de test.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestCase.maxDiff">
<code class="sig-name descname">maxDiff</code><a class="headerlink" href="#unittest.TestCase.maxDiff" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este atributo controla la longitud máxima de las diferencias de salida de métodos assert que reportan diferencias en caso de fallo. El valor predeterminado es de 80*8 caracteres. Los métodos assert afectados por este atributo son <a class="reference internal" href="#unittest.TestCase.assertSequenceEqual" title="unittest.TestCase.assertSequenceEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertSequenceEqual()</span></code></a> (incluyendo todos los métodos de comparación de secuencias que le delegan), <a class="reference internal" href="#unittest.TestCase.assertDictEqual" title="unittest.TestCase.assertDictEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertDictEqual()</span></code></a> y <a class="reference internal" href="#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertMultiLineEqual()</span></code></a>.</p>
<p>Poner <code class="docutils literal notranslate"><span class="pre">maxDiff</span></code> en <code class="docutils literal notranslate"><span class="pre">None</span></code> significa que no hay una longitud máxima de diferencias.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<p>Los marcos de test pueden utilizar los siguientes métodos para reunir información sobre el test:</p>
<dl class="py method">
<dt id="unittest.TestCase.countTestCases">
<code class="sig-name descname">countTestCases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.countTestCases" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el número de tests representados por este objeto de test.  Para las instancias de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>, este siempre será <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.defaultTestResult">
<code class="sig-name descname">defaultTestResult</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.defaultTestResult" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una instancia de la clase de resultado de test que debería utilizarse para esta clase de caso de test (si no se proporciona otra instancia de resultado al método <a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a>).</p>
<p>Para las instancias de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>, ésta siempre será una instancia de <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a>; las subclases de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> deben anular esto según sea necesario.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.id">
<code class="sig-name descname">id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.id" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Devuelva una cadena que identifique el caso de test específico.  Normalmente es el nombre completo del método de test, incluyendo el nombre del módulo y de la clase.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.shortDescription">
<code class="sig-name descname">shortDescription</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.shortDescription" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Devuelve una descripción de la prueba, o <code class="docutils literal notranslate"><span class="pre">None</span></code> si no se ha proporcionado ninguna descripción.  La implementación por defecto de este método devuelve la primera línea de la docstring del método de test, si está disponible, o  <code class="docutils literal notranslate"><span class="pre">None</span></code> .</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.1: </span>En 3.1 esto se cambió para añadir el nombre del test a la descripción corta incluso en presencia de una docstring.  Esto causó problemas de compatibilidad con las extensiones de unittest y la adición del nombre de test  fue movida a la <a class="reference internal" href="#unittest.TextTestResult" title="unittest.TextTestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextTestResult</span></code></a> en Python 3.2.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.addCleanup">
<code class="sig-name descname">addCleanup</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="o">/</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.addCleanup" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Añade una función que se llamará después de <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> a los recursos de limpieza utilizados durante el test. Las funciones se llamarán en orden inverso al orden en que se agregan (<abbr title="last-in, first-out">LIFO</abbr>).  Se llaman con cualquier argumento y argumentos de palabra clave que se pase a <a class="reference internal" href="#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addCleanup()</span></code></a> cuando se agregan.</p>
<p>Si <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> falla, lo que significa que <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> no se llama, entonces cualquier función de limpieza añadida seguirá siendo llamada.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.doCleanups">
<code class="sig-name descname">doCleanups</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.doCleanups" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método se llama incondicionalmente después de  <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a>,  o después de <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a>  si <a class="reference internal" href="#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> lanza una excepción.</p>
<p>Es responsable de llamar a todas las funciones de limpieza añadidas por <a class="reference internal" href="#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addCleanup()</span></code></a>. Si necesitas que las funciones de limpieza se llamen <em>con anterioridad</em> a <a class="reference internal" href="#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> entonces puedes llamar a <a class="reference internal" href="#unittest.TestCase.doCleanups" title="unittest.TestCase.doCleanups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">doCleanups()</span></code></a> tú mismo.</p>
<p><a class="reference internal" href="#unittest.TestCase.doCleanups" title="unittest.TestCase.doCleanups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">doCleanups()</span></code></a> saca los métodos de la pila de funciones de limpieza uno a uno, así que se puede llamar en cualquier momento.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.addClassCleanup">
<em class="property">classmethod </em><code class="sig-name descname">addClassCleanup</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="o">/</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.addClassCleanup" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Añade una función que se llamará después de <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a> para limpiar recursos utilizados durante la clase de test. Las funciones se llamarán en orden inverso al orden en que se agregan (<abbr title="last-in, first-out">LIFO</abbr>). Se llaman con cualquier argumento y argumento de palabra clave que se pase a <a class="reference internal" href="#unittest.TestCase.addClassCleanup" title="unittest.TestCase.addClassCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addClassCleanup()</span></code></a> cuando se añadan.</p>
<p>Si <a class="reference internal" href="#unittest.TestCase.setUpClass" title="unittest.TestCase.setUpClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code></a> falla, lo que significa que <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a> no se invoca, entonces cualquier función de limpieza añadida seguirá siendo llamada.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestCase.doClassCleanups">
<em class="property">classmethod </em><code class="sig-name descname">doClassCleanups</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestCase.doClassCleanups" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método se llama incondicionalmente después de <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a>, o después de <a class="reference internal" href="#unittest.TestCase.setUpClass" title="unittest.TestCase.setUpClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code></a>  si <a class="reference internal" href="#unittest.TestCase.setUpClass" title="unittest.TestCase.setUpClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code></a> lanza una excepción.</p>
<p>Es responsable de llamar a todas las funciones de limpieza añadidas por <code class="xref py py-meth docutils literal notranslate"><span class="pre">addCleanupClass()</span></code>. Si necesitas que las funciones de limpieza se llamen <em>con anterioridad</em> a <a class="reference internal" href="#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a> entonces puedes llamar a <code class="xref py py-meth docutils literal notranslate"><span class="pre">doCleanupsClass()</span></code> tú mismo.</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">doCleanupsClass()</span></code> saca los métodos de la pila de funciones de limpieza de uno en uno, así que se puede llamar en cualquier momento.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="unittest.IsolatedAsyncioTestCase">
<em class="property">class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">IsolatedAsyncioTestCase</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">methodName</span><span class="o">=</span><span class="default_value">'runTest'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta clase proporciona una API similar a <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> y también acepta corutinas como funciones de test.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
<dl class="py method">
<dt id="unittest.IsolatedAsyncioTestCase.asyncSetUp">
<em class="property">coroutine </em><code class="sig-name descname">asyncSetUp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase.asyncSetUp" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Método llamado para preparar la configuración de test. Esto se llama después de <code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code>. Se llama inmediatamente antes de llamar al método de test; aparte de <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> o <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>, cualquier excepción lanzada por este método se considerará un error más que un fallo del test. La implementación por defecto no hace nada.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.IsolatedAsyncioTestCase.asyncTearDown">
<em class="property">coroutine </em><code class="sig-name descname">asyncTearDown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase.asyncTearDown" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Método llamado inmediatamente después de que se haya llamado el método de test y se haya registrado el resultado.  Esto se llama antes de <code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code>. Se llama así aunque el método de test haya lanzado una excepción, por lo que la implementación en las subclases puede necesitar ser particularmente cuidadosa en la comprobación del estado interno.  Cualquier excepción, que no sea <a class="reference internal" href="exceptions.html#AssertionError" title="AssertionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> o <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>, lanzada por este método se considerará un error adicional en lugar de un fallo del test (aumentando así el número total de errores reportados). Este método sólo se llamará si <a class="reference internal" href="#unittest.IsolatedAsyncioTestCase.asyncSetUp" title="unittest.IsolatedAsyncioTestCase.asyncSetUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asyncSetUp()</span></code></a> tiene éxito, independientemente del resultado del método de test. La implementación por defecto no hace nada.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.IsolatedAsyncioTestCase.addAsyncCleanup">
<code class="sig-name descname">addAsyncCleanup</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="o">/</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase.addAsyncCleanup" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método acepta una corutina que puede ser utilizada como función de limpieza.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.IsolatedAsyncioTestCase.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">result</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.IsolatedAsyncioTestCase.run" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece un nuevo bucle de eventos para ejecutar el test, recogiendo el resultado en el objeto <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> pasado como <em>result</em>.  Si se omite <em>result</em> o <code class="docutils literal notranslate"><span class="pre">None</span></code>, se crea un objeto resultado temporal (llamando al método <code class="xref py py-meth docutils literal notranslate"><span class="pre">defaultTestResult()</span></code>) y se utiliza. El objeto resultante se devuelve al invocado de <a class="reference internal" href="#unittest.IsolatedAsyncioTestCase.run" title="unittest.IsolatedAsyncioTestCase.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a>. Al final del test se cancelan todas las tareas del bucle de eventos.</p>
</dd></dl>

<p>Un ejemplo ilustrando el orden:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">unittest</span> <span class="kn">import</span> <span class="n">IsolatedAsyncioTestCase</span>

<span class="n">events</span> <span class="o">=</span> <span class="p">[]</span>


<span class="k">class</span> <span class="nc">Test</span><span class="p">(</span><span class="n">IsolatedAsyncioTestCase</span><span class="p">):</span>


    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;setUp&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">asyncSetUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_async_connection</span> <span class="o">=</span> <span class="k">await</span> <span class="n">AsyncConnection</span><span class="p">()</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;asyncSetUp&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">test_response</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;test_response&quot;</span><span class="p">)</span>
        <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_async_connection</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;https://example.com&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">status_code</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addAsyncCleanup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_cleanup</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;tearDown&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">asyncTearDown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_async_connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;asyncTearDown&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">on_cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;cleanup&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>Después de ejecutar el test,  <code class="docutils literal notranslate"><span class="pre">events</span></code> contendría  <code class="docutils literal notranslate"><span class="pre">[“setUp”,</span> <span class="pre">“asyncSetUp”,</span> <span class="pre">“test_response”,</span> <span class="pre">“asyncTearDown”,</span> <span class="pre">“tearDown”,</span> <span class="pre">“cleanup”]</span></code>.</p>
</dd></dl>

<dl class="py class">
<dt id="unittest.FunctionTestCase">
<em class="property">class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">FunctionTestCase</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">testFunc</span></em>, <em class="sig-param"><span class="n">setUp</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tearDown</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">description</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.FunctionTestCase" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta clase implementa la porción de la interfaz <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> que permite al corredor de tests conducir los tests, pero no proporciona los métodos que el código de test puede utilizar para comprobar e informar de los errores.  Se utiliza para crear casos de test utilizando código de prueba heredado, lo que permite que se integre en un marco de tests basado en <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a>.</p>
</dd></dl>

<section id="deprecated-aliases">
<span id="id1"></span><h4>Alias obsoletos<a class="headerlink" href="#deprecated-aliases" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Por razones históricas, algunos de los métodos de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> tenían uno o más alias que ahora están obsoletos.  La siguiente tabla lista los nombres correctos junto con sus alias obsoletos:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 29%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Nombre del método</p></th>
<th class="head"><p>Alias deprecado</p></th>
<th class="head"><p>Alias deprecado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a></p></td>
<td><p>failUnlessEqual</p></td>
<td><p>assertEquals</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotEqual" title="unittest.TestCase.assertNotEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotEqual()</span></code></a></p></td>
<td><p>failIfEqual</p></td>
<td><p>assertNotEquals</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTrue()</span></code></a></p></td>
<td><p>failUnless</p></td>
<td><p>assert_</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertFalse()</span></code></a></p></td>
<td><p>failIf</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a></p></td>
<td><p>failUnlessRaises</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertAlmostEqual()</span></code></a></p></td>
<td><p>failUnlessAlmostEqual</p></td>
<td><p>assertAlmostEquals</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotAlmostEqual()</span></code></a></p></td>
<td><p>failIfAlmostEqual</p></td>
<td><p>assertNotAlmostEquals</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertRegex" title="unittest.TestCase.assertRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRegex()</span></code></a></p></td>
<td></td>
<td><p>assertRegexpMatches</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex()</span></code></a></p></td>
<td></td>
<td><p>assertNotRegexpMatches</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex()</span></code></a></p></td>
<td></td>
<td><p>assertRaisesRegexp</p></td>
</tr>
</tbody>
</table>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.1: </span>Los alias de fail* que figuran en la segunda columna han sido declarados obsoletos.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.2: </span>Los alias de aserción* que figuran en la tercera columna han sido declarados obsoletos.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.2: </span><code class="docutils literal notranslate"><span class="pre">assertRegexpMatches</span></code> y <code class="docutils literal notranslate"><span class="pre">assertRaisesRegexp</span></code> han sido renombrados a <a class="reference internal" href="#unittest.TestCase.assertRegex" title="unittest.TestCase.assertRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRegex()</span></code></a> y <a class="reference internal" href="#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegex()</span></code></a>.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.5: </span>El nombre <code class="docutils literal notranslate"><span class="pre">assertNotRegexpMatches</span></code> se ha declarado obsoleto en favor de <a class="reference internal" href="#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegex()</span></code></a>.</p>
</div>
</div></blockquote>
</section>
</section>
<section id="grouping-tests">
<span id="testsuite-objects"></span><h3>Agrupando tests<a class="headerlink" href="#grouping-tests" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py class">
<dt id="unittest.TestSuite">
<em class="property">class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">TestSuite</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tests</span><span class="o">=</span><span class="default_value">()</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta clase representa una agregación de casos de test individuales y conjuntos de tests. La clase presenta la interfaz que necesita el corredor de tests para poder ser ejecutado como cualquier otro caso de test.  Ejecutar una instancia <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> es lo mismo que iterar sobre el conjunto, ejecutando cada test individualmente.</p>
<p>Si se indican <em>tests</em>, debe ser un iterable de casos de test individuales u otros conjuntos de tests que se usarán para construir el conjunto inicialmente. Se proporcionan métodos adicionales para añadir casos de test y conjuntos a la colección más adelante.</p>
<p>Los objetos de <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> se comportan de manera muy parecida a los objetos de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>, excepto que no implementan un test.  En cambio, se usan para agregar tests en grupos de tests que deben ser ejecutados juntos. Existen algunos métodos adicionales para agregar tests a las instancias de <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>:</p>
<dl class="py method">
<dt id="unittest.TestSuite.addTest">
<code class="sig-name descname">addTest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">test</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.addTest" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Añade un <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> o <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> al conjunto.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestSuite.addTests">
<code class="sig-name descname">addTests</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tests</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.addTests" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Añade todos los tests de un iterable de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> y <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> a este conjunto de tests.</p>
<p>Esto equivale a iterar sobre <em>tests</em>, llamando a <a class="reference internal" href="#unittest.TestSuite.addTest" title="unittest.TestSuite.addTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addTest()</span></code></a> para cada elemento.</p>
</dd></dl>

<p><a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> comparte los siguientes métodos con <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>:</p>
<dl class="py method">
<dt id="unittest.TestSuite.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">result</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.run" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Ejecuta los tests asociados a este conjunto, recogiendo el resultado en el objeto de resultado del test pasado como <em>result</em>.  Tenga en cuenta que a diferencia de <a class="reference internal" href="#unittest.TestCase.run" title="unittest.TestCase.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.run()</span></code></a>, <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite.run()</span></code></a> requiere que se pase el objeto resultado.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestSuite.debug">
<code class="sig-name descname">debug</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.debug" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Ejecuta los tests asociados con este conjunto sin recoger los resultados. Esto permite que las excepciones lanzadas por este test sean propagadas al invocador y puedes ser usadas para apoyar tests que están ejecutándose con un debugger.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestSuite.countTestCases">
<code class="sig-name descname">countTestCases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.countTestCases" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el numero de tests representados por este objeto de test, incluidos todos los test individuales y los sub-conjuntos.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestSuite.__iter__">
<code class="sig-name descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestSuite.__iter__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Los tests agrupados por una <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> se acceden siempre por iteración. Las subclases pueden proporcionar tests anulando <a class="reference internal" href="#unittest.TestSuite.__iter__" title="unittest.TestSuite.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>. Tenga en cuenta que este método puede ser invocado varias veces en un mismo conjunto (por ejemplo, cuando se cuentan los tests o se comparan por igualdad), por lo que los tests retornados por iteraciones repetidas antes de <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite.run()</span></code></a> deben ser los mismos para cada iteración de invocación. Después de <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite.run()</span></code></a>, los invocados no deben confiar en los tests retornados por este método a menos que el invocado utilice una subclase que anule <code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite._removeTestAtIndex()</span></code> para preservar las referencias de los tests.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>En versiones anteriores la <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> accedía a los test directamente en lugar de a través de la iteración, por lo que anular <a class="reference internal" href="#unittest.TestSuite.__iter__" title="unittest.TestSuite.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> no era suficiente para proporcionar los tests.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>En versiones anteriores, la <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> tenía referencias a cada <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> después de <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite.run()</span></code></a>. Las subclases pueden restaurar ese comportamiento anulando <code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite._removeTestAtIndex()</span></code>.</p>
</div>
</dd></dl>

<p>En el uso típico de un objeto <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>, el método <a class="reference internal" href="#unittest.TestSuite.run" title="unittest.TestSuite.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> es invocado por un <code class="xref py py-class docutils literal notranslate"><span class="pre">TestRunner</span></code> en lugar de por el marco de test de pruebas automático del usuario final.</p>
</dd></dl>

</section>
<section id="loading-and-running-tests">
<h3>Cargando y ejecutando tests<a class="headerlink" href="#loading-and-running-tests" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py class">
<dt id="unittest.TestLoader">
<em class="property">class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">TestLoader</code><a class="headerlink" href="#unittest.TestLoader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La clase <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> se utiliza para crear conjuntos de tests a partir de clases y módulos.  Normalmente, no es necesario crear una instancia de esta clase; el módulo <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> proporciona una instancia que puede ser compartida como <a class="reference internal" href="#unittest.defaultTestLoader" title="unittest.defaultTestLoader"><code class="xref py py-data docutils literal notranslate"><span class="pre">unittest.defaultTestLoader</span></code></a>.  Sin embargo, el uso de una subclase o instancia permite la personalización de algunas propiedades configurables.</p>
<p>Los objetos <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a>  tienen los siguientes atributos:</p>
<dl class="py attribute">
<dt id="unittest.TestLoader.errors">
<code class="sig-name descname">errors</code><a class="headerlink" href="#unittest.TestLoader.errors" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>A list of the non-fatal errors encountered while loading tests. Not reset
by the loader at any point. Fatal errors are signalled by the relevant
method raising an exception to the caller. Non-fatal errors are also
indicated by a synthetic test that will raise the original error when
run.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
</dd></dl>

<p>Los objetos <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> tienen los siguientes métodos:</p>
<dl class="py method">
<dt id="unittest.TestLoader.loadTestsFromTestCase">
<code class="sig-name descname">loadTestsFromTestCase</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">testCaseClass</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromTestCase" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Devuelve un conjunto de todos los casos de test contenidos en la <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>derivada de <code class="xref py py-class docutils literal notranslate"><span class="pre">testCaseClass</span></code>.</p>
<p>Se crea una instancia de caso de test para cada método nombrado por <a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getTestCaseNames()</span></code></a>. Por defecto, estos son los nombres de los métodos que comienzan con <code class="docutils literal notranslate"><span class="pre">test</span></code>. Si <a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getTestCaseNames()</span></code></a> no retorna ningún método, pero se implementa el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">runTest()</span></code>, se crea un único caso de test para ese método.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestLoader.loadTestsFromModule">
<code class="sig-name descname">loadTestsFromModule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">module</span></em>, <em class="sig-param"><span class="n">pattern</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromModule" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Devuelva un conjunto de todos los casos de test contenidos en el módulo dado. Este método busca en <em>module</em> clases derivadas de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> y crea una instancia de la clase para cada método de test definido para la clase.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Aunque el uso de una jerarquía de clases derivadas de  <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>  puede ser conveniente para compartir configuraciones y funciones de ayuda, la definición de métodos de test en clases base que no están destinadas a ser instanciadas directamente no complementa bien con este método.  Hacerlo, sin embargo, puede ser útil cuando las configuraciones son diferentes y están definidas en subclases.</p>
</div>
<p>Si un módulo proporciona una función <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> será llamado para cargar los tests. Esto permite a los módulos personalizar la carga de los tests. Este es el <a class="reference internal" href="#load-tests-protocol">load_tests protocol</a>.  El argumento <em>pattern</em> se pasa como tercer argumento a <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Se ha añadido soporte para <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>El argumento por defecto <em>use_load_tests</em> no documentado y no oficial es obsoleto e ignorado, aunque sigue siendo aceptado por la retrocompatibilidad.  El método también acepta ahora un argumento de sólo palabra clave <em>pattern</em> que se pasa a <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> como tercer argumento.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestLoader.loadTestsFromName">
<code class="sig-name descname">loadTestsFromName</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">module</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromName" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un conjunto de todos los casos de test dado un especificador de cadena.</p>
<p>El especificador <em>name</em> es un «nombre punteado» que puede resolverse ya sea a un módulo, una clase de caso de test, un método de test dentro de una clase de caso de test, una instancia <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>, o un objeto invocable que devuelve una instancia <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> o <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>.  Estas comprobaciones se aplican en el orden que se indica aquí; es decir, un método en una posible clase de caso de test se recogerá como «un método de test dentro de una clase de caso de test”, en lugar de «un objeto invocable”.</p>
<p>Por ejemplo, si tiene un módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">SampleTests</span></code> que contiene una clase derivada de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> <code class="xref py py-class docutils literal notranslate"><span class="pre">SampleTestCase</span></code> con tres métodos de test (<code class="xref py py-meth docutils literal notranslate"><span class="pre">test_one()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">test_two()</span></code>, y <code class="xref py py-meth docutils literal notranslate"><span class="pre">test_three()</span></code>), el especificador <code class="docutils literal notranslate"><span class="pre">SampleTests.SampleTestCase'</span></code> haría que este método devolviera una suite que ejecutara los tres métodos de prueba. El uso del especificador <code class="docutils literal notranslate"><span class="pre">SampleTests.SampleTestCase.test_two'</span></code> provocaría que este método devolviera una suite de tests que ejecutaría sólo el método de test <code class="xref py py-meth docutils literal notranslate"><span class="pre">test_two()</span></code>. El especificador puede referirse a los módulos y paquetes que no han sido importados; serán importados como un efecto secundario.</p>
<p>El método opcionalmente resuelve <em>name</em> relativo al <em>module</em> dado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Si un <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> o <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> ocurre mientras atraviesa <em>name</em> entonces se devolverá un test sintético que lanza ese error cuando se ejecuta. Estos errores están incluidos en los errores acumulados por self.errors.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestLoader.loadTestsFromNames">
<code class="sig-name descname">loadTestsFromNames</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">names</span></em>, <em class="sig-param"><span class="n">module</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.loadTestsFromNames" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Similar a <a class="reference internal" href="#unittest.TestLoader.loadTestsFromName" title="unittest.TestLoader.loadTestsFromName"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFromName()</span></code></a>, pero toma una secuencia de nombres en lugar de un solo nombre.  El valor de retorno es una suite de tests que soporta todos los test  definidos para cada nombre.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestLoader.getTestCaseNames">
<code class="sig-name descname">getTestCaseNames</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">testCaseClass</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.getTestCaseNames" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Devuelve una secuencia ordenada de nombres de métodos encontrados dentro de <em>testCaseClass</em>; esta debería ser una subclase de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestLoader.discover">
<code class="sig-name descname">discover</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">start_dir</span></em>, <em class="sig-param"><span class="n">pattern</span><span class="o">=</span><span class="default_value">'test*.py'</span></em>, <em class="sig-param"><span class="n">top_level_dir</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestLoader.discover" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Encuentra todos los módulos de prueba recurriendo a subdirectorios del directorio de inicio especificado, y retorna un objeto de TestSuite que los contenga. Sólo se cargarán los archivos de test que coincidan con el <em>pattern</em>. (Utilizando la coincidencia de patrones de estilo de shell.) Sólo se cargarán los nombres de los módulos que sean importables (es decir, que sean identificadores Python válidos).</p>
<p>Todos los módulos de test deben ser importables desde el nivel superior del proyecto. Si el directorio de inicio no es el directorio de nivel superior, entonces el directorio de nivel superior debe ser especificado por separado.</p>
<p>Si la importación de un módulo falla, por ejemplo debido a un error de sintaxis, entonces esto se registrará como un error único y el descubrimiento continuará.  Si el fallo en la importación se debe a que <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> se ha lanzado, se registrará como un salto en lugar de un error.</p>
<p>Si se encuentra un paquete (un directorio que contiene un archivo llamado <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code>), se comprobará si el paquete tiene una función <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>. Si existe, entonces se invocará <code class="docutils literal notranslate"><span class="pre">package.load_tests(loader,</span> <span class="pre">tests,</span> <span class="pre">pattern)</span></code>. Test discovery se encarga de asegurar que un paquete sólo se comprueba una vez durante una invocación, incluso si la propia función load_tests llama a <code class="docutils literal notranslate"><span class="pre">loader.discover</span></code>.</p>
<p>Si <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> existe, entonces el descubrimiento <em>no</em> recurre en el paquete, <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> es responsable de cargar todos los tests en el paquete.</p>
<p>El patrón no se almacena deliberadamente como atributo cargador para que los paquetes puedan continuar descubriéndose a sí mismos. <em>top_level_dir</em> se almacena de forma que <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> no necesita pasar este argumento a <code class="docutils literal notranslate"><span class="pre">loader.discover()</span></code>.</p>
<p><em>start_dir</em> puede ser un nombre de módulo punteado así como un directorio.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Los módulos que lanzan <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> en la importación se registran como saltos, no como errores.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span><em>start_dir</em> puede ser un <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">paquete de espacios de nombres</span></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Las rutas se ordenan antes de ser importadas para que el orden de ejecución sea el mismo, incluso si el orden del sistema de archivos subyacente no depende del nombre del archivo.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Los paquetes encontrados son ahora comprobados para <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> sin importar si su ruta coincide con el <em>pattern</em>, porque es imposible que el nombre de un paquete coincida con el patrón por defecto.</p>
</div>
</dd></dl>

<p>Los siguientes atributos de un <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> pueden ser configurados ya sea por subclasificación o asignación en una instancia:</p>
<dl class="py attribute">
<dt id="unittest.TestLoader.testMethodPrefix">
<code class="sig-name descname">testMethodPrefix</code><a class="headerlink" href="#unittest.TestLoader.testMethodPrefix" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Cadena que da el prefijo de los nombres de métodos que serán interpretados como métodos de test.  El valor por defecto es <code class="docutils literal notranslate"><span class="pre">'test'</span></code>.</p>
<p>Esto afecta a <a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getTestCaseNames()</span></code></a> y a todos los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFrom*()</span></code> .</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestLoader.sortTestMethodsUsing">
<code class="sig-name descname">sortTestMethodsUsing</code><a class="headerlink" href="#unittest.TestLoader.sortTestMethodsUsing" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Función que se utiliza para comparar los nombres de los métodos al clasificarlos en <a class="reference internal" href="#unittest.TestLoader.getTestCaseNames" title="unittest.TestLoader.getTestCaseNames"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getTestCaseNames()</span></code></a> y todos los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFrom*()</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestLoader.suiteClass">
<code class="sig-name descname">suiteClass</code><a class="headerlink" href="#unittest.TestLoader.suiteClass" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Objeto invocable que construye un conjunto de pruebas a partir de una lista de pruebas. No se necesitan métodos en el objeto resultante.  El valor por defecto es la clase <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>.</p>
<p>Esto afecta a todos los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFrom*()</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestLoader.testNamePatterns">
<code class="sig-name descname">testNamePatterns</code><a class="headerlink" href="#unittest.TestLoader.testNamePatterns" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>List of Unix shell-style wildcard test name patterns that test methods
have to match to be included in test suites (see <code class="docutils literal notranslate"><span class="pre">-k</span></code> option).</p>
<p>If this attribute is not <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default), all test methods to be
included in test suites must match one of the patterns in this list.
Note that matches are always performed using <a class="reference internal" href="fnmatch.html#fnmatch.fnmatchcase" title="fnmatch.fnmatchcase"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fnmatch.fnmatchcase()</span></code></a>,
so unlike patterns passed to the <code class="docutils literal notranslate"><span class="pre">-k</span></code> option, simple substring patterns
will have to be converted using <code class="docutils literal notranslate"><span class="pre">*</span></code> wildcards.</p>
<p>Esto afecta a todos los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFrom*()</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="unittest.TestResult">
<em class="property">class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">TestResult</code><a class="headerlink" href="#unittest.TestResult" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta clase se utiliza para recopilar información sobre qué tests han tenido éxito y cuáles han fracasado.</p>
<p>Un objeto  <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a>  almacena los resultados de una serie de pruebas.  Las clases <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> y <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> aseguran que los resultados se registren correctamente; los autores de los tests no tienen que preocuparse de registrar el resultado de las mismas.</p>
<p>Los marcos de pruebas construidos sobre <a class="reference internal" href="#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> pueden querer acceder al objeto <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> generado por la ejecución de un conjunto de tests con fines de reporte; una instancia <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> es devuelta por el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">TestRunner.run()</span></code> para este propósito.</p>
<p>Las instancias de <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> tienen los siguientes atributos que serán de interés cuando se inspeccionen los resultados de la ejecución de un conjunto de tests:</p>
<dl class="py attribute">
<dt id="unittest.TestResult.errors">
<code class="sig-name descname">errors</code><a class="headerlink" href="#unittest.TestResult.errors" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una lista que contiene 2 tuplas de instancias <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> y cadenas con formato de tracebacks. Cada tupla representa una prueba que lanzó una excepción inesperada.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestResult.failures">
<code class="sig-name descname">failures</code><a class="headerlink" href="#unittest.TestResult.failures" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una lista que contiene 2 tuplas de instancias <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> y cadenas con formato de traceback. Cada tupla representa un test en el que un fallo fue explícitamente señalado usando los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">TestCase.assert*()</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestResult.skipped">
<code class="sig-name descname">skipped</code><a class="headerlink" href="#unittest.TestResult.skipped" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una lista que contiene 2 tuplas de instancias de <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> y cadenas que contienen la razón para saltarse el test.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestResult.expectedFailures">
<code class="sig-name descname">expectedFailures</code><a class="headerlink" href="#unittest.TestResult.expectedFailures" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una lista que contiene 2 tuplas de instancias <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> y cadenas con formato de traceback.  Cada tupla representa un fallo esperado del caso de test.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestResult.unexpectedSuccesses">
<code class="sig-name descname">unexpectedSuccesses</code><a class="headerlink" href="#unittest.TestResult.unexpectedSuccesses" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una lista que contiene instancias de  <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>  que fueron marcadas como fracasos esperados, pero tuvieron éxito.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestResult.shouldStop">
<code class="sig-name descname">shouldStop</code><a class="headerlink" href="#unittest.TestResult.shouldStop" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Puesto en <code class="docutils literal notranslate"><span class="pre">True</span></code> cuando la ejecución de los tests se detenga por <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestResult.testsRun">
<code class="sig-name descname">testsRun</code><a class="headerlink" href="#unittest.TestResult.testsRun" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El número total de tests realizados hasta ahora.</p>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestResult.buffer">
<code class="sig-name descname">buffer</code><a class="headerlink" href="#unittest.TestResult.buffer" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si se ajusta a true, <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> y <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> serán almacenados entre <a class="reference internal" href="#unittest.TestResult.startTest" title="unittest.TestResult.startTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startTest()</span></code></a> y <a class="reference internal" href="#unittest.TestResult.stopTest" title="unittest.TestResult.stopTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stopTest()</span></code></a> siendo llamados. La salida recolectada sólo tendrá eco en el verdadero <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> y <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> si la prueba falla o se equivoca. Cualquier salida también se adjunta al mensaje de fallo / error.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestResult.failfast">
<code class="sig-name descname">failfast</code><a class="headerlink" href="#unittest.TestResult.failfast" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si se ajusta a true <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> se llamará al primer fallo o error, deteniendo la ejecución de la prueba.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="unittest.TestResult.tb_locals">
<code class="sig-name descname">tb_locals</code><a class="headerlink" href="#unittest.TestResult.tb_locals" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si se ajusta a true entonces las variables locales se mostrarán en los tracebacks.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.wasSuccessful">
<code class="sig-name descname">wasSuccessful</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.wasSuccessful" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Devuelve <code class="docutils literal notranslate"><span class="pre">True</span></code> si todas las pruebas realizadas hasta ahora han pasado, de lo contrario devuelve <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Devuelve <code class="docutils literal notranslate"><span class="pre">False</span></code> si hubo algún <a class="reference internal" href="#unittest.TestResult.unexpectedSuccesses" title="unittest.TestResult.unexpectedSuccesses"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unexpectedSuccesses</span></code></a> de las pruebas marcadas con el decorador <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal notranslate"><span class="pre">expectedFailure()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.stop">
<code class="sig-name descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.stop" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método puede ser llamado para señalar que el conjunto de pruebas que se están ejecutando debe ser abortado poniendo el atributo <a class="reference internal" href="#unittest.TestResult.shouldStop" title="unittest.TestResult.shouldStop"><code class="xref py py-attr docutils literal notranslate"><span class="pre">shouldStop</span></code></a> en <code class="docutils literal notranslate"><span class="pre">True</span></code>. <code class="xref py py-class docutils literal notranslate"><span class="pre">TestRunner</span></code> los objetos deben respetar esta bandera y regresar sin ejecutar ninguna prueba adicional.</p>
<p>Por ejemplo, esta característica es utilizada por la clase <a class="reference internal" href="#unittest.TextTestRunner" title="unittest.TextTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextTestRunner</span></code></a> para detener el marco de pruebas cuando el usuario señala una interrupción desde el teclado.  Las herramientas interactivas que proporcionan implementaciones de <code class="xref py py-class docutils literal notranslate"><span class="pre">TestRunner</span></code> pueden usar esto de manera similar.</p>
</dd></dl>

<p>Los siguientes métodos de la clase <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> se utilizan para mantener las estructuras de datos internos, y pueden ampliarse en subclases para apoyar los requisitos de información adicionales.  Esto es particularmente útil para construir herramientas que apoyen la presentación de informes interactivos mientras se ejecutan las pruebas.</p>
<dl class="py method">
<dt id="unittest.TestResult.startTest">
<code class="sig-name descname">startTest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">test</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.startTest" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llamado cuando el caso de prueba <em>test</em> está a punto de ser ejecutado.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.stopTest">
<code class="sig-name descname">stopTest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">test</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.stopTest" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llamado después de que el caso de prueba <em>prueba</em> haya sido ejecutado, independientemente del resultado.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.startTestRun">
<code class="sig-name descname">startTestRun</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.startTestRun" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llamado una vez antes de que se ejecute cualquier prueba.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.stopTestRun">
<code class="sig-name descname">stopTestRun</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.stopTestRun" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llamado una vez después de que se ejecuten todas las pruebas.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.addError">
<code class="sig-name descname">addError</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">test</span></em>, <em class="sig-param"><span class="n">err</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addError" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llamado cuando el caso de prueba <em>test</em> plantea una excepción inesperada. <em>err</em> es una tupla de la forma devuelta por <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>: <code class="docutils literal notranslate"><span class="pre">(type,</span> <span class="pre">value,</span> <span class="pre">traceback)</span></code>.</p>
<p>La implementación por defecto añade una tupla <code class="docutils literal notranslate"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></code> al atributo <a class="reference internal" href="#unittest.TestResult.errors" title="unittest.TestResult.errors"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errors</span></code></a> de la instancia, donde <em>formatted_err</em> es una traza formateada derivada de <em>err</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.addFailure">
<code class="sig-name descname">addFailure</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">test</span></em>, <em class="sig-param"><span class="n">err</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addFailure" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llamado cuando el caso de prueba <em>test</em> señala un fallo. <em>err</em> es una tupla de la forma devuelta por <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>: <code class="docutils literal notranslate"><span class="pre">(type,</span> <span class="pre">value,</span> <span class="pre">traceback)</span></code>.</p>
<p>La implementación por defecto añade una tupla <code class="docutils literal notranslate"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></code> al atributo <a class="reference internal" href="#unittest.TestResult.failures" title="unittest.TestResult.failures"><code class="xref py py-attr docutils literal notranslate"><span class="pre">failures</span></code></a> de la instancia, donde <em>formatted_err</em> es una traza formateada derivada de <em>err</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.addSuccess">
<code class="sig-name descname">addSuccess</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">test</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addSuccess" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llamado cuando el caso de prueba <em>test</em> tenga éxito.</p>
<p>La implementación por defecto no hace nada.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.addSkip">
<code class="sig-name descname">addSkip</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">test</span></em>, <em class="sig-param"><span class="n">reason</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addSkip" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llamado cuando se salta el caso de prueba <em>test</em>. <em>reason</em> es la razón que la prueba dio para saltarse.</p>
<p>La implementación por defecto añade una tupla <code class="docutils literal notranslate"><span class="pre">(test,</span> <span class="pre">reason)</span></code> al atributo <a class="reference internal" href="#unittest.TestResult.skipped" title="unittest.TestResult.skipped"><code class="xref py py-attr docutils literal notranslate"><span class="pre">skipped</span></code></a> de la instancia.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.addExpectedFailure">
<code class="sig-name descname">addExpectedFailure</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">test</span></em>, <em class="sig-param"><span class="n">err</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addExpectedFailure" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llamó cuando el caso de prueba <em>test</em> falla, pero fue marcado con el decorador <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal notranslate"><span class="pre">expectedFailure()</span></code></a>.</p>
<p>La implementación por defecto añade una tupla <code class="docutils literal notranslate"><span class="pre">(test,</span> <span class="pre">formatted_err)</span></code> al atributo <a class="reference internal" href="#unittest.TestResult.expectedFailures" title="unittest.TestResult.expectedFailures"><code class="xref py py-attr docutils literal notranslate"><span class="pre">expectedFailures</span></code></a> de la instancia, donde <em>formatted_err</em> es una traza formateada derivada de <em>err</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.addUnexpectedSuccess">
<code class="sig-name descname">addUnexpectedSuccess</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">test</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addUnexpectedSuccess" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llamó cuando el caso de prueba <em>test</em> se marcó con el decorador <a class="reference internal" href="#unittest.expectedFailure" title="unittest.expectedFailure"><code class="xref py py-func docutils literal notranslate"><span class="pre">expectedFailure()</span></code></a>, pero tuvo éxito.</p>
<p>La implementación por defecto añade la prueba al atributo <a class="reference internal" href="#unittest.TestResult.unexpectedSuccesses" title="unittest.TestResult.unexpectedSuccesses"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unexpectedSuccesses</span></code></a> de la instancia.</p>
</dd></dl>

<dl class="py method">
<dt id="unittest.TestResult.addSubTest">
<code class="sig-name descname">addSubTest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">test</span></em>, <em class="sig-param"><span class="n">subtest</span></em>, <em class="sig-param"><span class="n">outcome</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TestResult.addSubTest" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Llamado cuando termina una subtest.  <em>test</em> es el caso de prueba correspondiente al método de test.  <em>subtest</em> es una instancia personalizada <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> que describe el test.</p>
<p>Si <em>outcome</em> es <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>, el subtest tuvo éxito.  De lo contrario, falló con una excepción en la que <em>outcome</em> es una tupla de la forma devuelta por <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>: <code class="docutils literal notranslate"><span class="pre">(type,</span> <span class="pre">value,</span> <span class="pre">traceback)</span></code>.</p>
<p>La implementación por defecto no hace nada cuando el resultado es un éxito, y registra los fallos del subtest como fallos normales.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="unittest.TextTestResult">
<em class="property">class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">TextTestResult</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">stream</span></em>, <em class="sig-param"><span class="n">descriptions</span></em>, <em class="sig-param"><span class="n">verbosity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestResult" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una implementación concreta de <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> utilizado por el <a class="reference internal" href="#unittest.TextTestRunner" title="unittest.TextTestRunner"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextTestRunner</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2: </span>Esta clase se llamaba anteriormente  <code class="docutils literal notranslate"><span class="pre">_TextTestResult</span></code>. El antiguo nombre todavía existe como un alias pero está obsoleto.</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="unittest.defaultTestLoader">
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">defaultTestLoader</code><a class="headerlink" href="#unittest.defaultTestLoader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Instancia de la clase <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> destinada a ser compartida.  Si no es necesario personalizar la clase <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a>, esta instancia puede utilizarse en lugar de crear repetidamente nuevas instancias.</p>
</dd></dl>

<dl class="py class">
<dt id="unittest.TextTestRunner">
<em class="property">class </em><code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">TextTestRunner</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">stream</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">descriptions</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">verbosity</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">failfast</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">buffer</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">resultclass</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">warnings</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">tb_locals</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestRunner" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una implementación básica del test runner que produce resultados en una corriente. Si <em>stream</em> es <code class="docutils literal notranslate"><span class="pre">None</span></code>, el valor por defecto, <a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a> se utiliza como flujo de salida. Esta clase tiene unos pocos parámetros configurables, pero es esencialmente muy simple.  Las aplicaciones gráficas que ejecutan las suites de prueba deben proporcionar implementaciones alternativas. Tales implementaciones deberían aceptar <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> como interfaz para construir los cambios de los corredores cuando se añaden características a unittest.</p>
<p>Por defecto este runner muestra <a class="reference internal" href="exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>, <a class="reference internal" href="exceptions.html#PendingDeprecationWarning" title="PendingDeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PendingDeprecationWarning</span></code></a>, <a class="reference internal" href="exceptions.html#ResourceWarning" title="ResourceWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ResourceWarning</span></code></a> y <a class="reference internal" href="exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportWarning</span></code></a> aunque estén <a class="reference internal" href="warnings.html#warning-ignored"><span class="std std-ref">ignorados por defecto</span></a>. Las advertencias de deprecación causadas por <a class="reference internal" href="#deprecated-aliases"><span class="std std-ref">métodos deprecated unittest</span></a> también tienen un caso especial y, cuando los filtros de advertencia están <code class="docutils literal notranslate"><span class="pre">'default'</span></code> o <code class="docutils literal notranslate"><span class="pre">'always'</span></code>, aparecerán sólo una vez por módulo, para evitar demasiados mensajes de advertencia.  Este comportamiento puede ser anulado usando las opciones <code class="xref std std-option docutils literal notranslate"><span class="pre">-Wd</span></code> o <code class="xref std std-option docutils literal notranslate"><span class="pre">-Wa</span></code> de Python (ver <a class="reference internal" href="../using/cmdline.html#using-on-warnings"><span class="std std-ref">Control de advertencias</span></a>) y dejando <em>warnings</em> a <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Añadió el argumento <code class="docutils literal notranslate"><span class="pre">warnings</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>El flujo por defecto está configurado como <a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a> en tiempo de instanciación en lugar de tiempo de importación.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Añadido el parámetro tb_locals.</p>
</div>
<dl class="py method">
<dt id="unittest.TextTestRunner._makeResult">
<code class="sig-name descname">_makeResult</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestRunner._makeResult" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método devuelve la instancia de <code class="docutils literal notranslate"><span class="pre">TestResult</span></code> usada por <a class="reference internal" href="#unittest.TextTestRunner.run" title="unittest.TextTestRunner.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a>. No está destinado a ser llamado directamente, pero puede ser anulado en subclases para proporcionar un <code class="docutils literal notranslate"><span class="pre">TestResult</span></code> personalizado.</p>
<p><code class="docutils literal notranslate"><span class="pre">_makeResult()</span></code> instanciando la clase o el pasaje llamado en el constructor <code class="docutils literal notranslate"><span class="pre">TextTestRunner</span></code> como el argumento de <code class="docutils literal notranslate"><span class="pre">resultclass</span></code>. Por defecto es <a class="reference internal" href="#unittest.TextTestResult" title="unittest.TextTestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextTestResult</span></code></a> si no se proporciona ninguna <code class="docutils literal notranslate"><span class="pre">resultclass</span></code>. La clase de resultado se instanciará con los siguientes argumentos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">stream</span><span class="p">,</span> <span class="n">descriptions</span><span class="p">,</span> <span class="n">verbosity</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="unittest.TextTestRunner.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">test</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.TextTestRunner.run" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método es la principal interfaz pública del <code class="docutils literal notranslate"><span class="pre">TextTestRunner</span></code>. Este método toma una instancia <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> o <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>. Se crea una <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> llamando a <a class="reference internal" href="#unittest.TextTestRunner._makeResult" title="unittest.TextTestRunner._makeResult"><code class="xref py py-func docutils literal notranslate"><span class="pre">_makeResult()</span></code></a> y se ejecuta(n) la(s) prueba(s) y se imprimen los resultados a stdout.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="unittest.main">
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">main</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">module</span><span class="o">=</span><span class="default_value">'__main__'</span></em>, <em class="sig-param"><span class="n">defaultTest</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">argv</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">testRunner</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">testLoader</span><span class="o">=</span><span class="default_value">unittest.defaultTestLoader</span></em>, <em class="sig-param"><span class="n">exit</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">verbosity</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">failfast</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">catchbreak</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">buffer</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">warnings</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.main" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un programa de línea de comandos que carga un conjunto de pruebas de <em>módulo</em> y las ejecuta; esto es principalmente para hacer los módulos de prueba convenientemente ejecutables. El uso más simple de esta función es incluir la siguiente línea al final de un guión de prueba:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>Puedes hacer pruebas con información más detallada pasando el argumento de la verbosity:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">unittest</span><span class="o">.</span><span class="n">main</span><span class="p">(</span><span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>El argumento <em>defaultTest</em> es el nombre de una prueba única o un iterable de nombres de pruebas a ejecutar si no se especifican nombres de pruebas a través de <em>argv</em>.  Si no se especifica o <code class="docutils literal notranslate"><span class="pre">Ninguno</span></code> y no se proporcionan nombres de pruebas vía <em>argv</em>, se ejecutan todas las pruebas encontradas en <em>modulo</em>.</p>
<p>El argumento <em>argv</em> puede ser una lista de opciones pasadas al programa, siendo el primer elemento el nombre del programa.  Si no se especifica o <code class="docutils literal notranslate"><span class="pre">Ninguno</span></code>, se utilizan los valores de <a class="reference internal" href="sys.html#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.argv</span></code></a>.</p>
<p>El argumento <em>testRunner</em> puede ser una clase de corredor de prueba o una instancia ya creada de él. Por defecto <code class="docutils literal notranslate"><span class="pre">main</span></code> llama <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a> con un código de salida que indica el éxito o el fracaso de la ejecución de las pruebas.</p>
<p>El argumento <em>testLoader</em> tiene que ser una instancia <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a>, y por defecto <a class="reference internal" href="#unittest.defaultTestLoader" title="unittest.defaultTestLoader"><code class="xref py py-data docutils literal notranslate"><span class="pre">defaultTestLoader</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">main</span></code> apoya el uso del intérprete interactivo pasando el argumento <code class="docutils literal notranslate"><span class="pre">exit=False</span></code>. Esto muestra el resultado en la salida estándar sin llamar a <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">unittest</span> <span class="kn">import</span> <span class="n">main</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">main</span><span class="p">(</span><span class="n">module</span><span class="o">=</span><span class="s1">&#39;test_module&#39;</span><span class="p">,</span> <span class="n">exit</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Los parámetros <em>failfast</em>, <em>catchbreak</em> y <em>buffer</em> tienen el mismo efecto que las <a class="reference internal" href="#command-line-options">command-line options</a> del mismo nombre.</p>
<p>El argumento <em>warnings</em> especifica el <a class="reference internal" href="warnings.html#warning-filter"><span class="std std-ref">filtro de aviso</span></a> que debe ser usado mientras se realizan los tests.  Si no se especifica, permanecerá como <code class="docutils literal notranslate"><span class="pre">None</span></code> si se pasa una opción <code class="xref std std-option docutils literal notranslate"><span class="pre">-W</span></code> a <strong class="program">python</strong> (ver <a class="reference internal" href="../using/cmdline.html#using-on-warnings"><span class="std std-ref">Warning control</span></a>), de lo contrario se establecerá como <code class="docutils literal notranslate"><span class="pre">’default’</span></code>.</p>
<p>Invocar <code class="docutils literal notranslate"><span class="pre">main</span></code> en realidad devuelve una instancia de la clase <code class="docutils literal notranslate"><span class="pre">TestProgram</span></code>. Esto almacena el resultado de las pruebas ejecutadas como el atributo <code class="docutils literal notranslate"><span class="pre">result</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.1: </span>El parámetro <em>exit</em> fue añadido.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Los parámetros <em>verbosity</em>, <em>failfast</em>, <em>catchbreak</em>, <em>buffer</em> y <em>warnings</em> fueron añadidos.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>El parámetro <em>defaultTest</em> fue cambiado para aceptar también un iterable de nombres de pruebas.</p>
</div>
</dd></dl>

<section id="load-tests-protocol">
<h4>load_tests protocolo<a class="headerlink" href="#load-tests-protocol" title="Enlazar permanentemente con este título">¶</a></h4>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
<p>Los módulos o paquetes pueden personalizar la forma en que se cargan las pruebas a partir de ellos durante las ejecuciones de prueba normales o el descubrimiento de pruebas mediante la implementación de una función llamada <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>.</p>
<p>Si un módulo de tests define <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> será llamado por <a class="reference internal" href="#unittest.TestLoader.loadTestsFromModule" title="unittest.TestLoader.loadTestsFromModule"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestLoader.loadTestsFromModule()</span></code></a> con los siguientes argumentos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
</pre></div>
</div>
<p>donde <em>pattern</em> se pasa directamente desde <code class="docutils literal notranslate"><span class="pre">loadTestsFromModule</span></code>.  Por defecto es <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Debe retornar una <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>.</p>
<p><em>loader</em> es la instancia de <a class="reference internal" href="#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> haciendo la carga. <em>standard_tests</em> son los tests que se cargarían por defecto desde el módulo. Es común que los módulos de test sólo quieran añadir o quitar tests del conjunto de tests estándar. El tercer argumento se usa cuando se cargan paquetes como parte del descubrimiento de tests.</p>
<p>Una típica función de <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> que carga pruebas de un conjunto específico de <code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase`class:`TestCase</span></code> puede ser como:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_cases</span> <span class="o">=</span> <span class="p">(</span><span class="n">TestCase1</span><span class="p">,</span> <span class="n">TestCase2</span><span class="p">,</span> <span class="n">TestCase3</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
    <span class="n">suite</span> <span class="o">=</span> <span class="n">TestSuite</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">test_class</span> <span class="ow">in</span> <span class="n">test_cases</span><span class="p">:</span>
        <span class="n">tests</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">loadTestsFromTestCase</span><span class="p">(</span><span class="n">test_class</span><span class="p">)</span>
        <span class="n">suite</span><span class="o">.</span><span class="n">addTests</span><span class="p">(</span><span class="n">tests</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">suite</span>
</pre></div>
</div>
<p>Si discovery se inicia en un directorio que contiene un paquete, ya sea desde la línea de comandos o llamando a <a class="reference internal" href="#unittest.TestLoader.discover" title="unittest.TestLoader.discover"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestLoader.discover()</span></code></a>, entonces el paquete <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> se comprobará por <code class="docutils literal notranslate"><span class="pre">load_tests</span></code>.  Si esa función no existe, discover se reincorporará al paquete como si fuera un directorio más.  De lo contrario, el descubrimiento de los tests del paquete se dejará en <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> que se llama con los siguientes argumentos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
</pre></div>
</div>
<p>Esto debería devolver un <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> que represente todas las pruebas del paquete. (<code class="docutils literal notranslate"><span class="pre">test_estándar</span></code> sólo contendrá las pruebas recogidas de <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code>.)</p>
<p>Debido a que el patrón se pasa a <code class="docutils literal notranslate"><span class="pre">load_tests</span></code> el paquete es libre de continuar (y potencialmente modificar) el descubrimiento de pruebas. Una función de “no hace nada” <code class="docutils literal notranslate"><span class="pre">load_test</span></code> para un paquete de pruebas se vería como:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_tests</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">standard_tests</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
    <span class="c1"># top level directory cached on loader instance</span>
    <span class="n">this_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>
    <span class="n">package_tests</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">discover</span><span class="p">(</span><span class="n">start_dir</span><span class="o">=</span><span class="n">this_dir</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="n">pattern</span><span class="p">)</span>
    <span class="n">standard_tests</span><span class="o">.</span><span class="n">addTests</span><span class="p">(</span><span class="n">package_tests</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">standard_tests</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Discovery ya no comprueba si los nombres de los paquetes coinciden con el <em>patrón</em> debido a la imposibilidad de que los nombres de los paquetes coincidan con el patrón por defecto.</p>
</div>
</section>
</section>
</section>
<section id="class-and-module-fixtures">
<h2>Instalaciones para clases y módulos<a class="headerlink" href="#class-and-module-fixtures" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los accesorios de nivel de clase y módulo se implementan en <a class="reference internal" href="#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a>. Cuando el conjunto de pruebas se encuentra con una prueba de una nueva clase entonces se llama <code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code> de la clase anterior (si existe), seguido de <code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code> de la nueva clase.</p>
<p>Del mismo modo, si una prueba es de un módulo diferente de la prueba anterior, entonces se ejecuta <code class="docutils literal notranslate"><span class="pre">DesmontarMódulo</span></code> del módulo anterior, seguido de <code class="docutils literal notranslate"><span class="pre">DesmontarMódulo</span></code> del nuevo módulo.</p>
<p>Después de todas las pruebas, se ejecutan los últimos <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code> y <code class="docutils literal notranslate"><span class="pre">tearDownModule</span></code>.</p>
<p>Tenga en cuenta que los accesorios compartidos no juegan bien con las características [potenciales] como la paralelización de la prueba y rompen el aislamiento de la prueba. Deben ser usados con cuidado.</p>
<p>El orden por defecto de las pruebas creadas por los cargadores de pruebas unitarias es agrupar todas las pruebas de los mismos módulos y clases. Esto llevará a que <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code> / <code class="docutils literal notranslate"><span class="pre">setUpModule</span></code> (etc) sea llamado exactamente una vez por clase y módulo. Si se aleatoriza el orden, de manera que las pruebas de diferentes módulos y clases sean adyacentes entre sí, entonces estas funciones compartidas de fixture pueden ser llamadas varias veces en una sola ejecución de prueba.</p>
<p>Los accesorios compartidos no están pensados para trabajar con suites con pedidos no estándar. Todavía existe una <code class="docutils literal notranslate"><span class="pre">BaseTestSuite</span></code> para los marcos de trabajo que no quieren soportar accesorios compartidos.</p>
<p>Si hay alguna excepción planteada durante una de las funciones compartidas del aparato, la prueba se notifica como un error. Debido a que no hay una instancia de prueba correspondiente, se crea un objeto <code class="docutils literal notranslate"><span class="pre">_ErrorHolder</span></code> (que tiene la misma interfaz que un <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>) para representar el error. Si sólo estás usando el standard unittest test runner entonces este detalle no importa, pero si eres un autor de marcos de trabajo puede ser relevante.</p>
<section id="setupclass-and-teardownclass">
<h3>setUpClass y tearDownClass<a class="headerlink" href="#setupclass-and-teardownclass" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Estos deben ser implementados como métodos de clase:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">Test</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">setUpClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_connection</span> <span class="o">=</span> <span class="n">createExpensiveConnectionObject</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">tearDownClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
</pre></div>
</div>
<p>Si quieres que se invoque a <code class="docutils literal notranslate"><span class="pre">SetUpClass</span></code> y <code class="docutils literal notranslate"><span class="pre">BreakdownClass</span></code> en clases base, debes llamarlos tú mismo. Las implementaciones en  <a class="reference internal" href="#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a>  están vacías.</p>
<p>Si se lanza una excepción durante una <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code>, entonces los tests de la clase no se ejecutan y la <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code> no se ejecuta. Las clases que se salten no tendrán <code class="docutils literal notranslate"><span class="pre">setUpClass</span></code> o <code class="docutils literal notranslate"><span class="pre">tearDownClass</span></code>. Si la excepción es una <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>  entonces la clase será reportada como salteada en lugar de como un error.</p>
</section>
<section id="setupmodule-and-teardownmodule">
<h3>setUpModule y tearDownModule<a class="headerlink" href="#setupmodule-and-teardownmodule" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Estos deben ser implementados como funciones:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">setUpModule</span><span class="p">():</span>
    <span class="n">createConnection</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">tearDownModule</span><span class="p">():</span>
    <span class="n">closeConnection</span><span class="p">()</span>
</pre></div>
</div>
<p>Si se lanza una excepción en un  <code class="docutils literal notranslate"><span class="pre">setUpModule</span></code>, entonces no se ejecutará ninguna de las pruebas del módulo y no se ejecutará el <code class="docutils literal notranslate"><span class="pre">tearDownModule</span></code>. Si la excepción es una <a class="reference internal" href="#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a>   entonces el módulo será reportado como saltado en lugar de como un error.</p>
<p>Para agregar código de limpieza que se debe ejecutar incluso en el caso de una excepción, utilice <code class="docutils literal notranslate"><span class="pre">addModuleCleanup</span></code>:</p>
<dl class="py function">
<dt id="unittest.addModuleCleanup">
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">addModuleCleanup</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="o">/</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.addModuleCleanup" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Añade una función que se llamará después de <code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code> para limpiar los recursos utilizados durante la clase de test. Las funciones se llamarán en orden inverso al orden en que se agregan (<abbr title="last-in, first-out">LIFO</abbr>). Se llaman con cualquier argumento y palabra clave que se pase a <a class="reference internal" href="#unittest.addModuleCleanup" title="unittest.addModuleCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addModuleCleanup()</span></code></a> cuando se añadan.</p>
<p>Si <code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpModule()</span></code> falla, lo que significa que <code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code> no se invoca, entonces cualquier función de limpieza añadida seguirá siendo invocada.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="unittest.doModuleCleanups">
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">doModuleCleanups</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.doModuleCleanups" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta función se llama incondicionalmente después de <code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code>, o después de <code class="xref py py-func docutils literal notranslate"><span class="pre">setUpModule()</span></code> si <code class="xref py py-func docutils literal notranslate"><span class="pre">setUpModule()</span></code> lanza una excepción.</p>
<p>It is responsible for calling all the cleanup functions added by
<a class="reference internal" href="#unittest.addModuleCleanup" title="unittest.addModuleCleanup"><code class="xref py py-func docutils literal notranslate"><span class="pre">addModuleCleanup()</span></code></a>. If you need cleanup functions to be called
<em>prior</em> to <code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code> then you can call
<a class="reference internal" href="#unittest.doModuleCleanups" title="unittest.doModuleCleanups"><code class="xref py py-func docutils literal notranslate"><span class="pre">doModuleCleanups()</span></code></a> yourself.</p>
<p><a class="reference internal" href="#unittest.doModuleCleanups" title="unittest.doModuleCleanups"><code class="xref py py-func docutils literal notranslate"><span class="pre">doModuleCleanups()</span></code></a> saca los métodos de la pila de funciones de limpieza uno a uno, así que se puede llamar en cualquier momento.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

</section>
</section>
<section id="signal-handling">
<h2>Manejo de señales<a class="headerlink" href="#signal-handling" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
<p>La opción <a class="reference internal" href="#cmdoption-unittest-c"><code class="xref std std-option docutils literal notranslate"><span class="pre">-c/--catch</span></code></a> línea de comando para unittest, junto con el parámetro <code class="docutils literal notranslate"><span class="pre">catchbreak</span></code> de <a class="reference internal" href="#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.main()</span></code></a>, proporcionan un manejo más amigable del control-C durante una prueba. Con el comportamiento catch break habilitado, control-C permitirá que se complete la prueba que se está ejecutando actualmente, y la ejecución de la prueba terminará y reportará todos los resultados hasta ahora. Un segundo control-C lanzará una <a class="reference internal" href="exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> de la manera habitual.</p>
<p>El manejador de señales de manejo de control-c intenta permanecer compatible con el código o las pruebas que instalan su propio manejador <a class="reference internal" href="signal.html#signal.SIGINT" title="signal.SIGINT"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIGINT</span></code></a> . Si se llama al manejador <code class="docutils literal notranslate"><span class="pre">unittest</span></code> pero <em>no es</em> el manejador <a class="reference internal" href="signal.html#signal.SIGINT" title="signal.SIGINT"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIGINT</span></code></a> instalado, es decir, ha sido reemplazado por el sistema bajo test y delegado, entonces llama al manejador por defecto. Este será normalmente el comportamiento esperado por el código que reemplaza un manejador instalado y delega en él. Para las pruebas individuales que necesiten el manejo de control-c de <code class="docutils literal notranslate"><span class="pre">unittest</span></code> deshabilitado se puede usar el decorador <a class="reference internal" href="#unittest.removeHandler" title="unittest.removeHandler"><code class="xref py py-func docutils literal notranslate"><span class="pre">removeHandler()</span></code></a>.</p>
<p>Hay algunas funciones de utilidad para que los autores de marcos de trabajo habiliten la funcionalidad de control de control-c dentro de los marcos de prueba.</p>
<dl class="py function">
<dt id="unittest.installHandler">
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">installHandler</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unittest.installHandler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Instala el controlador de control-c. Cuando se recibe una <a class="reference internal" href="signal.html#signal.SIGINT" title="signal.SIGINT"><code class="xref py py-const docutils literal notranslate"><span class="pre">signal.SIGINT</span></code></a>  (normalmente en respuesta a que el usuario presione control-c) todos los resultados registrados tienen <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> llamado.</p>
</dd></dl>

<dl class="py function">
<dt id="unittest.registerResult">
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">registerResult</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">result</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.registerResult" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Registrar un objeto  <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a>  para el manejo de control-c. El registro de un resultado almacena una referencia débil a él, por lo que no evita que el resultado sea recogido por el recolector de basura.</p>
<p>El registro de un objeto <a class="reference internal" href="#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> no tiene efectos secundarios si el manejo de control-c no está habilitado, por lo que los marcos de pruebas pueden registrar incondicionalmente todos los resultados que crean independientemente de si el manejo está habilitado o no.</p>
</dd></dl>

<dl class="py function">
<dt id="unittest.removeResult">
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">removeResult</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">result</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.removeResult" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Elimine un resultado registrado. Una vez que un resultado ha sido eliminado, <a class="reference internal" href="#unittest.TestResult.stop" title="unittest.TestResult.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> ya no se llamará en ese objeto de resultado en respuesta a un control-c.</p>
</dd></dl>

<dl class="py function">
<dt id="unittest.removeHandler">
<code class="sig-prename descclassname">unittest.</code><code class="sig-name descname">removeHandler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#unittest.removeHandler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Cuando se llama sin argumentos, esta función quita el gestor control-c si se ha instalado. Esta función también se puede utilizar como decorador de tests para quitar temporalmente el controlador mientras se ejecuta el test:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@unittest</span><span class="o">.</span><span class="n">removeHandler</span>
<span class="k">def</span> <span class="nf">test_signal_handling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code> — Infraestructura de tests unitarios</a><ul>
<li><a class="reference internal" href="#basic-example">Ejemplo sencillo</a></li>
<li><a class="reference internal" href="#command-line-interface">Interfaz de línea de comandos</a><ul>
<li><a class="reference internal" href="#command-line-options">Opciones de la línea de órdenes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#test-discovery">Descubrimiento de pruebas</a></li>
<li><a class="reference internal" href="#organizing-test-code">Organización del código de pruebas</a></li>
<li><a class="reference internal" href="#re-using-old-test-code">Reutilización de código de prueba anterior</a></li>
<li><a class="reference internal" href="#skipping-tests-and-expected-failures">Omitir tests y fallos esperados</a></li>
<li><a class="reference internal" href="#distinguishing-test-iterations-using-subtests">Distinguiendo iteraciones de tests empleando subtests</a></li>
<li><a class="reference internal" href="#classes-and-functions">Clases y funciones</a><ul>
<li><a class="reference internal" href="#test-cases">Casos de test</a><ul>
<li><a class="reference internal" href="#deprecated-aliases">Alias obsoletos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#grouping-tests">Agrupando tests</a></li>
<li><a class="reference internal" href="#loading-and-running-tests">Cargando y ejecutando tests</a><ul>
<li><a class="reference internal" href="#load-tests-protocol">load_tests protocolo</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#class-and-module-fixtures">Instalaciones para clases y módulos</a><ul>
<li><a class="reference internal" href="#setupclass-and-teardownclass">setUpClass y tearDownClass</a></li>
<li><a class="reference internal" href="#setupmodule-and-teardownmodule">setUpModule y tearDownModule</a></li>
</ul>
</li>
<li><a class="reference internal" href="#signal-handling">Manejo de señales</a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="doctest.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code> – Prueba ejemplos interactivos de Python</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="unittest.mock.html"
                        title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest.mock</span></code> — Biblioteca de objetos simulados</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/unittest.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="unittest.mock.html" title="unittest.mock — Biblioteca de objetos simulados"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="doctest.html" title="doctest – Prueba ejemplos interactivos de Python"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La Biblioteca Estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" >Herramientas de desarrollo</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code> — Infraestructura de tests unitarios</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 27, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>