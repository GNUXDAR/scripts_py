
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>urllib.request — Biblioteca extensible para abrir URLs &#8212; documentación de Python - 3.10.10</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.10.10"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="urllib.parse — Analiza URL en componentes" href="urllib.parse.html" />
    <link rel="prev" title="urllib — URL módulos de manipulación" href="urllib.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/urllib.request.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> — Biblioteca extensible para abrir URLs</a><ul>
<li><a class="reference internal" href="#request-objects">Objetos Request</a></li>
<li><a class="reference internal" href="#openerdirector-objects">Objetos OpenerDirector</a></li>
<li><a class="reference internal" href="#basehandler-objects">Objetos BaseHandler</a></li>
<li><a class="reference internal" href="#httpredirecthandler-objects">Objetos HTTPRedirectHandler</a></li>
<li><a class="reference internal" href="#httpcookieprocessor-objects">Objetos HTTPCookieProcessor</a></li>
<li><a class="reference internal" href="#proxyhandler-objects">Objetos ProxyHandler</a></li>
<li><a class="reference internal" href="#httppasswordmgr-objects">Objetos HTTPPasswordMgr</a></li>
<li><a class="reference internal" href="#httppasswordmgrwithpriorauth-objects">Objetos HTTPPasswordMgrWithPriorAuth</a></li>
<li><a class="reference internal" href="#abstractbasicauthhandler-objects">Objetos AbstractBasicAuthHandler</a></li>
<li><a class="reference internal" href="#httpbasicauthhandler-objects">Objetos HTTPBasicAuthHandler</a></li>
<li><a class="reference internal" href="#proxybasicauthhandler-objects">Objetos ProxyBasicAuthHandler</a></li>
<li><a class="reference internal" href="#abstractdigestauthhandler-objects">Objetos AbstractDigestAuthHandler</a></li>
<li><a class="reference internal" href="#httpdigestauthhandler-objects">Objetos HTTPDigestAuthHandler</a></li>
<li><a class="reference internal" href="#proxydigestauthhandler-objects">Objetos ProxyDigestAuthHandler</a></li>
<li><a class="reference internal" href="#httphandler-objects">Objetos HTTPHandler</a></li>
<li><a class="reference internal" href="#httpshandler-objects">Objetos HTTPSHandler</a></li>
<li><a class="reference internal" href="#filehandler-objects">Objetos FileHandler</a></li>
<li><a class="reference internal" href="#datahandler-objects">Objetos DataHandler</a></li>
<li><a class="reference internal" href="#ftphandler-objects">Objetos FTPHandler</a></li>
<li><a class="reference internal" href="#cacheftphandler-objects">Objetos CacheFTPHandler</a></li>
<li><a class="reference internal" href="#unknownhandler-objects">Objetos UnknownHandler</a></li>
<li><a class="reference internal" href="#httperrorprocessor-objects">Objetos HTTPErrorProcessor</a></li>
<li><a class="reference internal" href="#examples">Ejemplos</a></li>
<li><a class="reference internal" href="#legacy-interface">Interfaz heredada</a></li>
<li><a class="reference internal" href="#urllib-request-restrictions">Restricciones <code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-urllib.response"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.response</span></code> — Clases de respuesta usadas por urllib</a></li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="urllib.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code> — URL módulos de manipulación</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="urllib.parse.html"
                        title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.parse</span></code> — Analiza URL en componentes</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/urllib.request.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="urllib.parse.html" title="urllib.parse — Analiza URL en componentes"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="urllib.html" title="urllib — URL módulos de manipulación"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La Biblioteca Estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" accesskey="U">Protocolos y soporte de Internet</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> — Biblioteca extensible para abrir URLs</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-urllib.request">
<span id="urllib-request-extensible-library-for-opening-urls"></span><h1><a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> — Biblioteca extensible para abrir URLs<a class="headerlink" href="#module-urllib.request" title="Enlazar permanentemente con este título">¶</a></h1>
<p><strong>Código fuente:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/urllib/request.py">Lib/urllib/request.py</a></p>
<hr class="docutils" />
<p>El módulo <a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> define funciones y clases que ayudan en la apertura de URLs (la mayoría HTTP) en un mundo complejo — autenticación básica y digest, redirecciones, cookies y más.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Se recomienda el <a class="reference external" href="https://requests.readthedocs.io/en/master/">paquete Requests</a> para una interfaz de cliente HTTP de mayor nivel.</p>
</div>
<p>El módulo <a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> define las siguientes funciones:</p>
<dl class="py function">
<dt id="urllib.request.urlopen">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">urlopen</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">data=None</em>, <span class="optional">[</span><em class="sig-param">timeout</em>, <span class="optional">]</span><em class="sig-param">*</em>, <em class="sig-param">cafile=None</em>, <em class="sig-param">capath=None</em>, <em class="sig-param">cadefault=False</em>, <em class="sig-param">context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.urlopen" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Abre la URL <em>url</em>, la cual puede ser una cadena de caracteres o un objeto <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>.</p>
<p><em>data</em> debe ser un objeto que especifique datos adicionales a ser enviados al servidor o <code class="docutils literal notranslate"><span class="pre">None</span></code> si no se necesitan tales datos. Vea <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> para más detalles.</p>
<p>El módulo urllib.request usa HTTP/1.1 e incluye el encabezado <code class="docutils literal notranslate"><span class="pre">Connection:close</span></code> en sus peticiones HTTP.</p>
<p>El parámetro opcional <em>timeout</em> especifica un tiempo de expiración en segundos para operaciones bloqueantes como el intento de conexión (si no se especifica, será usado el tiempo de expiración global predeterminado). Esto actualmente sólo funciona para conexiones HTTP, HTTPS y FTP.</p>
<p>Si se especifica <em>context</em>, debe ser una instancia <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> describiendo las diferentes opciones SSL. Vea <a class="reference internal" href="http.client.html#http.client.HTTPSConnection" title="http.client.HTTPSConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPSConnection</span></code></a> para más detalles.</p>
<p>Los parámetros opcionales <em>cafile</em> y <em>capath</em> especifican un conjunto de certificados CA de confianza para peticiones HTTPS. <em>cafile</em> debe apuntar a un único archivo que contenga un paquete de certificados CA, mientras <em>capath</em> debe apuntar a un directorio de archivos de certificado hash. Se puede encontrar más información en <a class="reference internal" href="ssl.html#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.load_verify_locations()</span></code></a>.</p>
<p>Se ignora el parámetro <em>cadefault</em>.</p>
<p>Esta función siempre retorna un objeto que puede actuar como un <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">gestor de contexto</span></a>, y tiene las propiedades <em>url</em>, <em>headers</em> y <em>status</em>. Véase <a class="reference internal" href="#urllib.response.addinfourl" title="urllib.response.addinfourl"><code class="xref py py-class docutils literal notranslate"><span class="pre">urllib.response.addinfourl</span></code></a> para más detalles sobre estas propiedades.</p>
<p>Para URLs HTTP y HTTPS, esta función retorna un objeto <a class="reference internal" href="http.client.html#http.client.HTTPResponse" title="http.client.HTTPResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">http.client.HTTPResponse</span></code></a> ligeramente modificado. Adicionalmente a los tres nuevos métodos anteriores, el atributo msg contiene la misma información que el atributo <a class="reference internal" href="http.client.html#http.client.HTTPResponse.reason" title="http.client.HTTPResponse.reason"><code class="xref py py-attr docutils literal notranslate"><span class="pre">reason</span></code></a> — la frase de motivo devuelta por el servidor — en lugar de los encabezados de la respuesta como se especifica en la documentación para <a class="reference internal" href="http.client.html#http.client.HTTPResponse" title="http.client.HTTPResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPResponse</span></code></a>.</p>
<p>Para URLs FTP, de archivo y de datos y para peticiones manejadas explícitamente por las clases heredadas <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> y <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a>, esta función retorna un objeto <a class="reference internal" href="#urllib.response.addinfourl" title="urllib.response.addinfourl"><code class="xref py py-class docutils literal notranslate"><span class="pre">urllib.response.addinfourl</span></code></a>.</p>
<p>Genera <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a> en errores de protocolo.</p>
<p>Tenga en cuenta que <code class="docutils literal notranslate"><span class="pre">None</span></code> puede ser retornado si ningún manejador gestiona la petición (aunque el <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> global instalado de manera predeterminada usa <a class="reference internal" href="#urllib.request.UnknownHandler" title="urllib.request.UnknownHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnknownHandler</span></code></a> para asegurar que esto nunca suceda).</p>
<p>Adicionalmente, si se detectan configuraciones de proxy (por ejemplo, cuando se establece una variable de entorno <code class="docutils literal notranslate"><span class="pre">*_proxy</span></code> como <span class="target" id="index-25"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">http_proxy</span></code>), <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> está instalada de forma predeterminada y se asegura que las peticiones son gestionadas a través del proxy.</p>
<p>La función heredada de Python 2.6 y anteriores <code class="docutils literal notranslate"><span class="pre">urllib.urlopen</span></code> ha sido descontinuada, <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.request.urlopen()</span></code></a> corresponde a la antigua <code class="docutils literal notranslate"><span class="pre">urllib2.urlopen</span></code>. La gestión de proxy, la cual se hacía pasando un parámetro diccionario a <code class="docutils literal notranslate"><span class="pre">urllib.urlopen</span></code>, puede ser obtenida usando objetos <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a>.</p>
<p class="audit-hook">Genera un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">evento de auditoría</span></a> <code class="docutils literal notranslate"><span class="pre">urllib.Request</span></code> con los argumentos <code class="docutils literal notranslate"><span class="pre">fullurl</span></code>, <code class="docutils literal notranslate"><span class="pre">data</span></code>, <code class="docutils literal notranslate"><span class="pre">headers</span></code>, <code class="docutils literal notranslate"><span class="pre">method</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span><em>cafile</em> y <em>capath</em> fueron añadidos.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Los hosts virtuales HTTPS ahora están soportados si es posible (esto es, si <a class="reference internal" href="ssl.html#ssl.HAS_SNI" title="ssl.HAS_SNI"><code class="xref py py-data docutils literal notranslate"><span class="pre">ssl.HAS_SNI</span></code></a> es verdadero).</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2: </span><em>data</em> puede ser un objeto iterable.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span><em>cadefault</em> fue añadido.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4.3: </span><em>context</em> fue añadido.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>La conexión HTTPS ahora envía una extensión ALPN con indicador de protocolo <code class="docutils literal notranslate"><span class="pre">http/1.1</span></code> cuando no se proporciona <em>context</em>. El <em>context</em> personalizado debe establecer protocolos ALPN con <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_alpn_protocol()</span></code>.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.6: </span><em>cafile</em>, <em>capath</em> y <em>cadefault</em> están obsoletos en favor de <em>context</em>. Por favor, use <a class="reference internal" href="ssl.html#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.load_cert_chain()</span></code></a> en su lugar o deja a <a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a> seleccionar el certificado de confianza CA del sistema por ti.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="urllib.request.install_opener">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">install_opener</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">opener</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.install_opener" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Instala una instancia <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> como el abridor global predeterminado. Instalar un abridor sólo es necesario si quieres que urlopen use ese abridor; si no, simplemente invoca <a class="reference internal" href="#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OpenerDirector.open()</span></code></a> en lugar de <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>. El código no comprueba por un <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> real y cualquier clase con la interfaz apropiada funcionará.</p>
</dd></dl>

<dl class="py function">
<dt id="urllib.request.build_opener">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">build_opener</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">handler</em>, <em class="sig-param">...</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.build_opener" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una instancia <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>, la cual encadena los manejadores en el orden dado. <em>handler</em>s pueden ser tanto instancias de <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> o subclases de <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> (en cuyo caso debe ser posible invocar el constructor sin ningún parámetro). Instancias de las siguientes clases estarán delante del <em>handler</em>s, a no ser que el <em>handler</em>s las contenga, instancias o subclases de ellas: <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> (si son detectadas configuraciones de proxy), <a class="reference internal" href="#urllib.request.UnknownHandler" title="urllib.request.UnknownHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnknownHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPHandler" title="urllib.request.HTTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPDefaultErrorHandler" title="urllib.request.HTTPDefaultErrorHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPDefaultErrorHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPRedirectHandler" title="urllib.request.HTTPRedirectHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPRedirectHandler</span></code></a>, <a class="reference internal" href="#urllib.request.FTPHandler" title="urllib.request.FTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FTPHandler</span></code></a>, <a class="reference internal" href="#urllib.request.FileHandler" title="urllib.request.FileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code></a>, <a class="reference internal" href="#urllib.request.HTTPErrorProcessor" title="urllib.request.HTTPErrorProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPErrorProcessor</span></code></a>.</p>
<p>Si la instalación de Python tiene soporte SSL (ej. si se puede importar el módulo <a class="reference internal" href="ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a>), también será añadida <a class="reference internal" href="#urllib.request.HTTPSHandler" title="urllib.request.HTTPSHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPSHandler</span></code></a>.</p>
<p>Una subclase de <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> puede cambiar también su atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">handler_order</span></code> para modificar su posición en la lista de manejadores.</p>
</dd></dl>

<dl class="py function">
<dt id="urllib.request.pathname2url">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">pathname2url</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.pathname2url" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierte el nombre de ruta <em>path</em> desde la sintaxis local para una ruta a la forma usada en el componente ruta de una URL. Esto no produce una URL completa. El valor retornado ya estará entrecomillado usando la función <a class="reference internal" href="urllib.parse.html#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt id="urllib.request.url2pathname">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">url2pathname</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.url2pathname" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierte el componente ruta <em>path</em> desde una URL codificada con porcentajes a la sintaxis local para una ruta. No acepta una URL completa. Esta función usa <a class="reference internal" href="urllib.parse.html#urllib.parse.unquote" title="urllib.parse.unquote"><code class="xref py py-func docutils literal notranslate"><span class="pre">unquote()</span></code></a> para decodificar <em>path</em>.</p>
</dd></dl>

<dl class="py function">
<dt id="urllib.request.getproxies">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">getproxies</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.getproxies" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta función auxiliar retorna un diccionario de esquema para las asignaciones de URL del servidor proxy. Escanea el entorno en busca de variables denominadas <code class="docutils literal notranslate"><span class="pre">&lt;scheme&gt;_proxy</span></code>, tomando en cuenta diferencia entre mayúsculas y minúsculas, para todos los sistemas operativos primero, y cuando no pueden encontrarla, buscan información proxy desde la Configuración del Sistema de macOS y desde Registros del Sistema para Windows. Si existen variables de entorno tanto en mayúsculas como en minúsculas (y no concuerdan), las minúsculas son preferidas.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si la variable del entorno <code class="docutils literal notranslate"><span class="pre">REQUEST_METHOD</span></code> está definida, lo cual usualmente indica que tu script está ejecutándose en un entorno CGI, la variable de entorno <code class="docutils literal notranslate"><span class="pre">HTTP_PROXY</span></code> (mayúsculas <code class="docutils literal notranslate"><span class="pre">_PROXY</span></code>) será ignorada. Esto es porque esa variable puede ser inyectada por un cliente usando el encabezado HTTP «Proxy:». Si necesitas usar un proxy HTTP en un entorno CGI, usa <code class="docutils literal notranslate"><span class="pre">ProxyHandler</span></code> explícitamente o asegúrate de que el nombre de la variable está en minúsculas (o al menos el sufijo <code class="docutils literal notranslate"><span class="pre">_proxy</span></code>).</p>
</div>
</dd></dl>

<p>Se proveen las siguientes clases:</p>
<dl class="py class">
<dt id="urllib.request.Request">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">Request</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">url</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">headers</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">origin_req_host</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">unverifiable</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta clase es un abstracción de una petición URL.</p>
<p><em>url</em> debe ser una cadena de caracteres conteniendo una URL válida.</p>
<p><em>data</em> debe ser un objeto que especifique datos adicionales a enviar al servidor o <code class="docutils literal notranslate"><span class="pre">None</span></code> si no se necesitan tales datos. Actualmente las peticiones HTTP son las únicas que usan <em>data</em>. Los tipos de objetos soportados incluyen bytes, objetos como archivos e iterables de objetos como bytes. Si no se ha provisto el campo de encabezado <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code> ni <code class="docutils literal notranslate"><span class="pre">Transfer-Encoding</span></code>, <a class="reference internal" href="#urllib.request.HTTPHandler" title="urllib.request.HTTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPHandler</span></code></a> establecerá estos encabezados de acuerdo al tipo de <em>data</em>. <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code> será usado para enviar objetos de bytes, mientras <code class="docutils literal notranslate"><span class="pre">Transfer-Encoding:</span> <span class="pre">chunked</span></code> como se especifica en <span class="target" id="index-26"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7230.html"><strong>RFC 7230</strong></a>, Sección 3.3.1 será usado para enviar archivos y otros iterables.</p>
<p>Para un método de una petición HTTP POST, <em>data</em> debe ser un buffer en el formato estándar <em class="mimetype">application/x-www-form-urlencoded</em>. La función <a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a> toma un mapeo o una secuencia de tuplas de dos valores y retorna una cadena de caracteres ASCII en este formato. Debe ser codificada a bytes antes de ser usada como el parámetro <em>data</em>.</p>
<p><em>headers</em> should be a dictionary, and will be treated as if
<a class="reference internal" href="#urllib.request.Request.add_header" title="urllib.request.Request.add_header"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_header()</span></code></a> was called with each key and value as arguments.
This is often used to «spoof» the <code class="docutils literal notranslate"><span class="pre">User-Agent</span></code> header value, which is
used by a browser to identify itself – some HTTP servers only
allow requests coming from common browsers as opposed to scripts.
For example, Mozilla Firefox may identify itself as <code class="docutils literal notranslate"><span class="pre">&quot;Mozilla/5.0</span>
<span class="pre">(X11;</span> <span class="pre">U;</span> <span class="pre">Linux</span> <span class="pre">i686)</span> <span class="pre">Gecko/20071127</span> <span class="pre">Firefox/2.0.0.11&quot;</span></code>, while
<a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a>’s default user agent string is
<code class="docutils literal notranslate"><span class="pre">&quot;Python-urllib/2.6&quot;</span></code> (on Python 2.6).
All header keys are sent in camel case.</p>
<p>Un encabezado apropiado <code class="docutils literal notranslate"><span class="pre">Content-Type</span></code> debe ser incluido si el argumento <em>data</em> está presente. Si este encabezado no ha sido provisto y <em>data</em> no es None, será añadido <code class="docutils literal notranslate"><span class="pre">Content-Type:</span> <span class="pre">application/x-www-form-urlencoded</span></code> de forma predeterminada.</p>
<p>Los siguientes dos argumentos sólo tienen interés para la gestión correcta de cookies HTTP de terceros:</p>
<p><em>origin_req_host</em> debe ser el host de la petición de la transacción origen, como define <span class="target" id="index-27"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2965.html"><strong>RFC 2965</strong></a>. Por defecto es <code class="docutils literal notranslate"><span class="pre">http.cookiejar.request_host(self)</span></code>. Este es el nombre de host o la dirección IP de la petición original que fue iniciada por el usuario. Por ejemplo, si la petición es para una imagen en un documento HTML, debe ser el host de la petición para la página que contiene la imagen.</p>
<p><em>unverifiable</em> debe indicar si la petición no es verificable, como define <span class="target" id="index-28"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2965.html"><strong>RFC 2965</strong></a>. Por defecto es <code class="docutils literal notranslate"><span class="pre">False</span></code>. Una petición no verificable es una cuya URL el usuario no tuvo opción de aprobar. Por ejemplo, si la petición es por una imagen en un documento HTML y el usuario no tuvo opción de aprobar la obtención automática de la imagen, este debe ser verdadero.</p>
<p><em>method</em> debe ser una cadena que indica el método de la petición HTTP que será usado (ej. <code class="docutils literal notranslate"><span class="pre">'HEAD'</span></code>). Si se provee, su valor es almacenado en el atributo <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">method</span></code></a> y usado por <a class="reference internal" href="#urllib.request.Request.get_method" title="urllib.request.Request.get_method"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_method()</span></code></a>. Por defecto es <code class="docutils literal notranslate"><span class="pre">'GET'</span></code> si <em>data</em> es <code class="docutils literal notranslate"><span class="pre">None</span></code>, o <code class="docutils literal notranslate"><span class="pre">'POST'</span></code> si no. Las subclases pueden indicar un método predeterminado diferente estableciendo el atributo <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">method</span></code></a> es la clase misma.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La petición no funcionará como se espera si el objeto de datos es incapaz de entregar su contenido más de una vez (ej. un archivo o un iterable que puede producir el contenido sólo una vez) y la petición se reintentará para redirecciones HTTP o autenticación. El <em>data</em> es enviado al servidor HTTP directamente después de los encabezados. No hay soporte para una expectativa de funcionamiento 100% continuo en la biblioteca.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>El argumento <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a> es añadido a la clase Request.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>El atributo predeterminado <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a> puede ser indicado a nivel de clase.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>No se genera un error si el <code class="docutils literal notranslate"><span class="pre">Content-Length</span></code> no ha sido provisto y <em>data</em> no es <code class="docutils literal notranslate"><span class="pre">None</span></code> ni un objeto de bytes. En su lugar recurre a la codificación de transferencia fragmentada.</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.OpenerDirector">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">OpenerDirector</code><a class="headerlink" href="#urllib.request.OpenerDirector" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La clase <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> abre URLs mediante la encadenación conjunta de <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>. Este maneja el encadenamiento de manejadores y la recuperación de errores.</p>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.BaseHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">BaseHandler</code><a class="headerlink" href="#urllib.request.BaseHandler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta es la clase base para todos los manejadores registrados — y manejan sólo las mecánicas simples del registro.</p>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.HTTPDefaultErrorHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPDefaultErrorHandler</code><a class="headerlink" href="#urllib.request.HTTPDefaultErrorHandler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase la cual define un manejador predeterminado para los errores de respuesta HTTP; todas las respuestas son convertidas en excepciones <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.HTTPRedirectHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPRedirectHandler</code><a class="headerlink" href="#urllib.request.HTTPRedirectHandler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase para manejar redirecciones.</p>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.HTTPCookieProcessor">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPCookieProcessor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cookiejar</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPCookieProcessor" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase para manejar Cookies HTTP.</p>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.ProxyHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">ProxyHandler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">proxies</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyHandler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Causa que las peticiones vayan a través de un proxy. Si se provee <em>proxies</em>, debe ser un diccionario mapeando nombres de protocolos a URLs de proxies. Por defecto lee la lista de proxies de las variables de entorno <code class="docutils literal notranslate"><span class="pre">&lt;protocol&gt;_proxy</span></code>. Si no se establecen variables de entorno de proxy, entonces se obtienen las configuraciones de proxy en un entorno Windows desde la sección del registro de Configuraciones de Internet y en un entorno macOS se obtiene la información de proxy desde el Framework de Configuración del Sistema.</p>
<p>Para deshabilitar la detección automática de proxy pasa un diccionario vacío.</p>
<p>La variable de entorno <span class="target" id="index-29"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">no_proxy</span></code> puede ser usada para especificar hosts los cuales no deben ser alcanzados mediante proxy; si se establece, debe ser una lista separada por comas de sufijos de nombres de host, con <code class="docutils literal notranslate"><span class="pre">:port</span></code> añadidos opcionalmente, por ejemplo <code class="docutils literal notranslate"><span class="pre">cern.ch,ncsa.uiuc.edu,some.host:8080</span></code>.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Nota</p>
<p><code class="docutils literal notranslate"><span class="pre">HTTP_PROXY</span></code> será ignorado si se establece una variable <code class="docutils literal notranslate"><span class="pre">REQUEST_METHOD</span></code>; vea la documentación de <a class="reference internal" href="#urllib.request.getproxies" title="urllib.request.getproxies"><code class="xref py py-func docutils literal notranslate"><span class="pre">getproxies()</span></code></a>.</p>
</div>
</div></blockquote>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.HTTPPasswordMgr">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPPasswordMgr</code><a class="headerlink" href="#urllib.request.HTTPPasswordMgr" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Mantiene una base de datos de mapeos <code class="docutils literal notranslate"><span class="pre">(realm,</span> <span class="pre">uri)</span> <span class="pre">-&gt;</span> <span class="pre">(user,</span> <span class="pre">password)</span></code>.</p>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.HTTPPasswordMgrWithDefaultRealm">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPPasswordMgrWithDefaultRealm</code><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Mantiene una base de datos de mapeos <code class="docutils literal notranslate"><span class="pre">(realm,</span> <span class="pre">uri)</span> <span class="pre">-&gt;</span> <span class="pre">(user,</span> <span class="pre">password)</span></code>. Un reino de <code class="docutils literal notranslate"><span class="pre">None</span></code> se considera un reino caza todo, el cual es buscado si ningún otro reino encaja.</p>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.HTTPPasswordMgrWithPriorAuth">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPPasswordMgrWithPriorAuth</code><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una variante de <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> que también tiene una base de datos de mapeos <code class="docutils literal notranslate"><span class="pre">uri</span> <span class="pre">-&gt;</span> <span class="pre">is_authenticated</span></code>. Puede ser usada por un manejador BasicAuth para determinar cuando enviar credenciales de autenticación inmediatamente en lugar de esperar primero a una respuesta <code class="docutils literal notranslate"><span class="pre">401</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.AbstractBasicAuthHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">AbstractBasicAuthHandler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">password_mgr</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractBasicAuthHandler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta es una clase mixin que ayuda con la autenticación HTTP, tanto al host remoto y a un proxy. Si se proporciona <em>password_mgr</em>, debe ser algo compatible con <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a>; refiera a la sección <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">Objetos HTTPPasswordMgr</span></a> para información sobre la interfaz que debe ser soportada. Si <em>passwd_mgr</em> proporciona también métodos <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> y <code class="docutils literal notranslate"><span class="pre">update_authenticated</span></code> (vea <a class="reference internal" href="#http-password-mgr-with-prior-auth"><span class="std std-ref">Objetos HTTPPasswordMgrWithPriorAuth</span></a>), entonces el manejador usará el <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> resultado para una URI dada para determinar el envío o no de credenciales de autenticación con la petición. Si <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> para la URI, las peticiones subsecuentes a la URI o cualquiera de las super URIs incluirán automáticamente los credenciales de autenticación.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5: </span>Añadido soporte <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.HTTPBasicAuthHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPBasicAuthHandler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">password_mgr</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPBasicAuthHandler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Administra autenticación con el host remoto. Si se proporciona <em>password_mgr</em>, debe ser compatible con <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a>; refiera a la sección <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">Objetos HTTPPasswordMgr</span></a> para información sobre la interfaz que debe ser soportada. HTTPBasicAuthHandler lanzará un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> cuando se presente con un esquema de Autenticación incorrecto.</p>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.ProxyBasicAuthHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">ProxyBasicAuthHandler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">password_mgr</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyBasicAuthHandler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Administra autenticación con el proxy. Si se proporciona <em>password_mgr</em> debe ser compatible con <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a>; refiera a la sección <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">Objetos HTTPPasswordMgr</span></a> para información sobre la interfaz que debe ser soportada.</p>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.AbstractDigestAuthHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">AbstractDigestAuthHandler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">password_mgr</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractDigestAuthHandler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esto es una clase mixin que ayuda con la autenticación HTTP, tanto al host remoto como a un proxy. Si se proporciona <em>password_mgr</em> debe ser compatible con <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a>; refiera a la sección <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">Objetos HTTPPasswordMgr</span></a> para información sobre la interfaz que debe ser soportada.</p>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.HTTPDigestAuthHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPDigestAuthHandler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">password_mgr</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPDigestAuthHandler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Maneja autenticación con el host remoto. Si se proporciona <em>password_mgr</em> debe ser compatible con <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a>; refiera a la sección <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">Objetos HTTPPasswordMgr</span></a> para información sobre la interfaz que debe ser soportada. Cuando se añaden tanto el Manejador de Autenticación Digest (<em>Digest Authentication Handler</em>) como el Manejador de Autenticación Básico (<em>Basic Authentication Handler</em>) la Autenticación Digest siempre se intenta primero. Si la Autenticación Digest retorna una respuesta 40x de nuevo, se envía al controlador de Autenticación Básica para Manejar. Este método Handler lanzará un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> cuando sea presentado con un esquema de autenticación diferente a Digest o Básico.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Genera <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> en Esquema de Autenticación no soportado.</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.ProxyDigestAuthHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">ProxyDigestAuthHandler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">password_mgr</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyDigestAuthHandler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Administra autenticación con el proxy. Si se proporciona <em>password_mgr</em> debe ser compatible con <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a>; refiera a la sección <a class="reference internal" href="#http-password-mgr"><span class="std std-ref">Objetos HTTPPasswordMgr</span></a> para información sobre la interfaz que debe ser soportada.</p>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.HTTPHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPHandler</code><a class="headerlink" href="#urllib.request.HTTPHandler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase para gestionar apertura de URLs HTTP.</p>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.HTTPSHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPSHandler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">debuglevel</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">context</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">check_hostname</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPSHandler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase para gestionar apertura de URLs HTTPS. <em>context</em> y <em>check_hostname</em> tienen el mismo significado que en <a class="reference internal" href="http.client.html#http.client.HTTPSConnection" title="http.client.HTTPSConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">http.client.HTTPSConnection</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span><em>context</em> y <em>check_hostname</em> fueron añadidos.</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.FileHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">FileHandler</code><a class="headerlink" href="#urllib.request.FileHandler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Abre archivos locales.</p>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.DataHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">DataHandler</code><a class="headerlink" href="#urllib.request.DataHandler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Abre URLs de datos.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.FTPHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">FTPHandler</code><a class="headerlink" href="#urllib.request.FTPHandler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Abre URLs FTP.</p>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.CacheFTPHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">CacheFTPHandler</code><a class="headerlink" href="#urllib.request.CacheFTPHandler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Abre URLs FTP, manteniendo una caché de conexiones FTP abiertas para minimizar retrasos.</p>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.UnknownHandler">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">UnknownHandler</code><a class="headerlink" href="#urllib.request.UnknownHandler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una clase caza todo para gestionar URLs desconocidas.</p>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.HTTPErrorProcessor">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">HTTPErrorProcessor</code><a class="headerlink" href="#urllib.request.HTTPErrorProcessor" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Procesa errores de respuestas HTTP.</p>
</dd></dl>

<section id="request-objects">
<span id="id1"></span><h2>Objetos Request<a class="headerlink" href="#request-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los siguientes métodos describen la interfaz pública de <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> por lo que pueden ser sobrescritos en subclases. También define varios atributos públicos que pueden ser usado por clientes para inspeccionar la respuesta analizada.</p>
<dl class="py attribute">
<dt id="urllib.request.Request.full_url">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">full_url</code><a class="headerlink" href="#urllib.request.Request.full_url" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La URL original pasada al constructor.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4.</span></p>
</div>
<p>Request.full_url es una propiedad con setter, getter y deleter. Obtener <a class="reference internal" href="#urllib.request.Request.full_url" title="urllib.request.Request.full_url"><code class="xref py py-attr docutils literal notranslate"><span class="pre">full_url</span></code></a> retorna la petición URL original con el fragmento, si este estaba presente.</p>
</dd></dl>

<dl class="py attribute">
<dt id="urllib.request.Request.type">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">type</code><a class="headerlink" href="#urllib.request.Request.type" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El esquema de URI.</p>
</dd></dl>

<dl class="py attribute">
<dt id="urllib.request.Request.host">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">host</code><a class="headerlink" href="#urllib.request.Request.host" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La autoridad de URI, típicamente un host, pero también puede contener un puerto separado por un caracter de doble punto.</p>
</dd></dl>

<dl class="py attribute">
<dt id="urllib.request.Request.origin_req_host">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">origin_req_host</code><a class="headerlink" href="#urllib.request.Request.origin_req_host" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El host original de la petición, sin puerto.</p>
</dd></dl>

<dl class="py attribute">
<dt id="urllib.request.Request.selector">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">selector</code><a class="headerlink" href="#urllib.request.Request.selector" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La ruta de URI. Si <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> usa un proxy, entonces selector será la URL completa que se pasa al proxy.</p>
</dd></dl>

<dl class="py attribute">
<dt id="urllib.request.Request.data">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">data</code><a class="headerlink" href="#urllib.request.Request.data" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El cuerpo de la entidad para la solicitud o <code class="docutils literal notranslate"><span class="pre">None</span></code> si no es especificado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Cambiar el valor de <a class="reference internal" href="#urllib.request.Request.data" title="urllib.request.Request.data"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.data</span></code></a> elimina ahora el encabezado «Content-Length» si fue establecido o calculado previamente.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="urllib.request.Request.unverifiable">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">unverifiable</code><a class="headerlink" href="#urllib.request.Request.unverifiable" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>booleano, indica si la petición no es verificable como se define por <span class="target" id="index-30"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2965.html"><strong>RFC 2965</strong></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="urllib.request.Request.method">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">method</code><a class="headerlink" href="#urllib.request.Request.method" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El método de petición HTTP a usar. Por defecto su valor es <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>, lo que significa que <a class="reference internal" href="#urllib.request.Request.get_method" title="urllib.request.Request.get_method"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_method()</span></code></a> realizará su cálculo normal del método a usar. Su valor puede ser definido (sobrescribiendo así el cálculo predeterminado en <a class="reference internal" href="#urllib.request.Request.get_method" title="urllib.request.Request.get_method"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_method()</span></code></a>) tanto proporcionando un valor por defecto estableciéndolo a nivel de clase en una subclase de <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> o pasando un valor al constructor de <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> por medio del argumento <em>method</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Un valor predeterminado puede ser establecido ahora en subclases; previamente sólo podía ser definido mediante el argumento del constructor.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.Request.get_method">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">get_method</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.get_method" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una cadena indicando el método de petición HTTP. Si <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a> no es <code class="docutils literal notranslate"><span class="pre">None</span></code>, retorna su valor, de otra forma retorna <code class="docutils literal notranslate"><span class="pre">'GET'</span></code> si <a class="reference internal" href="#urllib.request.Request.data" title="urllib.request.Request.data"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.data</span></code></a> es <code class="docutils literal notranslate"><span class="pre">None</span></code> o <code class="docutils literal notranslate"><span class="pre">'POST'</span></code> si no lo es. Esto sólo es significativo para peticiones HTTP.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>get_method ahora mira el valor de <a class="reference internal" href="#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.method</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.Request.add_header">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">add_header</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">val</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.add_header" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Add another header to the request.  Headers are currently ignored by all
handlers except HTTP handlers, where they are added to the list of headers sent
to the server.  Note that there cannot be more than one header with the same
name, and later calls will overwrite previous calls in case the <em>key</em> collides.
Currently, this is no loss of HTTP functionality, since all headers which have
meaning when used more than once have a (header-specific) way of gaining the
same functionality using only one header.  Note that headers added using
this method are also added to redirected requests.</p>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.Request.add_unredirected_header">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">add_unredirected_header</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">header</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.add_unredirected_header" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Añade un encabezado que no será añadido a una petición redireccionada.</p>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.Request.has_header">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">has_header</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">header</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.has_header" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna si la instancia tiene el encabezado nombrado (comprueba tanto regular como no redirigido).</p>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.Request.remove_header">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">remove_header</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">header</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.remove_header" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Elimina el encabezado nombrado de la instancia de la petición (desde encabezados regulares y no redireccionados).</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.Request.get_full_url">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">get_full_url</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.get_full_url" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la URL dada en el constructor.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4.</span></p>
</div>
<p>Retorna <a class="reference internal" href="#urllib.request.Request.full_url" title="urllib.request.Request.full_url"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Request.full_url</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.Request.set_proxy">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">set_proxy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">host</span></em>, <em class="sig-param"><span class="n">type</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.set_proxy" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Prepara la petición conectando a un servidor proxy. Los <em>host</em> y <em>type</em> reemplazarán aquellos de la instancia y el selector de la instancia será la URL original dada en el constructor.</p>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.Request.get_header">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">get_header</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">header_name</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.get_header" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el valor del encabezado dado.</p>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.Request.header_items">
<code class="sig-prename descclassname">Request.</code><code class="sig-name descname">header_items</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.Request.header_items" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una lista de tuplas (header_name, header_value) de los encabezados de la Petición.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Los métodos de petición add_data, has_data, get_data, get_type, get_host, get_selector, get_origin_req_host y is_unverifiable que quedaron obsoletos desde 3.3 han sido eliminados.</p>
</div>
</section>
<section id="openerdirector-objects">
<span id="opener-director-objects"></span><h2>Objetos OpenerDirector<a class="headerlink" href="#openerdirector-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las instancias de <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> tienen los siguientes métodos:</p>
<dl class="py method">
<dt id="urllib.request.OpenerDirector.add_handler">
<code class="sig-prename descclassname">OpenerDirector.</code><code class="sig-name descname">add_handler</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">handler</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.OpenerDirector.add_handler" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p><em>handler</em> debe ser una instancia de <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>. Los siguientes métodos son buscados y añadidos a las cadenas posibles (tenga en cuenta que los errores HTTP son un caso espacial). Tenga en cuenta que, en los siguientes, <em>protocol</em> debe ser remplazado con el protocolo actual a manejar, por ejemplo <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_response()</span></code> sería el protocolo HTTP del manejador de respuesta. También <em>type</em> debe ser remplazado con el código HTTP actual, por ejemplo <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_404()</span></code> manejaría errores HTTP 404.</p>
<ul>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_open()</span></code> — señala que el manejador sabe como abrir URLs <em>protocol</em>.</p>
<p>Vea <a class="reference internal" href="#protocol-open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.&lt;protocol&gt;_open()</span></code></a> para más información.</p>
</li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_&lt;type&gt;()</span></code> — señala que el manejador sabe como manejar errores HTTP con el código de error <em>type</em>.</p>
<p>Vea <a class="reference internal" href="#http-error-nnn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.http_error_&lt;nnn&gt;()</span></code></a> para más información.</p>
</li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_error()</span></code> — señala que el manejador sabe como manejar errores de (no <code class="docutils literal notranslate"><span class="pre">http</span></code>) <em>protocol</em>.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_request()</span></code> — señala que el manejador sabe como preprocesar peticiones <em>protocol</em>.</p>
<p>Vea <a class="reference internal" href="#protocol-request"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.&lt;protocol&gt;_request()</span></code></a> para más información.</p>
</li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_response()</span></code> — señala que el manejador sabe como postprocesar respuestas <em>protocol</em>.</p>
<p>Vea <a class="reference internal" href="#protocol-response"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BaseHandler.&lt;protocol&gt;_response()</span></code></a> para más información.</p>
</li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.OpenerDirector.open">
<code class="sig-prename descclassname">OpenerDirector.</code><code class="sig-name descname">open</code><span class="sig-paren">(</span><em class="sig-param">url</em>, <em class="sig-param">data=None</em><span class="optional">[</span>, <em class="sig-param">timeout</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.OpenerDirector.open" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Abre la <em>url</em> dada (la cual puede ser un objeto de petición o una cadena de caracteres), pasando opcionalmente el <em>data</em> dado. Los argumentos, los valores de retorno y las excepciones generadas son las mismas que aquellas de <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> (las cuales simplemente invocan el método <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a> en el <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> instalado global). El parámetro opcional <em>timeout</em> especifica un tiempo de expiración en segundos para operaciones bloqueantes como el intento de conexión (si no se especifica, el tiempo de expiración global será usado). La característica de tiempo de expiración actualmente funciona sólo para conexiones HTTP, HTTPS y FTP.</p>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.OpenerDirector.error">
<code class="sig-prename descclassname">OpenerDirector.</code><code class="sig-name descname">error</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">proto</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.OpenerDirector.error" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Maneja un error del protocolo dado. Esto invocará los manejadores de error registrados para el protocolo dado con los argumentos dados (los cuales son específicos del protocolo). El protocolo HTTP es un caso especial el cual usa el código de respuesta HTTP para determinar el manejador de error específico; refiera a los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_&lt;type&gt;()</span></code> de las clases del manejador.</p>
<p>Retorna si los valores y excepciones generadas son las mismas que aquellas de <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>.</p>
</dd></dl>

<p>Los objetos OpenerDirector abren URLs en tres etapas:</p>
<p>El orden en el cual esos métodos son invocados dentro de cada etapa es determinado ordenando las instancias manejadoras.</p>
<ol class="arabic">
<li><p>Cada manejador con un método nombrado como <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_request()</span></code> tiene ese método invocador para preprocesar la petición.</p></li>
<li><p>Los manejadores con un método nombrado como <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_open()</span></code> son invocados para manejar la petición. Esta etapa termina cuando un manejador retorna un valor no <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> (ej. una respuesta) o genera una excepción (generalmente <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a>). Se permite que las excepciones propaguen.</p>
<p>De hecho, el algoritmo anterior se intenta primero para métodos nombrados <code class="xref py py-meth docutils literal notranslate"><span class="pre">default_open()</span></code>. Si todos esos métodos retornan <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>, el algoritmo se repite para métodos nombrados como <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_open()</span></code>. Si todos esos métodos retornan <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>, el algoritmo se repite para métodos nombrados como <code class="xref py py-meth docutils literal notranslate"><span class="pre">unknown_open()</span></code>.</p>
<p>Tenga en cuenta que la implementación de esos métodos puede involucrar invocaciones de los métodos <a class="reference internal" href="#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a> y <a class="reference internal" href="#urllib.request.OpenerDirector.error" title="urllib.request.OpenerDirector.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">error()</span></code></a> de la instancia <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> padre.</p>
</li>
<li><p>Cada manejador con un método nombrado como <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_response()</span></code> tiene ese método invocado para postprocesar la respuesta.</p></li>
</ol>
</section>
<section id="basehandler-objects">
<span id="base-handler-objects"></span><h2>Objetos BaseHandler<a class="headerlink" href="#basehandler-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los objetos <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a> proporcionan un par de métodos que son útiles directamente y otros que están destinados a ser utilizados por clases derivadas. Estos están pensados para uso directo:</p>
<dl class="py method">
<dt id="urllib.request.BaseHandler.add_parent">
<code class="sig-prename descclassname">BaseHandler.</code><code class="sig-name descname">add_parent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">director</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.add_parent" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Añade un director como padre.</p>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.BaseHandler.close">
<code class="sig-prename descclassname">BaseHandler.</code><code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.close" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Elimina cualquier padre.</p>
</dd></dl>

<p>El siguiente atributo y los siguientes métodos sólo deben ser usados por clases derivadas de <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Se ha adoptado la convención de que las subclases que definen los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_request()</span></code> o <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_response()</span></code> son nombradas <code class="xref py py-class docutils literal notranslate"><span class="pre">*Processor</span></code>; todas las otras son nombradas <code class="xref py py-class docutils literal notranslate"><span class="pre">*Handler</span></code>.</p>
</div>
<dl class="py attribute">
<dt id="urllib.request.BaseHandler.parent">
<code class="sig-prename descclassname">BaseHandler.</code><code class="sig-name descname">parent</code><a class="headerlink" href="#urllib.request.BaseHandler.parent" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> válido, el cual puede ser utilizado para abrir usando un protocolo diferente, o para manejar errores.</p>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.BaseHandler.default_open">
<code class="sig-prename descclassname">BaseHandler.</code><code class="sig-name descname">default_open</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">req</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.default_open" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método no es definido en <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>, pero las subclases deben definirlo si quieren cazar todas las URLs.</p>
<p>This method, if implemented, will be called by the parent
<a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>.  It should return a file-like object as described in
the return value of the <a class="reference internal" href="#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a> method of <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>, or <code class="docutils literal notranslate"><span class="pre">None</span></code>.
It should raise <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a>, unless a truly exceptional
thing happens (for example, <a class="reference internal" href="exceptions.html#MemoryError" title="MemoryError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MemoryError</span></code></a> should not be mapped to
<code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code>).</p>
<p>Este método será invocado antes de cualquier método de apertura específico de protocolo.</p>
</dd></dl>

<span class="target" id="protocol-open"></span><dl class="py method">
<dt>
<code class="sig-name descname">BaseHandler.&lt;protocol&gt;_open(req)</code></dt>
<dd><p>Este método no está definido en <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>, pero las subclases deben definirlo si quieren manejar URLs con el protocolo dado.</p>
<p>Este método, si está definido, será invocado por el <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> padre. Los valores retornados deben ser los mismos que para <code class="xref py py-meth docutils literal notranslate"><span class="pre">default_open()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.BaseHandler.unknown_open">
<code class="sig-prename descclassname">BaseHandler.</code><code class="sig-name descname">unknown_open</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">req</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.unknown_open" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método <em>no</em> está definido en <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>, pero las subclases deben definirlo si quieren cazar todas las URLs sin manejador registrado para abrirlo.</p>
<p>Este método, si está implementado, será invocado por el <a class="reference internal" href="#urllib.request.BaseHandler.parent" title="urllib.request.BaseHandler.parent"><code class="xref py py-attr docutils literal notranslate"><span class="pre">parent</span></code></a> de <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a>. Los valores retornados deben ser los mismos que para <a class="reference internal" href="#urllib.request.BaseHandler.default_open" title="urllib.request.BaseHandler.default_open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">default_open()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.BaseHandler.http_error_default">
<code class="sig-prename descclassname">BaseHandler.</code><code class="sig-name descname">http_error_default</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">req</span></em>, <em class="sig-param"><span class="n">fp</span></em>, <em class="sig-param"><span class="n">code</span></em>, <em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">hdrs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.BaseHandler.http_error_default" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método <em>no</em> está definido en <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>, pero las subclases deben sobreescribirlo si pretenden proporcionar una solución general para los errores HTTP que de otro modo no se manejarían. Sería invocado automáticamente por el <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> obteniendo el error y no debe ser invocado normalmente en otras circunstancias.</p>
<p><em>req</em> será un objeto <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>, <em>fp</em> será un objeto como archivo con el cuerpo de error HTTP, <em>code</em> será el código de error de tres dígitos, <em>msg</em> será la explicación visible para el usuario del código y <em>hdrs</em> será un objeto de mapeo con los encabezados del error.</p>
<p>Los valores de retorno y las excepciones generadas deben ser los mismos que aquellos de <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>.</p>
</dd></dl>

<span class="target" id="http-error-nnn"></span><dl class="py method">
<dt>
<code class="sig-name descname">BaseHandler.http_error_&lt;nnn&gt;(req, fp, code, msg, hdrs)</code></dt>
<dd><p><em>nnn</em> debe ser un código de error HTTP de tres dígitos. Este método tampoco está definido en <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>, pero será invocado, si existe, en una instancia de una subclase, cuando ocurra un error HTTP con código <em>nnn</em>.</p>
<p>Las subclases deben sobrescribir este método para manejar errores HTTP específicos.</p>
<p>Los argumentos, valores de retorno y las excepciones generadas deben ser las mismas que para <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_default()</span></code>.</p>
</dd></dl>

<span class="target" id="protocol-request"></span><dl class="py method">
<dt>
<code class="sig-name descname">BaseHandler.&lt;protocol&gt;_request(req)</code></dt>
<dd><p>Este método <em>no</em> está definido en <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>, pero las subclases deben definirlo si pretenden preprocesar peticiones del protocolo dado.</p>
<p>Este método, si está definido, será invocado por el <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> padre. <em>req</em> será un objeto <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>. El valor retornado debe ser un objeto <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>.</p>
</dd></dl>

<span class="target" id="protocol-response"></span><dl class="py method">
<dt>
<code class="sig-name descname">BaseHandler.&lt;protocol&gt;_response(req, response)</code></dt>
<dd><p>Este método <em>no</em> está definido en <a class="reference internal" href="#urllib.request.BaseHandler" title="urllib.request.BaseHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaseHandler</span></code></a>, pero las subclases deben definirlo si quieren postprocesar respuestas del protocolo dado.</p>
<p>Este método, si está definido, será invocado por el <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> padre. <em>req</em> será un objeto <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>. <em>response</em> será un objeto que implementa la misma interfaz que el valor retornado de <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>. El valor retornado debe implementar la misma interfaz que el valor retornado de <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>.</p>
</dd></dl>

</section>
<section id="httpredirecthandler-objects">
<span id="http-redirect-handler"></span><h2>Objetos HTTPRedirectHandler<a class="headerlink" href="#httpredirecthandler-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Algunas redirecciones HTTP requieren acción desde el código del módulo del cliente. Si este es el caso, se genera <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a>. Vea <span class="target" id="index-31"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2616.html"><strong>RFC 2616</strong></a> para más detalles de los significados precisos de los diferentes códigos de redirección.</p>
<p>Una excepción <code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPError</span></code> generada como consideración de seguridad si el HTTPRedirectHandler se presenta con una URL redirigida la cual no es una URL HTTP, HTTPS o FTP.</p>
</div>
<dl class="py method">
<dt id="urllib.request.HTTPRedirectHandler.redirect_request">
<code class="sig-prename descclassname">HTTPRedirectHandler.</code><code class="sig-name descname">redirect_request</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">req</span></em>, <em class="sig-param"><span class="n">fp</span></em>, <em class="sig-param"><span class="n">code</span></em>, <em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">hdrs</span></em>, <em class="sig-param"><span class="n">newurl</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.redirect_request" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> o <code class="docutils literal notranslate"><span class="pre">None</span></code> en respuesta a una redirección. Esto es invocado por las implementaciones predeterminadas de los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_30*()</span></code> cuando se recibe una redirección del servidor. Si puede tomar lugar una redirección, retorna un nuevo <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> para permitir a <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_30*()</span></code> realizar la redirección a <em>newurl</em>. De otra forma, genera <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a> si ningún otro manejador debe intentar manejar esta URL, o retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si no tú pero otro manejador puede.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La implementación predeterminada de este método no sigue estrictamente <span class="target" id="index-32"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2616.html"><strong>RFC 2616</strong></a>, la cual dice que las respuestas 301 y 302 a peticiones POST no deben ser redirigidas automáticamente sin confirmación por el usuario. En realidad, los navegadores permiten redirección automática de esas respuestas, cambiando el POST a un <code class="docutils literal notranslate"><span class="pre">GET</span></code> y la implementación predeterminada reproduce este comportamiento.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_301">
<code class="sig-prename descclassname">HTTPRedirectHandler.</code><code class="sig-name descname">http_error_301</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">req</span></em>, <em class="sig-param"><span class="n">fp</span></em>, <em class="sig-param"><span class="n">code</span></em>, <em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">hdrs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Redirecciona a la URL <code class="docutils literal notranslate"><span class="pre">Location:</span></code> o <code class="docutils literal notranslate"><span class="pre">URI:</span></code>. Este método es invocado por el <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> padre al obtener una respuesta HTTP “moved permanently”.</p>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_302">
<code class="sig-prename descclassname">HTTPRedirectHandler.</code><code class="sig-name descname">http_error_302</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">req</span></em>, <em class="sig-param"><span class="n">fp</span></em>, <em class="sig-param"><span class="n">code</span></em>, <em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">hdrs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_302" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Lo mismo que <a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_301()</span></code></a>, pero invocado para la respuesta “found”.</p>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_303">
<code class="sig-prename descclassname">HTTPRedirectHandler.</code><code class="sig-name descname">http_error_303</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">req</span></em>, <em class="sig-param"><span class="n">fp</span></em>, <em class="sig-param"><span class="n">code</span></em>, <em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">hdrs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_303" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Lo mismo que <a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_301()</span></code></a>, pero invocado para la respuesta “see other”.</p>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_307">
<code class="sig-prename descclassname">HTTPRedirectHandler.</code><code class="sig-name descname">http_error_307</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">req</span></em>, <em class="sig-param"><span class="n">fp</span></em>, <em class="sig-param"><span class="n">code</span></em>, <em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">hdrs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_307" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Lo mismo que <a class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="urllib.request.HTTPRedirectHandler.http_error_301"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_301()</span></code></a>, pero invocado para la respuesta “temporary redirect”.</p>
</dd></dl>

</section>
<section id="httpcookieprocessor-objects">
<span id="http-cookie-processor"></span><h2>Objetos HTTPCookieProcessor<a class="headerlink" href="#httpcookieprocessor-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las instancias <a class="reference internal" href="#urllib.request.HTTPCookieProcessor" title="urllib.request.HTTPCookieProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPCookieProcessor</span></code></a> tienen un atributo:</p>
<dl class="py attribute">
<dt id="urllib.request.HTTPCookieProcessor.cookiejar">
<code class="sig-prename descclassname">HTTPCookieProcessor.</code><code class="sig-name descname">cookiejar</code><a class="headerlink" href="#urllib.request.HTTPCookieProcessor.cookiejar" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El <a class="reference internal" href="http.cookiejar.html#http.cookiejar.CookieJar" title="http.cookiejar.CookieJar"><code class="xref py py-class docutils literal notranslate"><span class="pre">http.cookiejar.CookieJar</span></code></a> en el cual las cookies están almacenadas.</p>
</dd></dl>

</section>
<section id="proxyhandler-objects">
<span id="proxy-handler"></span><h2>Objetos ProxyHandler<a class="headerlink" href="#proxyhandler-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="py method">
<dt>
<code class="sig-name descname">ProxyHandler.&lt;protocol&gt;_open(request)</code></dt>
<dd><p>El <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> tendrá un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">&lt;protocol&gt;_open()</span></code> para cada <em>protocol</em> el cual tiene un proxy en el diccionario <em>proxies</em> dado en el constructor. El método modificará peticiones para ir a través del proxy, invocando <code class="docutils literal notranslate"><span class="pre">request.set_proxy()</span></code>, e invoca el siguiente manejador en la cadena que ejecuta actualmente el protocolo.</p>
</dd></dl>

</section>
<section id="httppasswordmgr-objects">
<span id="http-password-mgr"></span><h2>Objetos HTTPPasswordMgr<a class="headerlink" href="#httppasswordmgr-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Estos métodos están disponibles en los objetos <a class="reference internal" href="#urllib.request.HTTPPasswordMgr" title="urllib.request.HTTPPasswordMgr"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgr</span></code></a> y <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a>.</p>
<dl class="py method">
<dt id="urllib.request.HTTPPasswordMgr.add_password">
<code class="sig-prename descclassname">HTTPPasswordMgr.</code><code class="sig-name descname">add_password</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">realm</span></em>, <em class="sig-param"><span class="n">uri</span></em>, <em class="sig-param"><span class="n">user</span></em>, <em class="sig-param"><span class="n">passwd</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgr.add_password" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p><em>uri</em> puede ser una única URI o una secuencia de URIs. <em>realm</em>, <em>user</em> y <em>passwd</em> deben ser cadenas. Esto causa que <code class="docutils literal notranslate"><span class="pre">(user,</span> <span class="pre">passwd)</span></code> se utilice como tokens de autenticación cuando la autenticación para <em>realm</em> y para una super URI de ninguna de las URIs dadas es provista.</p>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.HTTPPasswordMgr.find_user_password">
<code class="sig-prename descclassname">HTTPPasswordMgr.</code><code class="sig-name descname">find_user_password</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">realm</span></em>, <em class="sig-param"><span class="n">authuri</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgr.find_user_password" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Obtener usuario/contraseña para el reino y URI dados, si alguno ha sido dado. Este método retornará <code class="docutils literal notranslate"><span class="pre">(None,</span> <span class="pre">None)</span></code> si no hay usuario/contraseña concordante.</p>
<p>Para objetos <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a>, el reino <code class="docutils literal notranslate"><span class="pre">None</span></code> será buscado si el <em>realm</em> dado no tiene usuario/contraseña concordante.</p>
</dd></dl>

</section>
<section id="httppasswordmgrwithpriorauth-objects">
<span id="http-password-mgr-with-prior-auth"></span><h2>Objetos HTTPPasswordMgrWithPriorAuth<a class="headerlink" href="#httppasswordmgrwithpriorauth-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Esta manejador de contraseña extiende <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a> para soportar el seguimiento de URIs para las cuales deben ser enviadas siempre credenciales de autenticación.</p>
<dl class="py method">
<dt id="urllib.request.HTTPPasswordMgrWithPriorAuth.add_password">
<code class="sig-prename descclassname">HTTPPasswordMgrWithPriorAuth.</code><code class="sig-name descname">add_password</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">realm</span></em>, <em class="sig-param"><span class="n">uri</span></em>, <em class="sig-param"><span class="n">user</span></em>, <em class="sig-param"><span class="n">passwd</span></em>, <em class="sig-param"><span class="n">is_authenticated</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.add_password" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p><em>realm</em>, <em>uri</em>, <em>user</em>, <em>passwd</em> son como para <a class="reference internal" href="#urllib.request.HTTPPasswordMgr.add_password" title="urllib.request.HTTPPasswordMgr.add_password"><code class="xref py py-meth docutils literal notranslate"><span class="pre">HTTPPasswordMgr.add_password()</span></code></a>. <em>is_authenticated</em> establece el valor inicial del indicador <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> para la URI o lista de URIs dadas. Si se especifica <em>is_authenticated</em> como <code class="docutils literal notranslate"><span class="pre">True</span></code>, <em>realm</em> se ignora.</p>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.HTTPPasswordMgrWithPriorAuth.find_user_password">
<code class="sig-prename descclassname">HTTPPasswordMgrWithPriorAuth.</code><code class="sig-name descname">find_user_password</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">realm</span></em>, <em class="sig-param"><span class="n">authuri</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.find_user_password" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Lo mismo que para objetos <a class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="urllib.request.HTTPPasswordMgrWithDefaultRealm"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.HTTPPasswordMgrWithPriorAuth.update_authenticated">
<code class="sig-prename descclassname">HTTPPasswordMgrWithPriorAuth.</code><code class="sig-name descname">update_authenticated</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">uri</span></em>, <em class="sig-param"><span class="n">is_authenticated</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.update_authenticated" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Actualiza el indicador <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> para la <em>uri</em> o lista de URIs dadas.</p>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.HTTPPasswordMgrWithPriorAuth.is_authenticated">
<code class="sig-prename descclassname">HTTPPasswordMgrWithPriorAuth.</code><code class="sig-name descname">is_authenticated</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">authuri</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithPriorAuth.is_authenticated" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el estado actual del indicador <code class="docutils literal notranslate"><span class="pre">is_authenticated</span></code> para la URI dada.</p>
</dd></dl>

</section>
<section id="abstractbasicauthhandler-objects">
<span id="abstract-basic-auth-handler"></span><h2>Objetos AbstractBasicAuthHandler<a class="headerlink" href="#abstractbasicauthhandler-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="py method">
<dt id="urllib.request.AbstractBasicAuthHandler.http_error_auth_reqed">
<code class="sig-prename descclassname">AbstractBasicAuthHandler.</code><code class="sig-name descname">http_error_auth_reqed</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">authreq</span></em>, <em class="sig-param"><span class="n">host</span></em>, <em class="sig-param"><span class="n">req</span></em>, <em class="sig-param"><span class="n">headers</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractBasicAuthHandler.http_error_auth_reqed" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Maneja una autenticación de petición obteniendo un par usuario/contraseña y reintentando la petición. <em>authreq</em> debe ser el nombre del encabezado donde la información sobre el reino se incluye en la petición, <em>host</em> especifica la URL y ruta para la cual autenticar, <em>req</em> debe ser el objeto <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> (fallido) y <em>headers</em> deben ser los encabezados de error.</p>
<p><em>host</em> es una autoridad (ej. <code class="docutils literal notranslate"><span class="pre">&quot;python.org&quot;</span></code>) o una URL conteniendo un componente de autoridad (ej. <code class="docutils literal notranslate"><span class="pre">&quot;http://python.org/&quot;</span></code>). En cualquier caso, la autoridad no debe contener un componente userinfo (por lo que <code class="docutils literal notranslate"><span class="pre">&quot;python.org&quot;</span></code> y <code class="docutils literal notranslate"><span class="pre">&quot;python.org:80&quot;</span></code> están bien, <code class="docutils literal notranslate"><span class="pre">&quot;joe:password&#64;python.org&quot;</span></code> no).</p>
</dd></dl>

</section>
<section id="httpbasicauthhandler-objects">
<span id="http-basic-auth-handler"></span><h2>Objetos HTTPBasicAuthHandler<a class="headerlink" href="#httpbasicauthhandler-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="py method">
<dt id="urllib.request.HTTPBasicAuthHandler.http_error_401">
<code class="sig-prename descclassname">HTTPBasicAuthHandler.</code><code class="sig-name descname">http_error_401</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">req</span></em>, <em class="sig-param"><span class="n">fp</span></em>, <em class="sig-param"><span class="n">code</span></em>, <em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">hdrs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPBasicAuthHandler.http_error_401" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Reintenta la petición con la información de autenticación, si está disponible.</p>
</dd></dl>

</section>
<section id="proxybasicauthhandler-objects">
<span id="proxy-basic-auth-handler"></span><h2>Objetos ProxyBasicAuthHandler<a class="headerlink" href="#proxybasicauthhandler-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="py method">
<dt id="urllib.request.ProxyBasicAuthHandler.http_error_407">
<code class="sig-prename descclassname">ProxyBasicAuthHandler.</code><code class="sig-name descname">http_error_407</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">req</span></em>, <em class="sig-param"><span class="n">fp</span></em>, <em class="sig-param"><span class="n">code</span></em>, <em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">hdrs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyBasicAuthHandler.http_error_407" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Reintenta la petición con la información de autenticación, si está disponible.</p>
</dd></dl>

</section>
<section id="abstractdigestauthhandler-objects">
<span id="abstract-digest-auth-handler"></span><h2>Objetos AbstractDigestAuthHandler<a class="headerlink" href="#abstractdigestauthhandler-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="py method">
<dt id="urllib.request.AbstractDigestAuthHandler.http_error_auth_reqed">
<code class="sig-prename descclassname">AbstractDigestAuthHandler.</code><code class="sig-name descname">http_error_auth_reqed</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">authreq</span></em>, <em class="sig-param"><span class="n">host</span></em>, <em class="sig-param"><span class="n">req</span></em>, <em class="sig-param"><span class="n">headers</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.AbstractDigestAuthHandler.http_error_auth_reqed" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p><em>authreq</em> debe ser el nombre del encabezado donde la información sobre el reino está incluida en la petición, <em>host</em> debe ser el host al que autenticar, <em>req</em> debe ser el objeto <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> (fallido) y <em>headers</em> deben ser los encabezados de error.</p>
</dd></dl>

</section>
<section id="httpdigestauthhandler-objects">
<span id="http-digest-auth-handler"></span><h2>Objetos HTTPDigestAuthHandler<a class="headerlink" href="#httpdigestauthhandler-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="py method">
<dt id="urllib.request.HTTPDigestAuthHandler.http_error_401">
<code class="sig-prename descclassname">HTTPDigestAuthHandler.</code><code class="sig-name descname">http_error_401</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">req</span></em>, <em class="sig-param"><span class="n">fp</span></em>, <em class="sig-param"><span class="n">code</span></em>, <em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">hdrs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPDigestAuthHandler.http_error_401" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Reintenta la petición con la información de autenticación, si está disponible.</p>
</dd></dl>

</section>
<section id="proxydigestauthhandler-objects">
<span id="proxy-digest-auth-handler"></span><h2>Objetos ProxyDigestAuthHandler<a class="headerlink" href="#proxydigestauthhandler-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="py method">
<dt id="urllib.request.ProxyDigestAuthHandler.http_error_407">
<code class="sig-prename descclassname">ProxyDigestAuthHandler.</code><code class="sig-name descname">http_error_407</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">req</span></em>, <em class="sig-param"><span class="n">fp</span></em>, <em class="sig-param"><span class="n">code</span></em>, <em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">hdrs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.ProxyDigestAuthHandler.http_error_407" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Reintenta la petición con la información de autenticación, si está disponible.</p>
</dd></dl>

</section>
<section id="httphandler-objects">
<span id="http-handler-objects"></span><h2>Objetos HTTPHandler<a class="headerlink" href="#httphandler-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="py method">
<dt id="urllib.request.HTTPHandler.http_open">
<code class="sig-prename descclassname">HTTPHandler.</code><code class="sig-name descname">http_open</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">req</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPHandler.http_open" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Envía una petición HTTP, que puede ser GET o POST, dependiendo de <code class="docutils literal notranslate"><span class="pre">req.has_data()</span></code>.</p>
</dd></dl>

</section>
<section id="httpshandler-objects">
<span id="https-handler-objects"></span><h2>Objetos HTTPSHandler<a class="headerlink" href="#httpshandler-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="py method">
<dt id="urllib.request.HTTPSHandler.https_open">
<code class="sig-prename descclassname">HTTPSHandler.</code><code class="sig-name descname">https_open</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">req</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPSHandler.https_open" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Envía una petición HTTPS, que puede ser GET o POST, dependiendo de <code class="docutils literal notranslate"><span class="pre">req.has_data()</span></code>.</p>
</dd></dl>

</section>
<section id="filehandler-objects">
<span id="file-handler-objects"></span><h2>Objetos FileHandler<a class="headerlink" href="#filehandler-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="py method">
<dt id="urllib.request.FileHandler.file_open">
<code class="sig-prename descclassname">FileHandler.</code><code class="sig-name descname">file_open</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">req</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FileHandler.file_open" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Abre el archivo localmente, si no hay nombre de host, o el nombre de host es <code class="docutils literal notranslate"><span class="pre">'localhost'</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Este método es aplicable sólo para nombres de host locales. Cuando un nombre de host remoto es dado, se genera una excepción <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="datahandler-objects">
<span id="data-handler-objects"></span><h2>Objetos DataHandler<a class="headerlink" href="#datahandler-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="py method">
<dt id="urllib.request.DataHandler.data_open">
<code class="sig-prename descclassname">DataHandler.</code><code class="sig-name descname">data_open</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">req</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.DataHandler.data_open" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Lee una URL de datos. Este tipo de URL contiene el contenido codificado en la URL misma. La sintaxis de la URL de datos se especifica en <span class="target" id="index-33"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2397.html"><strong>RFC 2397</strong></a>. Esta implementación ignora los espacios en blanco en datos codificados como base64 así que la URL puede ser envuelta en cualquier archivo fuente del que proviene. Pero a pesar de que a algunos navegadores no les importa si falta relleno al final de una URL codificada como base64, esta implementación lanzará un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> en este caso.</p>
</dd></dl>

</section>
<section id="ftphandler-objects">
<span id="ftp-handler-objects"></span><h2>Objetos FTPHandler<a class="headerlink" href="#ftphandler-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="py method">
<dt id="urllib.request.FTPHandler.ftp_open">
<code class="sig-prename descclassname">FTPHandler.</code><code class="sig-name descname">ftp_open</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">req</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FTPHandler.ftp_open" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Abre el archivo FTP indicado por <em>req</em>. El inicio de sesión siempre se realiza con un usuario y contraseña vacíos.</p>
</dd></dl>

</section>
<section id="cacheftphandler-objects">
<span id="cacheftp-handler-objects"></span><h2>Objetos CacheFTPHandler<a class="headerlink" href="#cacheftphandler-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los objetos <a class="reference internal" href="#urllib.request.CacheFTPHandler" title="urllib.request.CacheFTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">CacheFTPHandler</span></code></a> son objetos <a class="reference internal" href="#urllib.request.FTPHandler" title="urllib.request.FTPHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">FTPHandler</span></code></a> con los siguientes métodos adicionales:</p>
<dl class="py method">
<dt id="urllib.request.CacheFTPHandler.setTimeout">
<code class="sig-prename descclassname">CacheFTPHandler.</code><code class="sig-name descname">setTimeout</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.CacheFTPHandler.setTimeout" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece el tiempo de expiración de conexiones a <em>t</em> segundos.</p>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.CacheFTPHandler.setMaxConns">
<code class="sig-prename descclassname">CacheFTPHandler.</code><code class="sig-name descname">setMaxConns</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">m</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.CacheFTPHandler.setMaxConns" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece el número máximo de conexiones cacheadas a <em>m</em>.</p>
</dd></dl>

</section>
<section id="unknownhandler-objects">
<span id="unknown-handler-objects"></span><h2>Objetos UnknownHandler<a class="headerlink" href="#unknownhandler-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="py method">
<dt id="urllib.request.UnknownHandler.unknown_open">
<code class="sig-prename descclassname">UnknownHandler.</code><code class="sig-name descname">unknown_open</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.UnknownHandler.unknown_open" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Genera una excepción <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a>.</p>
</dd></dl>

</section>
<section id="httperrorprocessor-objects">
<span id="http-error-processor-objects"></span><h2>Objetos HTTPErrorProcessor<a class="headerlink" href="#httperrorprocessor-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="py method">
<dt id="urllib.request.HTTPErrorProcessor.http_response">
<code class="sig-prename descclassname">HTTPErrorProcessor.</code><code class="sig-name descname">http_response</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">request</span></em>, <em class="sig-param"><span class="n">response</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPErrorProcessor.http_response" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Procesa errores de respuestas HTTP.</p>
<p>Para códigos de error que no están en el rango de los 200, el objeto de respuesta es retornado inmediatamente.</p>
<p>Para códigos de error que no están en el rango de los 200, esto simplemente pasa el trabajo a los métodos del manejador <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_&lt;type&gt;()</span></code>, mediante <a class="reference internal" href="#urllib.request.OpenerDirector.error" title="urllib.request.OpenerDirector.error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OpenerDirector.error()</span></code></a>. Eventualmente, <a class="reference internal" href="#urllib.request.HTTPDefaultErrorHandler" title="urllib.request.HTTPDefaultErrorHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPDefaultErrorHandler</span></code></a> lanzará un <a class="reference internal" href="urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">HTTPError</span></code></a> si ningún otro manejador maneja el error.</p>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.HTTPErrorProcessor.https_response">
<code class="sig-prename descclassname">HTTPErrorProcessor.</code><code class="sig-name descname">https_response</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">request</span></em>, <em class="sig-param"><span class="n">response</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.HTTPErrorProcessor.https_response" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Procesa los errores HTTPS de las respuestas.</p>
<p>Este comportamiento es el mismo que <a class="reference internal" href="#urllib.request.HTTPErrorProcessor.http_response" title="urllib.request.HTTPErrorProcessor.http_response"><code class="xref py py-meth docutils literal notranslate"><span class="pre">http_response()</span></code></a>.</p>
</dd></dl>

</section>
<section id="examples">
<span id="urllib-request-examples"></span><h2>Ejemplos<a class="headerlink" href="#examples" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Adicionalmente a los ejemplos siguientes, se dan más ejemplos en <a class="reference internal" href="../howto/urllib2.html#urllib-howto"><span class="std std-ref">HOWTO - Cómo obtener recursos de Internet con el paquete urllib</span></a>.</p>
<p>Este ejemplo obtiene la página principal python.org y despliega los primeros 300 bytes de ella.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">300</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">b&#39;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>
<span class="go">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\n\n\n&lt;html</span>
<span class="go">xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n</span>
<span class="go">&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;\n</span>
<span class="go">&lt;title&gt;Python Programming &#39;</span>
</pre></div>
</div>
<p>Tenga en cuenta que urlopen retorna un objeto de bytes. Esto es porque no hay forma para urlopen de determinar automáticamente la codificación del flujo de bytes que recibe del servidor HTTP. En general, un programa decodificará el objeto de bytes retornado a cadena de caracteres una vez que determine o adivine la codificación apropiada.</p>
<p>El siguiente documento W3C, <a class="reference external" href="https://www.w3.org/International/O-charset">https://www.w3.org/International/O-charset</a>, lista las diferentes formas en la cual un documento (X)HTML o XML podría haber especificado su información de codificación.</p>
<p>Ya que el sitio web python.org usa codificación <em>utf-8</em> tal y como se especifica en su etiqueta meta, usaremos la misma para decodificar el objeto de bytes.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>
<span class="go">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtm</span>
</pre></div>
</div>
<p>Es posible conseguir el mismo resultado sin usar la aproximación <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">context manager</span></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="go">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span>
<span class="go">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtm</span>
</pre></div>
</div>
<p>En el siguiente ejemplo, estamos enviando un flujo de datos a la entrada estándar de un CGI y leyendo los datos que nos retorna. Tenga en cuenta que este ejemplo sólo funcionará cuando la instalación de Python soporte SSL.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="s1">&#39;https://localhost/cgi-bin/test.cgi&#39;</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">data</span><span class="o">=</span><span class="sa">b</span><span class="s1">&#39;This data is passed to stdin of the CGI&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">Got Data: &quot;This data is passed to stdin of the CGI&quot;</span>
</pre></div>
</div>
<p>El código para el CGI de muestra usado en el ejemplo anterior es:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Content-type: text/plain</span><span class="se">\n\n</span><span class="s1">Got Data: &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>Aquí hay un ejemplo de realizar una petición <code class="docutils literal notranslate"><span class="pre">PUT</span></code> usando <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">DATA</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;some data&#39;</span>
<span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="s1">&#39;http://localhost:8080&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">DATA</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;PUT&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">reason</span><span class="p">)</span>
</pre></div>
</div>
<p>Uso de Autenticación HTTP Básica:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="c1"># Create an OpenerDirector with support for Basic HTTP Authentication...</span>
<span class="n">auth_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">HTTPBasicAuthHandler</span><span class="p">()</span>
<span class="n">auth_handler</span><span class="o">.</span><span class="n">add_password</span><span class="p">(</span><span class="n">realm</span><span class="o">=</span><span class="s1">&#39;PDQ Application&#39;</span><span class="p">,</span>
                          <span class="n">uri</span><span class="o">=</span><span class="s1">&#39;https://mahler:8092/site-updates.py&#39;</span><span class="p">,</span>
                          <span class="n">user</span><span class="o">=</span><span class="s1">&#39;klem&#39;</span><span class="p">,</span>
                          <span class="n">passwd</span><span class="o">=</span><span class="s1">&#39;kadidd!ehopper&#39;</span><span class="p">)</span>
<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">(</span><span class="n">auth_handler</span><span class="p">)</span>
<span class="c1"># ...and install it globally so it can be used with urlopen.</span>
<span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">install_opener</span><span class="p">(</span><span class="n">opener</span><span class="p">)</span>
<span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/login.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#urllib.request.build_opener" title="urllib.request.build_opener"><code class="xref py py-func docutils literal notranslate"><span class="pre">build_opener()</span></code></a> proporciona muchos manejadores por defecto, incluyendo un <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a>. De forma predeterminada, <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> usa las variables de entorno llamadas <code class="docutils literal notranslate"><span class="pre">&lt;scheme&gt;_proxy</span></code>, donde <code class="docutils literal notranslate"><span class="pre">&lt;scheme&gt;</span></code> es el esquema URL involucrado. Por ejemplo, se lee la variable de entorno <span class="target" id="index-34"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">http_proxy</span></code> para obtener la URL del proxy HTTP.</p>
<p>This example replaces the default <a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> with one that uses
programmatically supplied proxy URLs, and adds proxy authorization support with
<a class="reference internal" href="#urllib.request.ProxyBasicAuthHandler" title="urllib.request.ProxyBasicAuthHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyBasicAuthHandler</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">proxy_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">ProxyHandler</span><span class="p">({</span><span class="s1">&#39;http&#39;</span><span class="p">:</span> <span class="s1">&#39;http://www.example.com:3128/&#39;</span><span class="p">})</span>
<span class="n">proxy_auth_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">ProxyBasicAuthHandler</span><span class="p">()</span>
<span class="n">proxy_auth_handler</span><span class="o">.</span><span class="n">add_password</span><span class="p">(</span><span class="s1">&#39;realm&#39;</span><span class="p">,</span> <span class="s1">&#39;host&#39;</span><span class="p">,</span> <span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="s1">&#39;password&#39;</span><span class="p">)</span>

<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">(</span><span class="n">proxy_handler</span><span class="p">,</span> <span class="n">proxy_auth_handler</span><span class="p">)</span>
<span class="c1"># This time, rather than install the OpenerDirector, we use it directly:</span>
<span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/login.html&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Añadiendo encabezados HTTP:</p>
<p>Usa el argumento <em>headers</em> en el constructor de <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>, o:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/&#39;</span><span class="p">)</span>
<span class="n">req</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;Referer&#39;</span><span class="p">,</span> <span class="s1">&#39;http://www.python.org/&#39;</span><span class="p">)</span>
<span class="c1"># Customize the default User-Agent header value:</span>
<span class="n">req</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s1">&#39;User-Agent&#39;</span><span class="p">,</span> <span class="s1">&#39;urllib-example/0.1 (Contact: . . .)&#39;</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> añade automáticamente un encabezado <em class="mailheader">User-Agent</em> a cada <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>. Para cambiar esto:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">()</span>
<span class="n">opener</span><span class="o">.</span><span class="n">addheaders</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;User-agent&#39;</span><span class="p">,</span> <span class="s1">&#39;Mozilla/5.0&#39;</span><span class="p">)]</span>
<span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>También, recuerda que algunos encabezados estándar (<em class="mailheader">Content-Length</em>, <em class="mailheader">Content-Type</em> y <em class="mailheader">Host</em>) son añadidos cuando se pasa <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> a <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> (o <a class="reference internal" href="#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OpenerDirector.open()</span></code></a>).</p>
<p id="urllib-examples">Aquí hay un ejemplo de sesión que usa el método <code class="docutils literal notranslate"><span class="pre">GET</span></code> para obtener una URL que contiene los parámetros:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">params</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">({</span><span class="s1">&#39;spam&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;eggs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;http://www.musi-cal.com/cgi-bin/query?</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">params</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>El siguiente ejemplo usa el método POST en su lugar. Tenga en cuenta que la salida de parámetros desde urlencode es codificada a bytes antes de ser enviados a urlopen como datos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">({</span><span class="s1">&#39;spam&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;eggs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s2">&quot;http://requestb.in/xrbl82xr&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>El siguiente ejemplo usa un proxy HTTP especificado, sobrescribiendo las configuraciones de entorno:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proxies</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;http&#39;</span><span class="p">:</span> <span class="s1">&#39;http://proxy.example.com:8080/&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">FancyURLopener</span><span class="p">(</span><span class="n">proxies</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;http://www.python.org&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>El siguiente ejemplo no usa proxies, sobrescribiendo las variables de entorno:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">FancyURLopener</span><span class="p">({})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;http://www.python.org/&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
</section>
<section id="legacy-interface">
<h2>Interfaz heredada<a class="headerlink" href="#legacy-interface" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las siguientes funciones y clases están portadas desde el módulo <code class="docutils literal notranslate"><span class="pre">urllib</span></code> de Python 2 (en oposición a <code class="docutils literal notranslate"><span class="pre">urllib2</span></code>). Ellas pueden estar obsoletas en algún punto del futuro.</p>
<dl class="py function">
<dt id="urllib.request.urlretrieve">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">urlretrieve</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">url</span></em>, <em class="sig-param"><span class="n">filename</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reporthook</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.urlretrieve" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Copia un objeto de red denotado por una URL a un archivo local. Si la URL apunta a un archivo local, el objeto no será copiado a no ser que sea suministrado un nombre de archivo. Retorna una tupla <code class="docutils literal notranslate"><span class="pre">(filename,</span> <span class="pre">headers)</span></code> donde <em>filename</em> es el nombre de archivo local bajo el cual el objeto puede ser encontrado y <em>headers</em> es lo que retorna el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code> retornado por <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> (para un objeto remoto). Las excepciones son las mismas que para <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>.</p>
<p>El segundo argumento, si está presente, especifica la localización a la que será copiada el objeto (si está ausente, la localización será un archivo temporal con un nombre generado). El tercer argumento, si está presente, es un objeto invocable que será invocado una vez que se establezca la conexión de red y después de eso una vez después de cada lectura de bloque. Al invocable se le pasarán tres argumentos; una cuenta de los bloques transferidos hasta el momento, un tamaño de bloque en bytes y el tamaño total del archivo. El tercer argumento puede ser <code class="docutils literal notranslate"><span class="pre">-1</span></code> en servidores FTP antiguos los cuales no retornan un tamaño de archivo en respuesta a una solicitud de recuperación.</p>
<p>El siguiente ejemplo ilustra el escenario de uso más común:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">local_filename</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlretrieve</span><span class="p">(</span><span class="s1">&#39;http://python.org/&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">html</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">local_filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">html</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>Si la <em>url</em> usa el esquema de identificador <code class="file docutils literal notranslate"><span class="pre">http:</span></code>, el argumento opcional <em>data</em> puede ser dado para especificar una petición <code class="docutils literal notranslate"><span class="pre">POST</span></code> (normalmente el tipo de petición es <code class="docutils literal notranslate"><span class="pre">GET</span></code>). El argumento <em>data</em> debe ser un objeto de bytes en formato <em class="mimetype">application/x-www-form-urlencoded</em>; vea la función <a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a>.</p>
<p><a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a> lanzará <code class="xref py py-exc docutils literal notranslate"><span class="pre">ContentTooShortError</span></code> cuando detecte que la cantidad de datos disponibles sea menor que la cantidad esperada (la cual es el tamaño reportado por un encabezado <em>Content-Length</em>). Esto puede ocurrir, por ejemplo, cuando se interrumpe la descarga.</p>
<p>El <em>Content-Length</em> es tratado como un límite inferior: si no hay más datos a leer, urlretrieve lee más datos, pero si están disponibles menos datos, se genera la excepción.</p>
<p>Puedes seguir obteniendo los datos descargados en este caso, son almacenados en el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">content</span></code> de la instancia de la excepción.</p>
<p>Si no fue proporcionado el encabezado <em>Content-Length</em>, urlretrieve no puede comprobar el tamaño de los datos que han sido descargados, y sólo los retorna. En este caso sólo tienes que asumir que la descarga fue exitosa.</p>
</dd></dl>

<dl class="py function">
<dt id="urllib.request.urlcleanup">
<code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">urlcleanup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.urlcleanup" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Limpia archivos temporales que pueden haber quedado tras llamadas anteriores a <a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt id="urllib.request.URLopener">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">URLopener</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">proxies</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">x509</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.3.</span></p>
</div>
<p>Clase base para apertura y lectura de URLs. A no ser que necesites soporte de apertura de objetos usando esquemas diferentes a <code class="file docutils literal notranslate"><span class="pre">http:</span></code>, <code class="file docutils literal notranslate"><span class="pre">ftp:</span></code> o <code class="file docutils literal notranslate"><span class="pre">file:</span></code>, probablemente quieras usar <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a>.</p>
<p>Por defecto, la clase <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> envía un encabezado <em class="mailheader">User-Agent</em> de <code class="docutils literal notranslate"><span class="pre">urllib/VVV</span></code>, donde <em>VVV</em> es el número de versión <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a>. Las aplicaciones pueden definir su propio encabezado <em class="mailheader">User-Agent</em> heredando de <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> o <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> y estableciendo el atributo de clase <a class="reference internal" href="#urllib.request.URLopener.version" title="urllib.request.URLopener.version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">version</span></code></a> a un valor de cadena de caracteres apropiado en la definición de la subclase.</p>
<p>El parámetro opcional <em>proxies</em> debe ser un diccionario mapeando nombres de esquemas a URLs de proxy, donde un diccionario vacío apaga los proxies completamente. Su valor predeterminado es <code class="docutils literal notranslate"><span class="pre">None</span></code>, en cuyo caso las configuraciones de proxy del entorno serán usadas si están presentes, como ha sido discutido en la definición de <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>, arriba.</p>
<p>Parámetros adicionales de palabra clave, recogidos en <em>x509</em>, pueden ser usados por autenticación del cliente cuando usan el esquema <code class="file docutils literal notranslate"><span class="pre">https:</span></code>. Las palabras claves <em>key_file</em> y <em>cert_file</em> están soportadas para proveer una clave y certificado SSL; ambos son necesarias para soportar autenticación de cliente.</p>
<p>Los objetos <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> lanzarán una excepción <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> si el servidor retorna un código de error.</p>
<dl class="py method">
<dt id="urllib.request.URLopener.open">
<code class="sig-name descname">open</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullurl</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener.open" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Abre <em>fullurl</em> usando el protocolo apropiado. Este método configura la información de caché e información de proxy, entonces invoca el método apropiado con sus argumentos de entrada. Si el esquema no está reconocido, se invoca <a class="reference internal" href="#urllib.request.URLopener.open_unknown" title="urllib.request.URLopener.open_unknown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open_unknown()</span></code></a>. El argumento <em>data</em> tiene el mismo significado que el argumento <em>data</em> de <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a>.</p>
<p>Este método siempre entrecomilla <em>fullurl</em> usando <a class="reference internal" href="urllib.parse.html#urllib.parse.quote" title="urllib.parse.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">quote()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.URLopener.open_unknown">
<code class="sig-name descname">open_unknown</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fullurl</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener.open_unknown" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Interfaz sobrescribible para abrir tipos de URL desconocidos.</p>
</dd></dl>

<dl class="py method">
<dt id="urllib.request.URLopener.retrieve">
<code class="sig-name descname">retrieve</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">url</span></em>, <em class="sig-param"><span class="n">filename</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reporthook</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.URLopener.retrieve" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Obtiene el contenido de <em>url</em> y lo coloca en <em>filename</em>. El valor retornado es una tupla que consiste de un nombre de archivo local y un objeto <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">email.message.Message</span></code></a> conteniendo los encabezados de respuesta (para URLs remotas) o <code class="docutils literal notranslate"><span class="pre">None</span></code> (para URLs locales). El invocador debe entonces abrir y leer los contenidos de <em>filename</em>. Si <em>filename</em> no está dado y la URL refiere a un archivo local, se retorna el nombre de archivo de entrada. Si la URL no es local y no se da <em>filename</em>, el nombre de archivo es la salida de la función <a class="reference internal" href="tempfile.html#tempfile.mktemp" title="tempfile.mktemp"><code class="xref py py-func docutils literal notranslate"><span class="pre">tempfile.mktemp()</span></code></a> con un sufijo que concuerda con el sufijo del último componente de la ruta de la URL de entrada. Si se da <em>reporthook</em>, debe ser una función que acepte tres parámetros numéricos: Un número de fragmento, se leen los fragmentos de tamaño máximo y el tamaño total de la descarga (-1 si es desconocida). Será invocada una vez al comienzo y después de que cada fragmento de datos sea leído de la red. <em>reporthook</em> es ignorado para URLs locales.</p>
<p>Si la <em>url</em> usa el identificador de esquema <code class="file docutils literal notranslate"><span class="pre">http:</span></code>, el argumento opcional <em>data</em> puede ser dado para especificar una petición <code class="docutils literal notranslate"><span class="pre">POST</span></code> (normalmente el tipo de petición es <code class="docutils literal notranslate"><span class="pre">GET</span></code>). El argumento <em>data</em> debe estar en formato estándar <em class="mimetype">application/x-www-form-urlencoded</em>; vea la función <a class="reference internal" href="urllib.parse.html#urllib.parse.urlencode" title="urllib.parse.urlencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.parse.urlencode()</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="urllib.request.URLopener.version">
<code class="sig-name descname">version</code><a class="headerlink" href="#urllib.request.URLopener.version" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Variable que especifica el agente de usuario del objeto abridor. Para obtener <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> para decir a los servidores que es un agente de usuario particular, establece esto en una subclase como una variable de clase o en el constructor antes de invocar el constructor base.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="urllib.request.FancyURLopener">
<em class="property">class </em><code class="sig-prename descclassname">urllib.request.</code><code class="sig-name descname">FancyURLopener</code><span class="sig-paren">(</span><em class="sig-param">...</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FancyURLopener" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.3.</span></p>
</div>
<p><a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> hereda de <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> proveyendo manejo predeterminado para los siguientes códigos de respuesta HTTP: 301, 302, 303, 307 y 401. Para los códigos de respuesta 30x listados anteriormente, se usa el encabezado <em class="mailheader">Location</em> para obtener la URL actual. Para códigos de respuesta 401 (autenticación requerida), se realiza autenticación HTTP. Para los códigos de respuesta 30x, la recursión está limitada por el valor del atributo <em>maxentries</em>, el cual por defecto es 10.</p>
<p>Para todos los demás códigos de respuesta, se invoca al método <code class="xref py py-meth docutils literal notranslate"><span class="pre">http_error_default()</span></code>, que puede sobrescribir en subclases para manejar el error de manera adecuada.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>De acuerdo a la carta de <span class="target" id="index-35"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2616.html"><strong>RFC 2616</strong></a>, las respuestas a las peticiones POST 301 y 302 no debe ser redireccionadas automáticamente sin confirmación por el usuario. En realidad, los navegadores permiten redirección automática de esas respuestas, cambiando de POST a GET, y <a class="reference internal" href="urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> reproduce este comportamiento.</p>
</div>
<p>Los parámetros del constructor son el mismo que aquellos para <a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Cuando se realiza autenticación básica, una instancia <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> invoca a su método <a class="reference internal" href="#urllib.request.FancyURLopener.prompt_user_passwd" title="urllib.request.FancyURLopener.prompt_user_passwd"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prompt_user_passwd()</span></code></a>. La implementación predeterminada pregunta a los usuarios la información requerida en la terminal de control. Una subclase puede sobrescribir este método para soportar un comportamiento más apropiado si se necesita.</p>
</div>
<p>La clase <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> ofrece un método adicional que debe ser sobrecargado para proveer el comportamiento apropiado:</p>
<dl class="py method">
<dt id="urllib.request.FancyURLopener.prompt_user_passwd">
<code class="sig-name descname">prompt_user_passwd</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">host</span></em>, <em class="sig-param"><span class="n">realm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.FancyURLopener.prompt_user_passwd" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la información necesaria para autenticar el usuario en el host dado en el reino de seguridad especificado. El valor retornado debe ser una tupla <code class="docutils literal notranslate"><span class="pre">(user,</span> <span class="pre">password)</span></code>, la cual puede ser usada para autenticación básica.</p>
<p>La implementación solicita esta información en el terminal; una aplicación debe sobrescribir este método para usar un modelo de interacción apropiado en el entorno local.</p>
</dd></dl>

</dd></dl>

</section>
<section id="urllib-request-restrictions">
<h2>Restricciones <a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a><a class="headerlink" href="#urllib-request-restrictions" title="Enlazar permanentemente con este título">¶</a></h2>
<blockquote>
<div></div></blockquote>
<ul id="index-11">
<li><p>Actualmente, sólo uno de los siguientes protocolo están soportados: HTTP (versiones 0.9 y 1.0), FTP, archivos locales y URLs de datos.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Añadido soporte para URLs de datos.</p>
</div>
</li>
<li><p>La característica de caché de <a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a> ha sido deshabilitada hasta que alguien encuentre el tiempo para hackear el procesamiento adecuado de los encabezados de tiempo de Expiración.</p></li>
<li><p>Debería haber una función para consultar si una URL en particular está en la caché.</p></li>
<li><p>Para compatibilidad con versiones anteriores, si una URL parece apuntar a un archivo local pero el archivo no puede ser abierto, la URL es reinterpretada usando el protocolo FTP. Esto a veces puede causar mensajes de error confusos.</p></li>
<li><p>Las funciones <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> y <a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a> pueden causar retrasos arbitrariamente largos mientras esperan a que se configure una conexión de red. Esto significa que es difícil construir un cliente Web interactivo usando estas funciones sin utilizar hilos.</p>
</li>
<li id="index-12"><p>Los datos retornados por <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlopen()</span></code></a> o <a class="reference internal" href="#urllib.request.urlretrieve" title="urllib.request.urlretrieve"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlretrieve()</span></code></a> son los datos en crudo retornados por el servidor. Estos pueden ser datos binarios (como una imagen), texto plano o (por ejemplo) HTML. El protocolo HTTP provee información de tipo en el encabezado de respuesta, el cual puede ser inspeccionado mirando el encabezado <em class="mailheader">Content-Type</em>. Si los datos retornados son HTML, puedes usar el módulo <a class="reference internal" href="html.parser.html#module-html.parser" title="html.parser: A simple parser that can handle HTML and XHTML."><code class="xref py py-mod docutils literal notranslate"><span class="pre">html.parser</span></code></a> para analizarlos.</p>
</li>
<li id="index-13"><p>El código que maneja el protocolo FTP no puede diferenciar entre un archivo y un directorio. Esto puede llevar a un comportamiento inesperado cuando se intenta leer una URL que apunta a un archivo que no es accesible. Si la URL termina en un <code class="docutils literal notranslate"><span class="pre">/</span></code>, se asume que se refiere a un directorio y será manejada acordemente. Pero si un intento de leer un archivo lleva a un error 550 (lo que significa que la URL no puede ser encontrada o no es accesible, a menudo por razones de permisos), entonces se trata la ruta como un directorio para manejar el caso cuando un directorio es especificado por una URL pero el <code class="docutils literal notranslate"><span class="pre">/</span></code> trasero ha sido dejado fuera. Esto puede causar resultados erróneos cuando intenta obtener un archivo cuyos permisos de lectura lo hacen inaccesible; el código FTP intentará leerlo, fallará con un error 550 y entonces realizará un listado de directorio para el archivo ilegible. Si se necesita un control más detallado, considere usar el módulo <a class="reference internal" href="ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftplib</span></code></a>, heredando <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> o cambiando <em>_urlopener</em> para ajustarlo a tus necesidades.</p></li>
</ul>
</section>
</section>
<section id="module-urllib.response">
<span id="urllib-response-response-classes-used-by-urllib"></span><h1><a class="reference internal" href="#module-urllib.response" title="urllib.response: Response classes used by urllib."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.response</span></code></a> — Clases de respuesta usadas por urllib<a class="headerlink" href="#module-urllib.response" title="Enlazar permanentemente con este título">¶</a></h1>
<p>El módulo <a class="reference internal" href="#module-urllib.response" title="urllib.response: Response classes used by urllib."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.response</span></code></a> define funciones y clases que definen una interfaz mínima <em>file-like</em>, incluyendo <code class="docutils literal notranslate"><span class="pre">read()</span></code> y <code class="docutils literal notranslate"><span class="pre">readline()</span></code>. Las funciones definidas en este módulo son usadas internamente por el módulo <a class="reference internal" href="#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a>. El objeto de respuesta típico es una instancia de <a class="reference internal" href="#urllib.response.addinfourl" title="urllib.response.addinfourl"><code class="xref py py-class docutils literal notranslate"><span class="pre">urllib.response.addinfourl</span></code></a>:</p>
<dl class="py class">
<dt id="urllib.response.addinfourl">
<em class="property">class </em><code class="sig-prename descclassname">urllib.response.</code><code class="sig-name descname">addinfourl</code><a class="headerlink" href="#urllib.response.addinfourl" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><dl class="py attribute">
<dt id="urllib.response.addinfourl.url">
<code class="sig-name descname">url</code><a class="headerlink" href="#urllib.response.addinfourl.url" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>:URL del recurso obtenido, comúnmente usado para determinar si se ha seguido una redirección.</p>
</dd></dl>

<dl class="py attribute">
<dt id="urllib.response.addinfourl.headers">
<code class="sig-name descname">headers</code><a class="headerlink" href="#urllib.response.addinfourl.headers" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna las cabeceras de la respuesta en la forma de una instancia de <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="urllib.response.addinfourl.status">
<code class="sig-name descname">status</code><a class="headerlink" href="#urllib.response.addinfourl.status" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
<p>Código de estado  retornado por el servidor.</p>
</dd></dl>

<dl class="py method">
<dt id="urllib.response.addinfourl.geturl">
<code class="sig-name descname">geturl</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.response.addinfourl.geturl" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span>Obsoleto en favor de <a class="reference internal" href="#urllib.response.addinfourl.url" title="urllib.response.addinfourl.url"><code class="xref py py-attr docutils literal notranslate"><span class="pre">url</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="urllib.response.addinfourl.info">
<code class="sig-name descname">info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.response.addinfourl.info" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span>Obsoleto en favor de <a class="reference internal" href="#urllib.response.addinfourl.headers" title="urllib.response.addinfourl.headers"><code class="xref py py-attr docutils literal notranslate"><span class="pre">headers</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="urllib.response.addinfourl.code">
<code class="sig-name descname">code</code><a class="headerlink" href="#urllib.response.addinfourl.code" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span>Obsoleto en favor de <a class="reference internal" href="#urllib.response.addinfourl.status" title="urllib.response.addinfourl.status"><code class="xref py py-attr docutils literal notranslate"><span class="pre">status</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="urllib.response.addinfourl.getcode">
<code class="sig-name descname">getcode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#urllib.response.addinfourl.getcode" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span>Obsoleto en favor de <a class="reference internal" href="#urllib.response.addinfourl.status" title="urllib.response.addinfourl.status"><code class="xref py py-attr docutils literal notranslate"><span class="pre">status</span></code></a>.</p>
</div>
</dd></dl>

</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> — Biblioteca extensible para abrir URLs</a><ul>
<li><a class="reference internal" href="#request-objects">Objetos Request</a></li>
<li><a class="reference internal" href="#openerdirector-objects">Objetos OpenerDirector</a></li>
<li><a class="reference internal" href="#basehandler-objects">Objetos BaseHandler</a></li>
<li><a class="reference internal" href="#httpredirecthandler-objects">Objetos HTTPRedirectHandler</a></li>
<li><a class="reference internal" href="#httpcookieprocessor-objects">Objetos HTTPCookieProcessor</a></li>
<li><a class="reference internal" href="#proxyhandler-objects">Objetos ProxyHandler</a></li>
<li><a class="reference internal" href="#httppasswordmgr-objects">Objetos HTTPPasswordMgr</a></li>
<li><a class="reference internal" href="#httppasswordmgrwithpriorauth-objects">Objetos HTTPPasswordMgrWithPriorAuth</a></li>
<li><a class="reference internal" href="#abstractbasicauthhandler-objects">Objetos AbstractBasicAuthHandler</a></li>
<li><a class="reference internal" href="#httpbasicauthhandler-objects">Objetos HTTPBasicAuthHandler</a></li>
<li><a class="reference internal" href="#proxybasicauthhandler-objects">Objetos ProxyBasicAuthHandler</a></li>
<li><a class="reference internal" href="#abstractdigestauthhandler-objects">Objetos AbstractDigestAuthHandler</a></li>
<li><a class="reference internal" href="#httpdigestauthhandler-objects">Objetos HTTPDigestAuthHandler</a></li>
<li><a class="reference internal" href="#proxydigestauthhandler-objects">Objetos ProxyDigestAuthHandler</a></li>
<li><a class="reference internal" href="#httphandler-objects">Objetos HTTPHandler</a></li>
<li><a class="reference internal" href="#httpshandler-objects">Objetos HTTPSHandler</a></li>
<li><a class="reference internal" href="#filehandler-objects">Objetos FileHandler</a></li>
<li><a class="reference internal" href="#datahandler-objects">Objetos DataHandler</a></li>
<li><a class="reference internal" href="#ftphandler-objects">Objetos FTPHandler</a></li>
<li><a class="reference internal" href="#cacheftphandler-objects">Objetos CacheFTPHandler</a></li>
<li><a class="reference internal" href="#unknownhandler-objects">Objetos UnknownHandler</a></li>
<li><a class="reference internal" href="#httperrorprocessor-objects">Objetos HTTPErrorProcessor</a></li>
<li><a class="reference internal" href="#examples">Ejemplos</a></li>
<li><a class="reference internal" href="#legacy-interface">Interfaz heredada</a></li>
<li><a class="reference internal" href="#urllib-request-restrictions">Restricciones <code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-urllib.response"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.response</span></code> — Clases de respuesta usadas por urllib</a></li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="urllib.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code> — URL módulos de manipulación</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="urllib.parse.html"
                        title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.parse</span></code> — Analiza URL en componentes</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/urllib.request.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="urllib.parse.html" title="urllib.parse — Analiza URL en componentes"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="urllib.html" title="urllib — URL módulos de manipulación"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La Biblioteca Estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="internet.html" >Protocolos y soporte de Internet</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code> — Biblioteca extensible para abrir URLs</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 27, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>