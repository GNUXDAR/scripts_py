
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>ssl —Empaquetador o wrapper TLS/SSL para objetos de tipo socket &#8212; documentación de Python - 3.10.10</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.10.10"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="select — Esperando la finalización de E/S" href="select.html" />
    <link rel="prev" title="socket — interfaz de red de bajo nivel" href="socket.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/ssl.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code> —Empaquetador o wrapper TLS/SSL para objetos de tipo socket</a><ul>
<li><a class="reference internal" href="#functions-constants-and-exceptions">Funciones, constantes y excepciones</a><ul>
<li><a class="reference internal" href="#socket-creation">Creación de sockets</a></li>
<li><a class="reference internal" href="#context-creation">Creación de contexto</a></li>
<li><a class="reference internal" href="#exceptions">Excepciones</a></li>
<li><a class="reference internal" href="#random-generation">Generación aleatoria</a></li>
<li><a class="reference internal" href="#certificate-handling">Gestión de certificados</a></li>
<li><a class="reference internal" href="#constants">Constantes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ssl-sockets">Sockets SSL</a></li>
<li><a class="reference internal" href="#ssl-contexts">Contextos SSL</a></li>
<li><a class="reference internal" href="#certificates">Certificados</a><ul>
<li><a class="reference internal" href="#certificate-chains">Cadenas de certificados</a></li>
<li><a class="reference internal" href="#ca-certificates">Certificados CA</a></li>
<li><a class="reference internal" href="#combined-key-and-certificate">Clave y certificado combinados</a></li>
<li><a class="reference internal" href="#self-signed-certificates">Certificados auto-firmados</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Ejemplos</a><ul>
<li><a class="reference internal" href="#testing-for-ssl-support">Pruebas de compatibilidad con SSL</a></li>
<li><a class="reference internal" href="#client-side-operation">Operación del lado del cliente</a></li>
<li><a class="reference internal" href="#server-side-operation">Operación del lado del servidor</a></li>
</ul>
</li>
<li><a class="reference internal" href="#notes-on-non-blocking-sockets">Notas sobre los sockets no bloqueantes</a></li>
<li><a class="reference internal" href="#memory-bio-support">Soporte de memoria BIO</a></li>
<li><a class="reference internal" href="#ssl-session">Sesión SSL</a></li>
<li><a class="reference internal" href="#security-considerations">Consideraciones de seguridad</a><ul>
<li><a class="reference internal" href="#best-defaults">Los mejores valores por defecto</a></li>
<li><a class="reference internal" href="#manual-settings">Ajustes manuales</a><ul>
<li><a class="reference internal" href="#verifying-certificates">Verificación de certificados</a></li>
<li><a class="reference internal" href="#protocol-versions">Versiones del protocolo</a></li>
<li><a class="reference internal" href="#cipher-selection">Selección de cifrado</a></li>
</ul>
</li>
<li><a class="reference internal" href="#multi-processing">Multiprocesamiento</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tls-1-3">TLS 1.3</a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="socket.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code> — interfaz de red de bajo nivel</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="select.html"
                        title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">select</span></code> — Esperando la finalización de E/S</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/ssl.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="select.html" title="select — Esperando la finalización de E/S"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="socket.html" title="socket — interfaz de red de bajo nivel"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La Biblioteca Estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" accesskey="U">Comunicación en redes y entre procesos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code> —Empaquetador o wrapper TLS/SSL para objetos de tipo socket</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-ssl">
<span id="ssl-tls-ssl-wrapper-for-socket-objects"></span><h1><a class="reference internal" href="#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> —Empaquetador o wrapper TLS/SSL para objetos de tipo socket<a class="headerlink" href="#module-ssl" title="Enlazar permanentemente con este título">¶</a></h1>
<p><strong>Código fuente:</strong><a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/ssl.py">Lib/ssl.py</a></p>
<span class="target" id="index-0"></span><hr class="docutils" id="index-1" />
<p>Este módulo proporciona acceso a las funciones de cifrado de Seguridad de la capa de transporte (a menudo conocida como «Capa de sockets seguros») y de autenticación de pares para sockets de red, tanto del lado del cliente como del lado del servidor. Este módulo utiliza la biblioteca OpenSSL. Está disponible en todos los sistemas Unix modernos, Windows, Mac OS X y probablemente en plataformas adicionales, siempre que OpenSSL esté instalado en esa plataforma.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Algunos comportamientos pueden depender de la plataforma, ya que se realizan llamadas a las API de socket del sistema operativo. La versión instalada de OpenSSL también puede provocar variaciones en el comportamiento. Por ejemplo, TLSv1.3 con OpenSSL versión 1.1.1.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>No use este módulo sin leer <a class="reference internal" href="#ssl-security"><span class="std std-ref">Consideraciones de seguridad</span></a>. Hacerlo puede generar una falsa sensación de seguridad, ya que la configuración predeterminada del módulo ssl no es necesariamente la adecuada para su aplicación.</p>
</div>
<p>Esta sección documenta los objetos y funciones en el módulo <code class="docutils literal notranslate"><span class="pre">ssl</span></code>; para más información general sobre TLS,SSL, y certificados, se recomienda que el lector acuda a la sección «Ver también» al final de la página.</p>
<p>Este módulo proporciona una clase, <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a>, que se deriva del tipo <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a>, y proporciona una envoltura similar a un socket que también encripta y desencripta los datos que pasan por el socket con SSL . Admite métodos adicionales como <code class="xref py py-meth docutils literal notranslate"><span class="pre">getpeercert()</span></code>, que recupera el certificado del otro lado de la conexión, y <code class="xref py py-meth docutils literal notranslate"><span class="pre">cipher()</span></code>, que recupera el cifrado que se utiliza para la conexión segura.</p>
<p>Para aplicaciones más sofisticadas, la clase <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> ayuda a administrar la configuración y los certificados, que luego pueden ser heredados por sockets SSL creados a través del método <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5.3: </span>Actualizado para admitir la vinculación con OpenSSL 1.1.0</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>OpenSSL 0.9.8, 1.0.0 y 1.0.1 son obsoletos y no son compatibles. En el futuro, el módulo ssl requerirá al menos OpenSSL 1.0.2 o 1.1.0.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Se ha implementado <span class="target" id="index-44"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0644"><strong>PEP 644</strong></a>. El módulo ssl requiere OpenSSL 1.1.1 o versiones más recientes.</p>
<p>El uso de constantes y funciones obsoletas genera advertencias de obsolescencia.</p>
</div>
<section id="functions-constants-and-exceptions">
<h2>Funciones, constantes y excepciones<a class="headerlink" href="#functions-constants-and-exceptions" title="Enlazar permanentemente con este título">¶</a></h2>
<section id="socket-creation">
<h3>Creación de sockets<a class="headerlink" href="#socket-creation" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Desde Python 3.2 y 2.7.9, se recomienda utilizar <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a> de una instancia de <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> para envolver sockets como objetos <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a>. La función utilitaria <a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> retorna un nuevo contexto con ajustes por defecto seguros. La vieja función <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a> es obsoleta debido a que es ineficiente y que no tiene soporte para la indicación de nombre de servidor (SNI) ni hostname matching.</p>
<p>Ejemplo de socket cliente con contexto por defecto y doble pila IPv4/IPv6:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">ssl</span>

<span class="n">hostname</span> <span class="o">=</span> <span class="s1">&#39;www.python.org&#39;</span>
<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span>

<span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">create_connection</span><span class="p">((</span><span class="n">hostname</span><span class="p">,</span> <span class="mi">443</span><span class="p">))</span> <span class="k">as</span> <span class="n">sock</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">server_hostname</span><span class="o">=</span><span class="n">hostname</span><span class="p">)</span> <span class="k">as</span> <span class="n">ssock</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">ssock</span><span class="o">.</span><span class="n">version</span><span class="p">())</span>
</pre></div>
</div>
<p>Ejemplo de socket cliente con contexto personalizado y IPv4:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">hostname</span> <span class="o">=</span> <span class="s1">&#39;www.python.org&#39;</span>
<span class="c1"># PROTOCOL_TLS_CLIENT requires valid cert chain and hostname</span>
<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLS_CLIENT</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">load_verify_locations</span><span class="p">(</span><span class="s1">&#39;path/to/cabundle.pem&#39;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">as</span> <span class="n">sock</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">server_hostname</span><span class="o">=</span><span class="n">hostname</span><span class="p">)</span> <span class="k">as</span> <span class="n">ssock</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">ssock</span><span class="o">.</span><span class="n">version</span><span class="p">())</span>
</pre></div>
</div>
<p>Ejemplo de socket servidor escuchando en localhost IPv4:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLS_SERVER</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">load_cert_chain</span><span class="p">(</span><span class="s1">&#39;/path/to/certchain.pem&#39;</span><span class="p">,</span> <span class="s1">&#39;/path/to/private.key&#39;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">as</span> <span class="n">sock</span><span class="p">:</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">8443</span><span class="p">))</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">server_side</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">ssock</span><span class="p">:</span>
        <span class="n">conn</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">ssock</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
        <span class="o">...</span>
</pre></div>
</div>
</section>
<section id="context-creation">
<h3>Creación de contexto<a class="headerlink" href="#context-creation" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Una función conveniente ayuda a crear objetos <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> para propósitos comunes.</p>
<dl class="py function">
<dt id="ssl.create_default_context">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">create_default_context</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">purpose</span><span class="o">=</span><span class="default_value">Purpose.SERVER_AUTH</span></em>, <em class="sig-param"><span class="n">cafile</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">capath</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cadata</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.create_default_context" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un nuevo objeto <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> con ajustes por defecto para el <em>purpose</em> dado. Los ajustes son elegidos por el módulo <a class="reference internal" href="#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> y generalmente representan un nivel de seguridad mas alto que invocando directamente el constructor de <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a>.</p>
<p><em>cafile</em>, <em>capath</em>, <em>cadata</em> representan certificados CA opcionales para confiar en la verificación de certificados, como en <a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_verify_locations()</span></code></a>. Si los tres son <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> al mismo tiempo, esta función puede optar por confiar en su lugar en los certificados CA por defecto del sistema.</p>
<p>Las configuraciones son: <a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> o <a class="reference internal" href="#ssl.PROTOCOL_TLS_SERVER" title="ssl.PROTOCOL_TLS_SERVER"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_SERVER</span></code></a>, <a class="reference internal" href="#ssl.OP_NO_SSLv2" title="ssl.OP_NO_SSLv2"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv2</span></code></a> y <a class="reference internal" href="#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a> con conjuntos de cifrado de alto cifrado sin RC4 y sin conjuntos de cifrado no autenticados. Pasando <a class="reference internal" href="#ssl.Purpose.SERVER_AUTH" title="ssl.Purpose.SERVER_AUTH"><code class="xref py py-data docutils literal notranslate"><span class="pre">SERVER_AUTH</span></code></a> como <em>purpose</em> establece <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-data docutils literal notranslate"><span class="pre">verify_mode</span></code></a> a <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> y carga certificados CA (cuando al menos uno de los <em>cafile</em>, <em>capath</em>, o <em>cadata</em>) o usa <a class="reference internal" href="#ssl.SSLContext.load_default_certs" title="ssl.SSLContext.load_default_certs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_default_certs()</span></code></a> para cargar certificados de CA predeterminados.</p>
<p>Cuando <a class="reference internal" href="#ssl.SSLContext.keylog_filename" title="ssl.SSLContext.keylog_filename"><code class="xref py py-attr docutils literal notranslate"><span class="pre">keylog_filename</span></code></a> es soportado y la variable de entorno <span class="target" id="index-45"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">SSLKEYLOGFILE</span></code> está establecida, <a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> activa el registro de claves.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>El protocolo, las opciones, el cifrado y otros ajustes pueden cambiar a valores mas restrictivos en cualquier momento sin previa obsolescencia. Los valores representan un equilibrio justo entre compatibilidad y seguridad.</p>
<p>Si su aplicación necesita ajustes específicos, debe crear un <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> y aplicar los ajustes usted mismo.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si encuentra que cuando ciertos clientes o servidores antiguos intentan conectarse con un <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> creado con esta función obtienen un error indicando <em>Protocol or cipher suite mismatch</em>, puede ser que estos sólo soportan SSL3.0 el cual esta función excluye utilizando <a class="reference internal" href="#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a>. SSL3.0 está ampliamente considerado como <a class="reference external" href="https://en.wikipedia.org/wiki/POODLE">completamente roto</a>. Si todavía desea seguir utilizando esta función pero permitir conexiones SSL 3.0, puede volver a activarlas mediante:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">(</span><span class="n">Purpose</span><span class="o">.</span><span class="n">CLIENT_AUTH</span><span class="p">)</span>
<span class="n">ctx</span><span class="o">.</span><span class="n">options</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ssl</span><span class="o">.</span><span class="n">OP_NO_SSLv3</span>
</pre></div>
</div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4.4: </span>RC4 ha sido abandonado de la cadena de cifrado por defecto.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>ChaCha20/Poly1305 ha sido agregado a la cadena de caracteres de cifrado por defecto.</p>
<p>3DES ha sido abandonado de la cadena de caracteres de cifrado por defecto.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Soporte del registro de claves en <span class="target" id="index-46"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">SSLKEYLOGFILE</span></code> ha sido agregado.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>El contexto ahora usa el protocolo <a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> o <a class="reference internal" href="#ssl.PROTOCOL_TLS_SERVER" title="ssl.PROTOCOL_TLS_SERVER"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_SERVER</span></code></a> en lugar del <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> genérico.</p>
</div>
</dd></dl>

</section>
<section id="exceptions">
<h3>Excepciones<a class="headerlink" href="#exceptions" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py exception">
<dt id="ssl.SSLError">
<em class="property">exception </em><code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">SSLError</code><a class="headerlink" href="#ssl.SSLError" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Se lanza para señalar un error de la implementación de SSL subyacente (actualmente proporcionada por la biblioteca OpenSSL). Esto indica algún problema en la capa de cifrado y autenticación de alto nivel que se superpone a la conexión de red subyacente. Este error es un subtipo de <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>. El código de error y el mensaje de las instancias de <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> son proporcionados por la biblioteca OpenSSL.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span><a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> era un subtipo de <a class="reference internal" href="socket.html#socket.error" title="socket.error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">socket.error</span></code></a>.</p>
</div>
<dl class="py attribute">
<dt id="ssl.SSLError.library">
<code class="sig-name descname">library</code><a class="headerlink" href="#ssl.SSLError.library" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una cadena de caracteres mnemotécnica que designa el submódulo de OpenSSL en el que se ha producido el error, como <code class="docutils literal notranslate"><span class="pre">SSL</span></code>, <code class="docutils literal notranslate"><span class="pre">PEM</span></code> o <code class="docutils literal notranslate"><span class="pre">X509</span></code>. El rango de valores posibles depende de la versión de OpenSSL.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLError.reason">
<code class="sig-name descname">reason</code><a class="headerlink" href="#ssl.SSLError.reason" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una cadena de caracteres mnemotécnica que designa la razón por la que se produjo el error, por ejemplo <code class="docutils literal notranslate"><span class="pre">CERTIFICATE_VERIFY_FAILED</span></code>. El rango de valores posibles depende de la versión de OpenSSL.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt id="ssl.SSLZeroReturnError">
<em class="property">exception </em><code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">SSLZeroReturnError</code><a class="headerlink" href="#ssl.SSLZeroReturnError" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una subclase de <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> lanzada cuando se intenta leer o escribir y la conexión SSL ha sido cerrada limpiamente. Tenga en cuenta que esto no significa que el transporte subyacente (lectura TCP) haya sido cerrado.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py exception">
<dt id="ssl.SSLWantReadError">
<em class="property">exception </em><code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">SSLWantReadError</code><a class="headerlink" href="#ssl.SSLWantReadError" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una subclase de <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> lanzada por un <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">socket SSL no bloqueante</span></a> cuando se intenta leer o escribir datos, pero mas datos necesitan ser recibidos en el transporte TCP subyacente antes de que la solicitud pueda ser completada.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py exception">
<dt id="ssl.SSLWantWriteError">
<em class="property">exception </em><code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">SSLWantWriteError</code><a class="headerlink" href="#ssl.SSLWantWriteError" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una subclase de <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> lanzada por un <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">socket SSL no bloqueante</span></a> cuando se intenta leer o escribir datos, pero mas datos necesitan ser enviados en el transporte TCP subyacente antes de que la solicitud pueda ser completada.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py exception">
<dt id="ssl.SSLSyscallError">
<em class="property">exception </em><code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">SSLSyscallError</code><a class="headerlink" href="#ssl.SSLSyscallError" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una subclase de <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> lanzada cuando se encuentra un error del sistema mientras se intenta completar una operación en un socket SSL. Por desgracia, no hay una manera fácil de inspeccionar el número errno original.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py exception">
<dt id="ssl.SSLEOFError">
<em class="property">exception </em><code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">SSLEOFError</code><a class="headerlink" href="#ssl.SSLEOFError" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una subclase de <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> lanzada cuando la conexión SSL ha sido cancelada abruptamente. Generalmente, no debería intentar reutilizar el transporte subyacente cuando este error se produce.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py exception">
<dt id="ssl.SSLCertVerificationError">
<em class="property">exception </em><code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">SSLCertVerificationError</code><a class="headerlink" href="#ssl.SSLCertVerificationError" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una subclase de <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> lanzada cuando la validación del certificado ha fallado.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
<dl class="py attribute">
<dt id="ssl.SSLCertVerificationError.verify_code">
<code class="sig-name descname">verify_code</code><a class="headerlink" href="#ssl.SSLCertVerificationError.verify_code" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un número de error numérico que indica el error de verificación.</p>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLCertVerificationError.verify_message">
<code class="sig-name descname">verify_message</code><a class="headerlink" href="#ssl.SSLCertVerificationError.verify_message" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una cadena de caracteres legible del error de verificación.</p>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt id="ssl.CertificateError">
<em class="property">exception </em><code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">CertificateError</code><a class="headerlink" href="#ssl.CertificateError" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un alias para <a class="reference internal" href="#ssl.SSLCertVerificationError" title="ssl.SSLCertVerificationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLCertVerificationError</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>La excepción es ahora un alias para <a class="reference internal" href="#ssl.SSLCertVerificationError" title="ssl.SSLCertVerificationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLCertVerificationError</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="random-generation">
<h3>Generación aleatoria<a class="headerlink" href="#random-generation" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py function">
<dt id="ssl.RAND_bytes">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">RAND_bytes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_bytes" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <em>num</em> bytes pseudoaleatorios criptográficamente fuertes. Lanza un <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLError</span></code></a> si el PRNG no a sido sembrado con suficiente datos o si la operación no es soportada por el método RAND actual. <a class="reference internal" href="#ssl.RAND_status" title="ssl.RAND_status"><code class="xref py py-func docutils literal notranslate"><span class="pre">RAND_status()</span></code></a> puede ser usada para verificar el estado de PRNG y <a class="reference internal" href="#ssl.RAND_add" title="ssl.RAND_add"><code class="xref py py-func docutils literal notranslate"><span class="pre">RAND_add()</span></code></a> puede ser usada para sembrar el PRNG.</p>
<p>Para casi todas las aplicaciones <a class="reference internal" href="os.html#os.urandom" title="os.urandom"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.urandom()</span></code></a> es preferible.</p>
<p>Léase el artículo Wikipedia, <a class="reference external" href="https://es.wikipedia.org/wiki/Generador_de_n%C3%BAmeros_pseudoaleatorios_criptogr%C3%A1ficamente_seguro">Generador de números pseudoaleatorios criptográficamente seguro (CSPRNG)</a>, para obtener los requisitos para un generador criptográficamente seguro.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="ssl.RAND_pseudo_bytes">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">RAND_pseudo_bytes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_pseudo_bytes" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna (bytes, is_cryptographic): bytes es <em>num</em> bytes pseudoaleatorios, is_cryptographic es <code class="docutils literal notranslate"><span class="pre">True</span></code> si los bytes generados son criptográficamente fuertes. Lanza un <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLError</span></code></a> si la operación no es soportada por el método RAND actual.</p>
<p>Las secuencias de bytes pseudoaleatorios generadas serán únicas si tienen una longitud suficiente, pero no son necesariamente impredecibles. Pueden utilizarse para fines no criptográficos y para ciertos fines en protocolos criptográficos, pero normalmente no para la generación de claves, etc.</p>
<p>Para casi todas las aplicaciones <a class="reference internal" href="os.html#os.urandom" title="os.urandom"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.urandom()</span></code></a> es preferible.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.6: </span>OpenSSL a dejado obsoleta <a class="reference internal" href="#ssl.RAND_pseudo_bytes" title="ssl.RAND_pseudo_bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.RAND_pseudo_bytes()</span></code></a>, utilice <a class="reference internal" href="#ssl.RAND_bytes" title="ssl.RAND_bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.RAND_bytes()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="ssl.RAND_status">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">RAND_status</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_status" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si el generador de números pseudoaleatorios SSL a sido sembrado con “suficiente” aleatoriedad, y <code class="docutils literal notranslate"><span class="pre">False</span></code> de lo contrario. Puede utilizarse <code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.RAND_egd()</span></code> y <a class="reference internal" href="#ssl.RAND_add" title="ssl.RAND_add"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.RAND_add()</span></code></a> para aumentar la aleatoriedad del generador de números pseudoaleatorios.</p>
</dd></dl>

<dl class="py function">
<dt id="ssl.RAND_add">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">RAND_add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">bytes</span></em>, <em class="sig-param"><span class="n">entropy</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_add" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Mezcla los <em>bytes</em> dados en el generador de números pseudoaleatorios de SSL. El parámetro <em>entropy</em> (un flotante) es un límite inferior de la entropía contenida en la cadena de caracteres (por lo que siempre se puede utilizar <code class="xref py py-const docutils literal notranslate"><span class="pre">0.0</span></code>). Véase <span class="target" id="index-47"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1750.html"><strong>RFC 1750</strong></a> para mas información sobre las fuentes de entropía.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Ahora se acepta <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> modificable.</p>
</div>
</dd></dl>

</section>
<section id="certificate-handling">
<h3>Gestión de certificados<a class="headerlink" href="#certificate-handling" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py function">
<dt id="ssl.match_hostname">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">match_hostname</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cert</span></em>, <em class="sig-param"><span class="n">hostname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.match_hostname" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Verifica que <em>cert</em> (en formato decodificado tal y como es retornado por <a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.getpeercert()</span></code></a>) coincide con el <em>hostname</em> dado. Las reglas aplicadas son las de comprobación de la identidad de los servidores HTTPS, como se indica en <span class="target" id="index-48"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2818.html"><strong>RFC 2818</strong></a>, <span class="target" id="index-49"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5280.html"><strong>RFC 5280</strong></a> y <span class="target" id="index-50"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6125.html"><strong>RFC 6125</strong></a>. Además de HTTPS, esta función debería ser adecuada para comprobar la identidad de servidores en varios protocolos basados en SSL como FTPS, IMAPS, POPS y otros.</p>
<p><a class="reference internal" href="#ssl.CertificateError" title="ssl.CertificateError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CertificateError</span></code></a> es lanzado en caso de error. En caso de éxito, la función no retorna nada:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cert</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;subject&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s1">&#39;commonName&#39;</span><span class="p">,</span> <span class="s1">&#39;example.com&#39;</span><span class="p">),),)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">match_hostname</span><span class="p">(</span><span class="n">cert</span><span class="p">,</span> <span class="s2">&quot;example.com&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">match_hostname</span><span class="p">(</span><span class="n">cert</span><span class="p">,</span> <span class="s2">&quot;example.org&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;/home/py3k/Lib/ssl.py&quot;</span>, line <span class="m">130</span>, in <span class="n">match_hostname</span>
<span class="gr">ssl.CertificateError</span>: <span class="n">hostname &#39;example.org&#39; doesn&#39;t match &#39;example.com&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3.3: </span>La función ahora sigue <span class="target" id="index-51"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6125.html"><strong>RFC 6125</strong></a> sección 6.4.3 y no soporta múltiples caracteres comodín (por ejemplo <code class="docutils literal notranslate"><span class="pre">*.*.com</span></code> o <code class="docutils literal notranslate"><span class="pre">*a*.example.org</span></code>) ni tampoco un carácter comodín dentro de un fragmento de un nombre de dominio internacionalizado (IDN). Etiquetas A de IDN tales como <code class="docutils literal notranslate"><span class="pre">www*.xn--pthon-kva.org</span></code> son todavía soportadas, pero <code class="docutils literal notranslate"><span class="pre">x*.python.org</span></code> ya no corresponde con <code class="docutils literal notranslate"><span class="pre">xn--tda.python.org</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Ahora se admite la coincidencia de direcciones IP cuando están presentes en el campo subjectAltName del certificado.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>La función ya no se utiliza para las conexiones TLS. La coincidencia de hostname es ahora realizada por OpenSSL.</p>
<p>Se permite el carácter comodín cuando es el carácter más a la izquierda y el único en ese segmento. Ya no se admiten comodines parciales como <code class="docutils literal notranslate"><span class="pre">www*.example.com</span></code> .</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="ssl.cert_time_to_seconds">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">cert_time_to_seconds</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cert_time</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.cert_time_to_seconds" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el tiempo en segundos desde la Época, dada la cadena de caracteres <code class="docutils literal notranslate"><span class="pre">cert_time</span></code> que representa la fecha <em>notBefore</em> o <em>notAfter</em> de un certificado en formato strptime <code class="docutils literal notranslate"><span class="pre">&quot;%b</span> <span class="pre">%d</span> <span class="pre">%H:%M:%S</span> <span class="pre">%Y</span> <span class="pre">%Z&quot;</span></code> (C locale).</p>
<p>He aquí un ejemplo:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ssl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">cert_time_to_seconds</span><span class="p">(</span><span class="s2">&quot;Jan  5 09:34:43 2018 GMT&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timestamp</span>  
<span class="go">1515144883</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">utcfromtimestamp</span><span class="p">(</span><span class="n">timestamp</span><span class="p">))</span>  
<span class="go">2018-01-05 09:34:43</span>
</pre></div>
</div>
<p>Las fechas <em>notBefore</em> o <em>notAfter</em> deben utilizar GMT (<span class="target" id="index-52"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5280.html"><strong>RFC 5280</strong></a>).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Interpreta la hora de entrada como una hora en UTC según lo especificado por la zona horaria “GMT” en la cadena de caracteres de entrada. Anteriormente se utilizaba la zona horaria local. Devuelve un número entero (sin fracciones de segundo en el formato de entrada)</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="ssl.get_server_certificate">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">get_server_certificate</code><span class="sig-paren">(</span><em class="sig-param">addr</em>, <em class="sig-param">ssl_version=PROTOCOL_TLS_CLIENT</em>, <em class="sig-param">ca_certs=None</em><span class="optional">[</span>, <em class="sig-param">timeout</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.get_server_certificate" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Dada la dirección <code class="docutils literal notranslate"><span class="pre">addr</span></code> de un servidor protegido con SSL, como un par (<em>hostname</em>, <em>port-number</em>), obtiene el certificado del servidor, y lo retorna como una cadena de caracteres codificada en PEM. Si se especifica <code class="docutils literal notranslate"><span class="pre">ssl_version</span></code>, utiliza esta versión del protocolo SSL para intentar conectarse al servidor. Si se especifica <code class="docutils literal notranslate"><span class="pre">ca_certs</span></code>, debe ser un archivo que contenga una lista de certificados raíz, con el mismo formato que se utiliza para el mismo parámetro en <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a>. La llamada intentará validar el certificado del servidor contra ese conjunto de certificados raíz, y fallará si el intento de validación falla.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Esta función es ahora compatible IPv6.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>La <em>ssl_version</em> por defecto se cambia de <a class="reference internal" href="#ssl.PROTOCOL_SSLv3" title="ssl.PROTOCOL_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_SSLv3</span></code></a> a <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> para una máxima compatibilidad con los servidores modernos.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Se agregó el argumento <em>session</em>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="ssl.DER_cert_to_PEM_cert">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">DER_cert_to_PEM_cert</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">DER_cert_bytes</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.DER_cert_to_PEM_cert" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Dado un certificado como blob de bytes codificado en DER, devuelve una versión de cadena de caracteres codificada en PEM del mismo certificado.</p>
</dd></dl>

<dl class="py function">
<dt id="ssl.PEM_cert_to_DER_cert">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">PEM_cert_to_DER_cert</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">PEM_cert_string</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.PEM_cert_to_DER_cert" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Dado un certificado como cadena de caracteres ASCII PEM, devuelve una secuencia de bytes codificada con DER para ese mismo certificado.</p>
</dd></dl>

<dl class="py function">
<dt id="ssl.get_default_verify_paths">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">get_default_verify_paths</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.get_default_verify_paths" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una tupla con nombre con las rutas por defecto de cafile y capath de OpenSSL. Las rutas son las mismas que las usadas por <a class="reference internal" href="#ssl.SSLContext.set_default_verify_paths" title="ssl.SSLContext.set_default_verify_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_default_verify_paths()</span></code></a>. El valor de retorno es una <a class="reference internal" href="../glossary.html#term-named-tuple"><span class="xref std std-term">named tuple</span></a> <code class="docutils literal notranslate"><span class="pre">DefaultVerifyPaths</span></code>:</p>
<ul class="simple">
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">cafile</span></code> - ruta resuelta a cafile o <code class="docutils literal notranslate"><span class="pre">None</span></code> si el archivo no existe,</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">capath</span></code> - ruta resuelta a capath o <code class="docutils literal notranslate"><span class="pre">None</span></code> si el directorio no existe,</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">openssl_cafile_env</span></code> - clave de entorno de OpenSSL que apunta a un cafile,</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">openssl_cafile</span></code> - camino codificado de forma rígida a un cafile,</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">openssl_capath_env</span></code> - clave de entorno de OpenSSL que apunta a un capath,</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">openssl_capath</span></code> - camino codificado de forma rígida a un directorio capath</p></li>
</ul>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Disponibilidad</span></a>: LibreSSL ignora las variables de entorno <code class="xref py py-attr docutils literal notranslate"><span class="pre">openssl_cafile_env</span></code> y <code class="xref py py-attr docutils literal notranslate"><span class="pre">openssl_capath_env</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="ssl.enum_certificates">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">enum_certificates</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">store_name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.enum_certificates" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Recupera los certificados del almacén de certificados del sistema de Windows. <em>store_name</em> puede ser uno de los siguientes: <code class="docutils literal notranslate"><span class="pre">CA</span></code>, <code class="docutils literal notranslate"><span class="pre">ROOT</span></code> o <code class="docutils literal notranslate"><span class="pre">MY</span></code>. Windows también puede proporcionar almacenes de certificados adicionales.</p>
<p>La función devuelve una lista de tuplas (cert_bytes, encoding_type, trust). El encoding_type especifica la codificación de cert_bytes. Es <code class="xref py py-const docutils literal notranslate"><span class="pre">x509_asn</span></code> para datos X.509 ASN.1 o <code class="xref py py-const docutils literal notranslate"><span class="pre">pkcs_7_asn</span></code> para datos PKCS#7 ASN.1. Trust especifica el propósito del certificado como un conjunto de OIDS o exactamente <code class="docutils literal notranslate"><span class="pre">True</span></code> si el certificado es de confianza para todos los propósitos.</p>
<p>Ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">enum_certificates</span><span class="p">(</span><span class="s2">&quot;CA&quot;</span><span class="p">)</span>
<span class="go">[(b&#39;data...&#39;, &#39;x509_asn&#39;, {&#39;1.3.6.1.5.5.7.3.1&#39;, &#39;1.3.6.1.5.5.7.3.2&#39;}),</span>
<span class="go"> (b&#39;data...&#39;, &#39;x509_asn&#39;, True)]</span>
</pre></div>
</div>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Disponibilidad</span></a>: Windows.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="ssl.enum_crls">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">enum_crls</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">store_name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.enum_crls" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Obtiene CRLs del almacén de certificados del sistema de Windows. <em>store_name</em> puede ser uno de los siguientes: <code class="docutils literal notranslate"><span class="pre">CA</span></code>, <code class="docutils literal notranslate"><span class="pre">ROOT</span></code> o <code class="docutils literal notranslate"><span class="pre">MY</span></code>. Windows también puede proporcionar almacenes de certificados adicionales.</p>
<p>La función devuelve una lista de tuplas (cert_bytes, encoding_type, trust). El encoding_type especifica la codificación de cert_bytes. Es <code class="xref py py-const docutils literal notranslate"><span class="pre">x509_asn</span></code> para datos X.509 ASN.1 o <code class="xref py py-const docutils literal notranslate"><span class="pre">pkcs_7_asn</span></code> para datos PKCS#7 ASN.1.</p>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Disponibilidad</span></a>: Windows.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="ssl.wrap_socket">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">wrap_socket</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sock</span></em>, <em class="sig-param"><span class="n">keyfile</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">certfile</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">server_side</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">cert_reqs</span><span class="o">=</span><span class="default_value">CERT_NONE</span></em>, <em class="sig-param"><span class="n">ssl_version</span><span class="o">=</span><span class="default_value">PROTOCOL_TLS</span></em>, <em class="sig-param"><span class="n">ca_certs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">do_handshake_on_connect</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">suppress_ragged_eofs</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">ciphers</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.wrap_socket" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Toma una instancia <code class="docutils literal notranslate"><span class="pre">sock</span></code> de <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a>, y devuelve una instancia de <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a>, un subtipo de <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a>, que envuelve el socket de base en un contexto SSL. <code class="docutils literal notranslate"><span class="pre">sock</span></code> debe ser un socket <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>; otros tipos de socket no son compatibles.</p>
<p>Internamente, la función crea un <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> con un protocolo <em>ssl_version</em> y <a class="reference internal" href="#ssl.SSLContext.options" title="ssl.SSLContext.options"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.options</span></code></a> establecido a <em>cert_reqs</em>. Si los parámetros <em>keyfile</em>, <em>certfile</em>, <em>ca_certs</em> o <em>ciphers</em> son establecidos, entonces los valores son pasados a <a class="reference internal" href="#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_cert_chain()</span></code></a>, <a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_verify_locations()</span></code></a>, y <a class="reference internal" href="#ssl.SSLContext.set_ciphers" title="ssl.SSLContext.set_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_ciphers()</span></code></a>.</p>
<p>Los argumentos <em>server_side</em>, <em>do_handshake_on_connect</em>, y <em>supress_ragged_eofs</em> tienen el mismo significado que <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.7: </span>Desde Python 3.2 y 2.7.9, se recomienda usar <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a> en lugar de <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>. La función de alto nivel tiene limitaciones y crea un socket cliente no seguro sin indicación de nombre de servidor ni hostname matching.</p>
</div>
</dd></dl>

</section>
<section id="constants">
<h3>Constantes<a class="headerlink" href="#constants" title="Enlazar permanentemente con este título">¶</a></h3>
<blockquote>
<div><p>Todas las constantes son ahora colecciones <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a> o <a class="reference internal" href="enum.html#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.</span></p>
</div>
</div></blockquote>
<dl class="py data">
<dt id="ssl.CERT_NONE">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">CERT_NONE</code><a class="headerlink" href="#ssl.CERT_NONE" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Valor posible para <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_mode</span></code></a>, o el parámetro <code class="docutils literal notranslate"><span class="pre">cert_reqs</span></code> de <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>. A excepción de <a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a>, es el modo por defecto. Con sockets del lado del cliente, se acepta casi cualquier certificado. Errores de validación, como certificado no confiable o caducado, son ignorados y no abortan el handshake TLS/SSL.</p>
<p>En modo servidor, no se solicita ningún certificado al cliente, por lo que el cliente no envía ninguno para la autenticación del certificado del cliente.</p>
<p>Vea la discusión sobre <a class="reference internal" href="#ssl-security"><span class="std std-ref">Consideraciones de seguridad</span></a> más abajo.</p>
</dd></dl>

<dl class="py data">
<dt id="ssl.CERT_OPTIONAL">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">CERT_OPTIONAL</code><a class="headerlink" href="#ssl.CERT_OPTIONAL" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Valor posible para <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_mode</span></code></a>, o el parámetro <code class="docutils literal notranslate"><span class="pre">cert_reqs</span></code> de <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>. En modo cliente, <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_OPTIONAL</span></code></a> tiene el mismo significado que <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>. Se recomienda usar en su lugar <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> para sockets del lado del cliente.</p>
<p>En el modo servidor, se envía una solicitud de certificado de cliente al cliente. El cliente puede ignorar la solicitud o enviar un certificado para realizar la autenticación de certificado de cliente TLS. Si el cliente opta por enviar un certificado, éste se verifica. Cualquier error de verificación aborta inmediatamente el handshake TLS.</p>
<p>El uso de esta configuración requiere que se pase un conjunto válido de certificados de CA, ya sea a <a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_verify_locations()</span></code></a> o como valor del parámetro <code class="docutils literal notranslate"><span class="pre">ca_certs</span></code> de <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>.</p>
</dd></dl>

<dl class="py data">
<dt id="ssl.CERT_REQUIRED">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">CERT_REQUIRED</code><a class="headerlink" href="#ssl.CERT_REQUIRED" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Valor posible para <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_mode</span></code></a>, o el parámetro <code class="docutils literal notranslate"><span class="pre">cert_reqs</span></code> de <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>. En este modo, se requieren certificados del otro lado de la conexión del socket; se lanzará un <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLError</span></code></a> si no se proporciona ningún certificado, o si su validación falla. Este modo <strong>no</strong> es suficiente para verificar un certificado en modo cliente, ya que no coincide con los hostnames. <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a> debe estar activado también para verificar la autenticidad de un certificado. <a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> utiliza <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> y activa <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a> por defecto.</p>
<p>Con socket servidor, este modo proporciona una autenticación obligatoria de certificado de cliente TLS. Se envía una solicitud de certificado de cliente al cliente y el cliente debe proporcionar un certificado válido y de confianza.</p>
<p>El uso de esta configuración requiere que se pase un conjunto válido de certificados de CA, ya sea a <a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_verify_locations()</span></code></a> o como valor del parámetro <code class="docutils literal notranslate"><span class="pre">ca_certs</span></code> de <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt id="ssl.VerifyMode">
<em class="property">class </em><code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">VerifyMode</code><a class="headerlink" href="#ssl.VerifyMode" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Colección <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a> de constantes CERT_*.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.VERIFY_DEFAULT">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">VERIFY_DEFAULT</code><a class="headerlink" href="#ssl.VERIFY_DEFAULT" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Valor posible para <a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a>. En este modo, las listas de revocación de certificado (CRLs) no son verificadas. Por defecto OpenSSL no requiere ni verifica CRLs.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.VERIFY_CRL_CHECK_LEAF">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">VERIFY_CRL_CHECK_LEAF</code><a class="headerlink" href="#ssl.VERIFY_CRL_CHECK_LEAF" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Valor posible para <a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a>. En este modo, sólo el certificado de pares es verificado pero ninguno de los certificados CA intermedios. El modo requiere una CRL válida que esté firmada por el emisor del certificado de pares (su CA antecesora directa). Si no se ha cargado una CRL adecuada con <a class="reference internal" href="#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.load_verify_locations</span></code></a>, la validación fallará.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.VERIFY_CRL_CHECK_CHAIN">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">VERIFY_CRL_CHECK_CHAIN</code><a class="headerlink" href="#ssl.VERIFY_CRL_CHECK_CHAIN" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Valor posible para <a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a>. En este modo, las CRLs de todos los certificados en la cadena de certificado de pares son verificadas.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.VERIFY_X509_STRICT">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">VERIFY_X509_STRICT</code><a class="headerlink" href="#ssl.VERIFY_X509_STRICT" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Valor posible para <a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a> para desactivar soluciones alternativas para certificados X.509 rotos.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.VERIFY_ALLOW_PROXY_CERTS">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">VERIFY_ALLOW_PROXY_CERTS</code><a class="headerlink" href="#ssl.VERIFY_ALLOW_PROXY_CERTS" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Valor posible para <a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a> para desactivar soluciones alternativas para certificados X.509 rotos.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.VERIFY_X509_TRUSTED_FIRST">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">VERIFY_X509_TRUSTED_FIRST</code><a class="headerlink" href="#ssl.VERIFY_X509_TRUSTED_FIRST" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Valor posible para <a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a>. Indica a OpenSSL de preferir certificados de confianza al construir la cadena de confianza para validar un certificado. Esta opción está activada por defecto.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.4.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.VERIFY_X509_PARTIAL_CHAIN">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">VERIFY_X509_PARTIAL_CHAIN</code><a class="headerlink" href="#ssl.VERIFY_X509_PARTIAL_CHAIN" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Valor posible para <a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a>. Indica a OpenSSL que acepte CA intermedias en el almacén de confianza para que se traten como anclajes de confianza, de la misma manera que los certificados de CA raíz autofirmados. Esto hace posible confiar en los certificados emitidos por una CA intermedia sin tener que confiar en su CA raíz antecesora.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt id="ssl.VerifyFlags">
<em class="property">class </em><code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">VerifyFlags</code><a class="headerlink" href="#ssl.VerifyFlags" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Colección <a class="reference internal" href="enum.html#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a> de constantes VERIFY_*.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.PROTOCOL_TLS">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">PROTOCOL_TLS</code><a class="headerlink" href="#ssl.PROTOCOL_TLS" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Selecciona la versión mas alta del protocolo soportada tanto por el cliente como por el servidor. A pesar de su nombre, esta opción puede seleccionar ambos protocolos «SSL» y «TLS».</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.10: </span>Los clientes y servidores TLS requieren diferentes configuraciones predeterminadas para una comunicación segura. La constante del protocolo TLS genérico está en desuso en favor de <a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> y <a class="reference internal" href="#ssl.PROTOCOL_TLS_SERVER" title="ssl.PROTOCOL_TLS_SERVER"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_SERVER</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.PROTOCOL_TLS_CLIENT">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">PROTOCOL_TLS_CLIENT</code><a class="headerlink" href="#ssl.PROTOCOL_TLS_CLIENT" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Negocie automáticamente la versión de protocolo más alta que admiten tanto el cliente como el servidor, y configure las conexiones del lado del cliente de contexto. El protocolo habilita <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> y <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a> de forma predeterminada.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.PROTOCOL_TLS_SERVER">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">PROTOCOL_TLS_SERVER</code><a class="headerlink" href="#ssl.PROTOCOL_TLS_SERVER" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Selecciona la versión mas alta del protocolo soportada tanto por el cliente como por el servidor. A pesar de su nombre, esta opción puede seleccionar ambos protocolos «SSL» y «TLS».</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.PROTOCOL_SSLv23">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">PROTOCOL_SSLv23</code><a class="headerlink" href="#ssl.PROTOCOL_SSLv23" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Alias para <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.6: </span>Utilice en su lugar <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.PROTOCOL_SSLv2">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">PROTOCOL_SSLv2</code><a class="headerlink" href="#ssl.PROTOCOL_SSLv2" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Selecciona la versión 2 de SSL como protocolo de cifrado del canal.</p>
<p>This protocol is not available if OpenSSL is compiled with the
<code class="docutils literal notranslate"><span class="pre">no-ssl2</span></code> option.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>La versión 2 de SSL es insegura. Su uso es muy desaconsejado.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.6: </span>OpenSSL a eliminado el soporte para SSLv2.</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.PROTOCOL_SSLv3">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">PROTOCOL_SSLv3</code><a class="headerlink" href="#ssl.PROTOCOL_SSLv3" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Selecciona la versión 3 de SSL como protocolo de cifrado del canal.</p>
<p>This protocol is not available if OpenSSL is compiled with the
<code class="docutils literal notranslate"><span class="pre">no-ssl3</span></code> option.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p>La versión 3 de SSL es insegura. Su uso es muy desaconsejado.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.6: </span>OpenSSL ha descontinuado todos los protocolos específicos de la versión. Utilice el protocolo predeterminado <a class="reference internal" href="#ssl.PROTOCOL_TLS_SERVER" title="ssl.PROTOCOL_TLS_SERVER"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_SERVER</span></code></a> o <a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> con <a class="reference internal" href="#ssl.SSLContext.minimum_version" title="ssl.SSLContext.minimum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.minimum_version</span></code></a> y <a class="reference internal" href="#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.maximum_version</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.PROTOCOL_TLSv1">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">PROTOCOL_TLSv1</code><a class="headerlink" href="#ssl.PROTOCOL_TLSv1" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Selecciona la versión 1.0 de TLS como protocolo de cifrado del canal.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.6: </span>OpenSSL ha descontinuado todos los protocolos específicos de la versión.</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.PROTOCOL_TLSv1_1">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">PROTOCOL_TLSv1_1</code><a class="headerlink" href="#ssl.PROTOCOL_TLSv1_1" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Selecciona la versión 1.1 de TLS como protocolo de cifrado del canal. Disponible sólo con openssl en versión 1.0.1+.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.6: </span>OpenSSL ha descontinuado todos los protocolos específicos de la versión.</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.PROTOCOL_TLSv1_2">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">PROTOCOL_TLSv1_2</code><a class="headerlink" href="#ssl.PROTOCOL_TLSv1_2" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Selecciona la versión 1.1 de TLS como protocolo de cifrado del canal. Disponible sólo con openssl en versión 1.0.1+.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.6: </span>OpenSSL ha descontinuado todos los protocolos específicos de la versión.</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.OP_ALL">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">OP_ALL</code><a class="headerlink" href="#ssl.OP_ALL" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Activa soluciones alternativas para varios errores presentes en otras implementaciones SSL. Esta opción esta activada por defecto. No necesariamente activa las mismas opciones como la constante <code class="docutils literal notranslate"><span class="pre">SSL_OP_ALL</span></code> de OpenSSL.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.OP_NO_SSLv2">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">OP_NO_SSLv2</code><a class="headerlink" href="#ssl.OP_NO_SSLv2" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Evita una conexión SSLv2. Esta opción sólo es aplicable junto con <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>. Evita que los pares elijan SSLv2 como versión del protocolo.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.6: </span>SSLv2 es obsoleto</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.OP_NO_SSLv3">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">OP_NO_SSLv3</code><a class="headerlink" href="#ssl.OP_NO_SSLv3" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Evita una conexión SSLv3. Esta opción sólo es aplicable junto con <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>. Evita que los pares elijan SSLv3 como versión del protocolo.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.6: </span>SSLv3 es obsoleto</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.OP_NO_TLSv1">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">OP_NO_TLSv1</code><a class="headerlink" href="#ssl.OP_NO_TLSv1" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Evita una conexión TLSv1. Esta opción sólo es aplicable junto con <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>. Evita que los pares elijan TLSv1 como versión del protocolo.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.7: </span>Esta opción es obsoleta desde OpenSSL 1.1.0, utilice en su lugar los nuevos <a class="reference internal" href="#ssl.SSLContext.minimum_version" title="ssl.SSLContext.minimum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.minimum_version</span></code></a> y <a class="reference internal" href="#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.maximum_version</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.OP_NO_TLSv1_1">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">OP_NO_TLSv1_1</code><a class="headerlink" href="#ssl.OP_NO_TLSv1_1" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Evita una conexión TLSv1.1. Esta opción sólo es aplicable junto con <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>. Evita que los pares elijan TLSv1.1 como versión del protocolo. Disponible sólo con openssl en versión 1.0.1+.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.7: </span>Esta opción es obsoleta desde OpenSSL 1.1.0.</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.OP_NO_TLSv1_2">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">OP_NO_TLSv1_2</code><a class="headerlink" href="#ssl.OP_NO_TLSv1_2" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Evita una conexión TLSv1.2. Esta opción sólo es aplicable junto con <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>. Evita que los pares elijan TLSv1.2 como versión del protocolo. Disponible sólo con openssl en versión 1.0.1+.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.7: </span>Esta opción es obsoleta desde OpenSSL 1.1.0.</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.OP_NO_TLSv1_3">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">OP_NO_TLSv1_3</code><a class="headerlink" href="#ssl.OP_NO_TLSv1_3" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Evita una conexión TLSv1.3. Esta opción sólo es aplicable junto con <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>. Evita que los pares elijan TLSv1.3 como versión del protocolo. TLS 1.3 está disponible con OpenSSL 1.1.1 o superior. Cuando Python es compilado contra una versión mas antigua de OpenSSL, la opción vale <em>0</em> por defecto.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.7: </span>Esta opción es obsoleta desde OpenSSL 1.1.0. Ha sido agregada a 2.7.15, 3.6.3 y 3.7.0 por retro-compatibilidad con OpenSSL 1.0.2.</p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.OP_NO_RENEGOTIATION">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">OP_NO_RENEGOTIATION</code><a class="headerlink" href="#ssl.OP_NO_RENEGOTIATION" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Desactiva toda re-negociación en TLSv1.2 y anteriores. No envía mensajes HelloRequest e ignora solicitudes de re-negociación vía ClientHello.</p>
<p>Esta opción sólo está disponible con OpenSSL 1.1.0h y posteriores.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.OP_CIPHER_SERVER_PREFERENCE">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">OP_CIPHER_SERVER_PREFERENCE</code><a class="headerlink" href="#ssl.OP_CIPHER_SERVER_PREFERENCE" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Utiliza la preferencia de ordenación de cifrado del servidor, en lugar de la del cliente. Esta opción no tiene efecto en los sockets del cliente ni en los sockets del servidor SSLv2.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.OP_SINGLE_DH_USE">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">OP_SINGLE_DH_USE</code><a class="headerlink" href="#ssl.OP_SINGLE_DH_USE" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Evita la reutilización de la misma clave DH para distintas sesiones SSL. Esto mejora el secreto hacia adelante pero requiere más recursos computacionales. Esta opción sólo se aplica a los sockets del servidor.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.OP_SINGLE_ECDH_USE">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">OP_SINGLE_ECDH_USE</code><a class="headerlink" href="#ssl.OP_SINGLE_ECDH_USE" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Evita la reutilización de la misma clave ECDH para distintas sesiones SSL. Esto mejora el secreto hacia adelante pero requiere más recursos computacionales. Esta opción sólo se aplica a los sockets del servidor.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.OP_ENABLE_MIDDLEBOX_COMPAT">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">OP_ENABLE_MIDDLEBOX_COMPAT</code><a class="headerlink" href="#ssl.OP_ENABLE_MIDDLEBOX_COMPAT" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Enviar mensajes Change Cipher Spec (CCS) ficticios en el handshake de TLS 1.3 para que una conexión TLS 1.3 se parezca más a una conexión TLS 1.2.</p>
<p>Esta opción sólo está disponible con OpenSSL 1.1.1 y posteriores.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.OP_NO_COMPRESSION">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">OP_NO_COMPRESSION</code><a class="headerlink" href="#ssl.OP_NO_COMPRESSION" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Desactivar la compresión en el canal SSL. Esto es útil si el protocolo de la aplicación soporta su propio esquema de compresión.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt id="ssl.Options">
<em class="property">class </em><code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">Options</code><a class="headerlink" href="#ssl.Options" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Colección <a class="reference internal" href="enum.html#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a> de constantes OP_*.</p>
</dd></dl>

<dl class="py data">
<dt id="ssl.OP_NO_TICKET">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">OP_NO_TICKET</code><a class="headerlink" href="#ssl.OP_NO_TICKET" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Evita que el lado del cliente solicite un ticket de sesión.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.OP_IGNORE_UNEXPECTED_EOF">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">OP_IGNORE_UNEXPECTED_EOF</code><a class="headerlink" href="#ssl.OP_IGNORE_UNEXPECTED_EOF" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Ignore el cierre inesperado de las conexiones TLS.</p>
<p>Esta opción sólo está disponible con OpenSSL 1.0.0 y posteriores.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.HAS_ALPN">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">HAS_ALPN</code><a class="headerlink" href="#ssl.HAS_ALPN" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si la biblioteca OpenSSL tiene soporte incorporado para la extensión TLS <em>Application-Layer Protocol Negotiation</em> como se describe en <span class="target" id="index-53"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7301.html"><strong>RFC 7301</strong></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.HAS_NEVER_CHECK_COMMON_NAME">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">HAS_NEVER_CHECK_COMMON_NAME</code><a class="headerlink" href="#ssl.HAS_NEVER_CHECK_COMMON_NAME" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si la biblioteca OpenSSL tiene soporte incorporado para no comprobar el nombre común del sujeto y <a class="reference internal" href="#ssl.SSLContext.hostname_checks_common_name" title="ssl.SSLContext.hostname_checks_common_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.hostname_checks_common_name</span></code></a> es modificable.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.HAS_ECDH">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">HAS_ECDH</code><a class="headerlink" href="#ssl.HAS_ECDH" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si la biblioteca OpenSSL tiene soporte incorporado para el intercambio de claves Diffie-Hellman basado en Elliptic Curve. Esto debería ser cierto a menos que la función haya sido desactivada explícitamente por el distribuidor.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.HAS_SNI">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">HAS_SNI</code><a class="headerlink" href="#ssl.HAS_SNI" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si la biblioteca OpenSSL tiene soporte incorporado para la extensión <em>Server Name Indication</em> (como se define en <span class="target" id="index-54"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6066.html"><strong>RFC 6066</strong></a>).</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.HAS_NPN">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">HAS_NPN</code><a class="headerlink" href="#ssl.HAS_NPN" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si la biblioteca OpenSSL tiene soporte incorporado para <em>Next Protocol Negotiation</em> como se describe en <a class="reference external" href="https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation">Application Layer Protocol Negotiation</a>. Cuando es verdadero, puede utilizar el método <a class="reference internal" href="#ssl.SSLContext.set_npn_protocols" title="ssl.SSLContext.set_npn_protocols"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_npn_protocols()</span></code></a> para anunciar los protocolos que desea soportar.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.HAS_SSLv2">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">HAS_SSLv2</code><a class="headerlink" href="#ssl.HAS_SSLv2" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si la biblioteca OpenSSL tiene soporte incorporado para el protocolo SSL 2.0.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.HAS_SSLv3">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">HAS_SSLv3</code><a class="headerlink" href="#ssl.HAS_SSLv3" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si la biblioteca OpenSSL tiene soporte incorporado para el protocolo SSL 3.0.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.HAS_TLSv1">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">HAS_TLSv1</code><a class="headerlink" href="#ssl.HAS_TLSv1" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si la biblioteca OpenSSL tiene soporte incorporado para el protocolo TLS 1.0.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.HAS_TLSv1_1">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">HAS_TLSv1_1</code><a class="headerlink" href="#ssl.HAS_TLSv1_1" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si la biblioteca OpenSSL tiene soporte incorporado para el protocolo TLS 1.1.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.HAS_TLSv1_2">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">HAS_TLSv1_2</code><a class="headerlink" href="#ssl.HAS_TLSv1_2" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si la biblioteca OpenSSL tiene soporte incorporado para el protocolo TLS 1.2.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.HAS_TLSv1_3">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">HAS_TLSv1_3</code><a class="headerlink" href="#ssl.HAS_TLSv1_3" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si la biblioteca OpenSSL tiene soporte incorporado para el protocolo TLS 1.3.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.CHANNEL_BINDING_TYPES">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">CHANNEL_BINDING_TYPES</code><a class="headerlink" href="#ssl.CHANNEL_BINDING_TYPES" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Lista de tipos de enlace de canales TLS admitidos. Las cadenas de caracteres en esta lista pueden ser usadas como argumentos para <a class="reference internal" href="#ssl.SSLSocket.get_channel_binding" title="ssl.SSLSocket.get_channel_binding"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.get_channel_binding()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.OPENSSL_VERSION">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">OPENSSL_VERSION</code><a class="headerlink" href="#ssl.OPENSSL_VERSION" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La cadena de versión de la biblioteca OpenSSL cargada por el intérprete:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION</span>
<span class="go">&#39;OpenSSL 1.0.2k  26 Jan 2017&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.OPENSSL_VERSION_INFO">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">OPENSSL_VERSION_INFO</code><a class="headerlink" href="#ssl.OPENSSL_VERSION_INFO" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una tupla de cinco números enteros representando la información de versión de la biblioteca OpenSSL:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_INFO</span>
<span class="go">(1, 0, 2, 11, 15)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.OPENSSL_VERSION_NUMBER">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">OPENSSL_VERSION_NUMBER</code><a class="headerlink" href="#ssl.OPENSSL_VERSION_NUMBER" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El número de versión en bruto de la biblioteca OpenSSL, como un único número entero:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_NUMBER</span>
<span class="go">268443839</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hex</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">OPENSSL_VERSION_NUMBER</span><span class="p">)</span>
<span class="go">&#39;0x100020bf&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">ALERT_DESCRIPTION_HANDSHAKE_FAILURE</code><a class="headerlink" href="#ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt id="ssl.ALERT_DESCRIPTION_INTERNAL_ERROR">
<code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">ALERT_DESCRIPTION_INTERNAL_ERROR</code><a class="headerlink" href="#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt>
<code class="sig-name descname">ALERT_DESCRIPTION_*</code></dt>
<dd><p>Descripciones de alertas de <span class="target" id="index-55"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5246.html"><strong>RFC 5246</strong></a> y otras. El <a class="reference external" href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-6">IANA TLS Alert Registry</a> contiene esta lista y las referencias a las RFC donde se define su significado.</p>
<p>Se utiliza como valor de retorno de la función callback en <a class="reference internal" href="#ssl.SSLContext.set_servername_callback" title="ssl.SSLContext.set_servername_callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_servername_callback()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt id="ssl.AlertDescription">
<em class="property">class </em><code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">AlertDescription</code><a class="headerlink" href="#ssl.AlertDescription" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Colección <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a> de constantes ALERT_DESCRIPTION_*.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.Purpose.SERVER_AUTH">
<code class="sig-prename descclassname">Purpose.</code><code class="sig-name descname">SERVER_AUTH</code><a class="headerlink" href="#ssl.Purpose.SERVER_AUTH" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Opción para <a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> y <a class="reference internal" href="#ssl.SSLContext.load_default_certs" title="ssl.SSLContext.load_default_certs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_default_certs()</span></code></a>. Este valor indica que el contexto puede utilizarse para autenticar servidores web (por lo tanto, se utilizará para crear sockets del lado del cliente).</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt id="ssl.Purpose.CLIENT_AUTH">
<code class="sig-prename descclassname">Purpose.</code><code class="sig-name descname">CLIENT_AUTH</code><a class="headerlink" href="#ssl.Purpose.CLIENT_AUTH" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Opción para <a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> y <a class="reference internal" href="#ssl.SSLContext.load_default_certs" title="ssl.SSLContext.load_default_certs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_default_certs()</span></code></a>. Este valor indica que el contexto puede utilizarse para autenticar clientes web (por lo tanto, se utilizará para crear sockets del lado del servidor).</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt id="ssl.SSLErrorNumber">
<em class="property">class </em><code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">SSLErrorNumber</code><a class="headerlink" href="#ssl.SSLErrorNumber" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Colección <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a> de constantes SSL_ERROR_*.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt id="ssl.TLSVersion">
<em class="property">class </em><code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">TLSVersion</code><a class="headerlink" href="#ssl.TLSVersion" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Colección <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></a> de versiones SSL y TLS para <a class="reference internal" href="#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.maximum_version</span></code></a> y <a class="reference internal" href="#ssl.SSLContext.minimum_version" title="ssl.SSLContext.minimum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.minimum_version</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.TLSVersion.MINIMUM_SUPPORTED">
<code class="sig-prename descclassname">TLSVersion.</code><code class="sig-name descname">MINIMUM_SUPPORTED</code><a class="headerlink" href="#ssl.TLSVersion.MINIMUM_SUPPORTED" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="ssl.TLSVersion.MAXIMUM_SUPPORTED">
<code class="sig-prename descclassname">TLSVersion.</code><code class="sig-name descname">MAXIMUM_SUPPORTED</code><a class="headerlink" href="#ssl.TLSVersion.MAXIMUM_SUPPORTED" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La mínima o máxima versión soportada de SSL o TLS. Estas son constantes mágicas. Sus valores no reflejan la mas baja o mas alta versión TLS/SSL disponible.</p>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.TLSVersion.SSLv3">
<code class="sig-prename descclassname">TLSVersion.</code><code class="sig-name descname">SSLv3</code><a class="headerlink" href="#ssl.TLSVersion.SSLv3" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="ssl.TLSVersion.TLSv1">
<code class="sig-prename descclassname">TLSVersion.</code><code class="sig-name descname">TLSv1</code><a class="headerlink" href="#ssl.TLSVersion.TLSv1" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="ssl.TLSVersion.TLSv1_1">
<code class="sig-prename descclassname">TLSVersion.</code><code class="sig-name descname">TLSv1_1</code><a class="headerlink" href="#ssl.TLSVersion.TLSv1_1" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="ssl.TLSVersion.TLSv1_2">
<code class="sig-prename descclassname">TLSVersion.</code><code class="sig-name descname">TLSv1_2</code><a class="headerlink" href="#ssl.TLSVersion.TLSv1_2" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="ssl.TLSVersion.TLSv1_3">
<code class="sig-prename descclassname">TLSVersion.</code><code class="sig-name descname">TLSv1_3</code><a class="headerlink" href="#ssl.TLSVersion.TLSv1_3" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>SSL 3.0 a TLS 1.3.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.10: </span>Todos los miembros de <a class="reference internal" href="#ssl.TLSVersion" title="ssl.TLSVersion"><code class="xref py py-class docutils literal notranslate"><span class="pre">TLSVersion</span></code></a>, excepto <a class="reference internal" href="#ssl.TLSVersion.TLSv1_2" title="ssl.TLSVersion.TLSv1_2"><code class="xref py py-attr docutils literal notranslate"><span class="pre">TLSVersion.TLSv1_2</span></code></a> y <a class="reference internal" href="#ssl.TLSVersion.TLSv1_3" title="ssl.TLSVersion.TLSv1_3"><code class="xref py py-attr docutils literal notranslate"><span class="pre">TLSVersion.TLSv1_3</span></code></a>, están en desuso.</p>
</div>
</dd></dl>

</section>
</section>
<section id="ssl-sockets">
<h2>Sockets SSL<a class="headerlink" href="#ssl-sockets" title="Enlazar permanentemente con este título">¶</a></h2>
<dl class="py class">
<dt id="ssl.SSLSocket">
<em class="property">class </em><code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">SSLSocket</code><span class="sig-paren">(</span><em class="sig-param">socket.socket</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Los sockets SSL proporcionan los siguientes métodos de <a class="reference internal" href="socket.html#socket-objects"><span class="std std-ref">Objetos Socket</span></a>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a></p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.bind" title="socket.socket.bind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bind()</span></code></a></p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.close" title="socket.socket.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a></p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a></p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.detach" title="socket.socket.detach"><code class="xref py py-meth docutils literal notranslate"><span class="pre">detach()</span></code></a></p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.fileno" title="socket.socket.fileno"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fileno()</span></code></a></p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.getpeername" title="socket.socket.getpeername"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getpeername()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.getsockname" title="socket.socket.getsockname"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getsockname()</span></code></a></p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.getsockopt" title="socket.socket.getsockopt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getsockopt()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.setsockopt" title="socket.socket.setsockopt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setsockopt()</span></code></a></p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.gettimeout" title="socket.socket.gettimeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gettimeout()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">settimeout()</span></code></a>,
<a class="reference internal" href="socket.html#socket.socket.setblocking" title="socket.socket.setblocking"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setblocking()</span></code></a></p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">listen()</span></code></a></p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a></p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.recv_into" title="socket.socket.recv_into"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv_into()</span></code></a> (pero no se admite pasar un argumento <code class="docutils literal notranslate"><span class="pre">flags</span></code> diferente de cero)</p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a>, <a class="reference internal" href="socket.html#socket.socket.sendall" title="socket.socket.sendall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendall()</span></code></a> (con la misma limitación)</p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.sendfile" title="socket.socket.sendfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendfile()</span></code></a> (pero <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.sendfile</span></code></a> sera utilizado sólo para sockets de texto simple, sino <a class="reference internal" href="socket.html#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> sera utilizado)</p></li>
<li><p><a class="reference internal" href="socket.html#socket.socket.shutdown" title="socket.socket.shutdown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shutdown()</span></code></a></p></li>
</ul>
<p>Sin embargo, dado que el protocolo SSL (y TLS) tiene su propia estructura encima de TCP, la abstracción de los sockets SSL puede, en ciertos aspectos, divergir de la especificación de los sockets normales a nivel de SO. Ver especialmente las <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">notas sobre sockets no bloqueantes</span></a>.</p>
<p>Instancias de <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> deben ser creadas usando el método <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>El método <code class="xref py py-meth docutils literal notranslate"><span class="pre">sendfile()</span></code> ha sido agregado.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">shutdown()</span></code> does not reset the socket timeout each time bytes
are received or sent. The socket timeout is now the maximum total duration
of the shutdown.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.6: </span>Crear una instancia de <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> directamente es obsoleto, utilice <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a> para envolver un socket.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Las instancias de <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> deben crearse con <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>. En versiones anteriores, era posible crear instancias directamente. Esto nunca fue documentado ni soportado oficialmente.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Python ahora usa <code class="docutils literal notranslate"><span class="pre">SSL_read_ex</span></code> y <code class="docutils literal notranslate"><span class="pre">SSL_write_ex</span></code> internamente. Las funciones admiten la lectura y escritura de datos de más de 2 GB. La escritura de datos de longitud cero ya no falla con un error de violación de protocolo.</p>
</div>
</dd></dl>

<p>Los sockets SSL tienen también los siguientes métodos y atributos adicionales:</p>
<dl class="py method">
<dt id="ssl.SSLSocket.read">
<code class="sig-prename descclassname">SSLSocket.</code><code class="sig-name descname">read</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">len</span><span class="o">=</span><span class="default_value">1024</span></em>, <em class="sig-param"><span class="n">buffer</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.read" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Lee hasta <em>len</em> bytes de datos del socket SSL y retorna el resultado como una instancia <code class="docutils literal notranslate"><span class="pre">bytes</span></code>. Si <em>buffer</em> es especificado, entonces se lee hacia el búfer en su lugar, y retorna el número de bytes leídos.</p>
<p>Lanza <a class="reference internal" href="#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> o <a class="reference internal" href="#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a> si el socket es <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">no-bloqueante</span></a> y la lectura se bloquearía.</p>
<p>Como en cualquier momento es posible una re-negociación, una llamada a <a class="reference internal" href="#ssl.SSLSocket.read" title="ssl.SSLSocket.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> también puede provocar operaciones de escritura.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>The socket timeout is no longer reset each time bytes are received or sent.
The socket timeout is now the maximum total duration to read up to <em>len</em>
bytes.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.6: </span>Utilice <code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code> en lugar de <a class="reference internal" href="#ssl.SSLSocket.read" title="ssl.SSLSocket.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLSocket.write">
<code class="sig-prename descclassname">SSLSocket.</code><code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">buf</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.write" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Escribe <em>buf</em> en el socket SSL y retorna el número de bytes escritos. El argumento <em>buf</em> debe ser un objeto que soporte la interfaz búfer.</p>
<p>Lanza <a class="reference internal" href="#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> o <a class="reference internal" href="#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a> si el socket es <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">no-bloqueante</span></a> y la escritura se bloquearía.</p>
<p>Como en cualquier momento es posible una re-negociación, una llamada a <a class="reference internal" href="#ssl.SSLSocket.write" title="ssl.SSLSocket.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> también puede provocar operaciones de lectura.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>The socket timeout is no longer reset each time bytes are received or sent.
The socket timeout is now the maximum total duration to write <em>buf</em>.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.6: </span>Utilice <code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code> en lugar de <a class="reference internal" href="#ssl.SSLSocket.write" title="ssl.SSLSocket.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a>.</p>
</div>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Los métodos <a class="reference internal" href="#ssl.SSLSocket.read" title="ssl.SSLSocket.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> y <a class="reference internal" href="#ssl.SSLSocket.write" title="ssl.SSLSocket.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> son los métodos de bajo nivel que leen y escriben datos no cifrados a nivel de aplicación y los descifran/cifran a datos cifrados a nivel de cable. Estos métodos requieren una conexión SSL activa, es decir, que se haya completado el handshake y no se haya llamado a <a class="reference internal" href="#ssl.SSLSocket.unwrap" title="ssl.SSLSocket.unwrap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.unwrap()</span></code></a>.</p>
<p>Normalmente se deberían utilizar los métodos de la API de sockets como <a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a> y <a class="reference internal" href="socket.html#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> en lugar de estos métodos.</p>
</div>
<dl class="py method">
<dt id="ssl.SSLSocket.do_handshake">
<code class="sig-prename descclassname">SSLSocket.</code><code class="sig-name descname">do_handshake</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.do_handshake" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Realiza el handshake de configuración SSL.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>El método handshake también realiza <a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_hostname()</span></code></a> cuando el atributo <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a> del <a class="reference internal" href="#ssl.SSLSocket.context" title="ssl.SSLSocket.context"><code class="xref py py-attr docutils literal notranslate"><span class="pre">context</span></code></a> del socket es verdadero.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>The socket timeout is no longer reset each time bytes are received or sent.
The socket timeout is now the maximum total duration of the handshake.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Hostname or IP address is matched by OpenSSL during handshake. The
function <a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_hostname()</span></code></a> is no longer used. In case OpenSSL
refuses a hostname or IP address, the handshake is aborted early and
a TLS alert message is sent to the peer.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLSocket.getpeercert">
<code class="sig-prename descclassname">SSLSocket.</code><code class="sig-name descname">getpeercert</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">binary_form</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.getpeercert" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si no hay un certificado para el peer en el otro extremo de la conexión, devuelve <code class="docutils literal notranslate"><span class="pre">None</span></code>. Si el handshake SSL no se ha realizado todavía, lanza <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
<p>Si el parámetro <code class="docutils literal notranslate"><span class="pre">binary_form</span></code> es <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>, y se ha recibido un certificado del peer, este método devuelve una instancia <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>. Si el certificado no fue validado, el dict está vacío. Si el certificado fue validado, devuelve un dict con varias claves, entre ellas <code class="docutils literal notranslate"><span class="pre">subject</span></code> (la entidad para la que se emitió el certificado) y <code class="docutils literal notranslate"><span class="pre">issuer</span></code> (la entidad que emite el certificado). Si un certificado contiene una instancia de la extensión <em>Subject Alternative Name</em> (véase <span class="target" id="index-56"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3280.html"><strong>RFC 3280</strong></a>), también habrá una clave <code class="docutils literal notranslate"><span class="pre">subjectAltName</span></code> en el diccionario.</p>
<p>Los campos <code class="docutils literal notranslate"><span class="pre">subject</span></code> y <code class="docutils literal notranslate"><span class="pre">issuer</span></code> son tuplas que contienen la secuencia de nombres distinguidos relativos (RDNs) indicados en la estructura de datos del certificado para los campos respectivos, y cada RDN es una secuencia de pares nombre-valor. Este es un ejemplo del mundo real:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;issuer&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s1">&#39;countryName&#39;</span><span class="p">,</span> <span class="s1">&#39;IL&#39;</span><span class="p">),),</span>
            <span class="p">((</span><span class="s1">&#39;organizationName&#39;</span><span class="p">,</span> <span class="s1">&#39;StartCom Ltd.&#39;</span><span class="p">),),</span>
            <span class="p">((</span><span class="s1">&#39;organizationalUnitName&#39;</span><span class="p">,</span>
              <span class="s1">&#39;Secure Digital Certificate Signing&#39;</span><span class="p">),),</span>
            <span class="p">((</span><span class="s1">&#39;commonName&#39;</span><span class="p">,</span>
              <span class="s1">&#39;StartCom Class 2 Primary Intermediate Server CA&#39;</span><span class="p">),)),</span>
 <span class="s1">&#39;notAfter&#39;</span><span class="p">:</span> <span class="s1">&#39;Nov 22 08:15:19 2013 GMT&#39;</span><span class="p">,</span>
 <span class="s1">&#39;notBefore&#39;</span><span class="p">:</span> <span class="s1">&#39;Nov 21 03:09:52 2011 GMT&#39;</span><span class="p">,</span>
 <span class="s1">&#39;serialNumber&#39;</span><span class="p">:</span> <span class="s1">&#39;95F0&#39;</span><span class="p">,</span>
 <span class="s1">&#39;subject&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s1">&#39;description&#39;</span><span class="p">,</span> <span class="s1">&#39;571208-SLe257oHY9fVQ07Z&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;countryName&#39;</span><span class="p">,</span> <span class="s1">&#39;US&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;stateOrProvinceName&#39;</span><span class="p">,</span> <span class="s1">&#39;California&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;localityName&#39;</span><span class="p">,</span> <span class="s1">&#39;San Francisco&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;organizationName&#39;</span><span class="p">,</span> <span class="s1">&#39;Electronic Frontier Foundation, Inc.&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;commonName&#39;</span><span class="p">,</span> <span class="s1">&#39;*.eff.org&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;emailAddress&#39;</span><span class="p">,</span> <span class="s1">&#39;hostmaster@eff.org&#39;</span><span class="p">),)),</span>
 <span class="s1">&#39;subjectAltName&#39;</span><span class="p">:</span> <span class="p">((</span><span class="s1">&#39;DNS&#39;</span><span class="p">,</span> <span class="s1">&#39;*.eff.org&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;DNS&#39;</span><span class="p">,</span> <span class="s1">&#39;eff.org&#39;</span><span class="p">)),</span>
 <span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Para validar un certificado para un servicio concreto, puede utilizar la función <a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_hostname()</span></code></a>.</p>
</div>
<p>Si el parámetro <code class="docutils literal notranslate"><span class="pre">binary_form</span></code> es <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>, y se proporcionó un certificado, este método devuelve la forma codificada en DER del certificado completo como una secuencia de bytes, o <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> si el par no proporcionó un certificado. El hecho de que el par proporcione un certificado depende del rol del socket SSL:</p>
<ul class="simple">
<li><p>para un socket SSL cliente, el servidor siempre proporcionará un certificado, independientemente de si se requirió la validación;</p></li>
<li><p>para un socket SSL servidor, el cliente sólo proporcionará un certificado cuando lo solicite el servidor; por lo tanto <a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getpeercert()</span></code></a> devolverá <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> si ha utilizado <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a> (en lugar de <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_OPTIONAL</span></code></a> o <code class="xref py py-const docutils literal notranslate"><span class="pre">CERT</span> <span class="pre">REQUIRED</span></code>).</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>El diccionario devuelto incluye elementos adicionales tales como <code class="docutils literal notranslate"><span class="pre">issuer</span></code> y <code class="docutils literal notranslate"><span class="pre">notBefore</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span><a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> se lanza cuando no se realiza el handshake. El diccionario retornado incluye elementos de extensión X509v3 adicionales como <code class="docutils literal notranslate"><span class="pre">crlDistributionPoints</span></code>, <code class="docutils literal notranslate"><span class="pre">caIssuers</span></code> y <code class="docutils literal notranslate"><span class="pre">OCSP</span></code> URIs.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.9: </span>Las cadenas de direcciones IPv6 ya no tienen una nueva línea al final.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLSocket.cipher">
<code class="sig-prename descclassname">SSLSocket.</code><code class="sig-name descname">cipher</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.cipher" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una tupla de tres valores que contiene el nombre del cifrado que se está utilizando, la versión del protocolo SSL que define su uso y el número de bits secretos que se están utilizando. Si no se ha establecido ninguna conexión, retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLSocket.shared_ciphers">
<code class="sig-prename descclassname">SSLSocket.</code><code class="sig-name descname">shared_ciphers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.shared_ciphers" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Return the list of ciphers available in both the client and server.  Each
entry of the returned list is a three-value tuple containing the name of the
cipher, the version of the SSL protocol that defines its use, and the number
of secret bits the cipher uses.  <a class="reference internal" href="#ssl.SSLSocket.shared_ciphers" title="ssl.SSLSocket.shared_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shared_ciphers()</span></code></a> returns
<code class="docutils literal notranslate"><span class="pre">None</span></code> if no connection has been established or the socket is a client
socket.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLSocket.compression">
<code class="sig-prename descclassname">SSLSocket.</code><code class="sig-name descname">compression</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.compression" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el algoritmo de compresión utilizado como una cadena de caracteres, o <code class="docutils literal notranslate"><span class="pre">None</span></code> si la conexión no está comprimida.</p>
<p>Si el protocolo de nivel superior soporta su propio mecanismo de compresión, puede utilizar <a class="reference internal" href="#ssl.OP_NO_COMPRESSION" title="ssl.OP_NO_COMPRESSION"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_COMPRESSION</span></code></a> para desactivar la compresión a nivel de SSL.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLSocket.get_channel_binding">
<code class="sig-prename descclassname">SSLSocket.</code><code class="sig-name descname">get_channel_binding</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cb_type</span><span class="o">=</span><span class="default_value">'tls-unique'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.get_channel_binding" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Obtiene los datos de enlace del canal para la conexión actual, como un objeto bytes. Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si no está conectado o no se ha completado el handshake.</p>
<p>El parámetro <em>cb_type</em> permite seleccionar el tipo de enlace de canal deseado. Los tipos de enlace de canal válidos se enumeran en la lista <a class="reference internal" href="#ssl.CHANNEL_BINDING_TYPES" title="ssl.CHANNEL_BINDING_TYPES"><code class="xref py py-data docutils literal notranslate"><span class="pre">CHANNEL_BINDING_TYPES</span></code></a>. Actualmente, sólo se admite la vinculación de canal “tls-unique”, definida por <span class="target" id="index-57"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5929.html"><strong>RFC 5929</strong></a>. <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> se lanzará si se solicita un tipo de vinculación de canal no admitido.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLSocket.selected_alpn_protocol">
<code class="sig-prename descclassname">SSLSocket.</code><code class="sig-name descname">selected_alpn_protocol</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.selected_alpn_protocol" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el protocolo que fue seleccionado durante el handshake TLS. Si no se ha llamado a <a class="reference internal" href="#ssl.SSLContext.set_alpn_protocols" title="ssl.SSLContext.set_alpn_protocols"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_alpn_protocols()</span></code></a>, si la otra parte no soporta ALPN, si este socket no soporta ninguno de los protocolos propuestos por el cliente, o si el handshake no ha ocurrido todavía, se devuelve <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLSocket.selected_npn_protocol">
<code class="sig-prename descclassname">SSLSocket.</code><code class="sig-name descname">selected_npn_protocol</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.selected_npn_protocol" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Devuelve el protocolo de nivel superior que se seleccionó durante el handshake TLS/SSL. Si no se llamó a <a class="reference internal" href="#ssl.SSLContext.set_npn_protocols" title="ssl.SSLContext.set_npn_protocols"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_npn_protocols()</span></code></a>, o si la otra parte no soporta NPN, o si el handshake aún no ha ocurrido, esto devolverá <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.10: </span>NPN ha sido reemplazada por ALPN</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLSocket.unwrap">
<code class="sig-prename descclassname">SSLSocket.</code><code class="sig-name descname">unwrap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.unwrap" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Realiza el handshake de cierre de SSL, que elimina la capa TLS del socket subyacente, y devuelve el objeto socket subyacente. Esto puede utilizarse para pasar de una operación encriptada sobre una conexión a una sin encriptar. El socket devuelto debe utilizarse siempre para la comunicación posterior con el otro lado de la conexión, en lugar del socket original.</p>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLSocket.verify_client_post_handshake">
<code class="sig-prename descclassname">SSLSocket.</code><code class="sig-name descname">verify_client_post_handshake</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.verify_client_post_handshake" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Solicita la autenticación post-handshake (PHA) de un cliente TLS 1.3. PHA sólo puede iniciarse para una conexión TLS 1.3 desde un socket del lado del servidor, después del handshake TLS inicial y con PHA habilitado en ambos lados, ver <a class="reference internal" href="#ssl.SSLContext.post_handshake_auth" title="ssl.SSLContext.post_handshake_auth"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.post_handshake_auth</span></code></a>.</p>
<p>El método no realiza un intercambio de certificados inmediatamente. El lado del servidor envía una CertificateRequest durante el siguiente evento de escritura y espera que el cliente responda con un certificado en el siguiente evento de lectura.</p>
<p>Si alguna precondición no se cumple (por ejemplo, no es TLS 1.3, PHA no está habilitado), se genera un <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Sólo está disponible con OpenSSL 1.1.1 y TLS 1.3 habilitados. Sin el soporte de TLS 1.3, el método lanza <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLSocket.version">
<code class="sig-prename descclassname">SSLSocket.</code><code class="sig-name descname">version</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.version" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Return the actual SSL protocol version negotiated by the connection
as a string, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if no secure connection is established.
As of this writing, possible return values include <code class="docutils literal notranslate"><span class="pre">&quot;SSLv2&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;SSLv3&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;TLSv1&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;TLSv1.1&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;TLSv1.2&quot;</span></code>.
Recent OpenSSL versions may define more return values.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLSocket.pending">
<code class="sig-prename descclassname">SSLSocket.</code><code class="sig-name descname">pending</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.pending" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el número de bytes ya descifrados disponibles para leer, pendientes de la conexión.</p>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLSocket.context">
<code class="sig-prename descclassname">SSLSocket.</code><code class="sig-name descname">context</code><a class="headerlink" href="#ssl.SSLSocket.context" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El objeto <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> al que está vinculado este socket SSL. Si el socket SSL fue creado usando la función obsoleta <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a> (en lugar de <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a>), este es un objeto de contexto personalizado creado para este socket SSL.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLSocket.server_side">
<code class="sig-prename descclassname">SSLSocket.</code><code class="sig-name descname">server_side</code><a class="headerlink" href="#ssl.SSLSocket.server_side" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un booleano que es <code class="docutils literal notranslate"><span class="pre">True</span></code> para los sockets del lado del servidor y <code class="docutils literal notranslate"><span class="pre">False</span></code> para los sockets del lado del cliente.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLSocket.server_hostname">
<code class="sig-prename descclassname">SSLSocket.</code><code class="sig-name descname">server_hostname</code><a class="headerlink" href="#ssl.SSLSocket.server_hostname" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Hostname del servidor: tipo <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, o <code class="docutils literal notranslate"><span class="pre">None</span></code> para el socket del lado del servidor o si el hostname no fue especificado en el constructor.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>El atributo es ahora siempre texto ASCII. Cuando <code class="docutils literal notranslate"><span class="pre">server_hostname</span></code> es un nombre de dominio internacionalizado (IDN), este atributo almacena ahora la forma de etiqueta A (<code class="docutils literal notranslate"><span class="pre">&quot;xn--pythn-mua.org&quot;</span></code>), en lugar de la forma de etiqueta U (<code class="docutils literal notranslate"><span class="pre">&quot;pythön.org&quot;</span></code>).</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLSocket.session">
<code class="sig-prename descclassname">SSLSocket.</code><code class="sig-name descname">session</code><a class="headerlink" href="#ssl.SSLSocket.session" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La <a class="reference internal" href="#ssl.SSLSession" title="ssl.SSLSession"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSession</span></code></a> para esta conexión SSL. La sesión está disponible para los sockets del lado del cliente y del servidor después de que se haya realizado el handshake TLS. Para los sockets del cliente la sesión puede ser establecida antes de que <a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">do_handshake()</span></code></a> haya sido llamado para reutilizar una sesión.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLSocket.session_reused">
<code class="sig-prename descclassname">SSLSocket.</code><code class="sig-name descname">session_reused</code><a class="headerlink" href="#ssl.SSLSocket.session_reused" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.</span></p>
</div>
</dd></dl>

</section>
<section id="ssl-contexts">
<h2>Contextos SSL<a class="headerlink" href="#ssl-contexts" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
<p>Un contexto SSL contiene varios datos más duraderos que las conexiones SSL individuales, como opciones de configuración SSL, certificado(s) y clave(s) privada(s). También gestiona un cache de sesiones SSL para sockets del lado del servidor, para acelerar conexiones repetidas de los mismos clientes.</p>
<dl class="py class">
<dt id="ssl.SSLContext">
<em class="property">class </em><code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">SSLContext</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocol</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un nuevo contexto SSL. Puede pasar <em>protocolo</em> que debe ser una de las constantes <code class="docutils literal notranslate"><span class="pre">PROTOCOL_*</span></code> definidas en este módulo. El parámetro especifica la versión del protocolo SSL a utilizar. Típicamente, el servidor elige una versión particular del protocolo, y el cliente debe adaptarse a la elección del servidor. La mayoría de las versiones no son interoperables con las demás. Si no se especifica, el valor por defecto es <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>; proporciona la mayor compatibilidad con otras versiones.</p>
<p>Esta es una tabla que muestra qué versiones de un cliente (en la parte inferior) pueden conectarse a qué versiones de un servidor (en la parte superior):</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 14%" />
<col style="width: 10%" />
<col style="width: 12%" />
<col style="width: 12%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><em>cliente</em> / <strong>servidor</strong></p></td>
<td><p><strong>SSLv2</strong></p></td>
<td><p><strong>SSLv3</strong></p></td>
<td><p><strong>TLS</strong> <a class="footnote-reference brackets" href="#id9" id="id1">3</a></p></td>
<td><p><strong>TLSv1</strong></p></td>
<td><p><strong>TLSv1.1</strong></p></td>
<td><p><strong>TLSv1.2</strong></p></td>
</tr>
<tr class="row-even"><td><p><em>SSLv2</em></p></td>
<td><p>si</p></td>
<td><p>no</p></td>
<td><p>no <a class="footnote-reference brackets" href="#id7" id="id2">1</a></p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p><em>SSLv3</em></p></td>
<td><p>no</p></td>
<td><p>si</p></td>
<td><p>no <a class="footnote-reference brackets" href="#id8" id="id3">2</a></p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p><em>TLS</em> (<em>SSLv23</em>) <a class="footnote-reference brackets" href="#id9" id="id4">3</a></p></td>
<td><p>no <a class="footnote-reference brackets" href="#id7" id="id5">1</a></p></td>
<td><p>no <a class="footnote-reference brackets" href="#id8" id="id6">2</a></p></td>
<td><p>si</p></td>
<td><p>si</p></td>
<td><p>si</p></td>
<td><p>si</p></td>
</tr>
<tr class="row-odd"><td><p><em>TLSv1</em></p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>si</p></td>
<td><p>si</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-even"><td><p><em>TLSv1.1</em></p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>si</p></td>
<td><p>no</p></td>
<td><p>si</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p><em>TLSv1.2</em></p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>si</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>si</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p class="rubric">Notas a pie de página</p>
<dl class="footnote brackets">
<dt class="label" id="id7"><span class="brackets">1</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id5">2</a>)</span></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> desactiva SSLv2 con <a class="reference internal" href="#ssl.OP_NO_SSLv2" title="ssl.OP_NO_SSLv2"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv2</span></code></a> por defecto.</p>
</dd>
<dt class="label" id="id8"><span class="brackets">2</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id6">2</a>)</span></dt>
<dd><p><a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> desactiva SSLv3 con <a class="reference internal" href="#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a> por defecto.</p>
</dd>
<dt class="label" id="id9"><span class="brackets">3</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id4">2</a>)</span></dt>
<dd><p>El protocolo TLS 1.3 estará disponible con <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a> en OpenSSL &gt;= 1.1.1. No existe una constante PROTOCOL dedicada sólo a TLS 1.3.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p><a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> permite al módulo <a class="reference internal" href="#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> elegir la configuración de seguridad para un propósito determinado.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>El contexto se crea con valores seguros por defecto. Las opciones <a class="reference internal" href="#ssl.OP_NO_COMPRESSION" title="ssl.OP_NO_COMPRESSION"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_COMPRESSION</span></code></a>, <a class="reference internal" href="#ssl.OP_CIPHER_SERVER_PREFERENCE" title="ssl.OP_CIPHER_SERVER_PREFERENCE"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_CIPHER_SERVER_PREFERENCE</span></code></a>, <a class="reference internal" href="#ssl.OP_SINGLE_DH_USE" title="ssl.OP_SINGLE_DH_USE"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_SINGLE_DH_USE</span></code></a>, <a class="reference internal" href="#ssl.OP_SINGLE_ECDH_USE" title="ssl.OP_SINGLE_ECDH_USE"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_SINGLE_ECDH_USE</span></code></a>, <a class="reference internal" href="#ssl.OP_NO_SSLv2" title="ssl.OP_NO_SSLv2"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv2</span></code></a> (excepto para <a class="reference internal" href="#ssl.PROTOCOL_SSLv2" title="ssl.PROTOCOL_SSLv2"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_SSLv2</span></code></a>), y <a class="reference internal" href="#ssl.OP_NO_SSLv3" title="ssl.OP_NO_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv3</span></code></a> (excepto para <a class="reference internal" href="#ssl.PROTOCOL_SSLv3" title="ssl.PROTOCOL_SSLv3"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_SSLv3</span></code></a>) están establecidas por defecto. La lista inicial de conjuntos de cifrado sólo contiene cifrados <code class="docutils literal notranslate"><span class="pre">HIGH</span></code>, ningún cifrado <code class="docutils literal notranslate"><span class="pre">NULL</span></code> y ningún cifrado <code class="docutils literal notranslate"><span class="pre">MD5</span></code> (excepto para <a class="reference internal" href="#ssl.PROTOCOL_SSLv2" title="ssl.PROTOCOL_SSLv2"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_SSLv2</span></code></a>).</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.10: </span><a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> sin argumento de protocolo está en desuso. La clase de contexto requerirá el protocolo <a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> o <a class="reference internal" href="#ssl.PROTOCOL_TLS_SERVER" title="ssl.PROTOCOL_TLS_SERVER"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_SERVER</span></code></a> en el futuro.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Los conjuntos de cifrado predeterminados ahora incluyen solo cifrados AES y ChaCha20 seguros con secreto directo y nivel de seguridad 2. Están prohibidas las claves RSA y DH con menos de 2048 bits y las claves ECC con menos de 224 bits. <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>, <a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> y <a class="reference internal" href="#ssl.PROTOCOL_TLS_SERVER" title="ssl.PROTOCOL_TLS_SERVER"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_SERVER</span></code></a> usan TLS 1.2 como versión mínima de TLS.</p>
</div>
</dd></dl>

<p>Los objetos <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> tienen los siguientes métodos y atributos:</p>
<dl class="py method">
<dt id="ssl.SSLContext.cert_store_stats">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">cert_store_stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.cert_store_stats" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Obtiene estadísticas sobre las cantidades de certificados X.509 cargados, la cantidad de certificados X.509 marcados como certificados CA y las listas de revocación de certificados como diccionario.</p>
<p>Ejemplo para un contexto con un certificado CA y otro certificado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">cert_store_stats</span><span class="p">()</span>
<span class="go">{&#39;crl&#39;: 0, &#39;x509_ca&#39;: 1, &#39;x509&#39;: 2}</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLContext.load_cert_chain">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">load_cert_chain</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">certfile</span></em>, <em class="sig-param"><span class="n">keyfile</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">password</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.load_cert_chain" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Load a private key and the corresponding certificate.  The <em>certfile</em>
string must be the path to a single file in PEM format containing the
certificate as well as any number of CA certificates needed to establish
the certificate’s authenticity.  The <em>keyfile</em> string, if present, must
point to a file containing the private key.  Otherwise the private
key will be taken from <em>certfile</em> as well.  See the discussion of
<a class="reference internal" href="#ssl-certificates"><span class="std std-ref">Certificados</span></a> for more information on how the certificate
is stored in the <em>certfile</em>.</p>
<p>El argumento <em>password</em> puede ser una función a la que llamar para obtener la contraseña para descifrar la clave privada. Sólo se llamará si la clave privada está encriptada y se necesita una contraseña. Se llamará sin argumentos, y deberá devolver una cadena de caracteres, bytes o bytearray. Si el valor devuelto es una cadena de caracteres, se codificará como UTF-8 antes de utilizarlo para descifrar la clave. Alternativamente, se puede suministrar un valor de cadena de caracteres, bytes o bytearray directamente como argumento <em>password</em>. Se ignorará si la clave privada no está cifrada y no se necesita una contraseña.</p>
<p>Si el argumento <em>password</em> no es especificado y una contraseña es requerida, el mecanismo de solicitud de contraseña incorporado de OpenSSL se usará para solicitarle una contraseña al usuario de forma interactiva.</p>
<p>Un <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLError</span></code></a> es lanzado si la clave privada no coincide con el certificado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Nuevo argumento opcional <em>password</em>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLContext.load_default_certs">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">load_default_certs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">purpose</span><span class="o">=</span><span class="default_value">Purpose.SERVER_AUTH</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.load_default_certs" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Load a set of default «certification authority» (CA) certificates from
default locations. On Windows it loads CA certs from the <code class="docutils literal notranslate"><span class="pre">CA</span></code> and
<code class="docutils literal notranslate"><span class="pre">ROOT</span></code> system stores. On all systems it calls
<a class="reference internal" href="#ssl.SSLContext.set_default_verify_paths" title="ssl.SSLContext.set_default_verify_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_default_verify_paths()</span></code></a>. In the future the method may
load CA certificates from other locations, too.</p>
<p>La opción <em>purpose</em> especifica qué tipo de certificados CA se cargan. La configuración por defecto <a class="reference internal" href="#ssl.Purpose.SERVER_AUTH" title="ssl.Purpose.SERVER_AUTH"><code class="xref py py-data docutils literal notranslate"><span class="pre">Purpose.SERVER_AUTH</span></code></a> carga certificados, que están marcados y son de confianza para la autenticación del servidor web TLS (sockets del lado del cliente). <a class="reference internal" href="#ssl.Purpose.CLIENT_AUTH" title="ssl.Purpose.CLIENT_AUTH"><code class="xref py py-data docutils literal notranslate"><span class="pre">Purpose.CLIENT_AUTH</span></code></a> carga certificados CA para la verificación de certificados de cliente en el lado del servidor.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLContext.load_verify_locations">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">load_verify_locations</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cafile</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">capath</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cadata</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.load_verify_locations" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Carga un conjunto de certificados de «autoridad de certificación» (CA) usados para validar certificados de otros pares cuando <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-data docutils literal notranslate"><span class="pre">verify_mode</span></code></a> es distinto de <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a>. Debe especificarse al menos uno de <em>cafile</em> o <em>capath</em>.</p>
<p>Este método puede cargar también listas de revocación de certificados (CRLs) en formato PEM o DER. Para poder usar CRLs, <a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a> debe ser configurado correctamente.</p>
<p>La cadena de caracteres <em>cafile</em>, si está presente, es la ruta a un archivo de certificados CA concatenados en formato PEM. Vea la discusión de <a class="reference internal" href="#ssl-certificates"><span class="std std-ref">Certificados</span></a> para más información acerca de como organizar los certificados en este archivo.</p>
<p>La cadena de caracteres <em>capath</em>, si está presente, es la ruta a un directorio que contiene varios certificados CA en formato PEM, siguiendo la <a class="reference external" href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations.html">disposición específica de OpenSSL</a>.</p>
<p>El objeto <em>cadata</em>, si está presente, es una cadena de caracteres ASCII de uno o más certificados codificados en PEM o un <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> de certificados codificados en DER. Al igual que con <em>capath</em>, las líneas adicionales alrededor de los certificados codificados en PEM se ignoran, pero debe haber al menos un certificado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Nuevo argumento opcional <em>cadata</em></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLContext.get_ca_certs">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">get_ca_certs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">binary_form</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.get_ca_certs" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Obtiene una lista de certificados de «autoridad de certificación» (CA) cargados. Si el parámetro <code class="docutils literal notranslate"><span class="pre">binary_form</span></code> es <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> cada entrada de la lista es un diccionario como la salida de <a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.getpeercert()</span></code></a>. En caso contrario, el método devuelve una lista de certificados codificados con DER. La lista devuelta no contiene certificados de <em>capath</em> a menos que un certificado haya sido solicitado y cargado por una conexión SSL.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Los certificados de un directorio capath no se cargan a menos que se hayan utilizado al menos una vez.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLContext.get_ciphers">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">get_ciphers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.get_ciphers" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Obtiene una lista de cifrados habilitados. La lista está en orden de prioridad de cifrado. Véase <a class="reference internal" href="#ssl.SSLContext.set_ciphers" title="ssl.SSLContext.set_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_ciphers()</span></code></a>.</p>
<p>Ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_SSLv23</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span><span class="o">.</span><span class="n">set_ciphers</span><span class="p">(</span><span class="s1">&#39;ECDHE+AESGCM:!ECDSA&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ctx</span><span class="o">.</span><span class="n">get_ciphers</span><span class="p">()</span>
<span class="go">[{&#39;aead&#39;: True,</span>
<span class="go">  &#39;alg_bits&#39;: 256,</span>
<span class="go">  &#39;auth&#39;: &#39;auth-rsa&#39;,</span>
<span class="go">  &#39;description&#39;: &#39;ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  &#39;</span>
<span class="go">                 &#39;Enc=AESGCM(256) Mac=AEAD&#39;,</span>
<span class="go">  &#39;digest&#39;: None,</span>
<span class="go">  &#39;id&#39;: 50380848,</span>
<span class="go">  &#39;kea&#39;: &#39;kx-ecdhe&#39;,</span>
<span class="go">  &#39;name&#39;: &#39;ECDHE-RSA-AES256-GCM-SHA384&#39;,</span>
<span class="go">  &#39;protocol&#39;: &#39;TLSv1.2&#39;,</span>
<span class="go">  &#39;strength_bits&#39;: 256,</span>
<span class="go">  &#39;symmetric&#39;: &#39;aes-256-gcm&#39;},</span>
<span class="go"> {&#39;aead&#39;: True,</span>
<span class="go">  &#39;alg_bits&#39;: 128,</span>
<span class="go">  &#39;auth&#39;: &#39;auth-rsa&#39;,</span>
<span class="go">  &#39;description&#39;: &#39;ECDHE-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH     Au=RSA  &#39;</span>
<span class="go">                 &#39;Enc=AESGCM(128) Mac=AEAD&#39;,</span>
<span class="go">  &#39;digest&#39;: None,</span>
<span class="go">  &#39;id&#39;: 50380847,</span>
<span class="go">  &#39;kea&#39;: &#39;kx-ecdhe&#39;,</span>
<span class="go">  &#39;name&#39;: &#39;ECDHE-RSA-AES128-GCM-SHA256&#39;,</span>
<span class="go">  &#39;protocol&#39;: &#39;TLSv1.2&#39;,</span>
<span class="go">  &#39;strength_bits&#39;: 128,</span>
<span class="go">  &#39;symmetric&#39;: &#39;aes-128-gcm&#39;}]</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLContext.set_default_verify_paths">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">set_default_verify_paths</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_default_verify_paths" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Carga un conjunto de certificados de «autoridad de certificación» (CA) por defecto desde una ruta del sistema de archivos definida al construir la biblioteca OpenSSL. Desafortunadamente, no hay una manera fácil de saber si este método tiene éxito: no se devuelve ningún error si no se encuentran certificados. Sin embargo, cuando la biblioteca OpenSSL se proporciona como parte del sistema operativo, es probable que esté configurada correctamente.</p>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLContext.set_ciphers">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">set_ciphers</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ciphers</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_ciphers" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece los cifrados disponibles para los sockets creados con este contexto. Debe ser una cadena de caracteres con el <a class="reference external" href="https://www.openssl.org/docs/manmaster/man1/ciphers.html">formato de la lista de cifrado de OpenSSL</a>. Si no se puede seleccionar ningún cifrado (porque las opciones en tiempo de compilación u otra configuración prohíben el uso de todos los cifrados especificados), se lanzará un <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLError</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>cuando se conecta, el método <a class="reference internal" href="#ssl.SSLSocket.cipher" title="ssl.SSLSocket.cipher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.cipher()</span></code></a> de los sockets SSL dará el cifrado actualmente seleccionado.</p>
<p>OpenSSL 1.1.1 tiene suites de cifrado TLS 1.3 habilitadas por defecto. Las suites no se pueden desactivar con <a class="reference internal" href="#ssl.SSLContext.set_ciphers" title="ssl.SSLContext.set_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_ciphers()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLContext.set_alpn_protocols">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">set_alpn_protocols</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocols</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_alpn_protocols" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Especifica qué protocolos debe anunciar el socket durante el handshake SSL/TLS. Debe ser una lista de cadenas de caracteres ASCII, como <code class="docutils literal notranslate"><span class="pre">['http/1.1',</span> <span class="pre">'spdy/2']</span></code>, ordenadas por preferencia. La selección de un protocolo ocurrirá durante el handshake, y se desarrollará de acuerdo con <span class="target" id="index-58"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7301.html"><strong>RFC 7301</strong></a>. Después de un handshake exitoso, el método <a class="reference internal" href="#ssl.SSLSocket.selected_alpn_protocol" title="ssl.SSLSocket.selected_alpn_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.selected_alpn_protocol()</span></code></a> devolverá el protocolo acordado.</p>
<p>Este método lanzará <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> si <a class="reference internal" href="#ssl.HAS_ALPN" title="ssl.HAS_ALPN"><code class="xref py py-data docutils literal notranslate"><span class="pre">HAS_ALPN</span></code></a> es <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLContext.set_npn_protocols">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">set_npn_protocols</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">protocols</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_npn_protocols" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Especifica qué protocolos debe anunciar el socket durante el handshake SSL/TLS. Debe ser una lista de cadenas, como <code class="docutils literal notranslate"><span class="pre">['http/1.1',</span> <span class="pre">'spdy/2']</span></code>, ordenadas por preferencia. La selección de un protocolo ocurrirá durante el handshake, y se desarrollará de acuerdo a la <a class="reference external" href="https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation">Negociación del Protocolo de la Capa de Aplicación</a>. Después de un handshake exitoso, el método <a class="reference internal" href="#ssl.SSLSocket.selected_npn_protocol" title="ssl.SSLSocket.selected_npn_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.selected_npn_protocol()</span></code></a> devolverá el protocolo acordado.</p>
<p>Este método lanzará <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> si <a class="reference internal" href="#ssl.HAS_NPN" title="ssl.HAS_NPN"><code class="xref py py-data docutils literal notranslate"><span class="pre">HAS_NPN</span></code></a> es <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.10: </span>NPN ha sido reemplazada por ALPN</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLContext.sni_callback">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">sni_callback</code><a class="headerlink" href="#ssl.SSLContext.sni_callback" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Registra una función callback que se llamará después de que el servidor SSL/TLS haya recibido el mensaje de diálogo TLS Client Hello cuando el cliente TLS especifique una indicación de nombre de servidor. El mecanismo de indicación de nombre de servidor se especifica en <span class="target" id="index-59"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6066.html"><strong>RFC 6066</strong></a> sección 3 - Server Name Indication.</p>
<p>Sólo se puede establecer una función callback por <code class="docutils literal notranslate"><span class="pre">SSLContext</span></code>. Si <em>sni_callback</em> se establece como <code class="docutils literal notranslate"><span class="pre">None</span></code>, la función callback se desactiva. Si se llama a esta función una vez más, se desactivará la función callback registrada anteriormente.</p>
<p>La función callback será llamada con tres argumentos; el primero es el <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a>, el segundo es una cadena que representa el nombre del servidor con el que el cliente pretende comunicarse (o <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> si el TLS Client Hello no contiene un nombre de servidor) y el tercer argumento es el <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> original. El argumento del nombre del servidor es un texto. En el caso de los nombres de dominio internacionalizados, el nombre del servidor es un IDN etiqueta A (<code class="docutils literal notranslate"><span class="pre">&quot;xn--pythn-mua.org&quot;</span></code>).</p>
<p>Un uso típico de esta función callback es cambiar el atributo <a class="reference internal" href="#ssl.SSLSocket.context" title="ssl.SSLSocket.context"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLSocket.context</span></code></a> de <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a> por un nuevo objeto de tipo <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> que representa una cadena de certificados que coincide con el nombre del servidor.</p>
<p>Due to the early negotiation phase of the TLS connection, only limited
methods and attributes are usable like
<a class="reference internal" href="#ssl.SSLSocket.selected_alpn_protocol" title="ssl.SSLSocket.selected_alpn_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.selected_alpn_protocol()</span></code></a> and <a class="reference internal" href="#ssl.SSLSocket.context" title="ssl.SSLSocket.context"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLSocket.context</span></code></a>.
The <a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.getpeercert()</span></code></a>,
<a class="reference internal" href="#ssl.SSLSocket.cipher" title="ssl.SSLSocket.cipher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.cipher()</span></code></a> and <a class="reference internal" href="#ssl.SSLSocket.compression" title="ssl.SSLSocket.compression"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.compression()</span></code></a> methods require that
the TLS connection has progressed beyond the TLS Client Hello and therefore
will not return meaningful values nor can they be called safely.</p>
<p>La función <em>sni_callback</em> debe devolver <code class="docutils literal notranslate"><span class="pre">None</span></code> para permitir que la negociación TLS continúe. Si se requiere un fallo TLS, se puede devolver una constante <a class="reference internal" href="#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR" title="ssl.ALERT_DESCRIPTION_INTERNAL_ERROR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ALERT_DESCRIPTION_*</span></code></a>. Otros valores de retorno resultarán en un error fatal TLS con <a class="reference internal" href="#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR" title="ssl.ALERT_DESCRIPTION_INTERNAL_ERROR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ALERT_DESCRIPTION_INTERNAL_ERROR</span></code></a>.</p>
<p>Si se lanza una excepción desde la función <em>sni_callback</em> la conexión TLS terminará con un mensaje de alerta TLS fatal <a class="reference internal" href="#ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE" title="ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE"><code class="xref py py-const docutils literal notranslate"><span class="pre">ALERT_DESCRIPTION_HANDSHAKE_FAILURE</span></code></a>.</p>
<p>Este método lanzará <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> si la biblioteca OpenSSL tenía definido OPENSSL_NO_TLSEXT cuando se construyó.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLContext.set_servername_callback">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">set_servername_callback</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">server_name_callback</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_servername_callback" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Se trata de una API heredada que se mantiene por compatibilidad con versiones anteriores. Cuando sea posible, debería utilizar <a class="reference internal" href="#ssl.SSLContext.sni_callback" title="ssl.SSLContext.sni_callback"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sni_callback</span></code></a> en su lugar. El <em>server_name_callback</em> dado es similar a <em>sni_callback</em>, excepto que cuando el nombre del servidor es un nombre de dominio internacionalizado codificado con IDN, el <em>server_name_callback</em> recibe una etiqueta U decodificada (<code class="docutils literal notranslate"><span class="pre">&quot;pythön.org&quot;</span></code>).</p>
<p>Si hay un error de decodificación en el nombre del servidor, la conexión TLS terminará con un mensaje fatal de alerta TLS <a class="reference internal" href="#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR" title="ssl.ALERT_DESCRIPTION_INTERNAL_ERROR"><code class="xref py py-const docutils literal notranslate"><span class="pre">ALERT_DESCRIPTION_INTERNAL_ERROR</span></code></a> al cliente.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLContext.load_dh_params">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">load_dh_params</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dhfile</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.load_dh_params" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Carga los parámetros de generación de claves para el intercambio de claves Diffie-Hellman (DH). El uso del intercambio de claves DH mejora el secreto hacia adelante a expensas de recursos computacionales (tanto en el servidor como en el cliente). El parámetro <em>dhfile</em> debe ser la ruta de un archivo que contenga los parámetros DH en formato PEM.</p>
<p>Esta configuración no se aplica a los sockets de los clientes. También puede utilizar la opción <a class="reference internal" href="#ssl.OP_SINGLE_DH_USE" title="ssl.OP_SINGLE_DH_USE"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_SINGLE_DH_USE</span></code></a> para mejorar aún más la seguridad.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLContext.set_ecdh_curve">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">set_ecdh_curve</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">curve_name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.set_ecdh_curve" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece el nombre de la curva para el intercambio de claves Diffie-Hellman basado en la curva elíptica (ECDH). ECDH es significativamente más rápido que el DH normal, aunque podría decirse que es igual de seguro. El parámetro <em>curve_name</em> debe ser una cadena que describa una curva elíptica conocida, por ejemplo <code class="docutils literal notranslate"><span class="pre">prime256v1</span></code> para una curva ampliamente soportada.</p>
<p>Esta configuración no se aplica a los sockets de los clientes. También puede utilizar la opción <a class="reference internal" href="#ssl.OP_SINGLE_ECDH_USE" title="ssl.OP_SINGLE_ECDH_USE"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_SINGLE_ECDH_USE</span></code></a> para mejorar aún más la seguridad.</p>
<p>Este método no está disponible si <a class="reference internal" href="#ssl.HAS_ECDH" title="ssl.HAS_ECDH"><code class="xref py py-data docutils literal notranslate"><span class="pre">HAS_ECDH</span></code></a> es <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><a class="reference external" href="https://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy">SSL/TLS &amp; Perfect Forward Secrecy</a></dt><dd><p>Vincent Bernat.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLContext.wrap_socket">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">wrap_socket</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sock</span></em>, <em class="sig-param"><span class="n">server_side</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">do_handshake_on_connect</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">suppress_ragged_eofs</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">server_hostname</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">session</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.wrap_socket" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Envuelve un socket Python existente <em>sock</em> y devuelve una instancia de <a class="reference internal" href="#ssl.SSLContext.sslsocket_class" title="ssl.SSLContext.sslsocket_class"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.sslsocket_class</span></code></a> (por defecto <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a>). El socket SSL devuelto está ligado al contexto, su configuración y certificados. <em>sock</em> debe ser un socket <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-data docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>; otros tipos de socket no son soportados.</p>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">server_side</span></code> es un booleano que identifica si se desea un comportamiento del lado del servidor o del lado del cliente en este socket.</p>
<p>Para los sockets del lado del cliente, la construcción del contexto es perezosa; si el socket subyacente no está conectado todavía, la construcción del contexto se realizará después de llamar a <code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code> en el socket. Para los sockets del lado del servidor, si el socket no tiene un par remoto, se asume que es un socket a la escucha, y la envoltura SSL del lado del servidor se realiza automáticamente en las conexiones del cliente aceptadas a través del método <code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code>. El método puede lanzar <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a>.</p>
<p>En las conexiones de cliente, el parámetro opcional <em>server_hostname</em> especifica el nombre del servicio al que nos estamos conectando. Esto permite que un único servidor aloje varios servicios basados en SSL con certificados distintos, de forma similar a los hosts virtuales HTTP. Al especificar <em>server_hostname</em> se producirá un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> si <em>server_side</em> es verdadero.</p>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">do_handshake_on_connect</span></code> especifica si se hace el handshake SSL automáticamente después de hacer un <code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.connect()</span></code>, o si el programa de aplicación lo llamará explícitamente, invocando el método <a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.do_handshake()</span></code></a>. Llamar explícitamente a <a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.do_handshake()</span></code></a> da al programa el control sobre el comportamiento de bloqueo de la E/S del socket involucrada en el handshake.</p>
<p>El parámetro <code class="docutils literal notranslate"><span class="pre">suppress_ragged_eofs</span></code> especifica cómo el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.recv()</span></code> debe señalar los EOF inesperados desde el otro extremo de la conexión. Si se especifica como <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> (el valor por defecto), devuelve un EOF normal (un objeto bytes vacío) en respuesta a los errores EOF inesperados que se produzcan desde el socket subyacente; si <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>, lanzará las excepciones al llamador.</p>
<p><em>session</em>, véase <a class="reference internal" href="#ssl.SSLSocket.session" title="ssl.SSLSocket.session"><code class="xref py py-attr docutils literal notranslate"><span class="pre">session</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Siempre permite pasar un server_hostname, incluso si OpenSSL no tiene SNI.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Se agregó el argumento <em>session</em>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>El método retorna una instancia de <a class="reference internal" href="#ssl.SSLContext.sslsocket_class" title="ssl.SSLContext.sslsocket_class"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.sslsocket_class</span></code></a> en lugar de un <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> rígidamente programado.</p>
</div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLContext.sslsocket_class">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">sslsocket_class</code><a class="headerlink" href="#ssl.SSLContext.sslsocket_class" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El tipo de retorno de <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a>, por defecto es <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a>. El atributo puede anularse en la instancia de la clase para devolver una subclase personalizada de <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLContext.wrap_bio">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">wrap_bio</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">incoming</span></em>, <em class="sig-param"><span class="n">outgoing</span></em>, <em class="sig-param"><span class="n">server_side</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">server_hostname</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">session</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.wrap_bio" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Envuelve los objetos BIO <em>incoming</em> y <em>outgoing</em> y devuelve una instancia de <a class="reference internal" href="#ssl.SSLContext.sslobject_class" title="ssl.SSLContext.sslobject_class"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.sslobject_class</span></code></a> (por defecto <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a>). Las rutinas SSL leerán los datos de entrada de la BIO entrante y escribirán los datos en la BIO saliente.</p>
<p>Los parámetros <em>server_side</em>, <em>server_hostname</em> y <em>session</em> tienen el mismo significado que en <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Se agregó el argumento <em>session</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>El método retorna una instancia de <a class="reference internal" href="#ssl.SSLContext.sslobject_class" title="ssl.SSLContext.sslobject_class"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.sslobject_class</span></code></a> en lugar de un <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> rígidamente programado.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLContext.sslobject_class">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">sslobject_class</code><a class="headerlink" href="#ssl.SSLContext.sslobject_class" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El tipo de retorno de <a class="reference internal" href="#ssl.SSLContext.wrap_bio" title="ssl.SSLContext.wrap_bio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_bio()</span></code></a>, por defecto es <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a>. El atributo puede anularse en la instancia de la clase para devolver una subclase personalizada de <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="ssl.SSLContext.session_stats">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">session_stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLContext.session_stats" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Get statistics about the SSL sessions created or managed by this context.
A dictionary is returned which maps the names of each <a class="reference external" href="https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_sess_number.html">piece of information</a> to their
numeric values.  For example, here is the total number of hits and misses
in the session cache since the context was created:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">session_stats</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;hits&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;misses&#39;</span><span class="p">]</span>
<span class="go">(0, 0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLContext.check_hostname">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">check_hostname</code><a class="headerlink" href="#ssl.SSLContext.check_hostname" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si debe coincidir con el nombre de host del certificado de pares en <a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.do_handshake()</span></code></a>. El <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verify_mode</span></code></a> del contexto debe establecerse en <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_OPTIONAL</span></code></a> o <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>, y debe pasar <em>server_hostname</em> a <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a> para que coincida con el nombre de host. La activación de la comprobación del nombre de host configura automáticamente <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verify_mode</span></code></a> de <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a> a <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>. No se puede volver a establecer en <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a> siempre que la comprobación del nombre de host esté habilitada. El protocolo <a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> habilita la verificación del nombre de host de forma predeterminada. Con otros protocolos, la verificación del nombre de host debe habilitarse explícitamente.</p>
<p>Ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">ssl</span>

<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLSv1_2</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">verify_mode</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">CERT_REQUIRED</span>
<span class="n">context</span><span class="o">.</span><span class="n">check_hostname</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">context</span><span class="o">.</span><span class="n">load_default_certs</span><span class="p">()</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">ssl_sock</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">server_hostname</span><span class="o">=</span><span class="s1">&#39;www.verisign.com&#39;</span><span class="p">)</span>
<span class="n">ssl_sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;www.verisign.com&#39;</span><span class="p">,</span> <span class="mi">443</span><span class="p">))</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span><a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verify_mode</span></code></a> ahora se cambia automáticamente a <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> cuando la comprobación del hostname está activada y <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verify_mode</span></code></a> es <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a>. Anteriormente la misma operación habría fallado con un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLContext.keylog_filename">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">keylog_filename</code><a class="headerlink" href="#ssl.SSLContext.keylog_filename" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Escribe las claves TLS en un archivo keylog, siempre que se genere o reciba material de claves. El archivo keylog está diseñado únicamente para fines de depuración. El formato del archivo está especificado por NSS y es utilizado por muchos analizadores de tráfico como Wireshark. El archivo de registro se abre en modo sólo añadir. Las escrituras se sincronizan entre hilos, pero no entre procesos.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLContext.maximum_version">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">maximum_version</code><a class="headerlink" href="#ssl.SSLContext.maximum_version" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un miembro enumeración de <a class="reference internal" href="#ssl.TLSVersion" title="ssl.TLSVersion"><code class="xref py py-class docutils literal notranslate"><span class="pre">TLSVersion</span></code></a> que representa la versión más alta de TLS soportada. El valor por defecto es <a class="reference internal" href="#ssl.TLSVersion.MAXIMUM_SUPPORTED" title="ssl.TLSVersion.MAXIMUM_SUPPORTED"><code class="xref py py-attr docutils literal notranslate"><span class="pre">TLSVersion.MAXIMUM_SUPPORTED</span></code></a>. El atributo es de sólo lectura para protocolos distintos de <a class="reference internal" href="#ssl.PROTOCOL_TLS" title="ssl.PROTOCOL_TLS"><code class="xref py py-attr docutils literal notranslate"><span class="pre">PROTOCOL_TLS</span></code></a>, <a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-attr docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> y <a class="reference internal" href="#ssl.PROTOCOL_TLS_SERVER" title="ssl.PROTOCOL_TLS_SERVER"><code class="xref py py-attr docutils literal notranslate"><span class="pre">PROTOCOL_TLS_SERVER</span></code></a>.</p>
<p>Los atributos <a class="reference internal" href="#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">maximum_version</span></code></a>, <a class="reference internal" href="#ssl.SSLContext.minimum_version" title="ssl.SSLContext.minimum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">minimum_version</span></code></a> y <a class="reference internal" href="#ssl.SSLContext.options" title="ssl.SSLContext.options"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.options</span></code></a> afectan a las versiones SSL y TLS soportadas del contexto. La implementación no evita la combinación inválida. Por ejemplo, un contexto con <a class="reference internal" href="#ssl.OP_NO_TLSv1_2" title="ssl.OP_NO_TLSv1_2"><code class="xref py py-attr docutils literal notranslate"><span class="pre">OP_NO_TLSv1_2</span></code></a> en <a class="reference internal" href="#ssl.SSLContext.options" title="ssl.SSLContext.options"><code class="xref py py-attr docutils literal notranslate"><span class="pre">options</span></code></a> y <a class="reference internal" href="#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">maximum_version</span></code></a> establecido en <a class="reference internal" href="#ssl.TLSVersion.TLSv1_2" title="ssl.TLSVersion.TLSv1_2"><code class="xref py py-attr docutils literal notranslate"><span class="pre">TLSVersion.TLSv1_2</span></code></a> no podrá establecer una conexión TLS 1.2.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLContext.minimum_version">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">minimum_version</code><a class="headerlink" href="#ssl.SSLContext.minimum_version" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Igual que <a class="reference internal" href="#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.maximum_version</span></code></a> excepto que es la versión más baja soportada o <a class="reference internal" href="#ssl.TLSVersion.MINIMUM_SUPPORTED" title="ssl.TLSVersion.MINIMUM_SUPPORTED"><code class="xref py py-attr docutils literal notranslate"><span class="pre">TLSVersion.MINIMUM_SUPPORTED</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLContext.num_tickets">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">num_tickets</code><a class="headerlink" href="#ssl.SSLContext.num_tickets" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Controla el número de tickets de sesión TLS 1.3 de un contexto <code class="xref py py-attr docutils literal notranslate"><span class="pre">TLS_PROTOCOL_SERVER</span></code>. El ajuste no tiene impacto en las conexiones TLS 1.0 a 1.2.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLContext.options">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">options</code><a class="headerlink" href="#ssl.SSLContext.options" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un número entero que representa el conjunto de opciones SSL habilitadas en este contexto. El valor por defecto es <a class="reference internal" href="#ssl.OP_ALL" title="ssl.OP_ALL"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_ALL</span></code></a>, pero se pueden especificar otras opciones como <a class="reference internal" href="#ssl.OP_NO_SSLv2" title="ssl.OP_NO_SSLv2"><code class="xref py py-data docutils literal notranslate"><span class="pre">OP_NO_SSLv2</span></code></a> mediante la combinación OR.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span><a class="reference internal" href="#ssl.SSLContext.options" title="ssl.SSLContext.options"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.options</span></code></a> retorna opciones <a class="reference internal" href="#ssl.Options" title="ssl.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">Options</span></code></a>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span><span class="o">.</span><span class="n">options</span>  
<span class="go">&lt;Options.OP_ALL|OP_NO_SSLv3|OP_NO_SSLv2|OP_NO_COMPRESSION: 2197947391&gt;</span>
</pre></div>
</div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.7: </span>Esta opción es obsoleta desde OpenSSL 1.1.0, utilice en su lugar los nuevos <a class="reference internal" href="#ssl.SSLContext.minimum_version" title="ssl.SSLContext.minimum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.minimum_version</span></code></a> y <a class="reference internal" href="#ssl.SSLContext.maximum_version" title="ssl.SSLContext.maximum_version"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.maximum_version</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLContext.post_handshake_auth">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">post_handshake_auth</code><a class="headerlink" href="#ssl.SSLContext.post_handshake_auth" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Habilita la autenticación del cliente TLS 1.3 post-handshake. La autenticación post-handshake está deshabilitada por defecto y un servidor sólo puede solicitar un certificado de cliente TLS durante el handshake inicial. Cuando se habilita, un servidor puede solicitar un certificado de cliente TLS en cualquier momento después del handshake.</p>
<p>Cuando se activa en los sockets del lado del cliente, el cliente indica al servidor que soporta la autenticación post-handshake.</p>
<p>Cuando se activa en los sockets del lado del servidor, <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_mode</span></code></a> debe establecerse también como <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_OPTIONAL</span></code></a> o <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>. El intercambio real de certificados del cliente se retrasa hasta que se llama a <a class="reference internal" href="#ssl.SSLSocket.verify_client_post_handshake" title="ssl.SSLSocket.verify_client_post_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.verify_client_post_handshake()</span></code></a> y se realiza alguna E/S.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLContext.protocol">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">protocol</code><a class="headerlink" href="#ssl.SSLContext.protocol" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La versión del protocolo elegida cuando se construyó el contexto. Este atributo es de sólo lectura.</p>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLContext.hostname_checks_common_name">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">hostname_checks_common_name</code><a class="headerlink" href="#ssl.SSLContext.hostname_checks_common_name" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a> vuelve a verificar el nombre común del sujeto del certificado en ausencia de una extensión de nombre alternativo del sujeto (por defecto: true).</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>La bandera no tuvo ningún efecto con OpenSSL antes de la versión 1.1.1k. Python 3.8.9, 3.9.3 y 3.10 incluyen soluciones para versiones anteriores.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLContext.security_level">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">security_level</code><a class="headerlink" href="#ssl.SSLContext.security_level" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un número entero que representa el <a class="reference external" href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_security_level.html">security level</a> para el contexto. Este atributo es de solo lectura.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLContext.verify_flags">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">verify_flags</code><a class="headerlink" href="#ssl.SSLContext.verify_flags" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Los indicadores para las operaciones de verificación de certificados. Se pueden establecer indicadores como <a class="reference internal" href="#ssl.VERIFY_CRL_CHECK_LEAF" title="ssl.VERIFY_CRL_CHECK_LEAF"><code class="xref py py-data docutils literal notranslate"><span class="pre">VERIFY_CRL_CHECK_LEAF</span></code></a> mediante la combinación OR. Por defecto, OpenSSL no requiere ni verifica las listas de revocación de certificados (CRL). Disponible sólo con la versión 0.9.8+ de openssl.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span><a class="reference internal" href="#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_flags</span></code></a> retorna opciones <a class="reference internal" href="#ssl.VerifyFlags" title="ssl.VerifyFlags"><code class="xref py py-class docutils literal notranslate"><span class="pre">VerifyFlags</span></code></a>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span><span class="o">.</span><span class="n">verify_flags</span>  
<span class="go">&lt;VerifyFlags.VERIFY_X509_TRUSTED_FIRST: 32768&gt;</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLContext.verify_mode">
<code class="sig-prename descclassname">SSLContext.</code><code class="sig-name descname">verify_mode</code><a class="headerlink" href="#ssl.SSLContext.verify_mode" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si se intenta verificar los certificados de otros pares y cómo comportarse si la verificación falla. Este atributo debe ser uno de los siguientes: <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a>, <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_OPTIONAL</span></code></a> o <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span><a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.verify_mode</span></code></a> retorna <a class="reference internal" href="#ssl.VerifyMode" title="ssl.VerifyMode"><code class="xref py py-class docutils literal notranslate"><span class="pre">VerifyMode</span></code></a> enum:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span><span class="o">.</span><span class="n">verify_mode</span>
<span class="go">&lt;VerifyMode.CERT_REQUIRED: 2&gt;</span>
</pre></div>
</div>
</div>
</dd></dl>

<span class="target" id="index-18"></span></section>
<section id="certificates">
<span id="ssl-certificates"></span><span id="index-19"></span><h2>Certificados<a class="headerlink" href="#certificates" title="Enlazar permanentemente con este título">¶</a></h2>
<p>En general, los certificados forman parte de un sistema de clave pública/clave privada. En este sistema, a cada <em>principal</em> (que puede ser una máquina, una persona o una organización) se le asigna una clave de cifrado única de dos partes. Una parte de la clave es pública y se llama <em>clave pública</em>; la otra parte se mantiene en secreto y se llama <em>clave privada</em>. Las dos partes están relacionadas, en el sentido de que si se cifra un mensaje con una de las partes, se puede descifrar con la otra parte, y <strong>sólo</strong> con la otra parte.</p>
<p>Un certificado contiene información sobre dos sujetos. Contiene el nombre de un <em>sujeto</em>, y la clave pública del sujeto. También contiene una declaración de un segundo titular, el <em>emisor</em>, de que el sujeto es quien dice ser, y de que ésta es efectivamente la clave pública del sujeto. La declaración del emisor está firmada con su clave privada, que sólo el emisor conoce. Sin embargo, cualquiera puede verificar la declaración del emisor encontrando la clave pública del emisor, descifrando la declaración con ella y comparándola con el resto de la información del certificado. El certificado también contiene información sobre el periodo de tiempo en el que es válido. Esto se expresa en dos campos, llamados <em>notBefore</em> y <em>notAfter</em>.</p>
<p>En el uso de certificados en Python, un cliente o servidor puede utilizar un certificado para demostrar quién es. El otro lado de una conexión de red también puede ser requerido para producir un certificado, y ese certificado puede ser validado a la satisfacción del cliente o servidor que requiere dicha validación. El intento de conexión puede configurarse para que lance una excepción si la validación falla. La validación se realiza automáticamente, por el subyacente framework OpenSSL; la aplicación no necesita preocuparse de su mecánica. Sin embargo, la aplicación normalmente necesita proporcionar conjuntos de certificados para permitir que este proceso tenga lugar.</p>
<p>Python utiliza archivos para contener certificados. Deben ser formateados como «PEM» (ver <span class="target" id="index-60"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1422.html"><strong>RFC 1422</strong></a>), que es una forma codificada en base-64 envuelta con una línea de cabecera y una línea de pie de página:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">PEM</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
<section id="certificate-chains">
<h3>Cadenas de certificados<a class="headerlink" href="#certificate-chains" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Los archivos de Python que contienen certificados pueden contener una secuencia de certificados, a veces llamada <em>cadena de certificados</em>. Esta cadena debería empezar con el certificado específico para el principal que «es» el cliente o servidor, y luego el certificado para el emisor de ese certificado, y luego el certificado para el emisor de <em>ese</em> certificado, y así sucesivamente hasta llegar a un certificado que es <em>auto-firmado</em>, es decir, un certificado que tiene el mismo sujeto y emisor, a veces llamado <em>certificado raíz</em>. Los certificados sólo deben concatenarse en el archivo de certificados. Por ejemplo, supongamos que tenemos una cadena de tres certificados, desde el certificado de nuestro servidor al certificado de la autoridad de certificación que firmó nuestro certificado del servidor, hasta el certificado raíz de la agencia que emitió el certificado de la autoridad de certificación:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="k">for</span> <span class="n">your</span> <span class="n">server</span><span class="p">)</span><span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">the</span> <span class="n">certificate</span> <span class="k">for</span> <span class="n">the</span> <span class="n">CA</span><span class="p">)</span><span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">the</span> <span class="n">root</span> <span class="n">certificate</span> <span class="k">for</span> <span class="n">the</span> <span class="n">CA</span><span class="s1">&#39;s issuer)...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
</section>
<section id="ca-certificates">
<h3>Certificados CA<a class="headerlink" href="#ca-certificates" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Si se requiere la validación del certificado del otro lado de la conexión, se necesita proporcionar un archivo «CA certs», con las cadenas de certificados para cada emisor en el que se está dispuesto a confiar. De nuevo, este archivo sólo contiene estas cadenas concatenadas. Para la validación, Python utilizará la primera cadena que encuentre en el archivo que coincida. El archivo de certificados de la plataforma se puede utilizar llamando a <a class="reference internal" href="#ssl.SSLContext.load_default_certs" title="ssl.SSLContext.load_default_certs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_default_certs()</span></code></a>, esto se hace automáticamente con <a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a>.</p>
</section>
<section id="combined-key-and-certificate">
<h3>Clave y certificado combinados<a class="headerlink" href="#combined-key-and-certificate" title="Enlazar permanentemente con este título">¶</a></h3>
<p>A menudo la clave privada se almacena en el mismo archivo que el certificado; en este caso, sólo es necesario pasar el parámetro <code class="docutils literal notranslate"><span class="pre">certfile</span></code> a <a class="reference internal" href="#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_cert_chain()</span></code></a> y <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>. Si la clave privada se almacena con el certificado, debe ir antes del primer certificado de la cadena de certificados:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">RSA</span> <span class="n">PRIVATE</span> <span class="n">KEY</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">private</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">RSA</span> <span class="n">PRIVATE</span> <span class="n">KEY</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">PEM</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
</section>
<section id="self-signed-certificates">
<h3>Certificados auto-firmados<a class="headerlink" href="#self-signed-certificates" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Si va a crear un servidor que proporcione servicios de conexión encriptada SSL, necesitará adquirir un certificado para ese servicio. Hay muchas formas de adquirir los certificados adecuados, como comprar uno a una autoridad de certificación. Otra práctica común es generar un certificado auto-firmado. La forma más sencilla de hacerlo es con el paquete OpenSSL, utilizando algo como lo siguiente:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="n">openssl</span> <span class="n">req</span> <span class="o">-</span><span class="n">new</span> <span class="o">-</span><span class="n">x509</span> <span class="o">-</span><span class="n">days</span> <span class="mi">365</span> <span class="o">-</span><span class="n">nodes</span> <span class="o">-</span><span class="n">out</span> <span class="n">cert</span><span class="o">.</span><span class="n">pem</span> <span class="o">-</span><span class="n">keyout</span> <span class="n">cert</span><span class="o">.</span><span class="n">pem</span>
<span class="n">Generating</span> <span class="n">a</span> <span class="mi">1024</span> <span class="n">bit</span> <span class="n">RSA</span> <span class="n">private</span> <span class="n">key</span>
<span class="o">.......++++++</span>
<span class="o">.............................++++++</span>
<span class="n">writing</span> <span class="n">new</span> <span class="n">private</span> <span class="n">key</span> <span class="n">to</span> <span class="s1">&#39;cert.pem&#39;</span>
<span class="o">-----</span>
<span class="n">You</span> <span class="n">are</span> <span class="n">about</span> <span class="n">to</span> <span class="n">be</span> <span class="n">asked</span> <span class="n">to</span> <span class="n">enter</span> <span class="n">information</span> <span class="n">that</span> <span class="n">will</span> <span class="n">be</span> <span class="n">incorporated</span>
<span class="n">into</span> <span class="n">your</span> <span class="n">certificate</span> <span class="n">request</span><span class="o">.</span>
<span class="n">What</span> <span class="n">you</span> <span class="n">are</span> <span class="n">about</span> <span class="n">to</span> <span class="n">enter</span> <span class="ow">is</span> <span class="n">what</span> <span class="ow">is</span> <span class="n">called</span> <span class="n">a</span> <span class="n">Distinguished</span> <span class="n">Name</span> <span class="ow">or</span> <span class="n">a</span> <span class="n">DN</span><span class="o">.</span>
<span class="n">There</span> <span class="n">are</span> <span class="n">quite</span> <span class="n">a</span> <span class="n">few</span> <span class="n">fields</span> <span class="n">but</span> <span class="n">you</span> <span class="n">can</span> <span class="n">leave</span> <span class="n">some</span> <span class="n">blank</span>
<span class="n">For</span> <span class="n">some</span> <span class="n">fields</span> <span class="n">there</span> <span class="n">will</span> <span class="n">be</span> <span class="n">a</span> <span class="n">default</span> <span class="n">value</span><span class="p">,</span>
<span class="n">If</span> <span class="n">you</span> <span class="n">enter</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">the</span> <span class="n">field</span> <span class="n">will</span> <span class="n">be</span> <span class="n">left</span> <span class="n">blank</span><span class="o">.</span>
<span class="o">-----</span>
<span class="n">Country</span> <span class="n">Name</span> <span class="p">(</span><span class="mi">2</span> <span class="n">letter</span> <span class="n">code</span><span class="p">)</span> <span class="p">[</span><span class="n">AU</span><span class="p">]:</span><span class="n">US</span>
<span class="n">State</span> <span class="ow">or</span> <span class="n">Province</span> <span class="n">Name</span> <span class="p">(</span><span class="n">full</span> <span class="n">name</span><span class="p">)</span> <span class="p">[</span><span class="n">Some</span><span class="o">-</span><span class="n">State</span><span class="p">]:</span><span class="n">MyState</span>
<span class="n">Locality</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">city</span><span class="p">)</span> <span class="p">[]:</span><span class="n">Some</span> <span class="n">City</span>
<span class="n">Organization</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">company</span><span class="p">)</span> <span class="p">[</span><span class="n">Internet</span> <span class="n">Widgits</span> <span class="n">Pty</span> <span class="n">Ltd</span><span class="p">]:</span><span class="n">My</span> <span class="n">Organization</span><span class="p">,</span> <span class="n">Inc</span><span class="o">.</span>
<span class="n">Organizational</span> <span class="n">Unit</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">section</span><span class="p">)</span> <span class="p">[]:</span><span class="n">My</span> <span class="n">Group</span>
<span class="n">Common</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">YOUR</span> <span class="n">name</span><span class="p">)</span> <span class="p">[]:</span><span class="n">myserver</span><span class="o">.</span><span class="n">mygroup</span><span class="o">.</span><span class="n">myorganization</span><span class="o">.</span><span class="n">com</span>
<span class="n">Email</span> <span class="n">Address</span> <span class="p">[]:</span><span class="n">ops</span><span class="nd">@myserver</span><span class="o">.</span><span class="n">mygroup</span><span class="o">.</span><span class="n">myorganization</span><span class="o">.</span><span class="n">com</span>
<span class="o">%</span>
</pre></div>
</div>
<p>La desventaja de un certificado auto-firmado es que es su propio certificado raíz, y nadie más lo tendrá en su caché de certificados raíz conocidos (y de confianza).</p>
</section>
</section>
<section id="examples">
<h2>Ejemplos<a class="headerlink" href="#examples" title="Enlazar permanentemente con este título">¶</a></h2>
<section id="testing-for-ssl-support">
<h3>Pruebas de compatibilidad con SSL<a class="headerlink" href="#testing-for-ssl-support" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para comprobar la presencia de soporte SSL en una instalación de Python, el código del usuario debe utilizar el siguiente modismo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">ssl</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="k">else</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># do something that requires SSL support</span>
</pre></div>
</div>
</section>
<section id="client-side-operation">
<h3>Operación del lado del cliente<a class="headerlink" href="#client-side-operation" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Este ejemplo crea un contexto SSL con la configuración de seguridad recomendada para los sockets del cliente, incluyendo la verificación automática de certificados:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span>
</pre></div>
</div>
<p>Si prefieres ajustar la configuración de seguridad tú mismo, puedes crear un contexto desde cero (pero ten en cuenta que podrías no acertar con la configuración):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLS_CLIENT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">load_verify_locations</span><span class="p">(</span><span class="s2">&quot;/etc/ssl/certs/ca-bundle.crt&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>(este fragmento asume que tu sistema operativo coloca un paquete de todos los certificados CA en <code class="docutils literal notranslate"><span class="pre">/etc/ssl/certs/ca-bundle.crt</span></code>; si no es así, obtendrá un error y tendrá que ajustar la ubicación)</p>
<p>El protocolo <a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> configura el contexto para la validación de certificados y la verificación del hostname. <a class="reference internal" href="#ssl.SSLContext.verify_mode" title="ssl.SSLContext.verify_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verify_mode</span></code></a> se establece en <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-data docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> y <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a> se establece en <code class="docutils literal notranslate"><span class="pre">True</span></code>. Todos los demás protocolos crean contextos SSL con valores predeterminados inseguros.</p>
<p>Cuando se utiliza el contexto para conectarse a un servidor, <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> y <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">check_hostname</span></code></a> validan el certificado del servidor: se asegura de que el certificado del servidor se ha firmado con uno de los certificados de la CA, se comprueba que la firma es correcta y se verifican otras propiedades como la validez y la identidad del hostname:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">),</span>
<span class="gp">... </span>                           <span class="n">server_hostname</span><span class="o">=</span><span class="s2">&quot;www.python.org&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s2">&quot;www.python.org&quot;</span><span class="p">,</span> <span class="mi">443</span><span class="p">))</span>
</pre></div>
</div>
<p>A continuación, puede obtener el certificado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cert</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">getpeercert</span><span class="p">()</span>
</pre></div>
</div>
<p>La inspección visual muestra que el certificado sí identifica el servicio deseado (es decir, el host HTTPS <code class="docutils literal notranslate"><span class="pre">www.python.org</span></code>):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">cert</span><span class="p">)</span>
<span class="go">{&#39;OCSP&#39;: (&#39;http://ocsp.digicert.com&#39;,),</span>
<span class="go"> &#39;caIssuers&#39;: (&#39;http://cacerts.digicert.com/DigiCertSHA2ExtendedValidationServerCA.crt&#39;,),</span>
<span class="go"> &#39;crlDistributionPoints&#39;: (&#39;http://crl3.digicert.com/sha2-ev-server-g1.crl&#39;,</span>
<span class="go">                           &#39;http://crl4.digicert.com/sha2-ev-server-g1.crl&#39;),</span>
<span class="go"> &#39;issuer&#39;: (((&#39;countryName&#39;, &#39;US&#39;),),</span>
<span class="go">            ((&#39;organizationName&#39;, &#39;DigiCert Inc&#39;),),</span>
<span class="go">            ((&#39;organizationalUnitName&#39;, &#39;www.digicert.com&#39;),),</span>
<span class="go">            ((&#39;commonName&#39;, &#39;DigiCert SHA2 Extended Validation Server CA&#39;),)),</span>
<span class="go"> &#39;notAfter&#39;: &#39;Sep  9 12:00:00 2016 GMT&#39;,</span>
<span class="go"> &#39;notBefore&#39;: &#39;Sep  5 00:00:00 2014 GMT&#39;,</span>
<span class="go"> &#39;serialNumber&#39;: &#39;01BB6F00122B177F36CAB49CEA8B6B26&#39;,</span>
<span class="go"> &#39;subject&#39;: (((&#39;businessCategory&#39;, &#39;Private Organization&#39;),),</span>
<span class="go">             ((&#39;1.3.6.1.4.1.311.60.2.1.3&#39;, &#39;US&#39;),),</span>
<span class="go">             ((&#39;1.3.6.1.4.1.311.60.2.1.2&#39;, &#39;Delaware&#39;),),</span>
<span class="go">             ((&#39;serialNumber&#39;, &#39;3359300&#39;),),</span>
<span class="go">             ((&#39;streetAddress&#39;, &#39;16 Allen Rd&#39;),),</span>
<span class="go">             ((&#39;postalCode&#39;, &#39;03894-4801&#39;),),</span>
<span class="go">             ((&#39;countryName&#39;, &#39;US&#39;),),</span>
<span class="go">             ((&#39;stateOrProvinceName&#39;, &#39;NH&#39;),),</span>
<span class="go">             ((&#39;localityName&#39;, &#39;Wolfeboro&#39;),),</span>
<span class="go">             ((&#39;organizationName&#39;, &#39;Python Software Foundation&#39;),),</span>
<span class="go">             ((&#39;commonName&#39;, &#39;www.python.org&#39;),)),</span>
<span class="go"> &#39;subjectAltName&#39;: ((&#39;DNS&#39;, &#39;www.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;pypi.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;docs.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;testpypi.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;bugs.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;wiki.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;hg.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;mail.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;packaging.python.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;pythonhosted.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;www.pythonhosted.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;test.pythonhosted.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;us.pycon.org&#39;),</span>
<span class="go">                    (&#39;DNS&#39;, &#39;id.python.org&#39;)),</span>
<span class="go"> &#39;version&#39;: 3}</span>
</pre></div>
</div>
<p>Ahora que se ha establecido el canal SSL y se ha verificado el certificado, se puede proceder a hablar con el servidor:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">conn</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;HEAD / HTTP/1.0</span><span class="se">\r\n</span><span class="s2">Host: linuxfr.org</span><span class="se">\r\n\r\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="se">\r\n</span><span class="s2">&quot;</span><span class="p">))</span>
<span class="go">[b&#39;HTTP/1.1 200 OK&#39;,</span>
<span class="go"> b&#39;Date: Sat, 18 Oct 2014 18:27:20 GMT&#39;,</span>
<span class="go"> b&#39;Server: nginx&#39;,</span>
<span class="go"> b&#39;Content-Type: text/html; charset=utf-8&#39;,</span>
<span class="go"> b&#39;X-Frame-Options: SAMEORIGIN&#39;,</span>
<span class="go"> b&#39;Content-Length: 45679&#39;,</span>
<span class="go"> b&#39;Accept-Ranges: bytes&#39;,</span>
<span class="go"> b&#39;Via: 1.1 varnish&#39;,</span>
<span class="go"> b&#39;Age: 2188&#39;,</span>
<span class="go"> b&#39;X-Served-By: cache-lcy1134-LCY&#39;,</span>
<span class="go"> b&#39;X-Cache: HIT&#39;,</span>
<span class="go"> b&#39;X-Cache-Hits: 11&#39;,</span>
<span class="go"> b&#39;Vary: Cookie&#39;,</span>
<span class="go"> b&#39;Strict-Transport-Security: max-age=63072000; includeSubDomains&#39;,</span>
<span class="go"> b&#39;Connection: close&#39;,</span>
<span class="go"> b&#39;&#39;,</span>
<span class="go"> b&#39;&#39;]</span>
</pre></div>
</div>
<p>Vea la discusión sobre <a class="reference internal" href="#ssl-security"><span class="std std-ref">Consideraciones de seguridad</span></a> más abajo.</p>
</section>
<section id="server-side-operation">
<h3>Operación del lado del servidor<a class="headerlink" href="#server-side-operation" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para el funcionamiento del servidor, normalmente necesitarás tener un certificado de servidor y una clave privada, cada uno en un archivo. Primero crearás un contexto que contenga la clave y el certificado, para que los clientes puedan comprobar tu autenticidad. Entonces abrirás un socket, lo enlazarás a un puerto, llamarás a <code class="xref py py-meth docutils literal notranslate"><span class="pre">listen()</span></code> en él, y empezarás a esperar a que los clientes se conecten:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">ssl</span>

<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">Purpose</span><span class="o">.</span><span class="n">CLIENT_AUTH</span><span class="p">)</span>
<span class="n">context</span><span class="o">.</span><span class="n">load_cert_chain</span><span class="p">(</span><span class="n">certfile</span><span class="o">=</span><span class="s2">&quot;mycertfile&quot;</span><span class="p">,</span> <span class="n">keyfile</span><span class="o">=</span><span class="s2">&quot;mykeyfile&quot;</span><span class="p">)</span>

<span class="n">bindsocket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="n">bindsocket</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;myaddr.example.com&#39;</span><span class="p">,</span> <span class="mi">10023</span><span class="p">))</span>
<span class="n">bindsocket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Cuando un cliente se conecta, llamarás a <code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code> en el socket para obtener el nuevo socket del otro extremo, y utilizarás el método <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.wrap_socket()</span></code></a> del contexto para crear un socket SSL del lado del servidor para la conexión:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">newsocket</span><span class="p">,</span> <span class="n">fromaddr</span> <span class="o">=</span> <span class="n">bindsocket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
    <span class="n">connstream</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">newsocket</span><span class="p">,</span> <span class="n">server_side</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">deal_with_client</span><span class="p">(</span><span class="n">connstream</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">connstream</span><span class="o">.</span><span class="n">shutdown</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SHUT_RDWR</span><span class="p">)</span>
        <span class="n">connstream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>Entonces leerás los datos del <code class="docutils literal notranslate"><span class="pre">connstream</span></code> y harás algo con ellos hasta que hayas terminado con el cliente (o el cliente haya terminado contigo):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">deal_with_client</span><span class="p">(</span><span class="n">connstream</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">connstream</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
    <span class="c1"># empty data means the client is finished with us</span>
    <span class="k">while</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">do_something</span><span class="p">(</span><span class="n">connstream</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
            <span class="c1"># we&#39;ll assume do_something returns False</span>
            <span class="c1"># when we&#39;re finished with client</span>
            <span class="k">break</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">connstream</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
    <span class="c1"># finished with client</span>
</pre></div>
</div>
<p>Y volver a escuchar nuevas conexiones de clientes (por supuesto, un servidor real probablemente manejaría cada conexión de cliente en un hilo separado, o pondría los sockets en modo <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">no-bloqueo</span></a> y usaría un bucle de eventos).</p>
</section>
</section>
<section id="notes-on-non-blocking-sockets">
<span id="ssl-nonblocking"></span><h2>Notas sobre los sockets no bloqueantes<a class="headerlink" href="#notes-on-non-blocking-sockets" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los sockets SSL se comportan de forma ligeramente diferente a los sockets normales en modo no bloqueante. Cuando se trabaja con sockets no bloqueantes, hay varias cosas que hay que tener en cuenta:</p>
<ul>
<li><p>La mayoría de los métodos de <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> lanzarán <a class="reference internal" href="#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a> o <a class="reference internal" href="#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> en lugar de <a class="reference internal" href="exceptions.html#BlockingIOError" title="BlockingIOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BlockingIOError</span></code></a> si una operación de E/S se bloquea. <a class="reference internal" href="#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> se lanzará si es necesaria una operación de lectura en el socket subyacente, y <a class="reference internal" href="#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a> para una operación de escritura en el socket subyacente. Tenga en cuenta que los intentos de <em>escribir</em> en un socket SSL pueden requerir <em>leer</em> del socket subyacente primero, y los intentos de <em>leer</em> del socket SSL pueden requerir una <em>escritura</em> previa en el socket subyacente.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>En versiones anteriores de Python, el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.send()</span></code> devolvía cero en lugar de lanzar <a class="reference internal" href="#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a> o <a class="reference internal" href="#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a>.</p>
</div>
</li>
<li><p>Llamar a <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> le indica que se puede leer (o escribir) en el socket a nivel del SO, pero no implica que haya suficientes datos en la capa superior SSL. Por ejemplo, puede que sólo haya llegado una parte de una trama SSL. Por lo tanto, debe estar preparado para manejar los fallos de <code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.recv()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.send()</span></code>, y re-intentar después de otra llamada a <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>.</p></li>
<li><p>Por el contrario, dado que la capa SSL tiene su propia estructura, un socket SSL puede tener datos disponibles para leer sin que <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> lo sepa. Por lo tanto, debería llamar primero a <code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.recv()</span></code> para drenar cualquier dato potencialmente disponible, y luego sólo bloquear en una llamada a <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> si todavía es necesario.</p>
<p>(por supuesto, se aplican disposiciones similares cuando se utilizan otras primitivas como <a class="reference internal" href="select.html#select.poll" title="select.poll"><code class="xref py py-func docutils literal notranslate"><span class="pre">poll()</span></code></a>, o las del módulo <a class="reference internal" href="selectors.html#module-selectors" title="selectors: High-level I/O multiplexing."><code class="xref py py-mod docutils literal notranslate"><span class="pre">selectors</span></code></a>)</p>
</li>
<li><p>El handshake SSL en sí mismo será no bloqueante: el método <a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.do_handshake()</span></code></a> tiene que ser re-intentado hasta que regrese con éxito. Aquí hay una sinopsis usando <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> para esperar la disponibilidad del socket:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">do_handshake</span><span class="p">()</span>
        <span class="k">break</span>
    <span class="k">except</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLWantReadError</span><span class="p">:</span>
        <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="n">sock</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[])</span>
    <span class="k">except</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLWantWriteError</span><span class="p">:</span>
        <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([],</span> <span class="p">[</span><span class="n">sock</span><span class="p">],</span> <span class="p">[])</span>
</pre></div>
</div>
</li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>El módulo <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> soporta <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">sockets SSL no bloqueantes</span></a> y proporciona una API de alto nivel. Busca eventos usando el módulo <a class="reference internal" href="selectors.html#module-selectors" title="selectors: High-level I/O multiplexing."><code class="xref py py-mod docutils literal notranslate"><span class="pre">selectors</span></code></a> y maneja las excepciones <a class="reference internal" href="#ssl.SSLWantWriteError" title="ssl.SSLWantWriteError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantWriteError</span></code></a>, <a class="reference internal" href="#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> y <a class="reference internal" href="exceptions.html#BlockingIOError" title="BlockingIOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BlockingIOError</span></code></a>. También ejecuta el handshake SSL de forma asíncrona.</p>
</div>
</section>
<section id="memory-bio-support">
<h2>Soporte de memoria BIO<a class="headerlink" href="#memory-bio-support" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
<p>Desde que se introdujo el módulo SSL en Python 2.6, la clase <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> ha proporcionado dos áreas de funcionalidad relacionadas pero distintas:</p>
<ul class="simple">
<li><p>Manejo del protocolo SSL</p></li>
<li><p>E/S de red</p></li>
</ul>
<p>La API de E/S de red es idéntica a la proporcionada por <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a>, de la que también hereda <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a>. Esto permite que un socket SSL sea utilizado como un reemplazo de un socket normal, haciendo que sea muy fácil añadir soporte SSL a una aplicación existente.</p>
<p>La combinación del manejo del protocolo SSL y la E/S de red suele funcionar bien, pero hay algunos casos en los que no es así. Un ejemplo son los frameworks de E/S asíncronos que quieren utilizar un modelo de multiplexación de E/S diferente al modelo «selección/consulta de un descriptor de archivo» (basado en la preparación) que es asumido por <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> y por las rutinas internas de E/S de socket de OpenSSL. Esto es principalmente relevante para plataformas como Windows donde este modelo no es eficiente. Para este propósito, se proporciona una variante de ámbito reducido de <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> llamada <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a>.</p>
<dl class="py class">
<dt id="ssl.SSLObject">
<em class="property">class </em><code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">SSLObject</code><a class="headerlink" href="#ssl.SSLObject" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una variante de alcance reducido de <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> que representa una instancia del protocolo SSL que no contiene ningún método de E/S de red. Esta clase suele ser utilizada por los autores de frameworks que quieren implementar E/S asíncrona para SSL a través de búfers de memoria.</p>
<p>Esta clase implementa una interfaz sobre un objeto SSL de bajo nivel como el implementado por OpenSSL. Este objeto captura el estado de una conexión SSL pero no proporciona ninguna E/S de red en sí misma. La E/S debe realizarse a través de objetos «BIO» separados que son la capa de abstracción de E/S de OpenSSL.</p>
<p>Esta clase no tiene un constructor público. Se debe crear una instancia <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> utilizando el método <a class="reference internal" href="#ssl.SSLContext.wrap_bio" title="ssl.SSLContext.wrap_bio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wrap_bio()</span></code></a>. Este método creará la instancia <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> y la vinculará a un par de BIOs. El BIO <em>de entrada</em> se utiliza para pasar los datos de Python a la instancia del protocolo SSL, mientras que el BIO <em>de salida</em> se utiliza para pasar los datos a la inversa.</p>
<p>Los siguientes métodos son disponibles:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#ssl.SSLSocket.context" title="ssl.SSLSocket.context"><code class="xref py py-attr docutils literal notranslate"><span class="pre">context</span></code></a></p></li>
<li><p><a class="reference internal" href="#ssl.SSLSocket.server_side" title="ssl.SSLSocket.server_side"><code class="xref py py-attr docutils literal notranslate"><span class="pre">server_side</span></code></a></p></li>
<li><p><a class="reference internal" href="#ssl.SSLSocket.server_hostname" title="ssl.SSLSocket.server_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">server_hostname</span></code></a></p></li>
<li><p><a class="reference internal" href="#ssl.SSLSocket.session" title="ssl.SSLSocket.session"><code class="xref py py-attr docutils literal notranslate"><span class="pre">session</span></code></a></p></li>
<li><p><a class="reference internal" href="#ssl.SSLSocket.session_reused" title="ssl.SSLSocket.session_reused"><code class="xref py py-attr docutils literal notranslate"><span class="pre">session_reused</span></code></a></p></li>
<li><p><a class="reference internal" href="#ssl.SSLSocket.read" title="ssl.SSLSocket.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a></p></li>
<li><p><a class="reference internal" href="#ssl.SSLSocket.write" title="ssl.SSLSocket.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a></p></li>
<li><p><a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getpeercert()</span></code></a></p></li>
<li><p><a class="reference internal" href="#ssl.SSLSocket.selected_alpn_protocol" title="ssl.SSLSocket.selected_alpn_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">selected_alpn_protocol()</span></code></a></p></li>
<li><p><a class="reference internal" href="#ssl.SSLSocket.selected_npn_protocol" title="ssl.SSLSocket.selected_npn_protocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">selected_npn_protocol()</span></code></a></p></li>
<li><p><a class="reference internal" href="#ssl.SSLSocket.cipher" title="ssl.SSLSocket.cipher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cipher()</span></code></a></p></li>
<li><p><a class="reference internal" href="#ssl.SSLSocket.shared_ciphers" title="ssl.SSLSocket.shared_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shared_ciphers()</span></code></a></p></li>
<li><p><a class="reference internal" href="#ssl.SSLSocket.compression" title="ssl.SSLSocket.compression"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compression()</span></code></a></p></li>
<li><p><a class="reference internal" href="#ssl.SSLSocket.pending" title="ssl.SSLSocket.pending"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pending()</span></code></a></p></li>
<li><p><a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">do_handshake()</span></code></a></p></li>
<li><p><a class="reference internal" href="#ssl.SSLSocket.verify_client_post_handshake" title="ssl.SSLSocket.verify_client_post_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">verify_client_post_handshake()</span></code></a></p></li>
<li><p><a class="reference internal" href="#ssl.SSLSocket.unwrap" title="ssl.SSLSocket.unwrap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unwrap()</span></code></a></p></li>
<li><p><a class="reference internal" href="#ssl.SSLSocket.get_channel_binding" title="ssl.SSLSocket.get_channel_binding"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_channel_binding()</span></code></a></p></li>
<li><p><a class="reference internal" href="#ssl.SSLSocket.version" title="ssl.SSLSocket.version"><code class="xref py py-meth docutils literal notranslate"><span class="pre">version()</span></code></a></p></li>
</ul>
<p>En comparación con <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a>, este objeto carece de las siguientes características:</p>
<ul class="simple">
<li><p>Cualquier forma de E/S de red; <code class="docutils literal notranslate"><span class="pre">recv()</span></code> y <code class="docutils literal notranslate"><span class="pre">send()</span></code> leen y escriben sólo en los búfers subyacentes de <a class="reference internal" href="#ssl.MemoryBIO" title="ssl.MemoryBIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryBIO</span></code></a>.</p></li>
<li><p>No existe la maquinaria <em>do_handshake_on_connect</em>. Siempre hay que llamar manualmente a <a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">do_handshake()</span></code></a> para iniciar el handshake.</p></li>
<li><p>No hay manejo de <em>suppress_ragged_eofs</em>. Todas las condiciones de fin de archivo que violan el protocolo se reportan a través de la excepción <a class="reference internal" href="#ssl.SSLEOFError" title="ssl.SSLEOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLEOFError</span></code></a>.</p></li>
<li><p>La llamada al método <a class="reference internal" href="#ssl.SSLSocket.unwrap" title="ssl.SSLSocket.unwrap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unwrap()</span></code></a> no devuelve nada, a diferencia de lo que ocurre con un socket SSL, que devuelve el socket subyacente.</p></li>
<li><p>La función callback <em>server_name_callback</em> pasada a <a class="reference internal" href="#ssl.SSLContext.set_servername_callback" title="ssl.SSLContext.set_servername_callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_servername_callback()</span></code></a> obtendrá una instancia de <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> en lugar de una instancia de <a class="reference internal" href="#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> como primer parámetro.</p></li>
</ul>
<p>Algunas notas relacionadas con el uso de <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a>:</p>
<ul class="simple">
<li><p>Toda la E/S en un <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> es <a class="reference internal" href="#ssl-nonblocking"><span class="std std-ref">non-blocking</span></a>. Esto significa que, por ejemplo, <a class="reference internal" href="#ssl.SSLSocket.read" title="ssl.SSLSocket.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> lanzará un <a class="reference internal" href="#ssl.SSLWantReadError" title="ssl.SSLWantReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLWantReadError</span></code></a> si necesita más datos de los que la BIO entrante tiene disponibles.</p></li>
<li><p>No hay una llamada a nivel de módulo <code class="docutils literal notranslate"><span class="pre">wrap_bio()</span></code> como la que hay para <a class="reference internal" href="#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>. Un <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> siempre se crea a través de un <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a>.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Las instancias <a class="reference internal" href="#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> deben crearse con <a class="reference internal" href="#ssl.SSLContext.wrap_bio" title="ssl.SSLContext.wrap_bio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wrap_bio()</span></code></a>. En versiones anteriores, era posible crear instancias directamente. Esto nunca fue documentado ni soportado oficialmente.</p>
</div>
</dd></dl>

<p>Un SSLObject se comunica con el mundo exterior utilizando búfers de memoria. La clase <a class="reference internal" href="#ssl.MemoryBIO" title="ssl.MemoryBIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryBIO</span></code></a> proporciona un búfer de memoria que puede ser utilizado para este propósito. Envuelve un objeto BIO (Basic IO) de memoria de OpenSSL:</p>
<dl class="py class">
<dt id="ssl.MemoryBIO">
<em class="property">class </em><code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">MemoryBIO</code><a class="headerlink" href="#ssl.MemoryBIO" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un búfer de memoria que se puede utilizar para pasar datos entre Python y una instancia del protocolo SSL.</p>
<dl class="py attribute">
<dt id="ssl.MemoryBIO.pending">
<code class="sig-name descname">pending</code><a class="headerlink" href="#ssl.MemoryBIO.pending" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el número de bytes que se encuentran actualmente en la memoria búfer.</p>
</dd></dl>

<dl class="py attribute">
<dt id="ssl.MemoryBIO.eof">
<code class="sig-name descname">eof</code><a class="headerlink" href="#ssl.MemoryBIO.eof" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un booleano que indica si la memoria BIO es actual en la posición de fin de archivo.</p>
</dd></dl>

<dl class="py method">
<dt id="ssl.MemoryBIO.read">
<code class="sig-name descname">read</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">- 1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.MemoryBIO.read" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Lee hasta <em>n</em> bytes del búfer de memoria. Si <em>n</em> no se especifica o es negativo, se devuelven todos los bytes.</p>
</dd></dl>

<dl class="py method">
<dt id="ssl.MemoryBIO.write">
<code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">buf</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.MemoryBIO.write" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Escribe los bytes de <em>buf</em> en la memoria BIO. El argumento <em>buf</em> debe ser un objeto que soporte el protocolo de búfer.</p>
<p>El valor de retorno es el número de bytes escritos, que siempre es igual a la longitud de <em>buf</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="ssl.MemoryBIO.write_eof">
<code class="sig-name descname">write_eof</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.MemoryBIO.write_eof" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Escribe un marcador EOF en la memoria BIO. Después de llamar a este método, es ilegal llamar a <a class="reference internal" href="#ssl.MemoryBIO.write" title="ssl.MemoryBIO.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a>. El atributo <a class="reference internal" href="#ssl.MemoryBIO.eof" title="ssl.MemoryBIO.eof"><code class="xref py py-attr docutils literal notranslate"><span class="pre">eof</span></code></a> se convertirá en verdadero después de que se hayan leído todos los datos que hay actualmente en el búfer.</p>
</dd></dl>

</dd></dl>

</section>
<section id="ssl-session">
<h2>Sesión SSL<a class="headerlink" href="#ssl-session" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.</span></p>
</div>
<dl class="py class">
<dt id="ssl.SSLSession">
<em class="property">class </em><code class="sig-prename descclassname">ssl.</code><code class="sig-name descname">SSLSession</code><a class="headerlink" href="#ssl.SSLSession" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Objeto sesión usado por <a class="reference internal" href="#ssl.SSLSocket.session" title="ssl.SSLSocket.session"><code class="xref py py-attr docutils literal notranslate"><span class="pre">session</span></code></a>.</p>
<dl class="py attribute">
<dt id="ssl.SSLSession.id">
<code class="sig-name descname">id</code><a class="headerlink" href="#ssl.SSLSession.id" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLSession.time">
<code class="sig-name descname">time</code><a class="headerlink" href="#ssl.SSLSession.time" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLSession.timeout">
<code class="sig-name descname">timeout</code><a class="headerlink" href="#ssl.SSLSession.timeout" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLSession.ticket_lifetime_hint">
<code class="sig-name descname">ticket_lifetime_hint</code><a class="headerlink" href="#ssl.SSLSession.ticket_lifetime_hint" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="ssl.SSLSession.has_ticket">
<code class="sig-name descname">has_ticket</code><a class="headerlink" href="#ssl.SSLSession.has_ticket" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="security-considerations">
<span id="ssl-security"></span><h2>Consideraciones de seguridad<a class="headerlink" href="#security-considerations" title="Enlazar permanentemente con este título">¶</a></h2>
<section id="best-defaults">
<h3>Los mejores valores por defecto<a class="headerlink" href="#best-defaults" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para el <strong>uso en el cliente</strong>, si no tiene ningún requisito especial para su política de seguridad, es muy recomendable que utilice la función <a class="reference internal" href="#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> para crear su contexto SSL. Cargará los certificados CA de confianza del sistema, habilitará la validación de certificados y la comprobación del hostname, e intentará elegir una configuración de protocolo y cifrado razonablemente segura.</p>
<p>Por ejemplo, así es como se utiliza la clase <a class="reference internal" href="smtplib.html#smtplib.SMTP" title="smtplib.SMTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">smtplib.SMTP</span></code></a> para crear una conexión segura y de confianza con un servidor SMTP:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ssl</span><span class="o">,</span> <span class="nn">smtplib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smtp</span> <span class="o">=</span> <span class="n">smtplib</span><span class="o">.</span><span class="n">SMTP</span><span class="p">(</span><span class="s2">&quot;mail.python.org&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">587</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">smtp</span><span class="o">.</span><span class="n">starttls</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
<span class="go">(220, b&#39;2.0.0 Ready to start TLS&#39;)</span>
</pre></div>
</div>
<p>Si se necesita un certificado de cliente para la conexión, se puede añadir con <a class="reference internal" href="#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.load_cert_chain()</span></code></a>.</p>
<p>Por el contrario, si crea el contexto SSL llamando usted mismo al constructor <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a>, no tendrá activada por defecto la validación de certificados ni la comprobación de hostname. Si lo hace, lea los párrafos siguientes para conseguir un buen nivel de seguridad.</p>
</section>
<section id="manual-settings">
<h3>Ajustes manuales<a class="headerlink" href="#manual-settings" title="Enlazar permanentemente con este título">¶</a></h3>
<section id="verifying-certificates">
<h4>Verificación de certificados<a class="headerlink" href="#verifying-certificates" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Cuando se llama al constructor de <a class="reference internal" href="#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> directamente, <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a> es el valor por defecto. Dado que no autentifica al otro peer, puede ser inseguro, especialmente en modo cliente, donde la mayoría de las veces se quiere asegurar la autenticidad del servidor con el que se está hablando. Por lo tanto, cuando se está en modo cliente, es muy recomendable utilizar <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>. Sin embargo, no es suficiente por sí mismo; también hay que comprobar que el certificado del servidor, que se puede obtener llamando a <a class="reference internal" href="#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.getpeercert()</span></code></a>, coincide con el servicio deseado. Para muchos protocolos y aplicaciones, el servicio puede ser identificado por el hostname; en este caso, se puede utilizar la función <a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_hostname()</span></code></a>. Esta comprobación común se realiza automáticamente cuando <a class="reference internal" href="#ssl.SSLContext.check_hostname" title="ssl.SSLContext.check_hostname"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.check_hostname</span></code></a> está activado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Las hostname matchings son ahora realizadas por OpenSSL. Python ya no utiliza <a class="reference internal" href="#ssl.match_hostname" title="ssl.match_hostname"><code class="xref py py-func docutils literal notranslate"><span class="pre">match_hostname()</span></code></a>.</p>
</div>
<p>En el modo servidor, si quiere autenticar a sus clientes utilizando la capa SSL (en lugar de utilizar un mecanismo de autenticación de nivel superior), también tendrá que especificar <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> y comprobar de forma similar el certificado del cliente.</p>
</section>
<section id="protocol-versions">
<h4>Versiones del protocolo<a class="headerlink" href="#protocol-versions" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Las versiones 2 y 3 de SSL se consideran inseguras y, por lo tanto, su uso es peligroso. Si desea la máxima compatibilidad entre clientes y servidores, se recomienda utilizar <a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> o <a class="reference internal" href="#ssl.PROTOCOL_TLS_SERVER" title="ssl.PROTOCOL_TLS_SERVER"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS_SERVER</span></code></a> como versión del protocolo. SSLv2 y SSLv3 están desactivados por defecto.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">client_context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLContext</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLS_CLIENT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">client_context</span><span class="o">.</span><span class="n">minimum_version</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">TLSVersion</span><span class="o">.</span><span class="n">TLSv1_3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">client_context</span><span class="o">.</span><span class="n">maximum_version</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">TLSVersion</span><span class="o">.</span><span class="n">TLSv1_3</span>
</pre></div>
</div>
<p>El contexto SSL creado anteriormente sólo permitirá conexiones TLSv1.2 y posteriores (si su sistema lo soporta) a un servidor. <a class="reference internal" href="#ssl.PROTOCOL_TLS_CLIENT" title="ssl.PROTOCOL_TLS_CLIENT"><code class="xref py py-const docutils literal notranslate"><span class="pre">PROTOCOL_TLS_CLIENT</span></code></a> implica la validación del certificado y la comprobación del nombre de host por defecto. Tiene que cargar los certificados en el contexto.</p>
</section>
<section id="cipher-selection">
<h4>Selección de cifrado<a class="headerlink" href="#cipher-selection" title="Enlazar permanentemente con este título">¶</a></h4>
<p>If you have advanced security requirements, fine-tuning of the ciphers
enabled when negotiating a SSL session is possible through the
<a class="reference internal" href="#ssl.SSLContext.set_ciphers" title="ssl.SSLContext.set_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_ciphers()</span></code></a> method.  Starting from Python 3.2.3, the
ssl module disables certain weak ciphers by default, but you may want
to further restrict the cipher choice. Be sure to read OpenSSL’s documentation
about the <a class="reference external" href="https://www.openssl.org/docs/man1.1.1/man1/ciphers.html#CIPHER-LIST-FORMAT">cipher list format</a>.
If you want to check which ciphers are enabled by a given cipher list, use
<a class="reference internal" href="#ssl.SSLContext.get_ciphers" title="ssl.SSLContext.get_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.get_ciphers()</span></code></a> or the <code class="docutils literal notranslate"><span class="pre">openssl</span> <span class="pre">ciphers</span></code> command on your
system.</p>
</section>
</section>
<section id="multi-processing">
<h3>Multiprocesamiento<a class="headerlink" href="#multi-processing" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Si utiliza este módulo como parte de una aplicación multiproceso (utilizando, por ejemplo, los módulos <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> o <a class="reference internal" href="concurrent.futures.html#module-concurrent.futures" title="concurrent.futures: Execute computations concurrently using threads or processes."><code class="xref py py-mod docutils literal notranslate"><span class="pre">concurrent.futures</span></code></a>), tenga en cuenta que el generador de números aleatorios interno de OpenSSL no maneja adecuadamente los procesos bifurcados. Las aplicaciones deben cambiar el estado del PRNG del proceso padre si utilizan cualquier función de SSL con <a class="reference internal" href="os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a>. Cualquier llamada exitosa de <a class="reference internal" href="#ssl.RAND_add" title="ssl.RAND_add"><code class="xref py py-func docutils literal notranslate"><span class="pre">RAND_add()</span></code></a>, <a class="reference internal" href="#ssl.RAND_bytes" title="ssl.RAND_bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">RAND_bytes()</span></code></a> o <a class="reference internal" href="#ssl.RAND_pseudo_bytes" title="ssl.RAND_pseudo_bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">RAND_pseudo_bytes()</span></code></a> es suficiente.</p>
</section>
</section>
<section id="tls-1-3">
<span id="ssl-tlsv1-3"></span><h2>TLS 1.3<a class="headerlink" href="#tls-1-3" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
<p>Python tiene soporte provisional y experimental para TLS 1.3 con OpenSSL 1.1.1. El nuevo protocolo se comporta de forma ligeramente diferente a la versión anterior de TLS/SSL. Algunas de las nuevas características de TLS 1.3 aún no están disponibles.</p>
<ul class="simple">
<li><p>TLS 1.3 utiliza un conjunto disjunto de suites de cifrado. Todas las suites de cifrado AES-GCM y ChaCha20 están habilitadas por defecto.  El método <a class="reference internal" href="#ssl.SSLContext.set_ciphers" title="ssl.SSLContext.set_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.set_ciphers()</span></code></a> aún no puede habilitar o deshabilitar ningún cifrado de TLS 1.3, pero <a class="reference internal" href="#ssl.SSLContext.get_ciphers" title="ssl.SSLContext.get_ciphers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLContext.get_ciphers()</span></code></a> los devuelve.</p></li>
<li><p>Los tickets de sesión ya no se envían como parte del handshake inicial y se manejan de forma diferente. <a class="reference internal" href="#ssl.SSLSocket.session" title="ssl.SSLSocket.session"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLSocket.session</span></code></a> y <a class="reference internal" href="#ssl.SSLSession" title="ssl.SSLSession"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSession</span></code></a> no son compatibles con TLS 1.3.</p></li>
<li><p>Los certificados del lado del cliente ya no se verifican durante el handshake inicial. Un servidor puede solicitar un certificado en cualquier momento. Los clientes procesan las solicitudes de certificados mientras envían o reciben datos de la aplicación desde el servidor.</p></li>
<li><p>Las funciones de TLS 1.3, como los datos anticipados, la solicitud de certificado de cliente TLS diferida, la configuración del algoritmo de firma y la repetición de claves, aún no son compatibles.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt>Clase <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a></dt><dd><p>Documentación de la clase <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> subyacente</p>
</dd>
<dt><a class="reference external" href="https://httpd.apache.org/docs/trunk/en/ssl/ssl_intro.html">SSL/TLS Strong Encryption: An Introduction</a></dt><dd><p>Introducción de la documentación del servidor HTTP Apache</p>
</dd>
<dt><span class="target" id="index-21"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc1422.html"><strong>RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: Certificate-Based Key Management</strong></a></dt><dd><p>Steve Kent</p>
</dd>
<dt><span class="target" id="index-22"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4086.html"><strong>RFC 4086: Randomness Requirements for Security</strong></a></dt><dd><p>Donald E., Jeffrey I. Schiller</p>
</dd>
<dt><span class="target" id="index-23"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5280.html"><strong>RFC 5280: Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</strong></a></dt><dd><p>D. Cooper</p>
</dd>
<dt><span class="target" id="index-24"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5246.html"><strong>RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2</strong></a></dt><dd><p>T. Dierks et. al.</p>
</dd>
<dt><span class="target" id="index-25"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc6066.html"><strong>RFC 6066: Transport Layer Security (TLS) Extensions</strong></a></dt><dd><p>D. Eastlake</p>
</dd>
<dt><a class="reference external" href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xml">IANA TLS: Transport Layer Security (TLS) Parameters</a></dt><dd><p>IANA</p>
</dd>
<dt><span class="target" id="index-26"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7525.html"><strong>RFC 7525: Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</strong></a></dt><dd><p>IETF</p>
</dd>
<dt><a class="reference external" href="https://wiki.mozilla.org/Security/Server_Side_TLS">Mozilla’s Server Side TLS recommendations</a></dt><dd><p>Mozilla</p>
</dd>
</dl>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code> —Empaquetador o wrapper TLS/SSL para objetos de tipo socket</a><ul>
<li><a class="reference internal" href="#functions-constants-and-exceptions">Funciones, constantes y excepciones</a><ul>
<li><a class="reference internal" href="#socket-creation">Creación de sockets</a></li>
<li><a class="reference internal" href="#context-creation">Creación de contexto</a></li>
<li><a class="reference internal" href="#exceptions">Excepciones</a></li>
<li><a class="reference internal" href="#random-generation">Generación aleatoria</a></li>
<li><a class="reference internal" href="#certificate-handling">Gestión de certificados</a></li>
<li><a class="reference internal" href="#constants">Constantes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ssl-sockets">Sockets SSL</a></li>
<li><a class="reference internal" href="#ssl-contexts">Contextos SSL</a></li>
<li><a class="reference internal" href="#certificates">Certificados</a><ul>
<li><a class="reference internal" href="#certificate-chains">Cadenas de certificados</a></li>
<li><a class="reference internal" href="#ca-certificates">Certificados CA</a></li>
<li><a class="reference internal" href="#combined-key-and-certificate">Clave y certificado combinados</a></li>
<li><a class="reference internal" href="#self-signed-certificates">Certificados auto-firmados</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Ejemplos</a><ul>
<li><a class="reference internal" href="#testing-for-ssl-support">Pruebas de compatibilidad con SSL</a></li>
<li><a class="reference internal" href="#client-side-operation">Operación del lado del cliente</a></li>
<li><a class="reference internal" href="#server-side-operation">Operación del lado del servidor</a></li>
</ul>
</li>
<li><a class="reference internal" href="#notes-on-non-blocking-sockets">Notas sobre los sockets no bloqueantes</a></li>
<li><a class="reference internal" href="#memory-bio-support">Soporte de memoria BIO</a></li>
<li><a class="reference internal" href="#ssl-session">Sesión SSL</a></li>
<li><a class="reference internal" href="#security-considerations">Consideraciones de seguridad</a><ul>
<li><a class="reference internal" href="#best-defaults">Los mejores valores por defecto</a></li>
<li><a class="reference internal" href="#manual-settings">Ajustes manuales</a><ul>
<li><a class="reference internal" href="#verifying-certificates">Verificación de certificados</a></li>
<li><a class="reference internal" href="#protocol-versions">Versiones del protocolo</a></li>
<li><a class="reference internal" href="#cipher-selection">Selección de cifrado</a></li>
</ul>
</li>
<li><a class="reference internal" href="#multi-processing">Multiprocesamiento</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tls-1-3">TLS 1.3</a></li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="socket.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code> — interfaz de red de bajo nivel</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="select.html"
                        title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">select</span></code> — Esperando la finalización de E/S</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/ssl.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="select.html" title="select — Esperando la finalización de E/S"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="socket.html" title="socket — interfaz de red de bajo nivel"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La Biblioteca Estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >Comunicación en redes y entre procesos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code> —Empaquetador o wrapper TLS/SSL para objetos de tipo socket</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 27, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>