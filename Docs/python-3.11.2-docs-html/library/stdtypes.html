
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="Tipos integrados" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/stdtypes.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Esta sección describe los tipos de datos estándar que vienen incluidos en el intérprete. Los principales tipos de datos son: numéricos, secuencias, mapas, clases, instancias y excepciones. Algunas ..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Esta sección describe los tipos de datos estándar que vienen incluidos en el intérprete. Los principales tipos de datos son: numéricos, secuencias, mapas, clases, instancias y excepciones. Algunas ..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>Tipos integrados &#8212; documentación de Python - 3.11.2</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=2d3badd06fe70b34b68db01f99471ce1624ffe4a" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.11.2"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="Excepciones incorporadas" href="exceptions.html" />
    <link rel="prev" title="Constantes incorporadas" href="constants.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/stdtypes.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">Tipos integrados</a><ul>
<li><a class="reference internal" href="#truth-value-testing">Evaluar como valor verdadero/falso</a></li>
<li><a class="reference internal" href="#boolean-operations-and-or-not">Operaciones booleanas — <code class="xref std std-keyword docutils literal notranslate"><span class="pre">and</span></code>, <code class="xref std std-keyword docutils literal notranslate"><span class="pre">or</span></code>, <code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span></code></a></li>
<li><a class="reference internal" href="#comparisons">Comparaciones</a></li>
<li><a class="reference internal" href="#numeric-types-int-float-complex">Tipos numéricos — <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a><ul>
<li><a class="reference internal" href="#bitwise-operations-on-integer-types">Operaciones de bits en números enteros</a></li>
<li><a class="reference internal" href="#additional-methods-on-integer-types">Métodos adicionales de los enteros</a></li>
<li><a class="reference internal" href="#additional-methods-on-float">Métodos adicionales de float</a></li>
<li><a class="reference internal" href="#hashing-of-numeric-types">Calculo del <em>hash</em> de tipos numéricos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#iterator-types">Tipos de iteradores</a><ul>
<li><a class="reference internal" href="#generator-types">Tipos generador</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sequence-types-list-tuple-range">Tipos secuencia — <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a><ul>
<li><a class="reference internal" href="#common-sequence-operations">Operaciones comunes de las secuencias</a></li>
<li><a class="reference internal" href="#immutable-sequence-types">Tipos de secuencia inmutables</a></li>
<li><a class="reference internal" href="#mutable-sequence-types">Tipos de secuencia mutables</a></li>
<li><a class="reference internal" href="#lists">Listas</a></li>
<li><a class="reference internal" href="#tuples">Tuplas</a></li>
<li><a class="reference internal" href="#ranges">Rangos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#text-sequence-type-str">Cadenas de caracteres — <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a><ul>
<li><a class="reference internal" href="#string-methods">Métodos de las cadenas de caracteres</a></li>
<li><a class="reference internal" href="#printf-style-string-formatting">Formateo de cadenas al estilo <code class="docutils literal notranslate"><span class="pre">*printf*</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#binary-sequence-types-bytes-bytearray-memoryview">Tipos de secuencias binarias — <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code> y <code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a><ul>
<li><a class="reference internal" href="#bytes-objects">Objetos de tipo Bytes</a></li>
<li><a class="reference internal" href="#bytearray-objects">Objetos de tipo <em>Bytearray</em></a></li>
<li><a class="reference internal" href="#bytes-and-bytearray-operations">Operaciones de <em>bytes</em> y <em>bytearray</em></a></li>
<li><a class="reference internal" href="#printf-style-bytes-formatting">Usando el formateo tipo <code class="docutils literal notranslate"><span class="pre">printf</span></code> con bytes</a></li>
<li><a class="reference internal" href="#memory-views">Vistas de memoria</a></li>
</ul>
</li>
<li><a class="reference internal" href="#set-types-set-frozenset">Conjuntos — <code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a></li>
<li><a class="reference internal" href="#mapping-types-dict">Tipos mapa — <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a><ul>
<li><a class="reference internal" href="#dictionary-view-objects">Objetos tipos vista de diccionario</a></li>
</ul>
</li>
<li><a class="reference internal" href="#context-manager-types">Tipos gestores de contexto</a></li>
<li><a class="reference internal" href="#type-annotation-types-generic-alias-union">Tipos de anotaciones de type — <span class="xref std std-ref">alias genérico</span>, <span class="xref std std-ref">Union</span></a><ul>
<li><a class="reference internal" href="#generic-alias-type">Tipo Alias Genérico</a><ul>
<li><a class="reference internal" href="#standard-generic-classes">Clases genéricas estándar</a></li>
<li><a class="reference internal" href="#special-attributes-of-genericalias-objects">Atributos especiales de los objetos <code class="docutils literal notranslate"><span class="pre">GenericAlias</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#union-type">Tipo de conversión</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-built-in-types">Otros tipos predefinidos</a><ul>
<li><a class="reference internal" href="#modules">Módulos</a></li>
<li><a class="reference internal" href="#classes-and-class-instances">Clases e instancias de clase</a></li>
<li><a class="reference internal" href="#functions">Funciones</a></li>
<li><a class="reference internal" href="#methods">Métodos</a></li>
<li><a class="reference internal" href="#code-objects">Objetos código</a></li>
<li><a class="reference internal" href="#type-objects">Objetos Tipo</a></li>
<li><a class="reference internal" href="#the-null-object">El objeto nulo (<em>Null</em>)</a></li>
<li><a class="reference internal" href="#the-ellipsis-object">El objeto puntos suspensivos (<em>Ellipsis</em>)</a></li>
<li><a class="reference internal" href="#the-notimplemented-object">El objeto <em>NotImplemented</em></a></li>
<li><a class="reference internal" href="#boolean-values">Valores booleanos</a></li>
<li><a class="reference internal" href="#internal-objects">Objetos internos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-attributes">Atributos especiales</a></li>
<li><a class="reference internal" href="#integer-string-conversion-length-limitation">Limitación de longitud de conversión de cadena de tipo entero</a><ul>
<li><a class="reference internal" href="#affected-apis">APIs afectadas</a></li>
<li><a class="reference internal" href="#configuring-the-limit">Configuración del límite</a></li>
<li><a class="reference internal" href="#recommended-configuration">Configuración recomendada</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="constants.html"
                          title="capítulo anterior">Constantes incorporadas</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="exceptions.html"
                          title="próximo capítulo">Excepciones incorporadas</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/library/stdtypes.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="exceptions.html" title="Excepciones incorporadas"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="constants.html" title="Constantes incorporadas"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">La biblioteca estándar de Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Tipos integrados</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="built-in-types">
<span id="bltin-types"></span><h1>Tipos integrados<a class="headerlink" href="#built-in-types" title="Enlazar permanentemente con este título">¶</a></h1>
<p>Esta sección describe los tipos de datos estándar que vienen incluidos en el intérprete.</p>
<p id="index-0">Los principales tipos de datos son: numéricos, secuencias, mapas, clases, instancias y excepciones.</p>
<p>Algunas clases de tipo colección son mutables. Los métodos que añaden, retiran u ordenan sus miembros en su lugar, y a no ser que retornen un elemento concreto, nunca retornan la propia instancia contenedora, sino <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Algunas operaciones son soportadas por varios tipos de objetos diferentes; por ejemplo, prácticamente todos los objetos pueden ser comparados por igualdad, evaluados para ser considerados como valores booleanos, o representarse en forma de cadena de caracteres (ya sea con la función <a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> o con la función ligeramente diferente <a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a>). Esta última es la usada implícitamente cuando un objeto se escribe con la función <a class="reference internal" href="functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a>.</p>
<section id="truth-value-testing">
<span id="truth"></span><h2>Evaluar como valor verdadero/falso<a class="headerlink" href="#truth-value-testing" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-1">Cualquier objeto puede ser evaluado como si fuera un valor verdadero o falso, para ser usado directamente en sentencias <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> o <a class="reference internal" href="../reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a>, o como un operador en una operación booleana como las que veremos más adelante.</p>
<p id="index-2">Por defecto, un objeto se considera verdadero a no ser que su clase defina o bien un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code> que retorna <code class="docutils literal notranslate"><span class="pre">False</span></code> o un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code> que retorna cero, cuando se invoque desde ese objeto. <a class="footnote-reference brackets" href="#id12" id="id1">1</a> Aquí están listados la mayoría de los objetos integrados que se evalúan como falsos:</p>
<blockquote>
<div></div></blockquote>
<ul class="simple" id="index-3">
<li><p>constantes definidas para tener valor falso: <code class="docutils literal notranslate"><span class="pre">None</span></code> y <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p>cero en cualquiera de los diferentes tipos numéricos: <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">0.0</span></code>, <code class="docutils literal notranslate"><span class="pre">0j</span></code>, <code class="docutils literal notranslate"><span class="pre">Decimal(0)</span></code>, <code class="docutils literal notranslate"><span class="pre">Fraction(0,</span> <span class="pre">1)</span></code></p></li>
<li><p>cualquier colección o secuencia vacía: <code class="docutils literal notranslate"><span class="pre">''</span></code>, <code class="docutils literal notranslate"><span class="pre">()</span></code>, <code class="docutils literal notranslate"><span class="pre">[]</span></code>, <code class="docutils literal notranslate"><span class="pre">{}</span></code>, <code class="docutils literal notranslate"><span class="pre">set()</span></code>, <code class="docutils literal notranslate"><span class="pre">range(0)</span></code></p></li>
</ul>
<p id="index-4">Las operaciones y funciones integradas que tienen como resultado un booleano siempre retornan <code class="docutils literal notranslate"><span class="pre">0</span></code> o <code class="docutils literal notranslate"><span class="pre">False</span></code> para un valor falso, y <code class="docutils literal notranslate"><span class="pre">1</span></code> o <code class="docutils literal notranslate"><span class="pre">True</span></code> para un valor verdadero, a no ser que se indique otra cosa. (Hay una excepción importante: Las operaciones booleanas <code class="docutils literal notranslate"><span class="pre">or</span></code> y <code class="docutils literal notranslate"><span class="pre">and</span></code> siempre retornan uno de los dos operadores.)</p>
</section>
<section id="boolean-operations-and-or-not">
<span id="boolean"></span><h2>Operaciones booleanas — <code class="xref std std-keyword docutils literal notranslate"><span class="pre">and</span></code>, <code class="xref std std-keyword docutils literal notranslate"><span class="pre">or</span></code>, <code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span></code><a class="headerlink" href="#boolean-operations-and-or-not" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-5">Estas son las operaciones booleanas, ordenadas de menor a mayor prioridad:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 62%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operación</p></th>
<th class="head"><p>Resultado</p></th>
<th class="head"><p>Notas</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">or</span> <span class="pre">y</span></code></p></td>
<td><p>if <em>x</em> is true, then <em>x</em>, else
<em>y</em></p></td>
<td><p>(1)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">and</span> <span class="pre">y</span></code></p></td>
<td><p>si <em>x</em> es falso, entonces <em>x</em>, si no, <em>y</em></p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">x</span></code></p></td>
<td><p>si <em>x</em> es falso, entonces <code class="docutils literal notranslate"><span class="pre">True</span></code>, si no, <code class="docutils literal notranslate"><span class="pre">False</span></code></p></td>
<td><p>(3)</p></td>
</tr>
</tbody>
</table>
<p id="index-6">Notas:</p>
<ol class="arabic simple">
<li><p>Este operador usa lógica cortocircuitada, por lo que solo evalúa el segundo argumento si el primero es falso.</p></li>
<li><p>Este operador usa lógica cortocircuitada, por lo que solo evalúa el segundo argumento si el primero es verdadero.</p></li>
<li><p>El operador <code class="docutils literal notranslate"><span class="pre">not</span></code> tiene menos prioridad que los operadores no booleanos, así que <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></code> se interpreta como <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">(a</span> <span class="pre">==</span> <span class="pre">b)</span></code>, y <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">not</span> <span class="pre">b</span></code> es un error sintáctico.</p></li>
</ol>
</section>
<section id="comparisons">
<span id="stdcomparisons"></span><h2>Comparaciones<a class="headerlink" href="#comparisons" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-7">Existen ocho operadores de comparación en Python. Todos comparten el mismo nivel de prioridad (que es mayor que el nivel de las operaciones booleanas). Las comparaciones pueden encadenarse de cualquier manera; por ejemplo, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code> equivale a <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">and</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">z</span></code>, excepto porque <em>y</em> solo se evalúa una vez (no obstante, en ambos casos <em>z</em> no se evalúa si no es verdad que <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code>).</p>
<p>Esta tabla resume las operaciones de comparación:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 32%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operación</p></th>
<th class="head"><p>Significado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&lt;</span></code></p></td>
<td><p>estrictamente menor que</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&lt;=</span></code></p></td>
<td><p>menor o igual que</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">&gt;</span></code></p></td>
<td><p>estrictamente mayor que</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">&gt;=</span></code></p></td>
<td><p>mayor o igual que</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">==</span></code></p></td>
<td><p>igual que</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">!=</span></code></p></td>
<td><p>diferente que</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">is</span></code></p></td>
<td><p>igualdad a nivel de identidad (Son el mismo objeto)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code></p></td>
<td><p>desigualdad a nivel de identidad (no son el mismo objeto)</p></td>
</tr>
</tbody>
</table>
<p id="index-8">Nunca se comparan iguales los objetos que son de tipos diferentes, con la excepción de los tipos numéricos. El operador <code class="docutils literal notranslate"><span class="pre">==</span></code> siempre está definido, pero en algunos tipos de objetos (como por ejemplo, las clases) es equivalente al operador <a class="reference internal" href="../reference/expressions.html#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a>. Los operadores <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> y <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> solo están definidos cuando tienen sentido; por ejemplo, si uno de los operadores es un número complejo, la comparación lanzará una excepción de tipo <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<p id="index-9">Las instancias de una clase que no son idénticas normalmente se comparan como diferentes, a no ser que la clase defina el método <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a>.</p>
<p>Las instancias de una clase no pueden ordenarse con respecto a otras instancias de la misma clase, ni con otro tipo de objetos, a no ser que la clase defina suficientes métodos <a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a> y <a class="reference internal" href="../reference/datamodel.html#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code></a> (en general, <a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a> y <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> son suficientes, si solo necesitas los significados convencionales de los operadores de comparación).</p>
<p>El comportamiento de los operadores <a class="reference internal" href="../reference/expressions.html#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> e <a class="reference internal" href="../reference/expressions.html#is-not"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code></a> no se puede personalizar; además, se pueden aplicar a dos objetos cualquiera y nunca lanzar una excepción.</p>
<p id="index-10">Hay otras dos operaciones con la misma prioridad sintáctica: <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> y <a class="reference internal" href="../reference/expressions.html#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a>, que son soportadas por aquellos tipos de datos que son de tipo <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> o que implementen el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code>.</p>
</section>
<section id="numeric-types-int-float-complex">
<span id="typesnumeric"></span><h2>Tipos numéricos — <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a><a class="headerlink" href="#numeric-types-int-float-complex" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-11">Hay tres tipos numéricos distintos: <em class="dfn">integers</em>, <em class="dfn">floating point numbers</em> y <em class="dfn">complex numbers</em>. Además, los booleanos son un subtipo de los enteros. Los enteros tiene precisión ilimitada. Los números en coma flotante se implementan normalmente usando el tipo <span class="c-expr sig sig-inline c"><span class="kt">double</span></span> de C; hay más información sobre la precisión y la representación interna de los números en coma flotante usadas por la máquina sobre la que se ejecuta tu programa en <a class="reference internal" href="sys.html#sys.float_info" title="sys.float_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.float_info</span></code></a>. Los números complejos tienen una parte real y otra imaginaria, ambas representadas con números en coma flotante. Para extraer estas partes del número complejo <em>z</em> se usan los métodos <code class="docutils literal notranslate"><span class="pre">z.real</span></code> y <code class="docutils literal notranslate"><span class="pre">z.imag</span></code>. (La librería estándar incluye tipos numéricos adicionales: <a class="reference internal" href="fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fractions.Fraction</span></code></a> para números racionales y <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal.Decimal</span></code></a> para números en coma flotante con precisión definida por el usuario.)</p>
<p id="index-12">Los números se crean a partir de literales numéricos, o como resultado de una combinación de funciones integradas y operadores. Expresiones literales de números (incluyendo números expresados en hexadecimal, octal o binario) producen enteros. Si la expresión literal contiene un punto decimal o un signo de exponente, se genera un número en coma flotante. Si se añade como sufijo una <code class="docutils literal notranslate"><span class="pre">'j'</span></code> o una <code class="docutils literal notranslate"><span class="pre">'J'</span></code> a un literal numérico, se genera un número imaginario puro (un número complejo con la parte real a cero), que se puede sumar a un número entero o de coma flotante para obtener un número complejo con parte real e imaginaria.</p>
<p id="index-13">Python soporta completamente una aritmética mixta: cuando un operador binario de tipo aritmético se encuentra con que los operandos son de tipos numéricos diferentes, el operando con el tipo de dato más «estrecho» o restrictivo se convierte o amplía hasta el nivel del otro operando, donde el número entero es más estrecho que el coma flotante, que es más estrecho que el número complejo. Las comparaciones entre números de diferentes tipos se comportan como si se compararan los valores exactos de estos. <a class="footnote-reference brackets" href="#id13" id="id2">2</a></p>
<p>Las funciones constructoras <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a> y <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a> se pueden usar para generar números de cada tipo determinado.</p>
<p>Todos los tipos numéricos (menos los complejos) soportan las siguientes operaciones (para las prioridades de las operaciones, véase <a class="reference internal" href="../reference/expressions.html#operator-summary"><span class="std std-ref">Prioridad de operador</span></a>):</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 40%" />
<col style="width: 11%" />
<col style="width: 24%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operación</p></th>
<th class="head"><p>Resultado</p></th>
<th class="head"><p>Notas</p></th>
<th class="head"><p>Documentación completa</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code></p></td>
<td><p>suma de <em>x</em> e <em>y</em></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></code></p></td>
<td><p>resta de <em>x</em> e <em>y</em></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span></code></p></td>
<td><p>multiplicación de <em>x</em> por <em>y</em></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code></p></td>
<td><p>división de <em>x</em> por <em>y</em></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">//</span> <span class="pre">y</span></code></p></td>
<td><p>división entera de <em>x</em> por <em>y</em></p></td>
<td><p>(1)</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">%</span> <span class="pre">y</span></code></p></td>
<td><p>resto o residuo de <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code></p></td>
<td><p>(2)</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-x</span></code></p></td>
<td><p>valor de <em>x</em>, negado</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">+x</span></code></p></td>
<td><p>valor de <em>x</em>, sin cambiar</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">abs(x)</span></code></p></td>
<td><p>valor absoluto de la magnitud de <em>x</em></p></td>
<td></td>
<td><p><a class="reference internal" href="functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">int(x)</span></code></p></td>
<td><p>valor de <em>x</em> convertido a entero</p></td>
<td><p>(3)(6)</p></td>
<td><p><a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">float(x)</span></code></p></td>
<td><p>valor de <em>x</em> convertido a número de coma flotante</p></td>
<td><p>(4)(6)</p></td>
<td><p><a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">complex(re,</span> <span class="pre">im)</span></code></p></td>
<td><p>un número complejo, con parte real <em>re</em> y parte imaginaria <em>im</em>. El valor de <em>im</em> por defecto vale cero.</p></td>
<td><p>(6)</p></td>
<td><p><a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">c.conjugate()</span></code></p></td>
<td><p>conjugado del número complejo <em>c</em></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">divmod(x,</span> <span class="pre">y)</span></code></p></td>
<td><p>el par de valores <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">//</span> <span class="pre">y,</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y)</span></code></p></td>
<td><p>(2)</p></td>
<td><p><a class="reference internal" href="functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">pow(x,</span> <span class="pre">y)</span></code></p></td>
<td><p><em>x</em> elevado a <em>y</em></p></td>
<td><p>(5)</p></td>
<td><p><a class="reference internal" href="functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">**</span> <span class="pre">y</span></code></p></td>
<td><p><em>x</em> elevado a <em>y</em></p></td>
<td><p>(5)</p></td>
<td></td>
</tr>
</tbody>
</table>
<p id="index-14">Notas:</p>
<ol class="arabic">
<li><p>También conocida como división entera. El resultado es un número entero en el sentido matemático, pero no necesariamente de tipo entero. El resultado se redondea de forma automática hacia menos infinito: <code class="docutils literal notranslate"><span class="pre">1//2</span></code> es <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">(-1)//2</span></code> es <code class="docutils literal notranslate"><span class="pre">-1</span></code>, <code class="docutils literal notranslate"><span class="pre">1//(-2)</span></code> es <code class="docutils literal notranslate"><span class="pre">-1</span></code> y <code class="docutils literal notranslate"><span class="pre">(-1)//(-2)</span></code> es <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p></li>
<li><p>No es apropiada para números complejos. Es preferible convertir a valores en coma flotante usando la función <a class="reference internal" href="functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a> si fuera apropiado.</p></li>
<li><p id="index-15">Conversion from <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> to <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> truncates, discarding the
fractional part. See functions <a class="reference internal" href="math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.floor()</span></code></a> and <a class="reference internal" href="math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.ceil()</span></code></a> for
alternative conversions.</p>
</li>
<li><p>float también acepta las cadenas de caracteres «<em>nan</em>» e «<em>inf</em>», con un prefijo opcional «+» o «-», para los valores <em>Not a Number</em> (<em>NaN</em>) e infinito positivo o negativo.</p></li>
<li><p>Python define <code class="docutils literal notranslate"><span class="pre">pow(0,</span> <span class="pre">0)</span></code> y <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">**</span> <span class="pre">0</span></code> para que valgan <code class="docutils literal notranslate"><span class="pre">1</span></code>, como es práctica habitual en los lenguajes de programación.</p></li>
<li><p>Los literales numéricos aceptables incluyen los dígitos desde el <code class="docutils literal notranslate"><span class="pre">0</span></code> hasta el <code class="docutils literal notranslate"><span class="pre">9</span></code>, así como cualquier carácter Unicode equivalente (puntos de código con la propiedad <code class="docutils literal notranslate"><span class="pre">Nd</span></code>).</p>
<p>Véase <a class="reference external" href="https://www.unicode.org/Public/14.0.0/ucd/extracted/DerivedNumericType.txt">https://www.unicode.org/Public/14.0.0/ucd/extracted/DerivedNumericType.txt</a> para una lista completa de los puntos de código con la propiedad <code class="docutils literal notranslate"><span class="pre">Nd</span></code>.</p>
</li>
</ol>
<p>Todas las clases derivadas de <a class="reference internal" href="numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Real</span></code></a> (<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> y <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>) también soportan las siguientes operaciones:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operación</p></th>
<th class="head"><p>Resultado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="math.html#math.trunc" title="math.trunc"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.trunc(x)</span></code></a></p></td>
<td><p><em>x</em> truncado a <a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="functions.html#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round(x[,</span>
<span class="pre">n])</span></code></a></p></td>
<td><p>El valor de <em>x</em> redondeado a <em>n</em> dígitos, redondeando la mitad al número par más cercano (redondeo del banquero). Si no se especifica valor para <em>n</em>, se asume 0.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.floor(x)</span></code></a></p></td>
<td><p>el mayor número <a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a> que sea &lt;= <em>x</em></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.ceil(x)</span></code></a></p></td>
<td><p>el menor número <a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a> que sea &gt;= <em>x</em></p></td>
</tr>
</tbody>
</table>
<p>Para más operaciones numéricas consulta los módulos <a class="reference internal" href="math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> y <a class="reference internal" href="cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code></a>.</p>
<section id="bitwise-operations-on-integer-types">
<span id="bitstring-ops"></span><h3>Operaciones de bits en números enteros<a class="headerlink" href="#bitwise-operations-on-integer-types" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-16">Las operaciones a nivel de bit solo tienen sentido con números enteros. El resultado de una de estas operaciones se calcula como si se hubiera realizado en una representación en complemento a dos que tuviera un número infinito de bits de signo.</p>
<p>La prioridad de todas las operaciones de bits son menores que las operaciones numéricas, pero mayores que las comparaciones; la operación unaria <code class="docutils literal notranslate"><span class="pre">~</span></code> tiene la misma prioridad que las otras operaciones unarias numéricas (<code class="docutils literal notranslate"><span class="pre">+</span></code> y <code class="docutils literal notranslate"><span class="pre">-</span></code>).</p>
<p>Esta tabla lista las operaciones de bits, ordenadas de menor a mayor prioridad:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 59%" />
<col style="width: 19%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operación</p></th>
<th class="head"><p>Resultado</p></th>
<th class="head"><p>Notas</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">|</span> <span class="pre">y</span></code></p></td>
<td><p>la operación <em class="dfn">or</em> entre <em>x</em> e <em>y</em></p></td>
<td><p>(4)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">^</span> <span class="pre">y</span></code></p></td>
<td><p>la operación <em class="dfn">exclusive or</em> entre <em>x</em> e <em>y</em></p></td>
<td><p>(4)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&amp;</span> <span class="pre">y</span></code></p></td>
<td><p>la operación <em class="dfn">and</em> entre <em>x</em> e <em>y</em></p></td>
<td><p>(4)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;&lt;</span> <span class="pre">n</span></code></p></td>
<td><p>valor de <em>x</em> desplazado a la izquierda <em>n</em> bits</p></td>
<td><p>(1)(2)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;&gt;</span> <span class="pre">n</span></code></p></td>
<td><p>valor de <em>x</em> desplazado a la derecha <em>n</em> bits</p></td>
<td><p>(1)(3)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">~x</span></code></p></td>
<td><p>invierte los bits de <em>x</em></p></td>
<td></td>
</tr>
</tbody>
</table>
<p>Notas:</p>
<ol class="arabic simple">
<li><p>Los desplazamientos negativos son ilegales y lanzarán una excepción de tipo <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p></li>
<li><p>Un desplazamiento de <em>n</em> bits a la izquierda es equivalente a multiplicar por <code class="docutils literal notranslate"><span class="pre">pow(2,</span> <span class="pre">n)</span></code>.</p></li>
<li><p>Un desplazamiento de <em>n</em> bits a la derecha es equivalente a efectuar la división de parte entera (floor) por <code class="docutils literal notranslate"><span class="pre">pow(2,</span> <span class="pre">n)</span></code>.</p></li>
<li><p>Realizar estos cálculos con al menos un bit extra de signo en una representación finita de un número en complemento a dos (un ancho de bits de trabajo de <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">max(x.bit_length(),</span> <span class="pre">y.bit_length())</span></code> o más) es suficiente para obtener el mismo resultado que si se hubiera realizado con un número infinito de bits de signo.</p></li>
</ol>
</section>
<section id="additional-methods-on-integer-types">
<h3>Métodos adicionales de los enteros<a class="headerlink" href="#additional-methods-on-integer-types" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El tipo int implementa la <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">clase base abstracta</span></a> <a class="reference internal" href="numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Integral</span></code></a>. Además, proporciona los siguientes métodos:</p>
<dl class="py method">
<dt class="sig sig-object py" id="int.bit_length">
<span class="sig-prename descclassname"><span class="pre">int.</span></span><span class="sig-name descname"><span class="pre">bit_length</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#int.bit_length" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el número de bits necesarios para representar un número entero, excluyendo el bit de signo y los ceros a la izquierda:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">37</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">&#39;-0b100101&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
<p>De forma más precisa, si <code class="docutils literal notranslate"><span class="pre">x</span></code> es distinto de cero, entonces <code class="docutils literal notranslate"><span class="pre">x.bit_length()</span></code> es el único número entero positivo <code class="docutils literal notranslate"><span class="pre">k</span></code> tal que <code class="docutils literal notranslate"><span class="pre">2**(k-1)</span> <span class="pre">&lt;=</span> <span class="pre">abs(x)</span> <span class="pre">&lt;</span> <span class="pre">2**k</span></code>. De igual manera, cuando <code class="docutils literal notranslate"><span class="pre">abs(x)</span></code> es lo suficientemente pequeño para tener un logaritmo redondeado correctamente, entonces <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">int(log(abs(x),</span> <span class="pre">2))</span></code>. Si <code class="docutils literal notranslate"><span class="pre">x</span></code> es cero, entonces <code class="docutils literal notranslate"><span class="pre">x.bit_length()</span></code> retorna <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>Equivale a:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bit_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>       <span class="c1"># binary representation:  bin(-37) --&gt; &#39;-0b100101&#39;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;-0b&#39;</span><span class="p">)</span> <span class="c1"># remove leading zeros and minus sign</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>       <span class="c1"># len(&#39;100101&#39;) --&gt; 6</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="int.bit_count">
<span class="sig-prename descclassname"><span class="pre">int.</span></span><span class="sig-name descname"><span class="pre">bit_count</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#int.bit_count" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el número de unos en la representación binaria del valor absoluto del entero. Esto también se conoce como el recuento de la población. Ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">19</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">&#39;0b10011&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">bit_count</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">bit_count</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Equivale a:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bit_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="int.to_bytes">
<span class="sig-prename descclassname"><span class="pre">int.</span></span><span class="sig-name descname"><span class="pre">to_bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">byteorder</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'big'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#int.to_bytes" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un arreglo de bytes que representan el número entero.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">b&#39;\x04\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">b&#39;\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">b&#39;\xff\xff\xff\xff\xff\xff\xff\xff\xfc\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;little&#39;</span><span class="p">)</span>
<span class="go">b&#39;\xe8\x03&#39;</span>
</pre></div>
</div>
<p>El número entero se representa usando el número de bits indicados con <em>length</em> y el valor predeterminado es 1. Se lanzará la excepción <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a> si no se puede representar el entero con ese número de bits.</p>
<p>El argumento <em>byteorder</em> determina el orden de representación del número entero y el valor predeterminado es <code class="docutils literal notranslate"><span class="pre">&quot;big&quot;</span></code>. Si <em>byteorder</em> es <code class="docutils literal notranslate"><span class="pre">&quot;big&quot;</span></code>, el byte más significativo ocupa la primera posición del arreglo del byte. Si <em>byteorder</em> es <code class="docutils literal notranslate"><span class="pre">&quot;little&quot;</span></code>, el byte más significativo estará en la última posición.</p>
<p>El parámetro <em>signed</em> determina si se usa el complemento a dos para representar los números enteros. Si <em>signed</em> es <code class="docutils literal notranslate"><span class="pre">False</span></code>, y se usa un valor entero negativo, se lanzará la excepción <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>. El valor por defecto para <em>signed</em> es <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>The default values can be used to conveniently turn an integer into a
single byte object:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">65</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">()</span>
<span class="go">b&#39;A&#39;</span>
</pre></div>
</div>
<p>However, when using the default arguments, don’t try
to convert a value greater than 255 or you’ll get an <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>.</p>
<p>Equivale a:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">to_bytes</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;little&#39;</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;big&#39;</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;byteorder must be either &#39;little&#39; or &#39;big&#39;&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">bytes</span><span class="p">((</span><span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">order</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Se agregaron valores de argumentos predeterminados para <code class="docutils literal notranslate"><span class="pre">length</span></code> y <code class="docutils literal notranslate"><span class="pre">byteorder</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="int.from_bytes">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">int.</span></span><span class="sig-name descname"><span class="pre">from_bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bytes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">byteorder</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'big'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#int.from_bytes" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el número entero que se representa por el arreglo de bytes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00\x10</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00\x10</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;little&#39;</span><span class="p">)</span>
<span class="go">4096</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xfc\x00</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">-1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xfc\x00</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">64512</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">([</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="go">16711680</span>
</pre></div>
</div>
<p>El argumento <em>bytes</em> debe ser o bien un <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto tipo binario</span></a> o un iterable que produzca bytes.</p>
<p>El argumento <em>byteorder</em> determina el orden de representación del número entero y el valor predeterminado es <code class="docutils literal notranslate"><span class="pre">&quot;big&quot;</span></code>. Si <em>byteorder</em> es <code class="docutils literal notranslate"><span class="pre">&quot;big&quot;</span></code>, el byte más significativo ocupa la primera posición en el arreglo del byte. Si <em>byteorder</em> es <code class="docutils literal notranslate"><span class="pre">&quot;little&quot;</span></code>, el byte más significativo estará en la última posición. Para solicitar el orden de bytes nativo del sistema host, usa <a class="reference internal" href="sys.html#sys.byteorder" title="sys.byteorder"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.byteorder</span></code></a> como valor de orden de bytes.</p>
<p>El argumento <em>signed</em> indica si se representará el número entero usando complemento a dos.</p>
<p>Equivale a:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">from_bytes</span><span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;big&#39;</span><span class="p">,</span> <span class="n">signed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;little&#39;</span><span class="p">:</span>
        <span class="n">little_ordered</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;big&#39;</span><span class="p">:</span>
        <span class="n">little_ordered</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">bytes</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;byteorder must be either &#39;little&#39; or &#39;big&#39;&quot;</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">*</span><span class="mi">8</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">little_ordered</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">signed</span> <span class="ow">and</span> <span class="n">little_ordered</span> <span class="ow">and</span> <span class="p">(</span><span class="n">little_ordered</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">little_ordered</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">n</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Se agregó valor de argumento predeterminado para <code class="docutils literal notranslate"><span class="pre">byteorder</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="int.as_integer_ratio">
<span class="sig-prename descclassname"><span class="pre">int.</span></span><span class="sig-name descname"><span class="pre">as_integer_ratio</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#int.as_integer_ratio" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una pareja de números enteros cuya proporción es igual a la del numero entero original, y con un denominador positivo. En el caso de números enteros, la proporción siempre es el entero en el numerador y <code class="docutils literal notranslate"><span class="pre">1</span></code> en el denominador.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

</section>
<section id="additional-methods-on-float">
<h3>Métodos adicionales de float<a class="headerlink" href="#additional-methods-on-float" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El tipo float implementa la <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">clase base abstracta</span></a> <a class="reference internal" href="numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Real</span></code></a>. Los números float tienen además los siguientes métodos.</p>
<dl class="py method">
<dt class="sig sig-object py" id="float.as_integer_ratio">
<span class="sig-prename descclassname"><span class="pre">float.</span></span><span class="sig-name descname"><span class="pre">as_integer_ratio</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#float.as_integer_ratio" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una pareja de números enteros cuya proporción es exactamente igual que la del valor en punto flotante original, con un denominador positivo. Si se llama con valores infinitos lanza una excepción de tipo <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a> y si se llama con <em>NaN</em> (<em>Not A Number</em>) lanza una excepción de tipo <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="float.is_integer">
<span class="sig-prename descclassname"><span class="pre">float.</span></span><span class="sig-name descname"><span class="pre">is_integer</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#float.is_integer" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si el valor en coma flotante es finita con valor integral, y <code class="docutils literal notranslate"><span class="pre">False</span></code> en caso contrario:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mf">3.2</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<p>Hay dos métodos que convierten desde y hacia cadenas de caracteres en hexadecimal. Como los valores en coma flotante en Python se almacenan internamente en binario, las conversiones desde o hacia cadenas <em>decimales</em> pueden implicar un pequeño error de redondeo. Pero con cadenas de caracteres en hexadecimal, las cadenas se corresponden y permiten representar de forma exacta los números en coma flotante. Esto puede ser útil, ya sea a la hora de depurar errores, o en procesos numéricos.</p>
<dl class="py method">
<dt class="sig sig-object py" id="float.hex">
<span class="sig-prename descclassname"><span class="pre">float.</span></span><span class="sig-name descname"><span class="pre">hex</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#float.hex" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la representación de un valor en coma flotante en forma de cadena de caracteres en hexadecimal. Para números finitos, la representación siempre empieza con el prefijo <code class="docutils literal notranslate"><span class="pre">0x</span></code>, y con una <code class="docutils literal notranslate"><span class="pre">p</span></code> justo antes del exponente.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="float.fromhex">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">float.</span></span><span class="sig-name descname"><span class="pre">fromhex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#float.fromhex" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Método de clase que retorna el valor en coma flotante que se representa por la cadena de caracteres en hexadecimal <em>s</em>. La cadena de caracteres <em>s</em> puede tener espacios en blanco al principio o al final.</p>
</dd></dl>

<p>Nótese que <a class="reference internal" href="#float.hex" title="float.hex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">float.hex()</span></code></a> es un método de instancia, mientras que <a class="reference internal" href="#float.fromhex" title="float.fromhex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">float.fromhex()</span></code></a> es un método de clase.</p>
<p>Una cadena de caracteres en hexadecimal sigue este formato:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">sign</span><span class="p">]</span> <span class="p">[</span><span class="s1">&#39;0x&#39;</span><span class="p">]</span> <span class="n">integer</span> <span class="p">[</span><span class="s1">&#39;.&#39;</span> <span class="n">fraction</span><span class="p">]</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span> <span class="n">exponent</span><span class="p">]</span>
</pre></div>
</div>
<p>donde el componente opcional <code class="docutils literal notranslate"><span class="pre">sign</span></code> puede ser o bien <code class="docutils literal notranslate"><span class="pre">+</span></code> o <code class="docutils literal notranslate"><span class="pre">-</span></code>, las componentes <code class="docutils literal notranslate"><span class="pre">integer</span></code> y <code class="docutils literal notranslate"><span class="pre">fraction</span></code> son cadenas de caracteres que solo usan dígitos hexadecimales, y <code class="docutils literal notranslate"><span class="pre">exponent</span></code> es un número decimal, precedido con un signo opcional. No se distingue entre mayúsculas y minúsculas, y debe haber al menos un dígito hexadecimal tanto en la parte entera como en la fracción. Esta sintaxis es similar a la sintaxis especificada en la sección 6.4.4.2 del estándar C99, y es también la sintaxis usada en Java desde la versión 1.5. En particular, la salida de <a class="reference internal" href="#float.hex" title="float.hex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">float.hex()</span></code></a> se puede usar como una cadena de caracteres en hexadecimal en código C o Java, y las cadenas de caracteres hexadecimal producidas por el carácter de formato <code class="docutils literal notranslate"><span class="pre">%a</span></code> en C, o por el método Java, <code class="docutils literal notranslate"><span class="pre">Double.toHexString</span></code>, son aceptadas por <a class="reference internal" href="#float.fromhex" title="float.fromhex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">float.fromhex()</span></code></a>.</p>
<p>Nótese que el valor del exponente se expresa en decimal, no en hexadecimal, e indica la potencia de 2 por la que debemos multiplicar el coeficiente. Por ejemplo, la cadena de caracteres hexadecimal <code class="docutils literal notranslate"><span class="pre">0x3.a7p10</span></code> representa el número en coma flotante <code class="docutils literal notranslate"><span class="pre">(3</span> <span class="pre">+</span> <span class="pre">10./16</span> <span class="pre">+</span> <span class="pre">7./16**2)</span> <span class="pre">*</span> <span class="pre">2.0**10</span></code>, o <code class="docutils literal notranslate"><span class="pre">3740.0</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s1">&#39;0x3.a7p10&#39;</span><span class="p">)</span>
<span class="go">3740.0</span>
</pre></div>
</div>
<p>Si aplicamos la operación inversa a <code class="docutils literal notranslate"><span class="pre">3740.0</span></code> retorna una cadena de caracteres hexadecimal diferente que, aun así, representa el mismo número:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="o">.</span><span class="n">hex</span><span class="p">(</span><span class="mf">3740.0</span><span class="p">)</span>
<span class="go">&#39;0x1.d380000000000p+11&#39;</span>
</pre></div>
</div>
</section>
<section id="hashing-of-numeric-types">
<span id="numeric-hash"></span><h3>Calculo del <em>hash</em> de tipos numéricos<a class="headerlink" href="#hashing-of-numeric-types" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para dos números <code class="docutils literal notranslate"><span class="pre">x</span></code> e <code class="docutils literal notranslate"><span class="pre">y</span></code>, posiblemente de tipos diferentes, se requiere que <code class="docutils literal notranslate"><span class="pre">hash(x)</span> <span class="pre">==</span> <span class="pre">hash(y)</span></code> sea verdadero siempre que <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> (véase la documentación sobre el método <a class="reference internal" href="../reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> para más detalles). Por razones tanto de eficiencia como de facilidad de implementación entre los tipos numéricos diferentes (incluyendo <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">decimal.Decimal</span></code></a> y <a class="reference internal" href="fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">fractions.Fraction</span></code></a>), el método de <em>hash</em> de Python se basa en una función matemática sencilla que está definida para cualquier número racional, con lo cual se puede aplicar a todas las instancias de <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> y <a class="reference internal" href="fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">fractions.Fraction</span></code></a>, y a todas las instancias finitas de <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> y <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">decimal.Decimal</span></code></a>. En esencia, lo que hace esta función es una reducción módulo <code class="docutils literal notranslate"><span class="pre">P</span></code> para un valor fijo del número primo <code class="docutils literal notranslate"><span class="pre">P</span></code>. El valor de <code class="docutils literal notranslate"><span class="pre">P</span></code> está disponible en Python como atributo de <a class="reference internal" href="sys.html#sys.hash_info" title="sys.hash_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.hash_info</span></code></a> con el nombre de <code class="xref py py-attr docutils literal notranslate"><span class="pre">modulus</span></code>.</p>
<div class="impl-detail compound">
<p><strong>Detalles de implementación de CPython:</strong> Actualmente, el número primo usado es <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">2**31</span> <span class="pre">-</span> <span class="pre">1</span></code> para máquinas de 32 bits, y <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">2**61</span> <span class="pre">-</span> <span class="pre">1</span></code> en máquinas de 64 bits.</p>
</div>
<p>Aquí están las reglas en detalle:</p>
<ul class="simple">
<li><p>Si <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">/</span> <span class="pre">n</span></code> es un número racional no negativo y <code class="docutils literal notranslate"><span class="pre">n</span></code> no es divisible por <code class="docutils literal notranslate"><span class="pre">P</span></code>, se define <code class="docutils literal notranslate"><span class="pre">hash(x)</span></code> como <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">*</span> <span class="pre">invmod(n,</span> <span class="pre">P)</span> <span class="pre">%</span> <span class="pre">P</span></code>, donde <code class="docutils literal notranslate"><span class="pre">invmod(n,</span> <span class="pre">P)</span></code> retorna la inversa de <code class="docutils literal notranslate"><span class="pre">n</span></code> módulo <code class="docutils literal notranslate"><span class="pre">P</span></code>.</p></li>
<li><p>Si <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">/</span> <span class="pre">n</span></code> es un número racional no negativo y <code class="docutils literal notranslate"><span class="pre">n</span></code> es divisible por <code class="docutils literal notranslate"><span class="pre">P</span></code> (pero no así <code class="docutils literal notranslate"><span class="pre">m</span></code>), entonces <code class="docutils literal notranslate"><span class="pre">n</span></code> no tiene módulo inverso de <code class="docutils literal notranslate"><span class="pre">P</span></code> y no se puede aplicar la regla anterior; en este caso, <code class="docutils literal notranslate"><span class="pre">hash(x)</span></code> retorna el valor constante definido en <code class="docutils literal notranslate"><span class="pre">sys.hash_info.inf</span></code>.</p></li>
<li><p>Si <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">/</span> <span class="pre">n</span></code> es un número racional negativo se define <code class="docutils literal notranslate"><span class="pre">hash(x)</span></code> como <code class="docutils literal notranslate"><span class="pre">-hash(-x)</span></code>. Si el resultado fuera <code class="docutils literal notranslate"><span class="pre">-1</span></code>, lo cambia por <code class="docutils literal notranslate"><span class="pre">-2</span></code>.</p></li>
<li><p>Los valores concretos <code class="docutils literal notranslate"><span class="pre">sys.hash_info.inf</span></code> y <code class="docutils literal notranslate"><span class="pre">-sys.hash_info.inf</span></code> se usan como valores <em>hash</em> para infinito positivo o infinito negativo (respectivamente).</p></li>
<li><p>Para un número complejo <code class="docutils literal notranslate"><span class="pre">z</span></code> (una instancia de la clase <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>), el valor de <em>hash</em> se calcula combinando los valores de <em>hash</em> de la parte real e imaginaria, usando la fórmula <code class="docutils literal notranslate"><span class="pre">hash(z.real)</span> <span class="pre">+</span> <span class="pre">sys.hash_info.imag</span> <span class="pre">*</span> <span class="pre">hash(z.imag)</span></code>, módulo reducido <code class="docutils literal notranslate"><span class="pre">2**sys.hash_info.width</span></code>, de forma que el valor obtenido esté en rango <code class="docutils literal notranslate"><span class="pre">range(-2**(sys.hash_info.width</span> <span class="pre">-</span> <span class="pre">1),</span> <span class="pre">2**(sys.hash_info.width</span> <span class="pre">-</span> <span class="pre">1))</span></code>. De nuevo, si el resultado fuera <code class="docutils literal notranslate"><span class="pre">-1</span></code>, se reemplaza por <code class="docutils literal notranslate"><span class="pre">-2</span></code>.</p></li>
</ul>
<p>Para clarificar las reglas previas, aquí mostramos un ejemplo de código Python, equivalente al cálculo realizado en la función <em>hash</em>, para calcular el <em>hash</em> de un número racional de tipo <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> o <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">hash_fraction</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the hash of a rational number m / n.</span>

<span class="sd">    Assumes m and n are integers, with n positive.</span>
<span class="sd">    Equivalent to hash(fractions.Fraction(m, n)).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">modulus</span>
    <span class="c1"># Remove common factors of P.  (Unnecessary if m and n already coprime.)</span>
    <span class="k">while</span> <span class="n">m</span> <span class="o">%</span> <span class="n">P</span> <span class="o">==</span> <span class="n">n</span> <span class="o">%</span> <span class="n">P</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">m</span> <span class="o">//</span> <span class="n">P</span><span class="p">,</span> <span class="n">n</span> <span class="o">//</span> <span class="n">P</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">P</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Fermat&#39;s Little Theorem: pow(n, P-1, P) is 1, so</span>
        <span class="c1"># pow(n, P-2, P) gives the inverse of n modulo P.</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">%</span> <span class="n">P</span><span class="p">)</span> <span class="o">*</span> <span class="nb">pow</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">P</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span> <span class="o">%</span> <span class="n">P</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="o">-</span><span class="n">hash_value</span>
    <span class="k">if</span> <span class="n">hash_value</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">hash_value</span>

<span class="k">def</span> <span class="nf">hash_float</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the hash of a float x.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hash_fraction</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">hash_complex</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the hash of a complex number z.&quot;&quot;&quot;</span>

    <span class="n">hash_value</span> <span class="o">=</span> <span class="n">hash_float</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">+</span> <span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">hash_float</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
    <span class="c1"># do a signed reduction modulo 2**sys.hash_info.width</span>
    <span class="n">M</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">hash_info</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">hash_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash_value</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">hash_value</span> <span class="o">&amp;</span> <span class="n">M</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">hash_value</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">hash_value</span>
</pre></div>
</div>
</section>
</section>
<section id="iterator-types">
<span id="typeiter"></span><h2>Tipos de iteradores<a class="headerlink" href="#iterator-types" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-17">Python soporta el concepto de iteradores sobre contenedores. Esto se implementa usando dos métodos diferentes: Estos son usados por las clases definidas por el usuario para soportar iteración. Las secuencias, que se describirán con mayor detalle, siempre soportan la iteración.</p>
<p>Es necesario definir un método para que los objetos contenedores proporcionen compatibilidad <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a>:</p>
<dl class="py method">
<dt class="sig sig-object py" id="container.__iter__">
<span class="sig-prename descclassname"><span class="pre">container.</span></span><span class="sig-name descname"><span class="pre">__iter__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#container.__iter__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un objeto <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>. Este objeto es requerido para soportar el protocolo de iteración que se describe a continuación. Si un contenedor soporta diferentes tipos de iteración, se pueden implementar métodos adicionales para estos iteradores. (Por ejemplo, un tipo de contenedor que puede soportar distintas formas de iteración podría ser una estructura de tipo árbol que proporcione a la vez un recorrido en profundidad o en anchura). Este método se corresponde al <em>slot</em> <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iter</span></code></a> de la estructura usada para los objetos Python en la API Python/C.</p>
</dd></dl>

<p>Los objetos iteradores en si necesitan definir los siguientes dos métodos, que forma juntos el <em class="dfn">iterator protocol</em>:</p>
<dl class="py method">
<dt class="sig sig-object py" id="iterator.__iter__">
<span class="sig-prename descclassname"><span class="pre">iterator.</span></span><span class="sig-name descname"><span class="pre">__iter__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iterator.__iter__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el propio objeto <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>. Este método es necesario para permitir tanto a los contenedores como a los iteradores usar la palabras clave <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> o <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a>. Este método se corresponde con el <em>slot</em> <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iter</span></code></a> de la estructura usada para los objetos Python en la API Python/C.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="iterator.__next__">
<span class="sig-prename descclassname"><span class="pre">iterator.</span></span><span class="sig-name descname"><span class="pre">__next__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iterator.__next__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el siguiente elemento del <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>. Si no hubiera más elementos, lanza la excepción <a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>. Este método se corresponde con el <em>slot</em> <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iternext</span></code></a> de la estructura usada para los objetos Python en la API Python/C.</p>
</dd></dl>

<p>Python define varios objetos iteradores que permiten iterar sobre las secuencias, ya sean generales o específicas, diccionarios y otras estructuras de datos especializadas. Los tipos específicos no son tan importantes como la implementación del protocolo iterador.</p>
<p>Una vez que la ejecución del método <a class="reference internal" href="#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> lanza la excepción <a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>, debe continuar haciéndolo en subsiguientes llamadas al método. Si una implementación no cumple esto, se considera rota.</p>
<section id="generator-types">
<span id="id3"></span><h3>Tipos generador<a class="headerlink" href="#generator-types" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Los <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a> de Python proporcionan una manera cómoda de implementar el protocolo iterador. Si un objeto de tipo contenedor implementa el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> como un generador, de forma automática este retornará un objeto iterador (técnicamente, un objeto generador) que implementa los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> y <a class="reference internal" href="../reference/expressions.html#generator.__next__" title="generator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a>. Se puede obtener más información acerca de los generadores en <a class="reference internal" href="../reference/expressions.html#yieldexpr"><span class="std std-ref">la documentación de la expresión yield</span></a>.</p>
</section>
</section>
<section id="sequence-types-list-tuple-range">
<span id="typesseq"></span><h2>Tipos secuencia — <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, <a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a><a class="headerlink" href="#sequence-types-list-tuple-range" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Hay tres tipos básicos de secuencia: listas, tuplas y objetos de tipo rango. Existen tipos de secuencia especiales usados para el procesado de <a class="reference internal" href="#binaryseq"><span class="std std-ref">datos binarios</span></a> y <a class="reference internal" href="#textseq"><span class="std std-ref">cadenas de caracteres</span></a> que se describirán en secciones específicas.</p>
<section id="common-sequence-operations">
<span id="typesseq-common"></span><h3>Operaciones comunes de las secuencias<a class="headerlink" href="#common-sequence-operations" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-18">Las operaciones de la siguiente tabla están soportadas por la mayoría de los tipos secuencia, tanto mutables como inmutables. La clase ABC <a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> se incluye para facilitar la implementación correcta de estas operaciones en nuestros propios tipos de secuencias.</p>
<p>La tabla lista las operaciones ordenadas de menor a mayor prioridad. En la tabla, <em>s</em> y <em>t</em> representan secuencias del mismo tipo, <em>n</em>, <em>i</em>, <em>j</em> y <em>k</em> son números enteros y <em>x</em> es un objeto arbitrario que cumple con cualquier restricción de tipo o valor impuesta por <em>s</em>.</p>
<p>Las operaciones <code class="docutils literal notranslate"><span class="pre">in</span></code> y <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code> tienen la misma prioridad que los operadores de comparación. Las operaciones <code class="docutils literal notranslate"><span class="pre">+</span></code> (concatenación) y <code class="docutils literal notranslate"><span class="pre">*</span></code> (repetición) tienen la misma prioridad que sus equivalentes numéricos. <a class="footnote-reference brackets" href="#id14" id="id4">3</a></p>
<table class="docutils align-default" id="index-19">
<colgroup>
<col style="width: 38%" />
<col style="width: 47%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operación</p></th>
<th class="head"><p>Resultado</p></th>
<th class="head"><p>Notas</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">True</span></code> si un elemento de <em>s</em> es igual a <em>x</em>, <code class="docutils literal notranslate"><span class="pre">False</span></code> en caso contrario</p></td>
<td><p>(1)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">s</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">False</span></code> si un elemento de <em>s</em> es igual a <em>x</em>, <code class="docutils literal notranslate"><span class="pre">True</span></code> en caso contrario</p></td>
<td><p>(1)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">+</span> <span class="pre">t</span></code></p></td>
<td><p>la concatenación de <em>s</em> y <em>t</em></p></td>
<td><p>(6)(7)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">*</span> <span class="pre">n</span></code> o <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">*</span> <span class="pre">s</span></code></p></td>
<td><p>equivale a concatenar <em>s</em> consigo mismo <em>n</em> veces</p></td>
<td><p>(2)(7)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s[i]</span></code></p></td>
<td><p>El elemento <em>i-esimo</em> de <em>s</em>, empezando a contar en 0</p></td>
<td><p>(3)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">s[i:j]</span></code></p></td>
<td><p>el segmento de <em>s</em> desde <em>i</em> hasta <em>j</em></p></td>
<td><p>(3)(4)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s[i:j:k]</span></code></p></td>
<td><p>el segmento de <em>s</em> desde <em>i</em> hasta <em>j</em>, con paso <em>j</em></p></td>
<td><p>(3)(5)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">len(s)</span></code></p></td>
<td><p>longitud de <em>s</em></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">min(s)</span></code></p></td>
<td><p>el elemento más pequeño de <em>s</em></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">max(s)</span></code></p></td>
<td><p>el elemento más grande de <em>s</em></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s.index(x[,</span> <span class="pre">i[,</span> <span class="pre">j]])</span></code></p></td>
<td><p>índice de la primera ocurrencia de <em>x</em> en <em>s</em> (en la posición <em>i</em> o superior, y antes de <em>j</em>)</p></td>
<td><p>(8)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">s.count(x)</span></code></p></td>
<td><p>número total de ocurrencias de <em>x</em> en <em>s</em></p></td>
<td></td>
</tr>
</tbody>
</table>
<p>También se pueden comparar secuencias del mismo tipo. En particular, las tuplas y las listas se comparan por orden lexicográfico, comparando los elementos en la misma posición. Esto significa que, para que se consideren iguales, todos los elementos correspondientes deben ser iguales entre si, y las dos secuencias deben ser del mismo tipo y de la misma longitud. (Para más detalles, véase <a class="reference internal" href="../reference/expressions.html#comparisons"><span class="std std-ref">Comparaciones</span></a> en la referencia del lenguaje).</p>
<p id="index-20">Los iteradores directos e inversos sobre secuencias mutables acceden a valores al usar un índice. Este índice continuará avanzando (o retrocediendo) incluso si la secuencia subyacente está mutada. El iterador termina solo cuando se encuentra un <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> o un <a class="reference internal" href="exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> (o cuando el índice cae por debajo de cero).</p>
<p>Notas:</p>
<ol class="arabic">
<li><p>Aunque las operaciones <code class="docutils literal notranslate"><span class="pre">in</span></code> y <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code> se usan generalmente para comprobar si un elemento está dentro de un contenedor, en algunas secuencias especializadas (como <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> y <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>) también se pueden usar para comprobar si está incluida una secuencia:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;gg&quot;</span> <span class="ow">in</span> <span class="s2">&quot;eggs&quot;</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
<li><p>Valores de <em>n</em> menores que <code class="docutils literal notranslate"><span class="pre">0</span></code> se consideran como <code class="docutils literal notranslate"><span class="pre">0</span></code> (que produce una secuencia vacía del mismo tipo que <em>s</em>). Nótese que los elementos de la secuencia <em>s</em> no se copian, sino que se referencian múltiples veces. Esto a menudo confunde a programadores noveles de Python; considérese:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span> <span class="o">=</span> <span class="p">[[]]</span> <span class="o">*</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[], [], []]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[3], [3], [3]]</span>
</pre></div>
</div>
<p>Lo que ha pasado es que <code class="docutils literal notranslate"><span class="pre">[[]]</span></code> es una lista de un elemento, siendo este elemento una lista vacía, así que los tres elementos de <code class="docutils literal notranslate"><span class="pre">[[]]</span> <span class="pre">*</span> <span class="pre">3</span></code> son referencias a la misma lista vacía. Modificar cualquiera de los elementos de <code class="docutils literal notranslate"><span class="pre">lists</span></code> modifica la lista inicial. Para crear una lista de listas independientes entre si, se puede hacer:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lists</span>
<span class="go">[[3], [5], [7]]</span>
</pre></div>
</div>
<p>Se puede consultar una explicación más completa en esta entrada de la lista de preguntas más frecuentes <a class="reference internal" href="../faq/programming.html#faq-multidimensional-list"><span class="std std-ref">¿Cómo puedo crear una lista multidimensional?</span></a>.</p>
</li>
<li><p>Si <em>i</em> o <em>j</em> es negativo, el índice es relativo al final de la secuencia <em>s</em>: Se realiza la sustitución <code class="docutils literal notranslate"><span class="pre">len(s)</span> <span class="pre">+</span> <span class="pre">i</span></code> o <code class="docutils literal notranslate"><span class="pre">len(s)</span> <span class="pre">+</span> <span class="pre">j</span></code>. Nótese que <code class="docutils literal notranslate"><span class="pre">-0</span></code> sigue siendo <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p></li>
<li><p>El segmento de <em>s</em> desde <em>i</em> hasta <em>j</em> se define como la secuencia de elementos con índice <em>k</em>, de forma que <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">j</span></code>. Si <em>i</em> o <em>j</em> es mayor que <code class="docutils literal notranslate"><span class="pre">len(s)</span></code> se usa <code class="docutils literal notranslate"><span class="pre">len(s)</span></code>. Si <em>i</em> se omite o es <code class="docutils literal notranslate"><span class="pre">None</span></code>, se usa <code class="docutils literal notranslate"><span class="pre">0</span></code>. Si <em>j</em> se omite o es <code class="docutils literal notranslate"><span class="pre">None</span></code>, se usa <code class="docutils literal notranslate"><span class="pre">len(s)</span></code>. Si <em>i</em> es mayor o igual a <em>j</em>, el segmento está vacío.</p></li>
<li><p>El segmento de <em>s</em>, desde <em>i</em> hasta <em>j</em> con paso <em>k</em>, se define como la secuencia de elementos con índice <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">n*k</span></code> tal que <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">(j-i)/k</span></code>. En otras palabras, los índices son <code class="docutils literal notranslate"><span class="pre">i</span></code>, <code class="docutils literal notranslate"><span class="pre">i+k</span></code>, <code class="docutils literal notranslate"><span class="pre">i+2*k</span></code>, <code class="docutils literal notranslate"><span class="pre">i+3*k</span></code> y así consecutivamente, hasta que se alcance el valor de <em>j</em> (pero sin incluir nunca <em>j</em>). Cuando <em>k</em> es positivo, <em>i</em> y <em>j</em> se limitan al valor de <code class="docutils literal notranslate"><span class="pre">len(s)</span></code>, si fueran mayores. Si <em>k</em> es negativo, <em>i</em> y <em>j</em> se reducen de <code class="docutils literal notranslate"><span class="pre">len(s)</span> <span class="pre">-</span> <span class="pre">1</span></code>. Si <em>i</em> o <em>j</em> se omiten o su valor es <code class="docutils literal notranslate"><span class="pre">None</span></code>, se convierten es valores «finales» (donde el sentido de final depende del signo de <em>k</em>). Nótese que <em>k</em> no puede valer <code class="docutils literal notranslate"><span class="pre">0</span></code>. Si <em>k</em> vale <code class="docutils literal notranslate"><span class="pre">None</span></code>, se considera como <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p></li>
<li><p>La concatenación de secuencias inmutables siempre produce un nuevo objeto. Esto significa que construir una secuencia usando la concatenación tiene un coste en ejecución cuadrático respecto al tamaño de la secuencia final. Para obtener un rendimiento lineal, se puede optar por una de las alternativas siguientes:</p>
<ul class="simple">
<li><p>en vez de concatenar objetos de tipo <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, se puede construir una lista y usar finalmente el método <a class="reference internal" href="#str.join" title="str.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.join()</span></code></a>, o bien utilizar una instancia de la clase <a class="reference internal" href="io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a> y recuperar el valor final completo</p></li>
<li><p>de forma similar, en vez de concatenar objetos de tipo <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> se puede usar el método <a class="reference internal" href="#bytes.join" title="bytes.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.join()</span></code></a>, la clase <a class="reference internal" href="io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BytesIO</span></code></a>, o se puede realizar una modificación interna usando un objeto de la clase <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>. Los objetos de tipo <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> son mutables y tienen un mecanismo interno de gestión muy eficiente</p></li>
<li><p>en vez de concatenar tuplas (instancias de <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>), usar una lista (<a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>) y expandirla</p></li>
<li><p>para otros tipos, investiga la documentación relevante de la clase</p></li>
</ul>
</li>
<li><p>Algunos tipos de secuencia (como la clase <a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a>) solo soportan elementos que siguen un patrón específico, y por tanto no soportan la concatenación ni la repetición.</p></li>
<li><p>El método <code class="docutils literal notranslate"><span class="pre">index</span></code> lanza la excepción <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> si <em>x</em> no se encuentra en <em>s</em>. No todas las implementaciones soportan los parámetros opcionales <em>i</em> y <em>j</em>. Estos parámetros permiten una búsqueda eficiente de partes de una secuencia. Usar estos parámetros es más o menos equivalente a usar <code class="docutils literal notranslate"><span class="pre">s[i:j].index(x)</span></code>, pero sin copiar ningún dato y con el valor de índice retornado como valor relativo al inicio de la secuencia, en vez de al inicio del segmento.</p></li>
</ol>
</section>
<section id="immutable-sequence-types">
<span id="typesseq-immutable"></span><h3>Tipos de secuencia inmutables<a class="headerlink" href="#immutable-sequence-types" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-21">La única operación que las secuencias inmutables implementan generalmente, y que no esta definida también en las secuencias mutables, es el soporte para el cálculo de la función predefinida <a class="reference internal" href="functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a>.</p>
<p>Este soporte permite usar secuencias inmutables, como por ejemplo las instancias de la clase <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, como claves para diccionarios (<a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>), así como ser almacenadas en conjuntos (<a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>) o conjuntos congelados (<a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>).</p>
<p>Intentar calcular el <em>hash</em> de una secuencia inmutable que contenga objetos mutables producirá una excepción de tipo <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
</section>
<section id="mutable-sequence-types">
<span id="typesseq-mutable"></span><h3>Tipos de secuencia mutables<a class="headerlink" href="#mutable-sequence-types" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-22">Las operaciones de la siguiente tabla están definidas para todas los tipos de secuencia mutables. La clase ABC <a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSequence</span></code></a> se incluye para facilitar la implementación correcta de un tipo de secuencia propio.</p>
<p>En la tabla, <em>s</em> es una instancia de una secuencia de tipo mutable, <em>t</em> es cualquier objeto iterable y <em>x</em> es un objeto arbitrario que cumple las restricciones de tipo y valor que vengan impuestas por <em>s</em> (como ejemplo, la clase <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> solo acepta enteros que cumplan la condición <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">255</span></code>).</p>
<table class="docutils align-default" id="index-23">
<colgroup>
<col style="width: 36%" />
<col style="width: 39%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operación</p></th>
<th class="head"><p>Resultado</p></th>
<th class="head"><p>Notas</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s[i]</span> <span class="pre">=</span> <span class="pre">x</span></code></p></td>
<td><p>el elemento <em>i</em> de <em>s</em> es reemplazado por <em>x</em></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">s[i:j]</span> <span class="pre">=</span> <span class="pre">t</span></code></p></td>
<td><p>el segmento de valores de <em>s</em> que van de <em>i</em> a <em>j</em> es reemplazada por el contenido del iterador <em>t</em></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">s[i:j]</span></code></p></td>
<td><p>equivalente a <code class="docutils literal notranslate"><span class="pre">s[i:j]</span> <span class="pre">=</span> <span class="pre">[]</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">s[i:j:k]</span> <span class="pre">=</span> <span class="pre">t</span></code></p></td>
<td><p>los elementos de <code class="docutils literal notranslate"><span class="pre">s[i:j:k]</span></code> son reemplazados por los elementos de <em>t</em></p></td>
<td><p>(1)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">s[i:j:k]</span></code></p></td>
<td><p>borra los elementos de <code class="docutils literal notranslate"><span class="pre">s[i:j:k]</span></code> de la lista</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">s.append(x)</span></code></p></td>
<td><p>añade <em>x</em> al final de la secuencia (equivale a <code class="docutils literal notranslate"><span class="pre">s[len(s):len(s)]</span> <span class="pre">=</span> <span class="pre">[x]</span></code>)</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s.clear()</span></code></p></td>
<td><p>elimina todos los elementos de <em>s</em> (equivale a <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">s[:]</span></code>)</p></td>
<td><p>(5)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">s.copy()</span></code></p></td>
<td><p>crea una copia superficial de <em>s</em> (equivale a <code class="docutils literal notranslate"><span class="pre">s[:]</span></code>)</p></td>
<td><p>(5)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s.extend(t)</span></code> o <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">+=</span> <span class="pre">t</span></code></p></td>
<td><p>extiende <em>s</em> con los contenidos de <em>t</em> (en la mayoría de los casos equivale a <code class="docutils literal notranslate"><span class="pre">s[len(s):len(s)]</span> <span class="pre">=</span> <span class="pre">t</span></code>)</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">*=</span> <span class="pre">n</span></code></p></td>
<td><p>actualiza <em>s</em> con su contenido repetido <em>n</em> veces</p></td>
<td><p>(6)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s.insert(i,</span> <span class="pre">x)</span></code></p></td>
<td><p>inserta <em>x</em> en <em>s</em> en la posición indicada por el índice <em>i</em> (equivale a <code class="docutils literal notranslate"><span class="pre">s[i:i]</span> <span class="pre">=</span> <span class="pre">[x]</span></code>)</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">s.pop()</span></code> o <code class="docutils literal notranslate"><span class="pre">s.pop(i)</span></code></p></td>
<td><p>retorna el elemento en la posición indicada por <em>i</em>, y a la vez lo elimina de la secuencia <em>s</em></p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s.remove(x)</span></code></p></td>
<td><p>elimina el primer elemento de <em>s</em> tal que <code class="docutils literal notranslate"><span class="pre">s[i]</span></code> sea igual a <em>x</em></p></td>
<td><p>(3)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">s.reverse()</span></code></p></td>
<td><p>invierte el orden de los elementos de <em>s</em>, a nivel interno</p></td>
<td><p>(4)</p></td>
</tr>
</tbody>
</table>
<p>Notas:</p>
<ol class="arabic">
<li><p>La secuencia <em>t</em> debe tener la misma longitud que el segmento a la que reemplaza.</p></li>
<li><p>El parámetro opcional <em>i</em> tiene un valor por defecto de <code class="docutils literal notranslate"><span class="pre">-1</span></code>, así que si no se especifica se retorna el último valor y este se elimina de la secuencia.</p></li>
<li><p>El método <code class="xref py py-meth docutils literal notranslate"><span class="pre">remove()</span></code> lanza la excepción <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> cuando no se encuentra <em>x</em> en <em>s</em>.</p></li>
<li><p>El método <code class="xref py py-meth docutils literal notranslate"><span class="pre">reverse()</span></code> modifica la secuencia internamente, por motivos de eficiencia espacial para secuencias muy grandes. Como recordatorio al usuario de que el método produce un efecto secundario, no se retorna la secuencia invertida.</p></li>
<li><p>Ambos métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code> se incluyen por consistencia con las interfaces de clases que no soportan operaciones de segmentación (como las clases <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> y <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>). El método <code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code> no es parte de la clase ABC <a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSequence</span></code></a>, pero la mayoría de las clases finales de tipo secuencia mutable lo incluyen.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3: </span>Los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code>.</p>
</div>
</li>
<li><p>El valor de <em>n</em> es un entero, o un objeto que implemente el método <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>. Los valores negativos, junto con el cero, producen una lista vacía. Los elementos de la secuencia no son copiados, sino que se referencian múltiples veces, tal y como se explicó para <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">*</span> <span class="pre">n</span></code> en <a class="reference internal" href="#typesseq-common"><span class="std std-ref">Operaciones comunes de las secuencias</span></a>.</p></li>
</ol>
</section>
<section id="lists">
<span id="typesseq-list"></span><h3>Listas<a class="headerlink" href="#lists" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-24">Las listas son secuencia mutables, usadas normalmente para almacenar colecciones de elementos homogéneos (donde el grado de similitud de los mismos depende de la aplicación).</p>
<dl class="py class">
<dt class="sig sig-object py" id="list">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">list</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#list" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Las listas se pueden construir de diferentes formas:</p>
<ul class="simple">
<li><p>Usando un par de corchetes para definir una lista vacía: <code class="docutils literal notranslate"><span class="pre">[]</span></code></p></li>
<li><p>Usando corchetes, separando los elementos incluidos con comas: <code class="docutils literal notranslate"><span class="pre">[a]</span></code>, <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">c]</span></code></p></li>
<li><p>Usando una lista intensiva o por comprensión: <code class="docutils literal notranslate"><span class="pre">[x</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">iterable]</span></code></p></li>
<li><p>Usando el constructor de tipo: <code class="docutils literal notranslate"><span class="pre">list()</span></code> o <code class="docutils literal notranslate"><span class="pre">list(iterable)</span></code></p></li>
</ul>
<p>La lista se construye con los mismos elementos y en el mismo orden que <em>iterable</em>, donde <em>iterable</em> puede ser una secuencia, un contenedor que soporta iteración, o un objeto iterador. Si <em>iterable</em> es de por si una lista, se construye y retorna una copia, como si se hubiera llamado a <code class="docutils literal notranslate"><span class="pre">iterable[:]</span></code>. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">list('abc')</span></code> retorna <code class="docutils literal notranslate"><span class="pre">['a',</span> <span class="pre">'b',</span> <span class="pre">'c']</span></code> y <code class="docutils literal notranslate"><span class="pre">list(</span> <span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span> <span class="pre">)</span></code> retorna <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code>. Si no se pasan parámetros, se construye una nueva lista vacía, <code class="docutils literal notranslate"><span class="pre">[]</span></code>.</p>
<p>Muchas otras operaciones también producen listas, incluyendo la función incorporada <a class="reference internal" href="functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a>.</p>
<p>Las listas implementan todas las operaciones <a class="reference internal" href="#typesseq-common"><span class="std std-ref">comunes</span></a> y <a class="reference internal" href="#typesseq-mutable"><span class="std std-ref">mutables</span></a> propias de las secuencias. Además, las listas incorporan los siguientes métodos:</p>
<dl class="py method">
<dt class="sig sig-object py" id="list.sort">
<span class="sig-name descname"><span class="pre">sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#list.sort" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método ordena la lista <em>in situ</em> (se modifica internamente), usando únicamente comparaciones de tipo <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>. Las excepciones no son capturadas internamente: si alguna comparación falla, la operación entera de ordenación falla (y la lista probablemente haya quedado modificada parcialmente).</p>
<p>El método <a class="reference internal" href="#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code></a> acepta dos parámetros, que solo pueden pasarse por nombre (<a class="reference internal" href="../glossary.html#keyword-only-parameter"><span class="std std-ref">keyword-only arguments</span></a>):</p>
<p>El parámetro <em>key</em> especifica una función de un argumento que se usa para obtener, para cada elemento de la lista, un valor concreto o clave (<em>key</em>) a usar en las operaciones de comparación (por ejemplo, <code class="docutils literal notranslate"><span class="pre">key=str.lower</span></code>). El elemento clave para cada elemento se calcula una única vez y se reutiliza para todo el proceso de ordenamiento. El valor por defecto, <code class="docutils literal notranslate"><span class="pre">None</span></code>, hace que la lista se ordene comparando directamente los elementos, sin obtener valores clave.</p>
<p>La utilidad <a class="reference internal" href="functools.html#functools.cmp_to_key" title="functools.cmp_to_key"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.cmp_to_key()</span></code></a> se puede usar para convertir una función <em>cmp</em> del estilo de la versión 2.x a una función <em>key</em>.</p>
<p>El valor de <em>reverse</em> es un valor booleano. Si se define como <code class="docutils literal notranslate"><span class="pre">True</span></code>, entonces los elementos de la lista se ordenan como si las operaciones de comparación se hubiesen invertido.</p>
<p>Este método modifica la lista <em>in situ</em>, para ahorrar espacio cuando se ordena una secuencia muy grande. Para recordar a los usuarios que funciona de esta manera, no se retorna la secuencia ordenada (puedes usar <a class="reference internal" href="functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a> para obtener de forma explicita una nueva secuencia ordenada).</p>
<p>El método <a class="reference internal" href="#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code></a> es estable. Un algoritmo de ordenación es estable si garantiza que no se cambia el orden relativo que mantienen inicialmente los elementos que se consideran iguales — esto es útil para realizar ordenaciones en múltiples fases (por ejemplo, ordenar por departamento y después por salario).</p>
<p>Para ver ejemplos de ordenación y un breve tutorial sobre el tema, véase <a class="reference internal" href="../howto/sorting.html#sortinghowto"><span class="std std-ref">HOW TO - Ordenar</span></a>.</p>
<div class="impl-detail compound">
<p><strong>Detalles de implementación de CPython:</strong> Mientras una lista está siendo ordenada, los efectos de intentar modificarla, o incluso examinarla, no están definidos. La implementación en C de Python hace que la lista parezca vacía durante la ordenación, y lanza una excepción del tipo <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> si detecta un cambio en la lista durante el proceso de ordenación.</p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="tuples">
<span id="typesseq-tuple"></span><h3>Tuplas<a class="headerlink" href="#tuples" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-25">Las tuplas son secuencias inmutables, usadas normalmente para almacenar colecciones de datos heterogéneos (como las duplas o tuplas de dos elementos producidas por la función incorporada <a class="reference internal" href="functions.html#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a>). También son usadas en aquellos casos donde se necesite una secuencia inmutable de datos homogéneos (como por ejemplo permitir el almacenamiento en un objeto de tipo <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> o <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>).</p>
<dl class="py class">
<dt class="sig sig-object py" id="tuple">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tuple</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#tuple" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Las tuplas se pueden construir de diferentes maneras:</p>
<ul class="simple">
<li><p>Usando un par de símbolos de paréntesis, para indicar una tupla vacía: <code class="docutils literal notranslate"><span class="pre">()</span></code></p></li>
<li><p>Usando una coma al final, para crear una tupla de un único elemento: <code class="docutils literal notranslate"><span class="pre">a,</span></code> o <code class="docutils literal notranslate"><span class="pre">(a,)</span></code></p></li>
<li><p>Separando los elementos por comas: <code class="docutils literal notranslate"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c</span></code> o <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code></p></li>
<li><p>Usando la función incorporada <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">tuple()</span></code></a>: <code class="docutils literal notranslate"><span class="pre">tuple()</span></code> o <code class="docutils literal notranslate"><span class="pre">tuple(iterable)</span></code></p></li>
</ul>
<p>El constructor genera una tupla cuyos elementos son los mismos y están en el mismo orden que los elementos del <em>iterable</em>, donde <em>iterable</em> puede ser una secuencia, un contenedor que soporta iteración, o un objeto de tipo <em>iterator</em>. Si <em>iterable</em> es ya de por si una tupla, se retorna sin cambiar. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">tuple('abc')</span></code> retorna <code class="docutils literal notranslate"><span class="pre">('a',</span> <span class="pre">'b',</span> <span class="pre">'c')</span></code> y <code class="docutils literal notranslate"><span class="pre">tuple(</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span> <span class="pre">)</span></code> retorna <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">2,</span> <span class="pre">3)</span></code>. Si no se indica ningún parámetro, el constructor creará una nueva tupla vacía. <code class="docutils literal notranslate"><span class="pre">()</span></code>.</p>
<p>Nótese que es la coma la que realmente construye la tupla, no los paréntesis. Los paréntesis son opcionales, excepto en el caso de la tupla vacía, o cuando se necesitan para evitar una ambigüedad sintáctica. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">f(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> es una llamada a una función con tres parámetros, pero <code class="docutils literal notranslate"><span class="pre">f((a,</span> <span class="pre">b,</span> <span class="pre">c))</span></code> es una llamada a una función con un único parámetro, en este caso una tupla de tres elementos.</p>
<p>Las tuplas implementan todas las operaciones de secuencia <a class="reference internal" href="#typesseq-common"><span class="std std-ref">comunes</span></a>.</p>
</dd></dl>

<p>Para colecciones de datos heterogéneos donde el acceso por nombre resulta más claro que por índice, quizá crear una tupla con nombres (<a class="reference internal" href="collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a>) pueden ser más apropiado.</p>
</section>
<section id="ranges">
<span id="typesseq-range"></span><h3>Rangos<a class="headerlink" href="#ranges" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-26">Los objetos de tipo <a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a> representan una secuencia inmutable de números y se usan habitualmente para ejecutar un bucle <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> un número determinado de veces.</p>
<dl class="py class">
<dt class="sig sig-object py" id="range">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stop</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#range" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">step</span></span></em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Los parámetros usados por el constructor del rango deben ser números enteros (o bien objetos de tipo <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> o instancias de una clase que implemente el método especial <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>). Si el parámetro <em>step</em> se omite, se asume el valor <code class="docutils literal notranslate"><span class="pre">1</span></code>. Si se omite el parámetro <code class="docutils literal notranslate"><span class="pre">start</span></code>, se toma como <code class="docutils literal notranslate"><span class="pre">0</span></code>. Si <em>step</em> es cero, se lanza una excepción de tipo <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
<p>Para un valor positivo de <em>step</em>, el contenido del rango <code class="docutils literal notranslate"><span class="pre">r</span></code> viene determinado por la fórmula <code class="docutils literal notranslate"><span class="pre">r[i]</span> <span class="pre">=</span> <span class="pre">start</span> <span class="pre">+</span> <span class="pre">step*i</span></code> donde <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> y <code class="docutils literal notranslate"><span class="pre">r[i]</span> <span class="pre">&lt;</span> <span class="pre">stop</span></code>.</p>
<p>Para un valor negativo de <em>step</em>, el contenido del rango sigue estando determinado por la fórmula <code class="docutils literal notranslate"><span class="pre">r[i]</span> <span class="pre">=</span> <span class="pre">start</span> <span class="pre">+</span> <span class="pre">step*i</span></code>, pero las restricciones ahora son <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> y <code class="docutils literal notranslate"><span class="pre">r[i]</span> <span class="pre">&gt;</span> <span class="pre">stop</span></code>.</p>
<p>Un objeto de tipo rango se considera vacío si <code class="docutils literal notranslate"><span class="pre">r[0]</span></code> no cumple con las restricciones de valor. Los rangos soportan índices negativos, pero estos son interpretados como índices considerados desde el final de la secuencia determinada por los índices positivos.</p>
<p>Los rangos que contengan valores mayores que <a class="reference internal" href="sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.maxsize</span></code></a> se permiten, pero algunas capacidades (como la función <a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>) pueden lanzar una excepción de tipo <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>.</p>
<p>Ejemplos de rangos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">[0, 5, 10, 15, 20, 25]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">[0, 3, 6, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>Los rangos implementan todas las operaciones <a class="reference internal" href="#typesseq-common"><span class="std std-ref">comunes</span></a> de las secuencias, excepto la concatenación y la repetición (esto es porque los objetos de tipo rango solamente pueden representar secuencias que siguen un patrón estricto, y tanto la repetición como la concatenación pueden romperlo).</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="range.start">
<span class="sig-name descname"><span class="pre">start</span></span><a class="headerlink" href="#range.start" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El valor del parámetro <em>start</em> (<code class="docutils literal notranslate"><span class="pre">0</span></code> si no se utiliza el parámetro)</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="range.stop">
<span class="sig-name descname"><span class="pre">stop</span></span><a class="headerlink" href="#range.stop" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El valor del parámetro <em>stop</em></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="range.step">
<span class="sig-name descname"><span class="pre">step</span></span><a class="headerlink" href="#range.step" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El valor del parámetro <em>step</em> (<code class="docutils literal notranslate"><span class="pre">1</span></code> si no se utiliza el parámetro)</p>
</dd></dl>

</dd></dl>

<p>La ventaja de usar un objeto de tipo <a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a> en vez de uno de tipo <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> o <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> es que con <a class="reference internal" href="#range" title="range"><code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a> siempre se usa una cantidad fija (y pequeña) de memoria, independientemente del rango que represente (ya que solamente necesita almacenar los valores para <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">stop</span></code> y <code class="docutils literal notranslate"><span class="pre">step</span></code>, y calcula los valores intermedios a medida que los va necesitando).</p>
<p>Los objetos rango implementan la clase ABC <a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a>, y proporcionan capacidades como comprobación de inclusión, búsqueda de elementos por índice, operaciones de segmentación y soporte de índices negativos (véase <a class="reference internal" href="#typesseq"><span class="std std-ref">Tipos secuencia — list, tuple, range</span></a>):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span>
<span class="go">range(0, 20, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">11</span> <span class="ow">in</span> <span class="n">r</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">10</span> <span class="ow">in</span> <span class="n">r</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">range(0, 10, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">18</span>
</pre></div>
</div>
<p>La comparación entre rangos usando los operadores <code class="docutils literal notranslate"><span class="pre">==</span></code> y <code class="docutils literal notranslate"><span class="pre">!=</span></code> se realiza como con las secuencias. Esto es, dos rangos se consideran iguales si representan exactamente la misma secuencia de elementos. (Fíjate que, según esta definición, dos rangos pueden considerarse iguales aunque tengan diferentes valores para <a class="reference internal" href="#range.start" title="range.start"><code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code></a>, <a class="reference internal" href="#range.stop" title="range.stop"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code></a> y <a class="reference internal" href="#range.step" title="range.step"><code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code></a>, por ejemplo <code class="docutils literal notranslate"><span class="pre">range(0)</span> <span class="pre">==</span> <span class="pre">range(2,</span> <span class="pre">1,</span> <span class="pre">3)</span></code> y <code class="docutils literal notranslate"><span class="pre">range(0,</span> <span class="pre">3,</span> <span class="pre">2)</span> <span class="pre">==</span> <span class="pre">range(0,</span> <span class="pre">4,</span> <span class="pre">2)</span></code>).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Implementa la secuencia ABC. Soporta operaciones de segmentación e índices negativos. Comprueba si un entero de tipo <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> está incluido en un rango que se realiza en un tiempo constante, en lugar de iterar a través de todos los elementos.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Define los operadores “==” y “!=” para comparar rangos en base a la secuencia de valores que definen (en vez de compararse en base a la identidad).</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3: </span>Los atributos <a class="reference internal" href="#range.start" title="range.start"><code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code></a>, <a class="reference internal" href="#range.stop" title="range.stop"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code></a> y <a class="reference internal" href="#range.step" title="range.step"><code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code></a>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<ul class="simple">
<li><p>En <a class="reference external" href="https://code.activestate.com/recipes/579000/">linspace recipe</a> se muestra como implementar una versión <em>lazy</em> o perezosa de rango adecuada para aplicaciones de coma flotante.</p></li>
</ul>
</div>
</section>
</section>
<section id="text-sequence-type-str">
<span id="textseq"></span><span id="index-27"></span><h2>Cadenas de caracteres — <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a><a class="headerlink" href="#text-sequence-type-str" title="Enlazar permanentemente con este título">¶</a></h2>
<p>La información textual se representa en Python con objetos de tipo <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, normalmente llamados cadenas de caracteres o simplemente <em class="dfn">strings</em>. Las cadenas de caracteres son <a class="reference internal" href="#typesseq"><span class="std std-ref">secuencias</span></a> inmutables de puntos de código Unicode. Las cadenas se pueden definir de diferentes maneras:</p>
<ul class="simple">
<li><p>Comillas simples: <code class="docutils literal notranslate"><span class="pre">'permite</span> <span class="pre">incluir</span> <span class="pre">comillas</span> <span class="pre">&quot;dobles&quot;'</span></code></p></li>
<li><p>Comillas dobles: <code class="docutils literal notranslate"><span class="pre">&quot;permite</span> <span class="pre">incluir</span> <span class="pre">comillas</span> <span class="pre">'simples'&quot;</span></code></p></li>
<li><p>Triples comillas: ya sea con comillas simples <code class="docutils literal notranslate"><span class="pre">'''Triples</span> <span class="pre">comillas</span> <span class="pre">simples'''</span></code> o dobles <code class="docutils literal notranslate"><span class="pre">&quot;&quot;&quot;Triples</span> <span class="pre">comillas</span> <span class="pre">dobles&quot;&quot;&quot;</span></code></p></li>
</ul>
<p>Las cadenas definidas con comillas tripes pueden incluir varias líneas - todos los espacios en blancos incluidos se incorporan a la cadena de forma literal.</p>
<p>Cadenas literales que forman parte de una expresión y que solo estén separados por espacios en blanco, se convertirán implícitamente a una única cadena. Esto es, <code class="docutils literal notranslate"><span class="pre">(&quot;spam</span> <span class="pre">&quot;</span> <span class="pre">&quot;eggs&quot;)</span> <span class="pre">==</span> <span class="pre">&quot;spam</span> <span class="pre">eggs&quot;</span></code>.</p>
<p>Véase <a class="reference internal" href="../reference/lexical_analysis.html#strings"><span class="std std-ref">Literales de cadenas y bytes</span></a> para más información acerca de las diferentes formas de expresar cadenas de forma literal, incluidos los caracteres de escape, y del prefijo <code class="docutils literal notranslate"><span class="pre">r</span></code> (»<em>raw</em>») que deshabilita el procesamiento de la mayoría de dichas secuencias de escape.</p>
<p>Las cadenas de caracteres también se pueden crear usando el constructor <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p>
<p>Como no hay un tipo separado para los «caracteres», indexar una cadena produce una cadena de longitud 1. Esto es, para una cadena de caracteres no vacía <em>s</em>, <code class="docutils literal notranslate"><span class="pre">s[0]</span> <span class="pre">==</span> <span class="pre">s[0:1]</span></code>.</p>
<p id="index-28">Tampoco hay una versión mutable de las cadenas de caracteres, pero el método <a class="reference internal" href="#str.join" title="str.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.join()</span></code></a> o la clase <a class="reference internal" href="io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a> pueden usarse para construir de forma eficiente una cadena de caracteres a partir de fragmentos.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Para facilitar la compatibilidad hacia atrás con la versión 2, el prefijo <code class="docutils literal notranslate"><span class="pre">u</span></code> se permite en las cadenas de caracteres. No tiene ningún efecto en la interpretación del literal y no se puede combinar con el prefijo <code class="docutils literal notranslate"><span class="pre">r</span></code>.</p>
</div>
<span class="target" id="index-29"></span><dl class="py class">
<dt class="sig sig-object py" id="str">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">str</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#str" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">str</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">b''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'utf-8'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Retorna una representación en forma de <a class="reference internal" href="#textseq"><span class="std std-ref">cadena de caracteres</span></a> de <em>object</em>. Si no se proporciona ningún valor, retorna una cadena vacía. Si se proporciona, el comportamiento de <code class="docutils literal notranslate"><span class="pre">str()</span></code> depende de los valores pasados en los parámetros <em>encoding</em> y <em>errors</em>, como veremos.</p>
<p>Si no se especifica ni <em>encoding</em> ni <em>errors</em>, <code class="docutils literal notranslate"><span class="pre">str(object)</span></code> retorna <a class="reference internal" href="../reference/datamodel.html#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">type(object).__str__(object)</span></code></a>, que es la representación «informal» o mas cómoda de usar, en forma de cadena de caracteres, del valor de <em>object</em>. Para una cadena de caracteres, es la cadena en sí. Si <em>object</em> no tiene un método <a class="reference internal" href="../reference/datamodel.html#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a>, entonces <a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> usará como reemplazo el método <a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-meth docutils literal notranslate"><span class="pre">repr(object)</span></code></a>.</p>
<p id="index-30">Si se indica alguno de los dos parámetros <em>encoding</em> o <em>errors</em>, entonces <em>object</em> debe ser un objeto binario o similar (<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>, es decir, una instancia de <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> o <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>). En este caso, si <em>object</em> es de tipo <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> o <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>, la llamada a <code class="docutils literal notranslate"><span class="pre">str(bytes,</span> <span class="pre">encoding,</span> <span class="pre">errors)</span></code> es equivalente a <a class="reference internal" href="#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode(encoding,</span> <span class="pre">errors)</span></code></a>. Si no, el objeto de tipo <em>bytes</em> que esta subyacente en el objeto <em>buffer</em> se obtiene mediante una llamada a <a class="reference internal" href="#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a>. Véase <a class="reference internal" href="#binaryseq"><span class="std std-ref">Tipos de secuencias binarias — bytes, bytearray y memoryview</span></a> y <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">Protocolo búfer</span></a> para más información sobre los objetos <em>buffer</em>.</p>
<p>Si se pasa un objeto de tipo <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> a la función <a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> sin especificar o bien el parámetro <em>encoding</em> o bien el <em>errors</em>, se vuelve al caso normal donde se retorna la representación informal de la cadena de caracteres (véase también la <a class="reference internal" href="../using/cmdline.html#cmdoption-b"><code class="xref std std-option docutils literal notranslate"><span class="pre">-b</span></code></a> de las opciones de línea de órdenes de Python). Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Zoot!&#39;</span><span class="p">)</span>
<span class="go">&quot;b&#39;Zoot!&#39;&quot;</span>
</pre></div>
</div>
<p>Para más información sobre la clase <code class="docutils literal notranslate"><span class="pre">str</span></code> y sus métodos, consulta <a class="reference internal" href="#textseq"><span class="std std-ref">Cadenas de caracteres — str</span></a> y la sección <a class="reference internal" href="#string-methods"><span class="std std-ref">Métodos de las cadenas de caracteres</span></a> a continuación. Para las opciones de formateo de cadenas, lee las secciones <a class="reference internal" href="../reference/lexical_analysis.html#f-strings"><span class="std std-ref">Literales de cadena formateados</span></a> y <a class="reference internal" href="string.html#formatstrings"><span class="std std-ref">Sintaxis de formateo de cadena</span></a>. También puedes consultar la sección <a class="reference internal" href="text.html#stringservices"><span class="std std-ref">Servicios de procesamiento de texto</span></a>.</p>
</dd></dl>

<section id="string-methods">
<span id="index-31"></span><span id="id5"></span><h3>Métodos de las cadenas de caracteres<a class="headerlink" href="#string-methods" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-32">Todas las cadenas de caracteres implementan las operaciones <a class="reference internal" href="#typesseq-common"><span class="std std-ref">comunes</span></a> de las secuencias, junto con los métodos descritos a continuación.</p>
<p>Las cadenas soportan dos estilos de formateo, uno proporciona un grado muy completo de flexibilidad y personalización (véase <a class="reference internal" href="#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a>, <a class="reference internal" href="string.html#formatstrings"><span class="std std-ref">Sintaxis de formateo de cadena</span></a> y <a class="reference internal" href="string.html#string-formatting"><span class="std std-ref">Formato de cadena de caracteres personalizado</span></a>) mientras que el otro se basa en la función C <code class="docutils literal notranslate"><span class="pre">printf</span></code>, que soporta un menor número de tipos y es ligeramente más complicada de usar, pero es a menudo más rápida para los casos que puede manejar (<a class="reference internal" href="#old-string-formatting"><span class="std std-ref">Formateo de cadenas al estilo *printf*</span></a>).</p>
<p>La sección <a class="reference internal" href="text.html#textservices"><span class="std std-ref">Servicios de procesamiento de texto</span></a> de la librería estándar cubre una serie de módulos que proporcionan varias utilidades para trabajar con textos (incluyendo las expresiones regulares en el módulo <a class="reference internal" href="re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a>).</p>
<dl class="py method">
<dt class="sig sig-object py" id="str.capitalize">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">capitalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.capitalize" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de la cadena con el primer carácter en mayúsculas y el resto en minúsculas.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>El primer carácter se pasa ahora a título, más que a mayúsculas. Esto significa que caracteres como dígrafos solo tendrán la primera letra en mayúsculas, en vez de todo el carácter.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.casefold">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">casefold</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.casefold" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el texto de la cadena, normalizado a minúsculas. Los textos así normalizados pueden usarse para realizar búsquedas textuales independientes de mayúsculas y minúsculas.</p>
<p>El texto normalizado a minúsculas es más agresivo que el texto en minúsculas normal, porque se intenta unificar todas las grafías distintas de la letras. Por ejemplo, en Alemán la letra minúscula <code class="docutils literal notranslate"><span class="pre">'ß'</span></code> equivale a <code class="docutils literal notranslate"><span class="pre">&quot;ss&quot;</span></code>. Como ya está en minúsculas, el método <a class="reference internal" href="#str.lower" title="str.lower"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lower()</span></code></a> no modifica <code class="docutils literal notranslate"><span class="pre">'ß'</span></code>, pero el método <a class="reference internal" href="#str.casefold" title="str.casefold"><code class="xref py py-meth docutils literal notranslate"><span class="pre">casefold()</span></code></a> lo convertirá a <code class="docutils literal notranslate"><span class="pre">&quot;ss&quot;</span></code>.</p>
<p>El algoritmo de normalización a minúsculas se describe en la sección 3.13 del estándar Unicode.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.center">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">center</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">fillchar</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.center" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el texto de la cadena, centrado en una cadena de longitud <em>width</em>. El relleno a izquierda y derecha se realiza usando el carácter definido por el parámetro <em>fillchar</em> (por defecto se usa el carácter espacio ASCII). Si la cadena original tiene una longitud <code class="docutils literal notranslate"><span class="pre">len(s)</span></code> igual o superior a <em>width</em>, se retorna el texto sin modificar.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.count">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">count</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.count" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el número de ocurrencias no solapadas de la cadena <em>sub</em> en el rango [<em>start</em>, <em>end</em>]. Los parámetros opcionales <em>start</em> y <em>end</em> se interpretan como en una expresión de segmento.</p>
<p>If <em>sub</em> is empty, returns the number of empty strings between characters
which is the length of the string plus one.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.encode">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'utf-8'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#str.encode" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Return the string encoded to <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
<p><em>encoding</em> defaults to <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>;
see <a class="reference internal" href="codecs.html#standard-encodings"><span class="std std-ref">Codificaciones estándar</span></a> for possible values.</p>
<p><em>errors</em> controls how encoding errors are handled.
If <code class="docutils literal notranslate"><span class="pre">'strict'</span></code> (the default), a <a class="reference internal" href="exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a> exception is raised.
Other possible values are <code class="docutils literal notranslate"><span class="pre">'ignore'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'replace'</span></code>, <code class="docutils literal notranslate"><span class="pre">'xmlcharrefreplace'</span></code>, <code class="docutils literal notranslate"><span class="pre">'backslashreplace'</span></code> and any
other name registered via <a class="reference internal" href="codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.register_error()</span></code></a>.
See <a class="reference internal" href="codecs.html#error-handlers"><span class="std std-ref">Manejadores de errores</span></a> for details.</p>
<p>For performance reasons, the value of <em>errors</em> is not checked for validity
unless an encoding error actually occurs,
<a class="reference internal" href="devmode.html#devmode"><span class="std std-ref">Modo de desarrollo de Python</span></a> is enabled
or a <a class="reference internal" href="../using/configure.html#debug-build"><span class="std std-ref">debug build</span></a> is used.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.1: </span>Añadido soporte para poder usar parámetros por nombre.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.9: </span>The value of the <em>errors</em> argument is now checked in <a class="reference internal" href="devmode.html#devmode"><span class="std std-ref">Modo de desarrollo de Python</span></a> and
in <a class="reference internal" href="../using/configure.html#debug-build"><span class="std std-ref">debug mode</span></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.endswith">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">endswith</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suffix</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.endswith" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si la cadena termina con el <em>suffix</em> especificado y <code class="docutils literal notranslate"><span class="pre">False</span></code> en caso contrario. También podemos usar <em>suffix</em> para pasar una tupla de sufijos a buscar. Si especificamos el parámetro opcional <em>start</em>, la comprobación empieza en esa posición. Con el parámetro opcional <em>stop</em>, la comprobación termina en esa posición.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.expandtabs">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">expandtabs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tabsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#str.expandtabs" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de la cadena, con todos los caracteres de tipo tabulador reemplazados por uno o más espacios, dependiendo de la columna actual y del tamaño definido para el tabulador. Las posiciones de tabulación ocurren cada <em>tabsize</em> caracteres (siendo el valor por defecto de <em>tabsize</em> 8, lo que produce las posiciones de tabulación 0, 8, 16,…). Para expandir la cadena, la columna actual se pone a cero y se va examinando el texto carácter a carácter. Si se encuentra un tabulador, (<code class="docutils literal notranslate"><span class="pre">\t</span></code>), se insertan uno o más espacios hasta que sea igual a la siguiente posición de tabulación (El carácter tabulador en sí es descartado). Si el carácter en un indicador de salto de línea (<code class="docutils literal notranslate"><span class="pre">\n</span></code>) o de retorno (<code class="docutils literal notranslate"><span class="pre">\r</span></code>), se copia y el valor de columna actual se vuelve a poner a cero. Cualquier otro carácter es copiado sin cambios y hace que el contador de columna se incremente en 1, sin tener en cuenta como se representa gráficamente el carácter.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234&#39;</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span>
<span class="go">&#39;01      012     0123    01234&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234&#39;</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&#39;01  012 0123    01234&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.find">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">find</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.find" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el menor índice de la cadena <em>s</em> donde se puede encontrar la cadena <em>sub</em>, considerando solo el intervalo <code class="docutils literal notranslate"><span class="pre">s[start:end]</span></code>. Los parámetros opcionales <em>start</em> y <em>end</em> se interpretan como notación de segmento. Retorna <code class="docutils literal notranslate"><span class="pre">-1</span></code> si no se encuentra la cadena.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>El método <a class="reference internal" href="#str.find" title="str.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a> se debe usar solo si se necesita saber la posición de la cadena <em>sub</em>. Si solo se necesita comprobar si <em>sub</em> es una parte de <em>s</em>, es mejor usar el operador <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Py&#39;</span> <span class="ow">in</span> <span class="s1">&#39;Python&#39;</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.format">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">format</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#str.format" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Realiza una operación de formateo. La cadena de caracteres sobre la que se está ejecutando este método puede contener texto literal y también marcas de reemplazo de texto definidas mediante llaves <code class="docutils literal notranslate"><span class="pre">{}</span></code>. Cada sección a reemplazar contiene o bien un índice numérico que hace referencia a un parámetro por posición, o el nombre de un parámetro por nombre. Retorna una copia de la cadena donde se han sustituido las marcas de reemplazo por los valores correspondientes pasados como parámetros.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;The sum of 1 + 2 is </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;The sum of 1 + 2 is 3&#39;</span>
</pre></div>
</div>
<p>Véase <a class="reference internal" href="string.html#formatstrings"><span class="std std-ref">Sintaxis de formateo de cadena</span></a> para una descripción de las distintas opciones de formateo que se pueden usar.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Cuando se formatea un número (<a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>, <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">decimal.Decimal</span></code></a> y clases derivadas) usando la <code class="docutils literal notranslate"><span class="pre">n</span></code> (por ejemplo, <code class="docutils literal notranslate"><span class="pre">'{:n}'.format(1234)</span></code>), la función ajusta temporalmente el valor de la variable de entorno local <code class="docutils literal notranslate"><span class="pre">LC_TYPE</span></code> a <code class="docutils literal notranslate"><span class="pre">LC_NUMERIC</span></code> para decodificar los campos <code class="docutils literal notranslate"><span class="pre">decimal_point</span></code> y <code class="docutils literal notranslate"><span class="pre">thousands_sep</span></code> de la función <code class="xref c c-func docutils literal notranslate"><span class="pre">localeconv()</span></code>, si usan caracteres que no son ASCII o si ocupan más de un byte, y el valor definido en <code class="docutils literal notranslate"><span class="pre">LC_NUMERIC</span></code> es diferente del definido en <code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code>. Estos cambios temporales pueden afectar a otros <em>threads</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Cuando se formatea un número usando la <code class="docutils literal notranslate"><span class="pre">n</span></code>, la función puede asignar de forma temporal la variable <code class="docutils literal notranslate"><span class="pre">LC_CTYPE</span></code> a <code class="docutils literal notranslate"><span class="pre">LC_NUMERIC</span></code> en algunos casos.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.format_map">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">format_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#str.format_map" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Similar a <code class="docutils literal notranslate"><span class="pre">str.format(**mapping)</span></code>, pero se usa <code class="docutils literal notranslate"><span class="pre">mapping</span></code> de forma directa y no se copia a un diccionario. Esto es útil si <code class="docutils literal notranslate"><span class="pre">mapping</span></code> es, por ejemplo, una instancia de una subclase de <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Default</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">key</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">{name}</span><span class="s1"> was born in </span><span class="si">{country}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format_map</span><span class="p">(</span><span class="n">Default</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Guido&#39;</span><span class="p">))</span>
<span class="go">&#39;Guido was born in country&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.index">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.index" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Como <a class="reference internal" href="#str.find" title="str.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a>, pero lanza una excepción de tipo <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> si no se encuentra la cadena a buscar.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.isalnum">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">isalnum</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isalnum" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si todos los caracteres de la cadena son alfanuméricos y hay, al menos, un carácter, en caso contrario, retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>. Un carácter <code class="docutils literal notranslate"><span class="pre">c</span></code> se considera alfanumérico si alguna de las siguientes funciones retorna <code class="docutils literal notranslate"><span class="pre">True</span></code>: <code class="docutils literal notranslate"><span class="pre">c.isalpha()</span></code>, <code class="docutils literal notranslate"><span class="pre">c.isdecimal()</span></code>, <code class="docutils literal notranslate"><span class="pre">c.isdigit()</span></code> o <code class="docutils literal notranslate"><span class="pre">c.isnumeric()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.isalpha">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">isalpha</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isalpha" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si todos los caracteres de la cadena son alfabéticos y hay, al menos, un carácter, en caso contrario, retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>. Los caracteres alfabéticos son aquellos definidos en la base de datos de Unicode como «Letter», es decir, aquellos cuya propiedad de categoría general es «Lm», «Lt», «Lu», «Ll» o «Lo». Nótese que esta definición de «Alfabético» es diferente de la que usa el estándar Unicode.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.isascii">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">isascii</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isascii" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si la cadena de caracteres está vacía, o si todos los caracteres de la cadena son ASCII, en caso contrario, retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>. Los caracteres ASCII son aquellos cuyos puntos de código Unicode que están en el rango U+0000-U+007F.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.isdecimal">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">isdecimal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isdecimal" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si todos los caracteres de la cadena son caracteres decimales y hay, al menos, un carácter, en caso contrario, retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>. Los caracteres decimales son aquellos que se pueden usar para formar números en base 10, por ejemplo, U+0660, ARABIC-INDIC DIGIT ZERO. Formalmente, un carácter decimal es un carácter en la categoría general «<cite>Nd</cite>» de Unicode.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.isdigit">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">isdigit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isdigit" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si todos los caracteres de la cadena son dígitos y hay, al menos, un carácter, en caso contrario, retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>. Los dígitos incluyen los caracteres decimales y dígitos que requieren un tratamiento especial, como por ejemplo los usados para superíndices. Esto incluye dígitos que no pueden ser usados para formar números en base 10, como los números Kharosthi. Formalmente, un dígito es un carácter que tiene la propiedad <code class="docutils literal notranslate"><span class="pre">Numeric_Type</span></code> definida como <code class="docutils literal notranslate"><span class="pre">Digit</span></code> o <code class="docutils literal notranslate"><span class="pre">Decimal</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.isidentifier">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">isidentifier</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isidentifier" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si la cadena de caracteres es un identificador válido de acuerdo a la especificación del lenguaje, véase <a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><span class="std std-ref">Identificadores y palabras clave</span></a>.</p>
<p>Se puede usar la función <a class="reference internal" href="keyword.html#keyword.iskeyword" title="keyword.iskeyword"><code class="xref py py-func docutils literal notranslate"><span class="pre">keyword.iskeyword()</span></code></a> para comprobar si la cadena <code class="docutils literal notranslate"><span class="pre">s</span></code> es un identificador reservado, como <a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a> o <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a>.</p>
<p>Ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">keyword</span> <span class="kn">import</span> <span class="n">iskeyword</span>

<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;hello&#39;</span><span class="o">.</span><span class="n">isidentifier</span><span class="p">(),</span> <span class="n">iskeyword</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="go">(True, False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;def&#39;</span><span class="o">.</span><span class="n">isidentifier</span><span class="p">(),</span> <span class="n">iskeyword</span><span class="p">(</span><span class="s1">&#39;def&#39;</span><span class="p">)</span>
<span class="go">(True, True)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.islower">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">islower</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.islower" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si todos los caracteres de la cadena que tengan formas en mayúsculas y minúsculas <a class="footnote-reference brackets" href="#id15" id="id6">4</a> están en minúsculas y hay, al menos, un carácter de ese tipo, en caso contrario, retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.isnumeric">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">isnumeric</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isnumeric" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si todos los caracteres de la cadena son caracteres numéricos y hay, al menos, un carácter, en caso contrario, retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>. Los caracteres numéricos incluyen los dígitos, y todos los caracteres Unicode que tienen definida la propiedad de valor numérico, por ejemplo U+2155, VULGAR FRACTION ONE FIFTH. Formalmente, los caracteres numéricos son aquellos que la propiedad <code class="docutils literal notranslate"><span class="pre">Numeric_Type</span></code> definida como <code class="docutils literal notranslate"><span class="pre">Digit</span></code>, <code class="docutils literal notranslate"><span class="pre">Decimal</span></code> o <code class="docutils literal notranslate"><span class="pre">Numeric</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.isprintable">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">isprintable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isprintable" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si todos los caracteres de la cadena son imprimibles o si la cadena está vacía, en caso contrario, retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>. Los caracteres no imprimibles son aquellos definidos en la base de datos de Unicode como «<em>Other</em>» o «<em>Separator</em>», con la excepción del carácter ASCII espacio (0x20), que se considera imprimible. (Nótese que en este contexto, imprimible son aquellos caracteres que no necesitan ser escapados cuando se imprimen con la función <a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a>. No tiene relevancia en cadenas escritas a <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a> o <a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a>.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.isspace">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">isspace</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isspace" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si todos los caracteres de la cadena son espacios en blanco y hay, al menos, un carácter, en caso contrario, retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>Un carácter se considera espacio en blanco si, en la base de datos de Unicode (véase <a class="reference internal" href="unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code></a>), está clasificado en la categoría general <code class="docutils literal notranslate"><span class="pre">Zs</span></code> («Separador, espacio») o la clase bidireccional es <code class="docutils literal notranslate"><span class="pre">WS</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code> o <code class="docutils literal notranslate"><span class="pre">S</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.istitle">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">istitle</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.istitle" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si las palabras en la cadena tiene forma de título y hay, al menos, un carácter, por ejemplo una mayúscula solo puede aparecer al principio o después de un carácter que no tenga formas alternativas mayúsculas-minúsculas, y las minúsculas solo después de carácter que si tiene formas alternativas mayúsculas-minúsculas. En caso contrario, retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.isupper">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">isupper</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.isupper" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si todos los caracteres de la cadena que tengan formas en mayúsculas y minúsculas <a class="footnote-reference brackets" href="#id15" id="id7">4</a> están en mayúsculas y hay, al menos, un carácter de ese tipo, en caso contrario, retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;BANANA&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;banana&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;baNana&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="meth-str-join"></span><dl class="py method">
<dt class="sig sig-object py" id="str.join">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#str.join" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una cadena de caracteres formada por la concatenación de las cadenas en el <em>iterable</em>. Se lanza una excepción de tipo <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> si alguno de los elementos en el <em>iterable</em> no es una cadena, incluyendo objetos de tipo <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. Se usa como separador entre los elementos la cadena de caracteres pasada como parámetro.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.ljust">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">ljust</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">fillchar</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.ljust" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el texto de la cadena, justificado a la izquierda en una cadena de longitud <em>width</em>. El carácter de relleno a usar viene definido por el parámetro <em>fillchar</em> (por defecto se usa el carácter espacio ASCII). Si la cadena original tiene una longitud <code class="docutils literal notranslate"><span class="pre">len(s)</span></code> igual o superior a <em>width</em>, se retorna el texto sin modificar.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.lower">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">lower</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.lower" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de la cadena de caracteres con todas las letras en minúsculas <a class="footnote-reference brackets" href="#id15" id="id8">4</a>.</p>
<p>El algoritmo usado para la conversión a minúsculas está descrito en la sección 3.13 del estándar Unicode.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.lstrip">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">lstrip</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">chars</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.lstrip" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de la cadena, eliminado determinados caracteres si se encuentren al principio. El parámetro <em>chars</em> especifica el conjunto de caracteres a eliminar. Si se omite o si se especifica <code class="docutils literal notranslate"><span class="pre">None</span></code>, se eliminan todos los espacios en blanco. No debe entenderse el valor de <em>chars</em> como un prefijo, sino que se elimina cualquier combinación de sus caracteres:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
<span class="go">&#39;spacious   &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">&#39;example.com&#39;</span>
</pre></div>
</div>
<p>Véase  <a class="reference internal" href="#str.removeprefix" title="str.removeprefix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.removeprefix()</span></code></a> para un método que removerá una única cadena de prefijo en lugar de todas las ocurrencias dentro de un set de caracteres. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Arthur: three!&#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;Arthur: &#39;</span><span class="p">)</span>
<span class="go">&#39;ee!&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Arthur: three!&#39;</span><span class="o">.</span><span class="n">removeprefix</span><span class="p">(</span><span class="s1">&#39;Arthur: &#39;</span><span class="p">)</span>
<span class="go">&#39;three!&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.maketrans">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">maketrans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.maketrans" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método estático retorna una tabla de traducción apta para ser usada por el método <a class="reference internal" href="#str.translate" title="str.translate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.translate()</span></code></a>.</p>
<p>Si solo se usa un parámetro, este debe ser un diccionario que mapea valores de punto Unicode (enteros) o caracteres (cadenas de longitud 1) a valores Unicode, cadenas (de cualquier longitud) o <code class="docutils literal notranslate"><span class="pre">None</span></code>. Las claves se convertirán a ordinales.</p>
<p>Si se pasan dos parámetros, deben ser cadenas de la misma longitud, y en la tabla resultante, cada carácter en <em>x</em> se mapea al carácter en la misma posición en <em>y</em>. Si se añade un tercer parámetro, debe ser una cadena de caracteres, los cuales se mapearán a <code class="docutils literal notranslate"><span class="pre">None</span></code> en la tabla resultante.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.partition">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">partition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#str.partition" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Divide la cadena en la primera ocurrencia de <em>sep</em>, y retorna una tupla de tres elementos, que contiene la parte anterior al separador, el separador en sí y la parte posterior al separador. Si no se encuentra el separador, retorna una tupla de tres elementos, el primero contiene la cadena original y los dos siguientes son cadenas vacías.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.removeprefix">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">removeprefix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#str.removeprefix" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si la cadena de caracteres empieza con la cadena <em>prefix</em>, retorna <code class="docutils literal notranslate"><span class="pre">string[len(prefix):]</span></code>. De otra manera, retorna una copia de la cadena original:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;TestHook&#39;</span><span class="o">.</span><span class="n">removeprefix</span><span class="p">(</span><span class="s1">&#39;Test&#39;</span><span class="p">)</span>
<span class="go">&#39;Hook&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;BaseTestCase&#39;</span><span class="o">.</span><span class="n">removeprefix</span><span class="p">(</span><span class="s1">&#39;Test&#39;</span><span class="p">)</span>
<span class="go">&#39;BaseTestCase&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.removesuffix">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">removesuffix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suffix</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#str.removesuffix" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si la cadena de caracteres termina con la cadena <em>suffix</em> y <em>suffix</em> no está vacío, retorna <code class="docutils literal notranslate"><span class="pre">string[:-len(suffix)]</span></code>. De otra manera, retorna una copia de la cadena original:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;MiscTests&#39;</span><span class="o">.</span><span class="n">removesuffix</span><span class="p">(</span><span class="s1">&#39;Tests&#39;</span><span class="p">)</span>
<span class="go">&#39;Misc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;TmpDirMixin&#39;</span><span class="o">.</span><span class="n">removesuffix</span><span class="p">(</span><span class="s1">&#39;Tests&#39;</span><span class="p">)</span>
<span class="go">&#39;TmpDirMixin&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.replace">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">old</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">count</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.replace" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de la cadena con todas las ocurrencias de la cadena <em>old</em> sustituidas por <em>new</em>. Si se utiliza el parámetro <em>count</em>, solo se cambian las primeras <em>count</em> ocurrencias.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.rfind">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">rfind</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rfind" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el mayor índice dentro de la cadena <em>s</em> donde se puede encontrar la cadena <em>sub</em>, estando <em>sub</em> incluida en <code class="docutils literal notranslate"><span class="pre">s[start:end]</span></code>. Los parámetros opcionales <em>start</em> y <em>end</em> se interpretan igual que en las operaciones de segmentado. Retorna <code class="docutils literal notranslate"><span class="pre">-1</span></code> si no se encuentra <em>sub</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.rindex">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">rindex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rindex" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Como el método <a class="reference internal" href="#str.rfind" title="str.rfind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rfind()</span></code></a>, pero lanza la excepción <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> si no se encuentra la cadena <em>sub</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.rjust">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">rjust</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">fillchar</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rjust" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el texto de la cadena, justificado a la derecha en una cadena de longitud <em>width</em>. El carácter de relleno a usar viene definido por el parámetro <em>fillchar</em> (por defecto se usa el carácter espacio ASCII). Si <em>width</em> es menor o igual que <code class="docutils literal notranslate"><span class="pre">len(s)</span></code>, se retorna el texto sin modificar.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.rpartition">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">rpartition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#str.rpartition" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Divide la cadena en la última ocurrencia de <em>sep</em>, y retorna una tupla de tres elementos, conteniendo la parte anterior al separador, el separador en sí y la parte posterior al separador. Si no se encuentra el separador, retorna una tupla de tres elementos, los dos primeras son posiciones con cadenas vacías y en la tercera la cadena original.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.rsplit">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">rsplit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsplit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#str.rsplit" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una lista con las palabras que componen la cadena de caracteres original, usando como separador el valor de <em>sep</em>. Si se utiliza el parámetro <em>maxsplit</em>, se realizan como máximo <em>maxsplit</em> divisiones, retornando los que están más a la derecha. Si no se especifica <em>sep</em> o se pasa con valor <code class="docutils literal notranslate"><span class="pre">None</span></code>, se usa como separador cualquier carácter de espacio en blanco. Si no contamos la diferencia de empezar las divisiones desde la derecha, el comportamiento de este método <a class="reference internal" href="#str.rsplit" title="str.rsplit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rsplit()</span></code></a> es equivalente al de <a class="reference internal" href="#str.split" title="str.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a>, que se describe con detalle más adelante.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.rstrip">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">rstrip</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">chars</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.rstrip" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de la cadena, eliminado determinados caracteres si se encuentren al final. El parámetro <em>chars</em> especifica el conjunto de caracteres a eliminar. Si se omite o si se especifica <code class="docutils literal notranslate"><span class="pre">None</span></code>, se eliminan todos los espacios en blanco. No debe entenderse el valor de <em>chars</em> como un sufijo, sino que se elimina cualquier combinación de sus caracteres:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
<span class="go">&#39;   spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;mississippi&#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;ipz&#39;</span><span class="p">)</span>
<span class="go">&#39;mississ&#39;</span>
</pre></div>
</div>
<p>Véase <a class="reference internal" href="#str.removesuffix" title="str.removesuffix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.removesuffix()</span></code></a> para un método que removerá una única cadena de sufijo en lugar de todas las ocurrencias dentro de un set de caracteres. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Monty Python&#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39; Python&#39;</span><span class="p">)</span>
<span class="go">&#39;M&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Monty Python&#39;</span><span class="o">.</span><span class="n">removesuffix</span><span class="p">(</span><span class="s1">&#39; Python&#39;</span><span class="p">)</span>
<span class="go">&#39;Monty&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.split">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsplit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#str.split" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una lista con las palabras que componen la cadena de caracteres original, usando como separador el valor de <em>sep</em>. Si se utiliza el parámetro <em>maxsplit</em>, se realizan como máximo <em>maxsplit</em> divisiones (por tanto, la lista resultante tendrá <code class="docutils literal notranslate"><span class="pre">maxsplit+1</span></code> elementos). Si no se especifica <em>maxsplit</em> o se pasa con valor <code class="docutils literal notranslate"><span class="pre">-1</span></code>, entonces no hay límite al número de divisiones a realizar (se harán todas las que se puedan).</p>
<p>Si se especifica <em>sep</em>, las repeticiones de caracteres delimitadores no se agrupan juntos, sino que se considera que están delimitando cadenas vacías (por ejemplo, <code class="docutils literal notranslate"><span class="pre">'1,,2'.split(',')</span></code> retorna <code class="docutils literal notranslate"><span class="pre">['1',</span> <span class="pre">'',</span> <span class="pre">'2']</span></code>). El parámetro <em>sep</em> puede contener más de un carácter (por ejemplo, <code class="docutils literal notranslate"><span class="pre">'1&lt;&gt;2&lt;&gt;3'.split('&lt;&gt;')</span></code> retorna <code class="docutils literal notranslate"><span class="pre">['1',</span> <span class="pre">'2',</span> <span class="pre">'3']</span></code>). Dividir una cadena vacía con un separador determinado retornará <code class="docutils literal notranslate"><span class="pre">['']</span></code>.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1,2,3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1,2,3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2,3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1,2,,3,&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;, &#39;&#39;, &#39;3&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<p>Si no se especifica <em>sep</em> o es <code class="docutils literal notranslate"><span class="pre">None</span></code>, se usa un algoritmo de división diferente: secuencias consecutivas de caracteres de espacio en blanco se consideran como un único separador, y el resultado no contendrá cadenas vacías ni al principio ni al final de la lista, aunque la cadena original tuviera espacios en blanco al principio o al final. En consecuencia, dividir una cadena vacía o una cadena que solo contenga espacios en blanco usando <code class="docutils literal notranslate"><span class="pre">None</span></code> como separador siempre retornará una lista vacía <code class="docutils literal notranslate"><span class="pre">[]</span></code>.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1 2 3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;1 2 3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[&#39;1&#39;, &#39;2 3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   1   2   3   &#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="index-33"></span><dl class="py method">
<dt class="sig sig-object py" id="str.splitlines">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">splitlines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">keepends</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#str.splitlines" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una lista con las líneas en la cadena, dividiendo por los saltos de línea. Los caracteres de salto de línea en sí no se incluyen a no ser que se especifique lo contrario pasando el valor <code class="docutils literal notranslate"><span class="pre">True</span></code> en al parámetro <em>keepends</em>.</p>
<p>Este método considera como saltos de línea los siguientes caracteres. En concreto, estos son un superconjunto de los <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">saltos de líneas universales</span></a>.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 44%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Representación</p></th>
<th class="head"><p>Descripción</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">\n</span></code></p></td>
<td><p>Salto de línea</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">\r</span></code></p></td>
<td><p>Retorno de carro</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">\r\n</span></code></p></td>
<td><p>Retorno de carro + salto de línea</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">\v</span></code> o <code class="docutils literal notranslate"><span class="pre">\x0b</span></code></p></td>
<td><p>Tabulación de línea</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">\f</span></code> o <code class="docutils literal notranslate"><span class="pre">\x0c</span></code></p></td>
<td><p>Avance de página</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">\x1c</span></code></p></td>
<td><p>Separador de archivo</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">\x1d</span></code></p></td>
<td><p>Separador de grupo</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">\x1e</span></code></p></td>
<td><p>Separador de registro</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">\x85</span></code></p></td>
<td><p>Siguiente línea (Código de control C1)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">\u2028</span></code></p></td>
<td><p>Separador de línea</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">\u2029</span></code></p></td>
<td><p>Separador de párrafo</p></td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Se añadieron <code class="docutils literal notranslate"><span class="pre">\v</span></code> y <code class="docutils literal notranslate"><span class="pre">\f</span></code> a la lista de separadores.</p>
</div>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[&#39;ab c&#39;, &#39;&#39;, &#39;de fg&#39;, &#39;kl&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="n">keepends</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[&#39;ab c\n&#39;, &#39;\n&#39;, &#39;de fg\r&#39;, &#39;kl\r\n&#39;]</span>
</pre></div>
</div>
<p>Al contrario que con <a class="reference internal" href="#str.split" title="str.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a>, cuando se especifica una cadena con <em>sep</em>, el método retorna una lista vacía para la cadena vacía, y un salto de línea al final del texto no produce una línea extra:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;One line</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[&#39;One line&#39;]</span>
</pre></div>
</div>
<p>Por comparación, <code class="docutils literal notranslate"><span class="pre">split('\n')</span></code> entrega:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Two lines</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">[&#39;Two lines&#39;, &#39;&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.startswith">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">startswith</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.startswith" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si la cadena empieza por <em>prefix</em>, en caso contrario retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>. El valor de <em>prefix</em> puede ser también una tupla de prefijos por los que buscar. Con el parámetro opcional <em>start</em>, la comprobación empieza en esa posición de la cadena. Con el parámetro opcional <em>end</em>, la comprobación se detiene en esa posición de la cadena.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.strip">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">strip</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">chars</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#str.strip" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de la cadena con los caracteres indicados eliminados, tanto si están al principio como al final de la cadena. El parámetro opcional <em>chars</em> es una cadena que especifica el conjunto de caracteres a eliminar. Si se omite o se usa <code class="docutils literal notranslate"><span class="pre">None</span></code>, se eliminan los caracteres de espacio en blanco. No debe entenderse el valor de <em>chars</em> como un prefijo o sufijo, sino que se elimina cualquier combinación de sus caracteres:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="go">&#39;spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">&#39;example&#39;</span>
</pre></div>
</div>
<p>Los caracteres indicados por <em>chars</em> se eliminan de los extremos al principio y al final de la cadena. Se elimina los caracteres del inicio hasta que se encuentra un carácter que no esté incluido en el conjunto definido por <em>chars</em>. Se procede de manera similar para los caracteres al final. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">comment_string</span> <span class="o">=</span> <span class="s1">&#39;#....... Section 3.2.1 Issue #32 .......&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comment_string</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;.#! &#39;</span><span class="p">)</span>
<span class="go">&#39;Section 3.2.1 Issue #32&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.swapcase">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">swapcase</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.swapcase" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de la cadena con los caracteres en mayúsculas convertidos a minúsculas, y viceversa. Nótese que no es necesariamente cierto que <code class="docutils literal notranslate"><span class="pre">s.swapcase().swapcase()</span> <span class="pre">==</span> <span class="pre">s</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.title">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">title</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.title" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una versión en forma de título de la cadena, con la primera letra de cada palabra en mayúsculas y el resto en minúsculas.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">&#39;Hello World&#39;</span>
</pre></div>
</div>
<p>El algoritmo usa una definición sencilla e independiente del lenguaje, consistente en considerar una palabra como un grupo de letras consecutivas. Esta definición funciona en varios entornos, pero implica que, por ejemplo en inglés, los apóstrofos en las contracciones y en los posesivos constituyen una separación entre palabras, que puede que no sea el efecto deseado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;they&#39;re bill&#39;s friends from the UK&quot;</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">&quot;They&#39;Re Bill&#39;S Friends From The Uk&quot;</span>
</pre></div>
</div>
<p>La función <a class="reference internal" href="string.html#string.capwords" title="string.capwords"><code class="xref py py-func docutils literal notranslate"><span class="pre">string.capwords()</span></code></a> no tiene este problema, ya que solo divide palabras en espacios.</p>
<p>Alternativamente, se puede solucionar parcialmente el problema de los apóstrofos usando expresiones regulares:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">titlecase</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[A-Za-z]+(&#39;[A-Za-z]+)?&quot;</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="k">lambda</span> <span class="n">mo</span><span class="p">:</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">capitalize</span><span class="p">(),</span>
<span class="gp">... </span>                  <span class="n">s</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">titlecase</span><span class="p">(</span><span class="s2">&quot;they&#39;re bill&#39;s friends.&quot;</span><span class="p">)</span>
<span class="go">&quot;They&#39;re Bill&#39;s Friends.&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.translate">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">translate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">table</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#str.translate" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de la cadena en la que cada carácter ha sido sustituido por su equivalente definido en la tabla de traducción dada. La tabla puede ser cualquier objeto que soporta el acceso mediante índices implementado en método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code>, normalmente un objeto de tipo <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapa</span></a> o <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">secuencia</span></a>. Cuando se accede como índice con un código Unicode (un entero), el objeto tabla puede hacer una de las siguientes cosas: retornar otro código Unicode o retornar una cadena de caracteres, de forma que se usarán uno u otro como reemplazo en la cadena de salida; retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> para eliminar el carácter en la cadena de salida, o lanza una excepción de tipo <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a>, que hará que el carácter se copie igual en la cadena de salida.</p>
<p>Se puede usar <a class="reference internal" href="#str.maketrans" title="str.maketrans"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.maketrans()</span></code></a> para crear un mapa de traducción carácter a carácter de diferentes formas.</p>
<p>Véase también el módulo <a class="reference internal" href="codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> para una aproximación más flexible al mapeo de caracteres.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.upper">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">upper</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#str.upper" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de la cadena, con todos los caracteres con formas mayúsculas/minúsculas <a class="footnote-reference brackets" href="#id15" id="id9">4</a> pasados a mayúsculas. Nótese que <code class="docutils literal notranslate"><span class="pre">s.upper().isupper()</span></code> puede ser <code class="docutils literal notranslate"><span class="pre">False</span></code> si <code class="docutils literal notranslate"><span class="pre">s</span></code> contiene caracteres que no tengan las dos formas, o si la categoría Unicode del carácter o caracteres resultantes no es «Lu» (Letra, mayúsculas), sino, por ejemplo, «Lt» (Letra, Título).</p>
<p>El algoritmo de paso a mayúsculas es el descrito en la sección 3.13 del estándar Unicode.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="str.zfill">
<span class="sig-prename descclassname"><span class="pre">str.</span></span><span class="sig-name descname"><span class="pre">zfill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#str.zfill" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de la cadena, rellena por la izquierda con dígitos <code class="docutils literal notranslate"><span class="pre">'0'</span></code> de ASCII necesarios para conseguir una cadena de longitud <em>width</em>. El carácter prefijo de signo (<code class="docutils literal notranslate"><span class="pre">'+'</span></code>/<code class="docutils literal notranslate"><span class="pre">'-'</span></code>) se gestiona insertando el relleno <em>después</em> del carácter de signo en vez de antes. Si <em>width</em> es menor o igual que <code class="docutils literal notranslate"><span class="pre">len(s)</span></code>, se retorna la cadena original.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;42&quot;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">&#39;00042&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;-42&quot;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">&#39;-0042&#39;</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="printf-style-string-formatting">
<span id="old-string-formatting"></span><h3>Formateo de cadenas al estilo <code class="docutils literal notranslate"><span class="pre">*printf*</span></code><a class="headerlink" href="#printf-style-string-formatting" title="Enlazar permanentemente con este título">¶</a></h3>
<div class="admonition note" id="index-34">
<p class="admonition-title">Nota</p>
<p>Las operaciones de formateo explicadas aquí tienen una serie de peculiaridades que conducen a ciertos errores comunes (como fallar al representar tuplas y diccionarios correctamente). Se pueden evitar estos errores usando las nuevas <a class="reference internal" href="../reference/lexical_analysis.html#f-strings"><span class="std std-ref">cadenas de caracteres con formato</span></a>, el método <a class="reference internal" href="#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a>, o <a class="reference internal" href="string.html#template-strings"><span class="std std-ref">plantillas de cadenas de caracteres</span></a>. Cada una de estas alternativas proporcionan sus propios compromisos entre facilidad de uso, flexibilidad y capacidad de extensión.</p>
</div>
<p>Las cadenas de caracteres tienen una operación básica: El operador <code class="docutils literal notranslate"><span class="pre">%</span></code> (módulo). Esta operación se conoce también como <em>formateo</em> de cadenas y operador de interpolación. Dada la expresión <code class="docutils literal notranslate"><span class="pre">formato</span> <span class="pre">%</span> <span class="pre">valores</span></code> (donde <em>formato</em> es una cadena), las especificaciones de conversión indicadas en la cadena con el símbolo <code class="docutils literal notranslate"><span class="pre">%</span></code> son reemplazadas por cero o más elementos de <em>valores</em>. El efecto es similar a usar la función del lenguaje C <code class="xref c c-func docutils literal notranslate"><span class="pre">sprintf()</span></code>.</p>
<p>Si <em>formato</em> tiene un único marcador, <em>valores</em> puede ser un objeto sencillo, no una tupla. <a class="footnote-reference brackets" href="#id16" id="id10">5</a> En caso contrario, <em>valores</em> debe ser una tupla con exactamente el mismo número de elementos que marcadores usados en la cadena de formato, o un único objeto de tipo mapa (por ejemplo, un diccionario).</p>
<p id="index-35">Un especificador de conversión consiste en dos o más caracteres y tiene los siguientes componentes, que deben aparecer en el siguiente orden:</p>
<ol class="arabic simple">
<li><p>El carácter <code class="docutils literal notranslate"><span class="pre">'%'</span></code>, que identifica el inicio del marcador.</p></li>
<li><p>Una clave de mapeo (opcional), consistente en una secuencia de caracteres entre paréntesis, como por ejemplo, <code class="docutils literal notranslate"><span class="pre">(somename)</span></code>.</p></li>
<li><p>Indicador de conversión (opcional), que afecta el resultado de ciertas conversiones de tipos.</p></li>
<li><p>Valor de ancho mínimo (opcional). Si se especifica un <code class="docutils literal notranslate"><span class="pre">'*'</span></code> (asterisco), el ancho real se lee del siguiente elemento de la tupla <em>valores</em>, y el objeto a convertir viene después del ancho mínimo, con un indicador de precisión opcional.</p></li>
<li><p>Precisión (opcional), en la forma <code class="docutils literal notranslate"><span class="pre">'.'</span></code> (punto) seguido de la precisión. Si se especifica un <code class="docutils literal notranslate"><span class="pre">'*'</span></code> (asterisco), el valor de precisión real se lee del siguiente elemento de la tupla <em>valores</em>, y el valor a convertir viene después de la precisión.</p></li>
<li><p>Modificador de longitud (opcional).</p></li>
<li><p>Tipo de conversión.</p></li>
</ol>
<p>Cuando el operador derecho es un diccionario (o cualquier otro objeto de tipo mapa), los marcadores en la cadena <em>deben</em> incluir un valor de clave entre paréntesis, inmediatamente después del carácter <code class="docutils literal notranslate"><span class="pre">'%'</span></code>. El valor de la clave se usa para seleccionar el valor a formatear desde el mapa. Por ejemplo:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%(language)s</span><span class="s1"> has </span><span class="si">%(number)03d</span><span class="s1"> quote types.&#39;</span> <span class="o">%</span>
<span class="gp">... </span>      <span class="p">{</span><span class="s1">&#39;language&#39;</span><span class="p">:</span> <span class="s2">&quot;Python&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">Python has 002 quote types.</span>
</pre></div>
</div>
<p>En este caso, no se puede usar el especificador <code class="docutils literal notranslate"><span class="pre">*</span></code> en la cadena de formato (dado que requiere una lista secuencial de parámetros).</p>
<p>Los indicadores de conversión son:</p>
<table class="docutils align-default" id="index-36">
<colgroup>
<col style="width: 12%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Flag</p></th>
<th class="head"><p>Significado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'#'</span></code></p></td>
<td><p>El valor a convertir usara la «forma alternativa» (que se definirá más adelante)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'0'</span></code></p></td>
<td><p>La conversión rellena con ceros por la izquierda para valores numéricos.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'-'</span></code></p></td>
<td><p>El valor convertido se ajusta a la izquierda (sobreescribe la conversión <code class="docutils literal notranslate"><span class="pre">'0'</span></code> si se especifican los dos)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'</span> <span class="pre">'</span></code></p></td>
<td><p>(Un espacio) Se debe añadir un espacio en blanco antes de un número positivo (o una cadena vacía) si se usa una conversión con signo.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'+'</span></code></p></td>
<td><p>Un carácter signo (<code class="docutils literal notranslate"><span class="pre">'+'</span></code> o <code class="docutils literal notranslate"><span class="pre">'-'</span></code>) precede a la conversión (sobreescribe el indicador de «espacio»)</p></td>
</tr>
</tbody>
</table>
<p>Puede estar presente un modificador de longitud (<code class="docutils literal notranslate"><span class="pre">h</span></code>, <code class="docutils literal notranslate"><span class="pre">l</span></code> o <code class="docutils literal notranslate"><span class="pre">L</span></code>), pero se ignora y no es necesario para Python – por lo que, por ejemplo, la salida de <code class="docutils literal notranslate"><span class="pre">%ld</span></code> es idéntica a <code class="docutils literal notranslate"><span class="pre">%d</span></code>.</p>
<p>Los tipos de conversión son:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 74%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Conversión</p></th>
<th class="head"><p>Significado</p></th>
<th class="head"><p>Notas</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'d'</span></code></p></td>
<td><p>Entero decimal con signo.</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'i'</span></code></p></td>
<td><p>Entero decimal con signo.</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'o'</span></code></p></td>
<td><p>Valor octal con signo.</p></td>
<td><p>(1)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'u'</span></code></p></td>
<td><p>Obsoleto – es idéntico a <code class="docutils literal notranslate"><span class="pre">'d'</span></code>.</p></td>
<td><p>(6)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'x'</span></code></p></td>
<td><p>Hexadecimal con signo (en minúsculas).</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'X'</span></code></p></td>
<td><p>Hexadecimal con signo (en mayúsculas).</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'e'</span></code></p></td>
<td><p>Formato en coma flotante exponencial (en minúsculas).</p></td>
<td><p>(3)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'E'</span></code></p></td>
<td><p>Formato en coma flotante exponencial (en mayúsculas).</p></td>
<td><p>(3)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'f'</span></code></p></td>
<td><p>Formato en coma flotante decimal.</p></td>
<td><p>(3)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'F'</span></code></p></td>
<td><p>Formato en coma flotante decimal.</p></td>
<td><p>(3)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'g'</span></code></p></td>
<td><p>Formato en coma flotante. Usa formato exponencial con minúsculas si el exponente es menor que -4 o no es menor que la precisión, en caso contrario usa el formato decimal.</p></td>
<td><p>(4)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'G'</span></code></p></td>
<td><p>Formato en coma flotante. Usa formato exponencial con mayúsculas si el exponente es menor que -4 o no es menor que la precisión, en caso contrario usa el formato decimal.</p></td>
<td><p>(4)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'c'</span></code></p></td>
<td><p>Un único carácter (acepta números enteros o cadenas de caracteres de longitud 1).</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'r'</span></code></p></td>
<td><p>Cadena de caracteres (representará cualquier objeto usando la función <a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a>).</p></td>
<td><p>(5)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'s'</span></code></p></td>
<td><p>Cadena de caracteres (representará cualquier objeto usando la función <a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a>).</p></td>
<td><p>(5)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'a'</span></code></p></td>
<td><p>Cadena de caracteres (representará cualquier objeto usando la función <a class="reference internal" href="functions.html#ascii" title="ascii"><code class="xref py py-func docutils literal notranslate"><span class="pre">ascii()</span></code></a>).</p></td>
<td><p>(5)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'%'</span></code></p></td>
<td><p>No se representa ningún argumento, obteniéndose en el resultado la cadena <code class="docutils literal notranslate"><span class="pre">'%'</span></code>.</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>Notas:</p>
<ol class="arabic">
<li><p>La forma alternativa hace que se inserte antes del primer dígito un prefijo indicativo del formato octal (<code class="docutils literal notranslate"><span class="pre">'0o'</span></code>)</p></li>
<li><p>La forma alternativa hace que se inserte antes del primer dígito uno de los dos prefijos indicativos del formato hexadecimal <code class="docutils literal notranslate"><span class="pre">'0x'</span></code> o <code class="docutils literal notranslate"><span class="pre">'0X'</span></code> (que se use uno u otro depende de que indicador de formato se haya usado, <code class="docutils literal notranslate"><span class="pre">'x'</span></code> o <code class="docutils literal notranslate"><span class="pre">'X'</span></code>).</p></li>
<li><p>La forma alternativa hace que se incluya siempre el símbolo del punto o coma decimal, incluso si no hubiera dígitos después.</p>
<p>La precisión determina el número de dígitos que vienen después del punto decimal, y por defecto es 6.</p>
</li>
<li><p>La forma alternativa hace que se incluya siempre el símbolo del punto o coma decimal, y los ceros a su derecha no se eliminan, como seria el caso en la forma normal.</p>
<p>La precisión determina el número de dígitos significativos que vienen antes y después del punto decimal, y por defecto es 6.</p>
</li>
<li><p>Si la precisión es <code class="docutils literal notranslate"><span class="pre">N</span></code>, la salida se trunca a <code class="docutils literal notranslate"><span class="pre">N</span></code> caracteres.</p></li>
<li><p>Véase <span class="target" id="index-76"></span><a class="pep reference external" href="https://peps.python.org/pep-0237/"><strong>PEP 237</strong></a>.</p></li>
</ol>
<p>Como en Python las cadenas de caracteres tiene una longitud explícita, la conversión de <code class="docutils literal notranslate"><span class="pre">%s</span></code> no requiere que la cadena termine con <code class="docutils literal notranslate"><span class="pre">'\0'</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.1: </span>Las conversiones <code class="docutils literal notranslate"><span class="pre">%f</span></code> para números con valores absolutos mayores que 1e50 ya no son reemplazadas por conversiones <code class="docutils literal notranslate"><span class="pre">%g</span></code>.</p>
</div>
</section>
</section>
<section id="binary-sequence-types-bytes-bytearray-memoryview">
<span id="binaryseq"></span><span id="index-38"></span><h2>Tipos de secuencias binarias — <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> y <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a><a class="headerlink" href="#binary-sequence-types-bytes-bytearray-memoryview" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-39">Los tipos básicos para trabajar con datos binarios son las clases <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> y <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>. Ambas pueden ser usadas por la clase <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>, que usa el <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">protocolo buffer</span></a> para acceder a la memoria de otros objetos binarios sin necesidad de hacer una copia.</p>
<p>El módulo <a class="reference internal" href="array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> soporta un almacenamiento eficiente de tipos de datos básicos como enteros de 32 bits o números en formato de doble precisión en coma flotante IEEE754.</p>
<section id="bytes-objects">
<span id="typebytes"></span><h3>Objetos de tipo Bytes<a class="headerlink" href="#bytes-objects" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-40">Los objetos <em>bytes</em> son secuencias inmutables de bytes. Como muchos de los protocolos binarios más usados se basan en la codificación ASCII para texto, los objetos <em>bytes</em> ofrecen varios métodos que solo son válidos cuando se trabaja con datos compatibles ASCII y son, en varios aspectos, muy cercanos a los cadenas de caracteres.</p>
<dl class="py class">
<dt class="sig sig-object py" id="bytes">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytes</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Para empezar, la sintaxis de los valores literales de <em>bytes</em> son prácticamente iguales que para las cadenas de caracteres, con la diferencia de que se añade el carácter <code class="docutils literal notranslate"><span class="pre">b</span></code> como prefijo:</p>
<ul class="simple">
<li><p>Comillas sencillas: <code class="docutils literal notranslate"><span class="pre">b'Se</span> <span class="pre">siguen</span> <span class="pre">aceptando</span> <span class="pre">comillas</span> <span class="pre">&quot;dobles&quot;</span> <span class="pre">embebidas'</span></code></p></li>
<li><p>Comillas dobles: <code class="docutils literal notranslate"><span class="pre">b&quot;Se</span> <span class="pre">siguen</span> <span class="pre">aceptando</span> <span class="pre">comillas</span> <span class="pre">'simples'</span> <span class="pre">embebidas&quot;</span></code></p></li>
<li><p>Comillas triples: <code class="docutils literal notranslate"><span class="pre">b'''3</span> <span class="pre">comillas</span> <span class="pre">simples'''</span></code>, <code class="docutils literal notranslate"><span class="pre">b&quot;&quot;&quot;3</span> <span class="pre">comillas</span> <span class="pre">dobles&quot;&quot;&quot;</span></code></p></li>
</ul>
<p>Solo se admiten caracteres ASCII en representaciones literales de <em>bytes</em> (con independencia del tipo de codificación declarado). Cualquier valor por encima de 127 debe ser definido usando su secuencia de escape.</p>
<p>Al igual que con las cadenas, los literales de <em>bytes</em> pueden usar el prefijo <code class="docutils literal notranslate"><span class="pre">r</span></code> para deshabilitar el procesado de las secuencias de escape. Véase <a class="reference internal" href="../reference/lexical_analysis.html#strings"><span class="std std-ref">Literales de cadenas y bytes</span></a> para más información acerca de los diferentes formas de expresar <em>bytes</em> de forma literal, incluyendo el soporte de secuencias de escape.</p>
<p>Aunque las secuencias de bytes y sus representaciones se basen en texto ASCII, los objetos <em>bytes</em> se comportan más como secuencias inmutables de números enteros, donde cada elemento de la secuencia está restringido a los valores de <em>x</em> tal que <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">256</span></code> (si se intenta violar esta restricción se lanzará una excepción de tipo <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>). Esto se ha hecho de forma intencionada para enfatizar que, aunque muchos formatos binarios incluyen elementos basados en caracteres ASCII y pueden ser manipulados mediante algunas técnicas de procesado de textos, este no es el caso general para los datos binarios (aplicar algoritmos pensados para proceso de textos a datos binarios que no se compatibles con ASCII normalmente corromperán dichos datos).</p>
<p>Además de con literales, se pueden crear objetos de tipo <em>byte</em> de las siguientes maneras:</p>
<ul class="simple">
<li><p>Un secuencia de una longitud especificada rellena con ceros: <code class="docutils literal notranslate"><span class="pre">bytes(10)</span></code></p></li>
<li><p>A partir de un iterable de números enteros: <code class="docutils literal notranslate"><span class="pre">bytes(range(20))</span></code></p></li>
<li><p>Copiando datos binarios ya existentes mediante el protocolo <em>buffer</em>: <code class="docutils literal notranslate"><span class="pre">bytes(obj)</span></code></p></li>
</ul>
<p>Véase además la función incorporada <a class="reference internal" href="functions.html#func-bytes"><span class="std std-ref">bytes</span></a>.</p>
<p>Como dos dígitos hexadecimales se corresponden exactamente con un byte, suelen usase números hexadecimales para describir datos binarios. Por ello, los objetos de tipo <em>byte</em> disponen de un método adicional para leer datos en ese formato:</p>
<dl class="py method">
<dt class="sig sig-object py" id="bytes.fromhex">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fromhex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.fromhex" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método de clase de <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> retorna un objeto binario, decodificado a partir de la cadena suministrada como parámetro. La cadena de caracteres debe consistir en dos dígitos hexadecimales por cada byte, ignorándose los caracteres ASCII de espacio en blanco, si los hubiera.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s1">&#39;2Ef0 F1f2  &#39;</span><span class="p">)</span>
<span class="go">b&#39;.\xf0\xf1\xf2&#39;</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>El método <a class="reference internal" href="#bytes.fromhex" title="bytes.fromhex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.fromhex()</span></code></a> ignora ahora todos los caracteres ASCII de espacio en blanco, no solo el carácter espacio.</p>
</div>
</dd></dl>

<p>Existe una función que realiza la operación inversa, es decir, transforma un objeto binario en una representación textual usando hexadecimal.</p>
<dl class="py method">
<dt class="sig sig-object py" id="bytes.hex">
<span class="sig-name descname"><span class="pre">hex</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">bytes_per_sep</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.hex" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una cadena de caracteres que contiene dos dígitos hexadecimales por cada byte de la instancia.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xf0\xf1\xf2</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;f0f1f2&#39;</span>
</pre></div>
</div>
<p>Si quieres que la cadena en hexadecimal sea más fácil de leer, se puede especificar un único carácter separador con el parámetro <em>sep</em> para que se añada a la salida. Por defecto, este separador se incluirá entre cada byte. Un segundo parámetro opcional, <em>bytes_per_sep</em>, controla los espacios. Valores positivos calculan la posición del separador desde la derecha, los negativos lo hacen desde la izquierda.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">value</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xf0\xf1\xf2</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">value</span><span class="o">.</span><span class="n">hex</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
<span class="go">&#39;f0-f1-f2&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">value</span><span class="o">.</span><span class="n">hex</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;f0_f1f2&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;UUDDLRLRAB&#39;</span><span class="o">.</span><span class="n">hex</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&#39;55554444 4c524c52 4142&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>El método <a class="reference internal" href="#bytes.hex" title="bytes.hex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.hex()</span></code></a> ahora soporta los parámetros opcionales <em>sep</em> y <em>bytes_per_sep</em>, que permiten insertar separadores entre los bytes de la cadena de salida.</p>
</div>
</dd></dl>

</dd></dl>

<p>Como los objetos de tipo <em>bytes</em> son secuencias de números enteros (similares a tuplas), para un objeto binario <em>b</em>, <code class="docutils literal notranslate"><span class="pre">b[0]</span></code> retorna un entero, mientras que <code class="docutils literal notranslate"><span class="pre">b[0:1]</span></code> retorna un objeto de tipo <em>bytes</em> de longitud 1. (Mientras que las cadenas de caracteres siempre retornan una cadena de longitud 1, ya sea accediendo por índice o mediante una operación de segmentado).</p>
<p>La representación de los objetos tipo <em>bytes</em> usa el formato literal (<code class="docutils literal notranslate"><span class="pre">b'...'</span></code>) ya que es, por lo general, más útil que, digamos, <code class="docutils literal notranslate"><span class="pre">bytes([46,</span> <span class="pre">46,</span> <span class="pre">46])</span></code>. Siempre se puede convertir un objeto binario en una lista de enteros usando <code class="docutils literal notranslate"><span class="pre">list(b)</span></code>.</p>
</section>
<section id="bytearray-objects">
<span id="typebytearray"></span><h3>Objetos de tipo <em>Bytearray</em><a class="headerlink" href="#bytearray-objects" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-41">Los objetos de tipo <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> son versiones mutables de los objetos de tipo <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="bytearray">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytearray</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>No existe una sintaxis específica para crear objetos de tipo <em>bytearray</em>, hay que crearlos siempre llamando a su constructor:</p>
<ul class="simple">
<li><p>Creando una secuencia vacía: <code class="docutils literal notranslate"><span class="pre">bytearray()</span></code></p></li>
<li><p>Creando una instancia de una longitud determinada, rellena con ceros: <code class="docutils literal notranslate"><span class="pre">bytearray(10)</span></code></p></li>
<li><p>A partir de un iterable de números enteros: <code class="docutils literal notranslate"><span class="pre">bytearray(range(20))</span></code></p></li>
<li><p>Copiando datos binarios ya existentes mediante el protocolo <em>buffer</em>: <code class="docutils literal notranslate"><span class="pre">bytearray(b'Hi!')</span></code></p></li>
</ul>
<p>Como los objetos <em>bytearray</em> son mutables, soportan todas las operaciones aplicables a tipos <a class="reference internal" href="#typesseq-mutable"><span class="std std-ref">mutables</span></a>, además de las operaciones propias de los <em>bytearrays</em> descritas en <a class="reference internal" href="#bytes-methods"><span class="std std-ref">Operaciones de bytes y bytearray</span></a>.</p>
<p>Véase también la función incorporada <a class="reference internal" href="functions.html#func-bytearray"><span class="std std-ref">bytearray</span></a>.</p>
<p>Como dos dígitos hexadecimales se corresponden exactamente con un byte, suelen usase números hexadecimales para describir datos binarios. Por ello, los objetos de tipo <em>bytearray</em> disponen de un método de clase adicional para leer datos en ese formato:</p>
<dl class="py method">
<dt class="sig sig-object py" id="bytearray.fromhex">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fromhex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.fromhex" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método de clase de <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> retorna un objeto <em>bytearray</em>, decodificado a partir de la cadena suministrada como parámetro. La cadena de caracteres debe consistir en dos dígitos hexadecimales por cada byte, ignorándose los caracteres ASCII de espacio en blanco, si los hubiera.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytearray</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s1">&#39;2Ef0 F1f2  &#39;</span><span class="p">)</span>
<span class="go">bytearray(b&#39;.\xf0\xf1\xf2&#39;)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>El método <a class="reference internal" href="#bytearray.fromhex" title="bytearray.fromhex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytearray.fromhex()</span></code></a> ignora ahora todos los caracteres ASCII de espacio en blanco, no solo el carácter espacio.</p>
</div>
</dd></dl>

<p>Existe una función que realiza la operación inversa, es decir, transforma un objeto <em>bytearray</em> en una representación textual usando hexadecimal.</p>
<dl class="py method">
<dt class="sig sig-object py" id="bytearray.hex">
<span class="sig-name descname"><span class="pre">hex</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">bytes_per_sep</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.hex" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una cadena de caracteres que contiene dos dígitos hexadecimales por cada byte de la instancia.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\xf0\xf1\xf2</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;f0f1f2&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>De forma similar a <a class="reference internal" href="#bytes.hex" title="bytes.hex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.hex()</span></code></a>, <a class="reference internal" href="#bytearray.hex" title="bytearray.hex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytearray.hex()</span></code></a> soporta ahora los parámetros opcionales <em>sep</em> y <em>bytes_per_sep</em> para insertar separadores entre los bytes en la cadena hexadecimal de salida.</p>
</div>
</dd></dl>

</dd></dl>

<p>Como los objetos de tipo <em>bytearray</em> son secuencias de números enteros (similares a listas), para un objeto <em>bytearray</em> <em>b</em>, <code class="docutils literal notranslate"><span class="pre">b[0]</span></code> retorna un entero, mientras que <code class="docutils literal notranslate"><span class="pre">b[0:1]</span></code> retorna un objeto de tipo <em>bytearray</em> de longitud 1. (Mientras que las cadenas de caracteres siempre retornan una cadena de longitud 1, ya sea accediendo por índice o mediante una operación de segmentado).</p>
<p>La representación de los objetos tipo <em>bytearray</em> usa el formato literal (<code class="docutils literal notranslate"><span class="pre">bytearray(b'...')</span></code>) ya que es, por lo general, más útil que, digamos, <code class="docutils literal notranslate"><span class="pre">bytearray([46,</span> <span class="pre">46,</span> <span class="pre">46])</span></code>. Siempre se puede convertir un objeto <em>bytearray</em> en una lista de enteros usando <code class="docutils literal notranslate"><span class="pre">list(b)</span></code>.</p>
</section>
<section id="bytes-and-bytearray-operations">
<span id="bytes-methods"></span><h3>Operaciones de <em>bytes</em> y <em>bytearray</em><a class="headerlink" href="#bytes-and-bytearray-operations" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-42">Ambos tipos, <em>bytes</em> y <em>bytearray</em> soportan las operaciones <a class="reference internal" href="#typesseq-common"><span class="std std-ref">comunes</span></a> de las secuencias. Los operadores no funcionan solo con operandos del mismo tipo, sino con cualquier <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto tipo binario</span></a>. Gracias a esta flexibilidad, estos tipos pueden combinarse libremente en expresiones sin que se produzcan errores. Sin embargo, el tipo del valor resultante puede depender del orden de los operandos.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Los métodos de objetos de tipo <em>bytes</em> y <em>bytesarray</em> no aceptan cadenas de caracteres como parámetros, de la misma manera que los métodos de las cadenas tampoco aceptan <em>bytes</em> como parámetros. Por ejemplo, debes escribir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;abc&quot;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>y:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;abc&quot;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Algunas operaciones de <em>bytes</em> y <em>bytearrays</em> asumen el uso de formatos binarios compatibles ASCII, y por tanto deben ser evitadas cuando trabajamos con datos binarios arbitrarios. Estas restricciones se explican a continuación.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Usar estas operaciones basadas en ASCII para manipular datos binarios que no se almacenan en un formato basado en ASCII pueden producir corrupción de datos.</p>
</div>
<p>Los siguientes métodos de <em>bytes</em> y <em>bytearrays</em> pueden ser usados con datos en formatos binarios arbitrarios.</p>
<dl class="py method">
<dt class="sig sig-object py" id="bytes.count">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">count</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.count" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.count">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">count</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.count" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el número de secuencias no solapadas de la subsecuencia <em>sub</em> en el rango [<em>start</em>, <em>end</em>]. Los parámetros opcionales <em>start</em> y <em>end</em> se interpretan como en las operaciones de segmentado.</p>
<p>La subsecuencia a buscar puede ser cualquier <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto tipo binario</span></a> o un número entero entre 0 y 255.</p>
<p>If <em>sub</em> is empty, returns the number of empty slices between characters
which is the length of the bytes object plus one.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>También acepta como subsecuencia un número entero entre 0 y 255.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.removeprefix">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">removeprefix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.removeprefix" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.removeprefix">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">removeprefix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.removeprefix" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si los datos binarios comienzan con la cadena <em>prefix</em>, retorna <code class="docutils literal notranslate"><span class="pre">bytes[len(prefix):]</span></code>. De otra manera, retorna una copia de los datos binarios originales:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;TestHook&#39;</span><span class="o">.</span><span class="n">removeprefix</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Test&#39;</span><span class="p">)</span>
<span class="go">b&#39;Hook&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;BaseTestCase&#39;</span><span class="o">.</span><span class="n">removeprefix</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Test&#39;</span><span class="p">)</span>
<span class="go">b&#39;BaseTestCase&#39;</span>
</pre></div>
</div>
<p>El argumento <em>prefix</em> puede ser cualquier <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto tipo binario</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La versión <em>bytearray</em> de este método <em>no</em> opera in situ - siempre produce un nuevo objeto, aún si no se hubiera realizado ningún cambio.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.removesuffix">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">removesuffix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suffix</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.removesuffix" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.removesuffix">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">removesuffix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suffix</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.removesuffix" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si los datos binarios terminan con la cadena expresada en <em>suffix</em> y el argumento <em>suffix</em> no está vacío, retorna <code class="docutils literal notranslate"><span class="pre">bytes[:-len(suffix)]</span></code>. De otra manera, retorna una copia de los datos binarios originales:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;MiscTests&#39;</span><span class="o">.</span><span class="n">removesuffix</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Tests&#39;</span><span class="p">)</span>
<span class="go">b&#39;Misc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;TmpDirMixin&#39;</span><span class="o">.</span><span class="n">removesuffix</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Tests&#39;</span><span class="p">)</span>
<span class="go">b&#39;TmpDirMixin&#39;</span>
</pre></div>
</div>
<p>El argumento <em>suffix</em> puede ser cualquier <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto tipo binario</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La versión <em>bytearray</em> de este método <em>no</em> opera in situ - siempre produce un nuevo objeto, aún si no se hubiera realizado ningún cambio.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.decode">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'utf-8'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.decode" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.decode">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'utf-8'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.decode" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Return the bytes decoded to a <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p>
<p><em>encoding</em> defaults to <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>;
see <a class="reference internal" href="codecs.html#standard-encodings"><span class="std std-ref">Codificaciones estándar</span></a> for possible values.</p>
<p><em>errors</em> controls how decoding errors are handled.
If <code class="docutils literal notranslate"><span class="pre">'strict'</span></code> (the default), a <a class="reference internal" href="exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a> exception is raised.
Other possible values are <code class="docutils literal notranslate"><span class="pre">'ignore'</span></code>, <code class="docutils literal notranslate"><span class="pre">'replace'</span></code>,
and any other name registered via <a class="reference internal" href="codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.register_error()</span></code></a>.
See <a class="reference internal" href="codecs.html#error-handlers"><span class="std std-ref">Manejadores de errores</span></a> for details.</p>
<p>For performance reasons, the value of <em>errors</em> is not checked for validity
unless a decoding error actually occurs,
<a class="reference internal" href="devmode.html#devmode"><span class="std std-ref">Modo de desarrollo de Python</span></a> is enabled or a <a class="reference internal" href="../using/configure.html#debug-build"><span class="std std-ref">debug build</span></a> is used.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Passing the <em>encoding</em> argument to <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> allows decoding any
<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> directly, without needing to make a temporary
<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code> object.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.1: </span>Añadido soporte para poder usar parámetros por nombre.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.9: </span>The value of the <em>errors</em> argument is now checked in <a class="reference internal" href="devmode.html#devmode"><span class="std std-ref">Modo de desarrollo de Python</span></a> and
in <a class="reference internal" href="../using/configure.html#debug-build"><span class="std std-ref">debug mode</span></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.endswith">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">endswith</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suffix</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.endswith" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.endswith">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">endswith</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suffix</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.endswith" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si los datos binarios acaban con el valor indicado por <em>suffix</em>, en caso contrario retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>. El valor de <em>suffix</em> puede ser también una tupla de sufijos para buscar. Con el parámetro opcional <em>start</em>, la comparación empieza a partir de esa posición. Si se especifica el parámetro opcional <em>end</em>, la comparación termina en esa posición.</p>
<p>El sufijo (o sufijos) a buscar puede ser cualquier <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto tipo binario</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.find">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">find</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.find" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.find">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">find</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.find" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el mínimo índice dentro de los datos donde se ha encontrado la subsecuencia <em>sub</em>, de forma que <em>sub</em> está contenida en el segmento <code class="docutils literal notranslate"><span class="pre">s[start:end]</span></code>. Los parámetros opcionales <em>start</em> y <em>end</em> se interpretan como en las operaciones de segmentado. Retorna <code class="docutils literal notranslate"><span class="pre">-1</span></code> si no se puede encontrar <em>sub</em>.</p>
<p>La subsecuencia a buscar puede ser cualquier <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto tipo binario</span></a> o un número entero entre 0 y 255.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>El método <a class="reference internal" href="#bytes.find" title="bytes.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a> se debe usar solo si se necesita saber la posición de <em>sub</em>. Si solo se necesita comprobar si <em>sub</em> es una parte de <em>s</em>, es mejor usar el operador <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Py&#39;</span> <span class="ow">in</span> <span class="sa">b</span><span class="s1">&#39;Python&#39;</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>También acepta como subsecuencia un número entero entre 0 y 255.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.index">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.index" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.index">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.index" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Como <a class="reference internal" href="#bytes.find" title="bytes.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a>, pero lanza una excepción de tipo <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> si no se encuentra la subsecuencia a buscar.</p>
<p>La subsecuencia a buscar puede ser cualquier <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto tipo binario</span></a> o un número entero entre 0 y 255.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>También acepta como subsecuencia un número entero entre 0 y 255.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.join">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.join" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.join">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.join" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un objeto de tipo <em>bytes</em> o <em>bytearray</em> que es la concatenación de las secuencias binarias en <em>iterable</em>. Si alguno de los objetos de la secuencia no es un <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto tipo binario</span></a> se lanza la excepción <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>, incluso si son cadenas de caracteres (objetos <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>). El separador entre los distintos elementos es el contenido del objeto <em>bytes</em> o <em>bytearray</em> usando para invocar el método.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.maketrans">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">maketrans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.maketrans" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.maketrans">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">maketrans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.maketrans" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método estático retorna una tabla de traducción apta para ser usada por el método <a class="reference internal" href="#bytes.translate" title="bytes.translate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.translate()</span></code></a>, que mapea cada carácter en <em>from</em> en la misma posición en <em>to</em>; tanto <em>from</em> como <em>to</em> deben ser <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objetos tipo binario</span></a> y deben tener la misma longitud.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.1.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.partition">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">partition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.partition" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.partition">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">partition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.partition" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Divide la secuencia en la primera ocurrencia de <em>sep</em>, y retorna una tupla de tres elementos que contiene la parte antes del separador, el separador en sí o una copia de tipo <em>bytearray</em> y la parte después del separador. Si no se encuentra el separador, retorna una tupla de tres elementos, con la primera posición ocupada por la secuencia original, y las dos posiciones siguientes rellenas con objetos <em>bytes</em> o <em>bytearray</em> vacíos.</p>
<p>El separador a buscar puede ser cualquier <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto tipo binario</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.replace">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">old</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">count</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.replace" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.replace">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">old</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">count</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.replace" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de la secuencia con todas las ocurrencias de <em>old</em> sustituidas por <em>new</em>. Si se utiliza el parámetro <em>count</em>, solo se cambian las primeras <em>count</em> ocurrencias.</p>
<p>La subsecuencia a buscar y su reemplazo puede ser cualquier <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto tipo binario</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La versión <em>bytearray</em> de este método <em>no</em> opera in situ - siempre produce un nuevo objeto, aún si no se hubiera realizado ningún cambio.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.rfind">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">rfind</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rfind" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.rfind">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">rfind</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rfind" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el mayor índice dentro de la secuencia <em>s</em> donde se puede encontrar <em>sub</em>, estando <em>sub</em> incluida en <code class="docutils literal notranslate"><span class="pre">s[start:end]</span></code>. Los parámetros opcionales <em>start</em> y <em>end</em> se interpretan igual que en las operaciones de segmentado. Retorna <code class="docutils literal notranslate"><span class="pre">-1</span></code> si no se encuentra <em>sub</em>.</p>
<p>La subsecuencia a buscar puede ser cualquier <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto tipo binario</span></a> o un número entero entre 0 y 255.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>También acepta como subsecuencia un número entero entre 0 y 255.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.rindex">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">rindex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rindex" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.rindex">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">rindex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rindex" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Como el método <a class="reference internal" href="#bytes.rfind" title="bytes.rfind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rfind()</span></code></a>, pero lanza la excepción <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> si no se encuentra <em>sub</em>.</p>
<p>La subsecuencia a buscar puede ser cualquier <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto tipo binario</span></a> o un número entero entre 0 y 255.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>También acepta como subsecuencia un número entero entre 0 y 255.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.rpartition">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">rpartition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rpartition" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.rpartition">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">rpartition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rpartition" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Divide la secuencia en la primera ocurrencia de <em>sep</em>, y retorna una tupla de tres elementos que contiene la parte antes del separador, el separador en sí o una copia de tipo <em>bytearray</em> y la parte después del separador. Si no se encuentra el separador, retorna una tupla de tres elementos, con las dos primeras posiciones rellenas con objetos <em>bytes</em> o <em>bytearray</em> vacíos, y la tercera posición ocupada por la secuencia original.</p>
<p>El separador a buscar puede ser cualquier <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto tipo binario</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.startswith">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">startswith</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.startswith" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.startswith">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">startswith</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.startswith" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si los datos binarios empiezan con el valor indicado por <em>prefix</em>, en caso contrario retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>. El valor de <em>prefix</em> puede ser también una tupla de prefijos para buscar. Con el parámetro opcional <em>start</em>, la comparación empieza a partir de esa posición. Si se especifica el parámetro opcional <em>end</em>, la comparación termina en esa posición.</p>
<p>El prefijo (o prefijos) a buscar puede ser cualquier <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto tipo binario</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.translate">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">translate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">table</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delete</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">b''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.translate" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.translate">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">translate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">table</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delete</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">b''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.translate" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia del objeto <em>bytes</em> o <em>bytearray</em> donde todas las ocurrencias de bytes especificados en el parámetro <em>delete</em> han sido borrados, y el resto han sido mapeados a través de la tabla de traducción indicada, que debe ser un objeto de tipo <em>bytes</em> con una longitud de 256 elementos.</p>
<p>Puedes usar el método <a class="reference internal" href="#bytes.maketrans" title="bytes.maketrans"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes.maketrans()</span></code></a> para crear la tabla de traducción.</p>
<p>Se puede ajustar el parámetro <em>table</em> a <code class="docutils literal notranslate"><span class="pre">None</span></code> para conseguir una traducción que solo borra caracteres:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;read this short text&#39;</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;aeiou&#39;</span><span class="p">)</span>
<span class="go">b&#39;rd ths shrt txt&#39;</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>El parámetro <em>delete</em> se puede ahora especificar por nombre.</p>
</div>
</dd></dl>

<p>Los siguientes métodos de los objetos <em>bytes</em> y <em>bytearray</em> presentan un comportamiento por defecto que asume el uso de formatos binarios compatibles con ASCII, pero aun así pueden ser usados con datos binarios arbitrarios usando los parámetros apropiados. Nótese que todos los métodos de <em>bytearray</em> en esta sección nunca operan in situ, sino que siempre retornan objetos nuevos.</p>
<dl class="py method">
<dt class="sig sig-object py" id="bytes.center">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">center</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">fillbyte</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.center" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.center">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">center</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">fillbyte</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.center" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia del objeto centrado en una secuencia de longitud <em>width</em>. El relleno se realiza usando el valor definido en el parámetro <em>fillbyte</em> (por defecto, el carácter espacio en ASCII). Para los objetos de tipo <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, se retorna la secuencia original intacta si <em>width</em> es menor o igual que <code class="docutils literal notranslate"><span class="pre">len(s)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La versión <em>bytearray</em> de este método <em>no</em> opera in situ - siempre produce un nuevo objeto, aún si no se hubiera realizado ningún cambio.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.ljust">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">ljust</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">fillbyte</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.ljust" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.ljust">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">ljust</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">fillbyte</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.ljust" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia del objeto justificado por la izquierda en una secuencia de longitud <em>width</em>. El relleno se realiza usando el valor definido en el parámetro <em>fillbyte</em> (por defecto, el carácter espacio en ASCII). Para los objetos de tipo <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, se retorna la secuencia original intacta si <em>width</em> es menor o igual que <code class="docutils literal notranslate"><span class="pre">len(s)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La versión <em>bytearray</em> de este método <em>no</em> opera in situ - siempre produce un nuevo objeto, aún si no se hubiera realizado ningún cambio.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.lstrip">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">lstrip</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">chars</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.lstrip" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.lstrip">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">lstrip</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">chars</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.lstrip" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de la secuencia con los caracteres iniciales especificados eliminados. El parámetro <em>chars</em> es una secuencia binaria que especifica el conjunto bytes a ser eliminados; el nombre hace referencia a que este método se usa normalmente con secuencias de caracteres ASCII. Si no se indica o si se especifica <code class="docutils literal notranslate"><span class="pre">None</span></code>, el comportamiento por defecto será eliminar los caracteres de espacio ASCII. No debe entenderse el valor de <em>chars</em> como un prefijo, sino que se elimina cualquier combinación de sus caracteres:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
<span class="go">b&#39;spacious   &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">b&#39;example.com&#39;</span>
</pre></div>
</div>
<p>La secuencia binaria que especifica el conjunto bytes a ser eliminados puede ser cualquier <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto de tipo binario</span></a>. Véase <a class="reference internal" href="#bytes.removeprefix" title="bytes.removeprefix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">removeprefix()</span></code></a> para un método que removerá una única cadena de prefijo en lugar de todas las ocurrencias dentro de un set de caracteres. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Arthur: three!&#39;</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Arthur: &#39;</span><span class="p">)</span>
<span class="go">b&#39;ee!&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Arthur: three!&#39;</span><span class="o">.</span><span class="n">removeprefix</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Arthur: &#39;</span><span class="p">)</span>
<span class="go">b&#39;three!&#39;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La versión <em>bytearray</em> de este método <em>no</em> opera in situ - siempre produce un nuevo objeto, aún si no se hubiera realizado ningún cambio.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.rjust">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">rjust</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">fillbyte</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rjust" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.rjust">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">rjust</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">fillbyte</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rjust" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia del objeto justificado por la derecha en una secuencia de longitud <em>width</em>. El relleno se realiza usando el valor definido en el parámetro <em>fillbyte</em> (por defecto, el carácter espacio en ASCII). Para los objetos de tipo <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, se retorna la secuencia original intacta si <em>width</em> es menor o igual que <code class="docutils literal notranslate"><span class="pre">len(s)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La versión <em>bytearray</em> de este método <em>no</em> opera in situ - siempre produce un nuevo objeto, aún si no se hubiera realizado ningún cambio.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.rsplit">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">rsplit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsplit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rsplit" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.rsplit">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">rsplit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsplit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rsplit" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Divide una secuencia binaria en subsecuencias del mismo tipo, usando como separador el valor de <em>sep</em>. Si se utiliza el parámetro <em>maxsplit</em>, se realizan como máximo <em>maxsplit</em> divisiones, retornando los que están más a la derecha. Si no se especifica <em>sep</em> o se pasa con valor <code class="docutils literal notranslate"><span class="pre">None</span></code>, se usa como separador el carácter espacio en ASCII. Si no contamos la diferencia de empezar las divisiones desde la derecha, el comportamiento de este método <a class="reference internal" href="#bytearray.rsplit" title="bytearray.rsplit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rsplit()</span></code></a> es equivalente al de <a class="reference internal" href="#bytearray.split" title="bytearray.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a>, que se describe con detalle más adelante.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.rstrip">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">rstrip</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">chars</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.rstrip" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.rstrip">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">rstrip</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">chars</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.rstrip" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de la cadena, eliminado determinados bytes si se encuentren al final. El parámetro <em>chars</em> es una secuencia binaria que especifica el conjunto de bytes a eliminar; el nombre hace referencia a que este método se usa normalmente con secuencias de caracteres ASCII. Si se omite o si se especifica <code class="docutils literal notranslate"><span class="pre">None</span></code>, se eliminan los caracteres espacio en ASCII. No debe entenderse el valor de <em>chars</em> como un prefijo, sino que se elimina cualquier combinación de sus caracteres:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
<span class="go">b&#39;   spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;mississippi&#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;ipz&#39;</span><span class="p">)</span>
<span class="go">b&#39;mississ&#39;</span>
</pre></div>
</div>
<p>La secuencia binaria que especifica el conjunto bytes a ser eliminados puede ser cualquier <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto de tipo binario</span></a>. Véase <a class="reference internal" href="#bytes.removesuffix" title="bytes.removesuffix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">removesuffix()</span></code></a> para un método que removerá una única cadena de sufijo en lugar de todas las ocurrencias dentro de un set de caracteres. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Monty Python&#39;</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39; Python&#39;</span><span class="p">)</span>
<span class="go">b&#39;M&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Monty Python&#39;</span><span class="o">.</span><span class="n">removesuffix</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39; Python&#39;</span><span class="p">)</span>
<span class="go">b&#39;Monty&#39;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La versión <em>bytearray</em> de este método <em>no</em> opera in situ - siempre produce un nuevo objeto, aún si no se hubiera realizado ningún cambio.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.split">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsplit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.split" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.split">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsplit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.split" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Divide una secuencia binaria en subsecuencias del mismo tipo, usando como separador el valor de <em>sep</em>. Si se utiliza el parámetro <em>maxsplit</em> y es un número positivo, se realizan como máximo <em>maxsplit</em> divisiones (resultando en una secuencia de como mucho <code class="docutils literal notranslate"><span class="pre">maxsplit+1</span></code> elementos). Si no se especifica <em>maxsplit</em> o se pasa <code class="docutils literal notranslate"><span class="pre">'-1</span></code>, no hay límite al número de divisiones (se hacen todas las posibles divisiones).</p>
<p>Si se especifica <em>sep</em>, las repeticiones de caracteres delimitadores no se agrupan juntos, sino que se considera que están delimitando cadenas vacías (por ejemplo, <code class="docutils literal notranslate"><span class="pre">b'1,,2'.split(b',')</span></code> retorna <code class="docutils literal notranslate"><span class="pre">[b'1',</span> <span class="pre">b'',</span> <span class="pre">b'2']</span></code>). El parámetro <em>sep</em> puede contener más de un carácter (por ejemplo, <code class="docutils literal notranslate"><span class="pre">b'1&lt;&gt;2&lt;&gt;3'.split(b'&lt;&gt;')</span></code> retorna <code class="docutils literal notranslate"><span class="pre">[b'1',</span> <span class="pre">b'2',</span> <span class="pre">b'3']</span></code>). Dividir una cadena vacía con un separador determinado retornará <code class="docutils literal notranslate"><span class="pre">[b'']</span></code> o <code class="docutils literal notranslate"><span class="pre">[bytearray(b'')]</span></code> dependiendo del tipo de objeto dividido. El parámetro <em>sep</em> puede ser cualquier <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto tipo binario</span></a>.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1,2,3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">[b&#39;1&#39;, b&#39;2&#39;, b&#39;3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1,2,3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[b&#39;1&#39;, b&#39;2,3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1,2,,3,&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="go">[b&#39;1&#39;, b&#39;2&#39;, b&#39;&#39;, b&#39;3&#39;, b&#39;&#39;]</span>
</pre></div>
</div>
<p>Si no se especifica <em>sep</em> o es <code class="docutils literal notranslate"><span class="pre">None</span></code>, se usa un algoritmo de división diferente: secuencias consecutivas de caracteres de espacio en ASCII se consideran como un único separador, y el resultado no contendrá cadenas vacías ni al principio ni al final de la lista, aunque la cadena original tuviera espacios en blanco al principio o al final. En consecuencia, dividir una secuencia vacía o que solo contenga espacios en blanco usando <code class="docutils literal notranslate"><span class="pre">None</span></code> como separador siempre retornará una lista vacía <code class="docutils literal notranslate"><span class="pre">[]</span></code>.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1 2 3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[b&#39;1&#39;, b&#39;2&#39;, b&#39;3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1 2 3&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[b&#39;1&#39;, b&#39;2 3&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;   1   2   3   &#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="go">[b&#39;1&#39;, b&#39;2&#39;, b&#39;3&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.strip">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">strip</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">chars</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.strip" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.strip">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">strip</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">chars</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.strip" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de la secuencia con los bytes indicados eliminados, tanto si están al principio como al final de la cadena. El parámetro opcional <em>chars</em> es una secuencia de bytes que especifica el conjunto de caracteres a eliminar; el nombre hace referencia a que este método se usa normalmente con secuencias de caracteres ASCII. Si se omite o se usa <code class="docutils literal notranslate"><span class="pre">None</span></code>, se eliminan los caracteres de espacio ASCII. No debe entenderse el valor de <em>chars</em> como un prefijo o sufijo, sino que se elimina cualquier combinación de sus valores:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;   spacious   &#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="go">b&#39;spacious&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;www.example.com&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;cmowz.&#39;</span><span class="p">)</span>
<span class="go">b&#39;example&#39;</span>
</pre></div>
</div>
<p>La secuencia binaria de bytes a eliminar debe ser un <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objeto tipo binario</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La versión <em>bytearray</em> de este método <em>no</em> opera in situ - siempre produce un nuevo objeto, aún si no se hubiera realizado ningún cambio.</p>
</div>
</dd></dl>

<p>Los siguientes métodos de los objetos <em>bytes</em> y <em>bytearray</em> asumen el uso de formatos binarios compatibles con ASCII, y no deben ser usados con datos binarios arbitrarios. Nótese que todos los métodos de <em>bytearray</em> en esta sección nunca operan in situ, sino que siempre retornan objetos nuevos.</p>
<dl class="py method">
<dt class="sig sig-object py" id="bytes.capitalize">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">capitalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.capitalize" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.capitalize">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">capitalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.capitalize" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de la secuencia con cada byte interpretado como un carácter ASCII, y el primer byte en mayúsculas y el resto en minúsculas. Los valores que no sean ASCII no se ven modificados.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La versión <em>bytearray</em> de este método <em>no</em> opera in situ - siempre produce un nuevo objeto, aún si no se hubiera realizado ningún cambio.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.expandtabs">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">expandtabs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tabsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.expandtabs" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.expandtabs">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">expandtabs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tabsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.expandtabs" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de la secuencia, con todos los caracteres ASCII <em>tab</em> reemplazados por uno o más espacios ASCII, dependiendo de la columna actual y del tamaño definido para el tabulador. Las posiciones de tabulación ocurren cada <em>tabsize</em> caracteres (siendo el valor por defecto de <em>tabsize</em> 8, lo que produce las posiciones de tabulación 0, 8, 16,…). Para expandir la secuencia, la columna actual se pone a cero y se va examinando byte a byte. Si se encuentra un tabulador, (<code class="docutils literal notranslate"><span class="pre">b'\t'</span></code>), se insertan uno o más espacios hasta que sea igual a la siguiente posición de tabulación. (El carácter tabulador en sí es descartado). Si el byte es un indicador de salto de línea (<code class="docutils literal notranslate"><span class="pre">b'\n'</span></code>) o de retorno (<code class="docutils literal notranslate"><span class="pre">b'\r'</span></code>), se copia y el valor de columna actual se vuelve a poner a cero. Cualquier otro carácter es copiado sin cambios y hace que el contador de columna se incremente en 1, sin tener en cuenta como se representa impreso el byte:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234&#39;</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span>
<span class="go">b&#39;01      012     0123    01234&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;01</span><span class="se">\t</span><span class="s1">012</span><span class="se">\t</span><span class="s1">0123</span><span class="se">\t</span><span class="s1">01234&#39;</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">b&#39;01  012 0123    01234&#39;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La versión <em>bytearray</em> de este método <em>no</em> opera in situ - siempre produce un nuevo objeto, aún si no se hubiera realizado ningún cambio.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.isalnum">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">isalnum</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isalnum" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.isalnum">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">isalnum</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isalnum" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si todos los bytes de la secuencia son caracteres alfabéticos ASCII o caracteres decimales ASCII y la secuencia no está vacía, en cualquier otro caso retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>. Los caracteres alfabéticos ASCII son los bytes incluidos en la secuencia <code class="docutils literal notranslate"><span class="pre">b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>. Los caracteres decimales ASCII son los bytes incluidos en la secuencia <code class="docutils literal notranslate"><span class="pre">b'0123456789'</span></code>.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ABCabc1&#39;</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ABC abc1&#39;</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.isalpha">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">isalpha</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isalpha" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.isalpha">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">isalpha</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isalpha" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si todos los bytes de la secuencia son caracteres alfabéticos ASCII y la secuencia no está vacía, en cualquier otro caso retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>. Los caracteres alfabéticos ASCII son los bytes incluidos en la secuencia <code class="docutils literal notranslate"><span class="pre">b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ABCabc&#39;</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ABCabc1&#39;</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.isascii">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">isascii</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isascii" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.isascii">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">isascii</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isascii" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si la secuencia está vacía o si todos los bytes de la secuencia son caracteres ASCII, en cualquier otro caso retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>. Los caracteres ASCII son los bytes incluidos en el rango 0-0x7F.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.isdigit">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">isdigit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isdigit" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.isdigit">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">isdigit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isdigit" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si todos los bytes de la secuencia son caracteres decimales ASCII y la secuencia no está vacía, en cualquier otro caso retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>. Los caracteres decimales ASCII son los bytes incluidos en la secuencia <code class="docutils literal notranslate"><span class="pre">b'0123456789'</span></code>.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1234&#39;</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;1.23&#39;</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.islower">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">islower</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.islower" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.islower">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">islower</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.islower" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si hay al menos un carácter ASCII en minúsculas, y no hay ningún carácter ASCII en mayúsculas, en cualquier otro caso retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;hello world&#39;</span><span class="o">.</span><span class="n">islower</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">islower</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Los caracteres ASCII en minúsculas son los bytes incluidos en la secuencia <code class="docutils literal notranslate"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>. Los caracteres ASCII en mayúsculas son los bytes en la secuencia <code class="docutils literal notranslate"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.isspace">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">isspace</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isspace" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.isspace">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">isspace</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isspace" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si todos los bytes de la secuencia son caracteres ASCII de espacio en blanco y la secuencia no está vacía, en cualquier otro caso retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>. Los caracteres de espacio en blanco ASCII son los bytes incluidos en la secuencia <code class="docutils literal notranslate"><span class="pre">b'</span> <span class="pre">\t\n\r\x0b\f'</span></code> (espacio, tabulador, nueva línea, retorno de carro, tabulador vertical y avance de página).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.istitle">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">istitle</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.istitle" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.istitle">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">istitle</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.istitle" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si la secuencia ASCII está en forma de título, y la secuencia no está vacía, en cualquier otro caso retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>. Véase el método <a class="reference internal" href="#bytes.title" title="bytes.title"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.title()</span></code></a> para más detalles en la definición de «En forma de título».</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="o">.</span><span class="n">istitle</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">istitle</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.isupper">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">isupper</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.isupper" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.isupper">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">isupper</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.isupper" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si hay al menos un carácter ASCII en mayúsculas, y no hay ningún carácter ASCII en minúsculas, en cualquier otro caso retorna <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;HELLO WORLD&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Los caracteres ASCII en minúsculas son los bytes incluidos en la secuencia <code class="docutils literal notranslate"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>. Los caracteres ASCII en mayúsculas son los bytes en la secuencia <code class="docutils literal notranslate"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.lower">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">lower</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.lower" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.lower">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">lower</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.lower" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de la secuencia con todos los caracteres ASCII en mayúsculas sustituidos por su versión correspondiente en minúsculas.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
<span class="go">b&#39;hello world&#39;</span>
</pre></div>
</div>
<p>Los caracteres ASCII en minúsculas son los bytes incluidos en la secuencia <code class="docutils literal notranslate"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>. Los caracteres ASCII en mayúsculas son los bytes en la secuencia <code class="docutils literal notranslate"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La versión <em>bytearray</em> de este método <em>no</em> opera in situ - siempre produce un nuevo objeto, aún si no se hubiera realizado ningún cambio.</p>
</div>
</dd></dl>

<span class="target" id="index-43"></span><dl class="py method">
<dt class="sig sig-object py" id="bytes.splitlines">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">splitlines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">keepends</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.splitlines" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.splitlines">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">splitlines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">keepends</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.splitlines" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una lista de las líneas en la secuencia binaria, usando como separadores los <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">saltos de líneas universales</span></a>. Los caracteres usados como separadores no se incluyen en la lista de resultados a no ser que se pase el parámetro <em>keepends</em> a <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[b&#39;ab c&#39;, b&#39;&#39;, b&#39;de fg&#39;, b&#39;kl&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ab c</span><span class="se">\n\n</span><span class="s1">de fg</span><span class="se">\r</span><span class="s1">kl</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="n">keepends</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[b&#39;ab c\n&#39;, b&#39;\n&#39;, b&#39;de fg\r&#39;, b&#39;kl\r\n&#39;]</span>
</pre></div>
</div>
<p>Al contrario que el método <a class="reference internal" href="#bytes.split" title="bytes.split"><code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code></a>, cuando se especifica una cadena delimitadora con el parámetro <em>sep</em>, este método retorna una lista vacía para la cadena vacía, y un carácter de salto de línea al final de la secuencia no resulta en una línea extra:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">),</span> <span class="sa">b</span><span class="s2">&quot;Two lines</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">([b&#39;&#39;], [b&#39;Two lines&#39;, b&#39;&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(),</span> <span class="sa">b</span><span class="s2">&quot;One line</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">([], [b&#39;One line&#39;])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.swapcase">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">swapcase</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.swapcase" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.swapcase">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">swapcase</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.swapcase" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de la secuencia con todos los caracteres ASCII en minúsculas sustituidos por su versión correspondiente en mayúsculas, y viceversa.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="o">.</span><span class="n">swapcase</span><span class="p">()</span>
<span class="go">b&#39;hELLO wORLD&#39;</span>
</pre></div>
</div>
<p>Los caracteres ASCII en minúsculas son los bytes incluidos en la secuencia <code class="docutils literal notranslate"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>. Los caracteres ASCII en mayúsculas son los bytes en la secuencia <code class="docutils literal notranslate"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>.</p>
<p>Al contrario que la función <a class="reference internal" href="#str.swapcase" title="str.swapcase"><code class="xref py py-func docutils literal notranslate"><span class="pre">str.swapcase()</span></code></a>, en este caso siempre se cumple que <code class="docutils literal notranslate"><span class="pre">bin.swapcase().swapcase()</span> <span class="pre">==</span> <span class="pre">bin</span></code> para las versiones binarias. La conversión de mayúsculas a minúsculas son simétricas en ASCII, aunque esto no es el caso general para códigos de punto Unicode.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La versión <em>bytearray</em> de este método <em>no</em> opera in situ - siempre produce un nuevo objeto, aún si no se hubiera realizado ningún cambio.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.title">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">title</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.title" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.title">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">title</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.title" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una versión en forma de título de la secuencia binaria, con la primera letra de cada palabra en mayúsculas y el resto en minúsculas. Los valores de bytes sin mayúsculas y minúsculas se dejan sin modificar.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello world&#39;</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">b&#39;Hello World&#39;</span>
</pre></div>
</div>
<p>Los caracteres ASCII en minúsculas son los bytes incluidos en la secuencia <code class="docutils literal notranslate"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>. Los caracteres ASCII en mayúsculas son los bytes en la secuencia <code class="docutils literal notranslate"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>. El resto de los caracteres no presentan diferencias entre mayúsculas y minúsculas.</p>
<p>El algoritmo usa una definición sencilla e independiente del lenguaje, consistente en considerar una palabra como un grupo de letras consecutivas. Esta definición funciona en varios entornos, pero implica que, por ejemplo en inglés, los apóstrofos en las contracciones y en los posesivos constituyen una separación entre palabras, que puede que no sea el efecto deseado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;they&#39;re bill&#39;s friends from the UK&quot;</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">b&quot;They&#39;Re Bill&#39;S Friends From The Uk&quot;</span>
</pre></div>
</div>
<p>Se puede solucionar parcialmente el problema de los apóstrofos usando expresiones regulares:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">titlecase</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">rb</span><span class="s2">&quot;[A-Za-z]+(&#39;[A-Za-z]+)?&quot;</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="k">lambda</span> <span class="n">mo</span><span class="p">:</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span>
<span class="gp">... </span>                             <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
<span class="gp">... </span>                  <span class="n">s</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">titlecase</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;they&#39;re bill&#39;s friends.&quot;</span><span class="p">)</span>
<span class="go">b&quot;They&#39;re Bill&#39;s Friends.&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La versión <em>bytearray</em> de este método <em>no</em> opera in situ - siempre produce un nuevo objeto, aún si no se hubiera realizado ningún cambio.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.upper">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">upper</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytes.upper" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.upper">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">upper</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.upper" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de la secuencia con todos los caracteres ASCII en minúsculas sustituidos por su versión correspondiente en mayúsculas.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;Hello World&#39;</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
<span class="go">b&#39;HELLO WORLD&#39;</span>
</pre></div>
</div>
<p>Los caracteres ASCII en minúsculas son los bytes incluidos en la secuencia <code class="docutils literal notranslate"><span class="pre">b'abcdefghijklmnopqrstuvwxyz'</span></code>. Los caracteres ASCII en mayúsculas son los bytes en la secuencia <code class="docutils literal notranslate"><span class="pre">b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La versión <em>bytearray</em> de este método <em>no</em> opera in situ - siempre produce un nuevo objeto, aún si no se hubiera realizado ningún cambio.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bytes.zfill">
<span class="sig-prename descclassname"><span class="pre">bytes.</span></span><span class="sig-name descname"><span class="pre">zfill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytes.zfill" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="bytearray.zfill">
<span class="sig-prename descclassname"><span class="pre">bytearray.</span></span><span class="sig-name descname"><span class="pre">zfill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#bytearray.zfill" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia de la secuencia rellenada por la izquierda con los caracteres ASCII <code class="docutils literal notranslate"><span class="pre">b'0'</span></code> necesarios para conseguir una cadena de longitud <em>width</em>. El carácter prefijo de signo (<code class="docutils literal notranslate"><span class="pre">b'+'</span></code>/<code class="docutils literal notranslate"><span class="pre">b'-'</span></code>) se gestiona insertando el relleno <em>después</em> del carácter de signo en vez de antes. Para objetos <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, se retorna la secuencia original si <em>width</em> es menor o igual que <code class="docutils literal notranslate"><span class="pre">len(s)</span></code>.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;42&quot;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">b&#39;00042&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;-42&quot;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">b&#39;-0042&#39;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La versión <em>bytearray</em> de este método <em>no</em> opera in situ - siempre produce un nuevo objeto, aún si no se hubiera realizado ningún cambio.</p>
</div>
</dd></dl>

</section>
<section id="printf-style-bytes-formatting">
<span id="bytes-formatting"></span><h3>Usando el formateo tipo <code class="docutils literal notranslate"><span class="pre">printf</span></code> con bytes<a class="headerlink" href="#printf-style-bytes-formatting" title="Enlazar permanentemente con este título">¶</a></h3>
<div class="admonition note" id="index-44">
<p class="admonition-title">Nota</p>
<p>Las operaciones de formateo explicadas aquí tienen una serie de peculiaridades que conducen a ciertos errores comunes (como fallar al representar tuplas y diccionarios correctamente). Si el valor a representar es una tupla o un diccionario, hay que envolverlos en una tupla.</p>
</div>
<p>Los objetos binarios (<code class="docutils literal notranslate"><span class="pre">bytes</span></code>/<code class="docutils literal notranslate"><span class="pre">bytearray</span></code>) tienen una operación incorporada: el operador <code class="docutils literal notranslate"><span class="pre">%</span></code> (módulo). Esta operación se conoce también como operador de <em>formateo</em> o de <em>interpolación</em>. Dada la expresión <code class="docutils literal notranslate"><span class="pre">formato</span> <span class="pre">%</span> <span class="pre">valores</span></code> (donde <em>formato</em> es un objeto binario), las especificaciones de conversión indicadas en la cadena con el símbolo <code class="docutils literal notranslate"><span class="pre">%</span></code> son reemplazadas por cero o más elementos de <em>valores</em>. El efecto es similar a usar la función del lenguaje C <code class="xref c c-func docutils literal notranslate"><span class="pre">sprintf()</span></code>.</p>
<p>Si <em>formato</em> tiene un único marcador, <em>valores</em> puede ser un objeto sencillo, no una tupla. <a class="footnote-reference brackets" href="#id16" id="id11">5</a> En caso contrario, <em>valores</em> debe ser una tupla con exactamente el mismo número de elementos que marcadores usados en el objeto binario, o un único objeto de tipo mapa (por ejemplo, un diccionario).</p>
<p id="index-45">Un especificador de conversión consiste en dos o más caracteres y tiene los siguientes componentes, que deben aparecer en el siguiente orden:</p>
<ol class="arabic simple">
<li><p>El carácter <code class="docutils literal notranslate"><span class="pre">'%'</span></code>, que identifica el inicio del marcador.</p></li>
<li><p>Una clave de mapeo (opcional), consistente en una secuencia de caracteres entre paréntesis, como por ejemplo, <code class="docutils literal notranslate"><span class="pre">(somename)</span></code>.</p></li>
<li><p>Indicador de conversión (opcional), que afecta el resultado de ciertas conversiones de tipos.</p></li>
<li><p>Valor de ancho mínimo (opcional). Si se especifica un <code class="docutils literal notranslate"><span class="pre">'*'</span></code> (asterisco), el ancho real se lee del siguiente elemento de la tupla <em>valores</em>, y el objeto a convertir viene después del ancho mínimo, con un indicador de precisión opcional.</p></li>
<li><p>Precisión (opcional), en la forma <code class="docutils literal notranslate"><span class="pre">'.'</span></code> (punto) seguido de la precisión. Si se especifica un <code class="docutils literal notranslate"><span class="pre">'*'</span></code> (asterisco), el valor de precisión real se lee del siguiente elemento de la tupla <em>valores</em>, y el valor a convertir viene después de la precisión.</p></li>
<li><p>Modificador de longitud (opcional).</p></li>
<li><p>Tipo de conversión.</p></li>
</ol>
<p>Cuando el argumento derecho es un diccionario (o cualquier otro objeto de tipo mapa), los marcadores en el objeto binario <em>deben</em> incluir un valor de clave entre paréntesis, inmediatamente después del carácter <code class="docutils literal notranslate"><span class="pre">'%'</span></code>. El valor de la clave se usa para seleccionar el valor a formatear desde el mapa. Por ejemplo:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="si">%(language)s</span><span class="s1"> has </span><span class="si">%(number)03d</span><span class="s1"> quote types.&#39;</span> <span class="o">%</span>
<span class="gp">... </span>      <span class="p">{</span><span class="sa">b</span><span class="s1">&#39;language&#39;</span><span class="p">:</span> <span class="sa">b</span><span class="s2">&quot;Python&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;number&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">b&#39;Python has 002 quote types.&#39;</span>
</pre></div>
</div>
<p>En este caso, no se puede usar el especificador <code class="docutils literal notranslate"><span class="pre">*</span></code> en la cadena de formato (dado que requiere una lista secuencial de parámetros).</p>
<p>Los indicadores de conversión son:</p>
<table class="docutils align-default" id="index-46">
<colgroup>
<col style="width: 12%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Flag</p></th>
<th class="head"><p>Significado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'#'</span></code></p></td>
<td><p>El valor a convertir usara la «forma alternativa» (que se definirá más adelante)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'0'</span></code></p></td>
<td><p>La conversión rellena con ceros por la izquierda para valores numéricos.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'-'</span></code></p></td>
<td><p>El valor convertido se ajusta a la izquierda (sobreescribe la conversión <code class="docutils literal notranslate"><span class="pre">'0'</span></code> si se especifican los dos)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'</span> <span class="pre">'</span></code></p></td>
<td><p>(Un espacio) Se debe añadir un espacio en blanco antes de un número positivo (o una cadena vacía) si se usa una conversión con signo.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'+'</span></code></p></td>
<td><p>Un carácter signo (<code class="docutils literal notranslate"><span class="pre">'+'</span></code> o <code class="docutils literal notranslate"><span class="pre">'-'</span></code>) precede a la conversión (sobreescribe el indicador de «espacio»)</p></td>
</tr>
</tbody>
</table>
<p>Puede estar presente un modificador de longitud (<code class="docutils literal notranslate"><span class="pre">h</span></code>, <code class="docutils literal notranslate"><span class="pre">l</span></code> o <code class="docutils literal notranslate"><span class="pre">L</span></code>), pero se ignora y no es necesario para Python – por lo que, por ejemplo, la salida de <code class="docutils literal notranslate"><span class="pre">%ld</span></code> es idéntica a <code class="docutils literal notranslate"><span class="pre">%d</span></code>.</p>
<p>Los tipos de conversión son:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 74%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Conversión</p></th>
<th class="head"><p>Significado</p></th>
<th class="head"><p>Notas</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'d'</span></code></p></td>
<td><p>Entero decimal con signo.</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'i'</span></code></p></td>
<td><p>Entero decimal con signo.</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'o'</span></code></p></td>
<td><p>Valor octal con signo.</p></td>
<td><p>(1)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'u'</span></code></p></td>
<td><p>Obsoleto – es idéntico a <code class="docutils literal notranslate"><span class="pre">'d'</span></code>.</p></td>
<td><p>(8)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'x'</span></code></p></td>
<td><p>Hexadecimal con signo (en minúsculas).</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'X'</span></code></p></td>
<td><p>Hexadecimal con signo (en mayúsculas).</p></td>
<td><p>(2)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'e'</span></code></p></td>
<td><p>Formato en coma flotante exponencial (en minúsculas).</p></td>
<td><p>(3)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'E'</span></code></p></td>
<td><p>Formato en coma flotante exponencial (en mayúsculas).</p></td>
<td><p>(3)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'f'</span></code></p></td>
<td><p>Formato en coma flotante decimal.</p></td>
<td><p>(3)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'F'</span></code></p></td>
<td><p>Formato en coma flotante decimal.</p></td>
<td><p>(3)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'g'</span></code></p></td>
<td><p>Formato en coma flotante. Usa formato exponencial con minúsculas si el exponente es menor que -4 o no es menor que la precisión, en caso contrario usa el formato decimal.</p></td>
<td><p>(4)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'G'</span></code></p></td>
<td><p>Formato en coma flotante. Usa formato exponencial con mayúsculas si el exponente es menor que -4 o no es menor que la precisión, en caso contrario usa el formato decimal.</p></td>
<td><p>(4)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'c'</span></code></p></td>
<td><p>Byte único (acepta números enteros o binarios de un único byte).</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'b'</span></code></p></td>
<td><p>Bytes (cualquier objeto que siga el <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">protocolo búfer</span></a> o implemente el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__bytes__()</span></code>).</p></td>
<td><p>(5)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'s'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'s'</span></code> es un alias de <code class="docutils literal notranslate"><span class="pre">'b'</span></code> y solo debe ser usado para bases de código Python2/3.</p></td>
<td><p>(6)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'a'</span></code></p></td>
<td><p>Bytes (convierte cualquier objeto Python usando <code class="docutils literal notranslate"><span class="pre">repr(obj).encode('ascii','backslashreplace')</span></code>).</p></td>
<td><p>(5)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">'r'</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">'r'</span></code> es un alias de <code class="docutils literal notranslate"><span class="pre">'a'</span></code> y solo debe ser usado para bases de código Python2/3.</p></td>
<td><p>(7)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">'%'</span></code></p></td>
<td><p>No se representa ningún argumento, obteniéndose en el resultado la cadena <code class="docutils literal notranslate"><span class="pre">'%'</span></code>.</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>Notas:</p>
<ol class="arabic">
<li><p>La forma alternativa hace que se inserte antes del primer dígito un prefijo indicativo del formato octal (<code class="docutils literal notranslate"><span class="pre">'0o'</span></code>)</p></li>
<li><p>La forma alternativa hace que se inserte antes del primer dígito uno de los dos prefijos indicativos del formato hexadecimal <code class="docutils literal notranslate"><span class="pre">'0x'</span></code> o <code class="docutils literal notranslate"><span class="pre">'0X'</span></code> (que se use uno u otro depende de que indicador de formato se haya usado, <code class="docutils literal notranslate"><span class="pre">'x'</span></code> o <code class="docutils literal notranslate"><span class="pre">'X'</span></code>).</p></li>
<li><p>La forma alternativa hace que se incluya siempre el símbolo del punto o coma decimal, incluso si no hubiera dígitos después.</p>
<p>La precisión determina el número de dígitos que vienen después del punto decimal, y por defecto es 6.</p>
</li>
<li><p>La forma alternativa hace que se incluya siempre el símbolo del punto o coma decimal, y los ceros a su derecha no se eliminan, como seria el caso en la forma normal.</p>
<p>La precisión determina el número de dígitos significativos que vienen antes y después del punto decimal, y por defecto es 6.</p>
</li>
<li><p>Si la precisión es <code class="docutils literal notranslate"><span class="pre">N</span></code>, la salida se trunca a <code class="docutils literal notranslate"><span class="pre">N</span></code> caracteres.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b'%s'</span></code> está obsoleto, pero no se retirará durante la serie 3.x.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b'%r'</span></code> está obsoleto, pero no se retirará durante la serie 3.x.</p></li>
<li><p>Véase <span class="target" id="index-77"></span><a class="pep reference external" href="https://peps.python.org/pep-0237/"><strong>PEP 237</strong></a>.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La versión <em>bytearray</em> de este método <em>no</em> opera in situ - siempre produce un nuevo objeto, aún si no se hubiera realizado ningún cambio.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p><span class="target" id="index-78"></span><a class="pep reference external" href="https://peps.python.org/pep-0461/"><strong>PEP 461</strong></a> - Añadiendo % formatea a bytes y bytearray</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
</section>
<section id="memory-views">
<span id="typememoryview"></span><h3>Vistas de memoria<a class="headerlink" href="#memory-views" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Los objetos de tipo <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> permiten al código Python acceder a los datos internos de objetos que soporten el <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">protocolo buffer</span></a> sin necesidad de hacer copias.</p>
<dl class="py class">
<dt class="sig sig-object py" id="memoryview">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">memoryview</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#memoryview" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> que referencia <em>object</em>. La variable <em>object</em> debe soportar el protocolo buffer. Los objetos incorporados que soportan el protocolo buffer incluyen los <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> y <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>.</p>
<p>La clase <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> usa el concepto de <em>elemento</em>, que es la unidad de memoria atómica gestionada por el objeto original <em>object</em>. Para muchos tipos de datos simples como <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> y <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>, un elemento es un único byte, pero otros tipos, como la clase <a class="reference internal" href="array.html#array.array" title="array.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">array.array</span></code></a> pueden tener elementos más grandes.</p>
<p>El resultado de <code class="docutils literal notranslate"><span class="pre">len(view)</span></code> es igual a la longitud de <a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-class docutils literal notranslate"><span class="pre">tolist</span></code></a>. Si <code class="docutils literal notranslate"><span class="pre">view.ndim</span> <span class="pre">=</span> <span class="pre">0</span></code>, la longitud es 1. Si <code class="docutils literal notranslate"><span class="pre">view.ndim</span> <span class="pre">=</span> <span class="pre">1</span></code>, la longitud es igual al número de elementos en la vista. Para dimensiones superiores, la longitud es igual a la de la representación como lista anidada de la vista. El atributo <a class="reference internal" href="#memoryview.itemsize" title="memoryview.itemsize"><code class="xref py py-class docutils literal notranslate"><span class="pre">itemsize</span></code></a> contiene el número de bytes que ocupa un único elemento.</p>
<p>Un objeto de tipo <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> soporta operaciones de segmentado y acceso por índices a sus datos. Un segmentado unidimensional producirá una sub-vista:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">98</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">103</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">&lt;memory at 0x7f3ddc9f4350&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
<span class="go">b&#39;bce&#39;</span>
</pre></div>
</div>
<p>Si <a class="reference internal" href="#memoryview.format" title="memoryview.format"><code class="xref py py-class docutils literal notranslate"><span class="pre">format</span></code></a> es uno de los especificadores de formato nativos del módulo <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a>, el indexado con un número entero o una tupla de números enteros también es posible, y retorna un único <em>elemento</em> con el tipo adecuado. Objetos <em>memoryview</em> unidimensionales pueden ser indexados con un entero o con una tupla de enteros. Los <em>memoryview</em> con múltiples dimensiones pueden ser indexados con tuplas de exactamente <em>ndim</em> enteros, donde <em>ndim</em> es el número de dimensiones. Vistas <em>memoryviews</em> con cero dimensiones pueden ser indexados con una tupla vacía.</p>
<p>Aquí hay un ejemplo con un formato que no es un byte:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">11111111</span><span class="p">,</span> <span class="mi">22222222</span><span class="p">,</span> <span class="o">-</span><span class="mi">33333333</span><span class="p">,</span> <span class="mi">44444444</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-11111111</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">44444444</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[-11111111, -33333333]</span>
</pre></div>
</div>
<p>Si el objeto usado para crear la vista es modificable, la vista <em>memoryview</em> soporta asignación unidimensional mediante segmentos. Sin embargo, no se permite el cambio de tamaño:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">readonly</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b&#39;zbcefg&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;123&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b&#39;z123fg&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;spam&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">memoryview assignment: lvalue and rvalue have different structures</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;spam&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b&#39;z1spam&#39;)</span>
</pre></div>
</div>
<p>One-dimensional memoryviews of <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> (read-only) types with formats
“B”, “b” or “c” are also hashable. The hash is defined as
<code class="docutils literal notranslate"><span class="pre">hash(m)</span> <span class="pre">==</span> <span class="pre">hash(m.tobytes())</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;ce&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">v</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcefg&#39;</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>One-dimensional memoryviews can now be sliced.
One-dimensional memoryviews with formats “B”, “b” or “c” are now <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>los objetos <em>memoryview</em> son registrados automáticamente con la clase <a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>los objetos <em>memoryviews</em> se pueden ahora acceder usando como índices una tupla de números enteros.</p>
</div>
<p>La clase <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> tiene varios métodos:</p>
<dl class="py method">
<dt class="sig sig-object py" id="memoryview.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exporter</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.__eq__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un objeto <em>memoryview</em> y un exportador <span class="target" id="index-79"></span><a class="pep reference external" href="https://peps.python.org/pep-3118/"><strong>PEP 3118</strong></a> son iguales si sus formas son equivalentes y todos los valores correspondientes son iguales cuando los formatos respectivos de los operandos son interpretados usando la sintaxis de <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a>.</p>
<p>Para el subconjunto de formatos de <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> soportados actualmente por <a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tolist()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">v</span></code> y <code class="docutils literal notranslate"><span class="pre">w</span></code> son iguales si <code class="docutils literal notranslate"><span class="pre">v.tolist()</span> <span class="pre">==</span> <span class="pre">w.tolist()</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="n">a</span> <span class="o">==</span> <span class="n">y</span> <span class="o">==</span> <span class="n">b</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">==</span> <span class="n">c</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">c</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Si cualquiera de las cadenas de formato no es soportada por el módulo <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a>, entonces la comparación de los objetos siempre los considerará diferentes (incluso si las cadenas de formato y el contenido del <em>buffer</em> son idénticos):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="n">BigEndianStructure</span><span class="p">,</span> <span class="n">c_long</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">BEPoint</span><span class="p">(</span><span class="n">BigEndianStructure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_long</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_long</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">BEPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">point</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Nótese que, al igual que con los números en coma flotante, <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">is</span> <span class="pre">w</span></code> <em>no</em> implica que <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">==</span> <span class="pre">w</span></code> para objetos del tipo <em>memoryview</em>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Versiones previas comparaban la memoria directamente, sin considerar ni el formato de los elementos ni la estructura lógica del arreglo.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="memoryview.tobytes">
<span class="sig-name descname"><span class="pre">tobytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.tobytes" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna los datos en el <em>buffer</em> en forma de cadena de bytes. Equivale a llamar al constructor de la clase <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> en el objeto <em>memoryview</em>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">b&#39;abc&#39;</span>
</pre></div>
</div>
<p>Para arreglos no contiguos el resultado es igual a la representación en forma de lista aplanada, con todos los elementos convertidos a bytes. El método <a class="reference internal" href="#memoryview.tobytes" title="memoryview.tobytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tobytes()</span></code></a> soporta todos los formatos de cadenas de caracteres, incluidos aquellos que no se encuentran en la sintaxis del módulo <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8: </span>El valor de <em>order</em> puede ser {“C”, “F”, “A”}. Cuando <em>order</em> es “C” o “F”, los datos en el arreglo original se convierten al orden de C o Fortran. Para vistas contiguas, “A” retorna una copia exacta de la memoria física. En particular, el orden en memoria de Fortran se mantiene inalterado. Para vistas no contiguas, los datos se convierten primero a C. Definir <em>order=None</em> es lo mismo que <em>order=”C”</em>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="memoryview.hex">
<span class="sig-name descname"><span class="pre">hex</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">sep</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">bytes_per_sep</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.hex" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una cadena de caracteres que contiene dos dígitos hexadecimales por cada byte en el <em>buffer</em>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;616263&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>De forma similar a <a class="reference internal" href="#bytes.hex" title="bytes.hex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.hex()</span></code></a>, <a class="reference internal" href="#memoryview.hex" title="memoryview.hex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">memoryview.hex()</span></code></a> soporta ahora los parámetros opcionales <em>sep</em> y <em>bytes_per_sep</em> para insertar separadores entre los bytes en la cadena hexadecimal de salida.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="memoryview.tolist">
<span class="sig-name descname"><span class="pre">tolist</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.tolist" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna los datos en el <em>buffer</em> como una lista de elementos.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[97, 98, 99]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[1.1, 2.2, 3.3]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>El método <a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tolist()</span></code></a> soporta ahora todos los formatos nativos de un solo carácter definidos en el módulo <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a>, así como las representaciones de múltiples dimensiones.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="memoryview.toreadonly">
<span class="sig-name descname"><span class="pre">toreadonly</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.toreadonly" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una versión de solo lectura del objeto <em>memoryview</em>. El objeto original permanece inalterado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mm</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">toreadonly</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mm</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[89, 98, 99]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">cannot modify read-only memory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">43</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mm</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[43, 98, 99]</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="memoryview.release">
<span class="sig-name descname"><span class="pre">release</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.release" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Libera el buffer subyacente expuesto por el objeto <em>memoryview</em>. Muchos objetos realizan operaciones especiales cuando una vista los está conteniendo (por ejemplo, un objeto <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> temporalmente prohíbe el cambio de tamaño); la llamada a <em>release()</em> sirve para eliminar estas restricciones (así como para tratar con los recursos pendientes) lo más pronto posible.</p>
<p>Después de que se ha llamado a este método, cualquier operación posterior sobre la vista lanzará una excepción de tipo <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code></a> (excepto por el propio método <a class="reference internal" href="#memoryview.release" title="memoryview.release"><code class="xref py py-meth docutils literal notranslate"><span class="pre">release()</span></code></a>, que puede ser llamado las veces que se quiera):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">operation forbidden on released memoryview object</span>
</pre></div>
</div>
<p>El protocolo de gestión de contexto puede ser usado para obtener un efecto similar, usando la sentencia <code class="docutils literal notranslate"><span class="pre">with</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">m</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">97</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">operation forbidden on released memoryview object</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="memoryview.cast">
<span class="sig-name descname"><span class="pre">cast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.cast" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Transforma el formato o el tamaño de un objeto <em>memoryview</em>. El parámetro <em>shape</em> por defecto vale <code class="docutils literal notranslate"><span class="pre">[byte_length//new_itemsize]</span></code>, lo que significa que el resultado será unidimensional. El valor de retorno es un nuevo objeto de tipo <em>memoryview</em>, pero el buffer en sí no se copia. Las transformaciones pueden ser 1D -&gt; C-<a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguo</span></a> y C-contiguo -&gt; 1D.</p>
<p>El formato de destino está restringido a un único elemento de formato nativo en la sintaxis de <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a>. Uno de los formatos debe ser un formato de byte (“B”, “b” o “c”). La longitud en bytes del resultado debe coincidir con la longitud original.</p>
<p>Transforma de <code class="docutils literal notranslate"><span class="pre">1D/long</span></code> a bytes <code class="docutils literal notranslate"><span class="pre">1D/unsigned</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">format</span>
<span class="go">&#39;l&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">24</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">format</span>
<span class="go">&#39;B&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">24</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">24</span>
</pre></div>
</div>
<p>Transforma de <code class="docutils literal notranslate"><span class="pre">1D/unsigned</span></code> a bytes <code class="docutils literal notranslate"><span class="pre">1D/char</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;zyz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;a&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">memoryview: invalid value for format &quot;B&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">bytearray(b&#39;ayz&#39;)</span>
</pre></div>
</div>
<p>Transforma de <code class="docutils literal notranslate"><span class="pre">1D/bytes</span></code> a <code class="docutils literal notranslate"><span class="pre">3D/ints</span></code> a caracteres <code class="docutils literal notranslate"><span class="pre">1D/signed</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">format</span>
<span class="go">&#39;i&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">format</span>
<span class="go">&#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">48</span>
</pre></div>
</div>
<p>Transforma de <em>long</em> <code class="docutils literal notranslate"><span class="pre">1D/unsigned</span></code> a <em>long</em> <code class="docutils literal notranslate"><span class="pre">2D/unsigned</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;L&quot;</span><span class="o">*</span><span class="mi">6</span><span class="p">,</span> <span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[0, 1, 2], [3, 4, 5]]</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>El formato de origen ya no está restringido cuando se transforma a una vista de bytes.</p>
</div>
</dd></dl>

<p>Hay disponibles varios atributos de solo lectura:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="memoryview.obj">
<span class="sig-name descname"><span class="pre">obj</span></span><a class="headerlink" href="#memoryview.obj" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El objeto subyacente del <em>memoryview</em>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;xyz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">obj</span> <span class="ow">is</span> <span class="n">b</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="memoryview.nbytes">
<span class="sig-name descname"><span class="pre">nbytes</span></span><a class="headerlink" href="#memoryview.nbytes" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">nbytes</span> <span class="pre">==</span> <span class="pre">product(shape)</span> <span class="pre">*</span> <span class="pre">itemsize</span> <span class="pre">==</span> <span class="pre">len(m.tobytes())</span></code>. Este es el espacio, medido en bytes, que usará el arreglo en una representación continua. No tiene que ser necesariamente igual a <code class="docutils literal notranslate"><span class="pre">len(m)</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">m</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">12</span>
</pre></div>
</div>
<p>Arreglos de múltiples dimensiones:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="o">*</span><span class="p">[</span><span class="mf">1.5</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">96</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="memoryview.readonly">
<span class="sig-name descname"><span class="pre">readonly</span></span><a class="headerlink" href="#memoryview.readonly" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un booleano que indica si la memoria es de solo lectura.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="memoryview.format">
<span class="sig-name descname"><span class="pre">format</span></span><a class="headerlink" href="#memoryview.format" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una cadena de caracteres que contiene el formato (en el estilo del módulo <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a>) para cada elemento de la vista. Un objeto <em>memoryview</em> se puede crear a partir de un exportador con textos de formato arbitrarios, pero algunos métodos (como, por ejemplo, <a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tolist()</span></code></a>) están restringidos a usar formatos de elementos nativos sencillos.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>el formato <code class="docutils literal notranslate"><span class="pre">'B'</span></code> se gestiona ahora de acuerdo a la sintaxis descrita en el módulo <code class="docutils literal notranslate"><span class="pre">struct</span></code>. Esto significa que <code class="docutils literal notranslate"><span class="pre">memoryview(b'abc')[0]</span> <span class="pre">==</span> <span class="pre">b'abc'[0]</span> <span class="pre">==</span> <span class="pre">97</span></code>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="memoryview.itemsize">
<span class="sig-name descname"><span class="pre">itemsize</span></span><a class="headerlink" href="#memoryview.itemsize" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El tamaño en bytes de cada elemento del objeto <em>memoryview</em>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span><span class="o">,</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">32000</span><span class="p">,</span> <span class="mi">32001</span><span class="p">,</span> <span class="mi">32002</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">32000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="memoryview.ndim">
<span class="sig-name descname"><span class="pre">ndim</span></span><a class="headerlink" href="#memoryview.ndim" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un número entero que indica cuantas dimensiones de un arreglo multi-dimensional representa la memoria.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="memoryview.shape">
<span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#memoryview.shape" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una tupla de números enteros, de longitud <a class="reference internal" href="#memoryview.ndim" title="memoryview.ndim"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ndim</span></code></a>, que indica la forma de la memoria en un arreglo de <em>N</em> dimensiones.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Una tupla vacía, en vez de <code class="docutils literal notranslate"><span class="pre">None</span></code>, cuando <code class="docutils literal notranslate"><span class="pre">ndim</span> <span class="pre">=</span> <span class="pre">0</span></code>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="memoryview.strides">
<span class="sig-name descname"><span class="pre">strides</span></span><a class="headerlink" href="#memoryview.strides" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una tupla de números enteros, de longitud <a class="reference internal" href="#memoryview.ndim" title="memoryview.ndim"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ndim</span></code></a>, que indica el tamaño en bytes para acceder a cada dimensión del arreglo.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Una tupla vacía, en vez de <code class="docutils literal notranslate"><span class="pre">None</span></code>, cuando <code class="docutils literal notranslate"><span class="pre">ndim</span> <span class="pre">=</span> <span class="pre">0</span></code>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="memoryview.suboffsets">
<span class="sig-name descname"><span class="pre">suboffsets</span></span><a class="headerlink" href="#memoryview.suboffsets" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>De uso interno para los arreglos estilo <em>PIL</em>. El valor es solo informativo.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="memoryview.c_contiguous">
<span class="sig-name descname"><span class="pre">c_contiguous</span></span><a class="headerlink" href="#memoryview.c_contiguous" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un booleano que indica si la memoria es <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a> al estilo C.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="memoryview.f_contiguous">
<span class="sig-name descname"><span class="pre">f_contiguous</span></span><a class="headerlink" href="#memoryview.f_contiguous" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un booleano que indica si la memoria es <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a> al estilo Fortran.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="memoryview.contiguous">
<span class="sig-name descname"><span class="pre">contiguous</span></span><a class="headerlink" href="#memoryview.contiguous" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un booleano que indica si la memoria es <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="set-types-set-frozenset">
<span id="types-set"></span><h2>Conjuntos — <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>, <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a><a class="headerlink" href="#set-types-set-frozenset" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-50">Un objeto de tipo <em class="dfn">set</em> es una colección no ordenada de distintos objetos <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>. Los casos de uso habituales incluyen comprobar la pertenencia al conjunto de un elemento, eliminar duplicados de una secuencia y realizar operaciones matemáticas como la intersección, la unión, la diferencia o la diferencia simétrica. (Para otros tipos de contenedores véanse las clases incorporadas <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>, <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, y <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, así como el módulo <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a>).</p>
<p>Como otras colecciones, los conjuntos soportan <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">set</span></code>, <code class="docutils literal notranslate"><span class="pre">len(set)</span></code> y <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">set</span></code>. Como es una colección sin orden, los conjuntos no registran ni la posición ni el orden de inserción de los elementos. Por lo mismo, los conjuntos no soportan indexado, ni operaciones de segmentado, ni otras capacidades propias de las secuencias.</p>
<p>En la actualidad hay dos tipos de conjuntos incorporados: <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> y <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>. La clase <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> es mutable, es decir, el contenido del conjunto puede ser modificado con métodos como <code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">remove()</span></code>. Como es mutable, no tiene un valor de <em>hash</em> y no pueden ser usados como claves de diccionarios ni como elementos de otros conjuntos. La clase <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> es inmutable y <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>, es decir, que sus contenidos no pueden ser modificados después de creados. Puede ser usado, por tanto, como claves de diccionario o como elemento de otro conjunto.</p>
<p>Se pueden crear conjuntos no vacíos (<em>sets</em>, no <em>frozensets</em>) escribiendo una lista de elementos separados por comas, entre llaves, por ejemplo <code class="docutils literal notranslate"><span class="pre">{'jack',</span> <span class="pre">'sjoerd'}</span></code>, además de con el constructor de la clase <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>.</p>
<p>El constructor para ambas clases se usa de la misma forma:</p>
<dl class="py class">
<dt class="sig sig-object py" id="set">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#set" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="frozenset">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">frozenset</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un nuevo <em>set</em> o <em>frozenset</em>, tomando los elementos a partir de <em>iterable</em>. Los elementos de un conjunto tienen que tener la propiedad de ser <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>. Para representar conjuntos anidados, o conjuntos de conjuntos, los conjuntos interiores tienen que ser instancias de <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>. Si no se especifica el parámetro <em>iterable</em>, se retorna un conjunto vacío.</p>
<p>Los conjuntos (<em>sets</em>) se pueden construir de diferentes formas:</p>
<ul class="simple">
<li><p>Usando una lista de elementos separados por coma entre corchetes: <code class="docutils literal notranslate"><span class="pre">{'jack',</span> <span class="pre">'sjoerd'}</span></code></p></li>
<li><p>Usando un <em>set comprehention</em>: <code class="docutils literal notranslate"><span class="pre">{c</span> <span class="pre">for</span> <span class="pre">c</span> <span class="pre">in</span> <span class="pre">'abracadabra'</span> <span class="pre">if</span> <span class="pre">c</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">'abc'}</span></code></p></li>
<li><p>Usando un constructor de tipo: <code class="docutils literal notranslate"><span class="pre">set()</span></code>, <code class="docutils literal notranslate"><span class="pre">set('foobar')</span></code>, <code class="docutils literal notranslate"><span class="pre">set(['a',</span> <span class="pre">'b',</span> <span class="pre">'foo'])</span></code></p></li>
</ul>
<p>Las instancias de <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> y <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> proporcionan las siguientes operaciones:</p>
<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">len(s)</span></span></dt>
<dd><p>Retorna el número de elementos en el conjunto <em>s</em> (cardinalidad de <em>s</em>).</p>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">s</span></span></dt>
<dd><p>Comprueba que el elemento <em>x</em> está incluido en <em>s</em>.</p>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">x</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">s</span></span></dt>
<dd><p>Comprueba que el elemento <em>x</em> no está incluido en <em>s</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frozenset.isdisjoint">
<span class="sig-name descname"><span class="pre">isdisjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.isdisjoint" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si el conjunto no tienen ningún elemento en común con <em>other</em>. Dos conjuntos son disjuntos si y solo si su intersección es el conjunto vacío.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frozenset.issubset">
<span class="sig-name descname"><span class="pre">issubset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.issubset" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set</span> <span class="pre">&lt;=</span> <span class="pre">other</span></span></dt>
<dd><p>Comprueba si cada elemento del conjunto también se encuentra en <em>other</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set</span> <span class="pre">&lt;</span> <span class="pre">other</span></span></dt>
<dd><p>Comprueba si el conjunto es un subconjunto propio de <em>other</em>, es decir, <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">&lt;=</span> <span class="pre">other</span> <span class="pre">and</span> <span class="pre">set</span> <span class="pre">!=</span> <span class="pre">other</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frozenset.issuperset">
<span class="sig-name descname"><span class="pre">issuperset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.issuperset" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set</span> <span class="pre">&gt;=</span> <span class="pre">other</span></span></dt>
<dd><p>Comprueba que cada elemento de <em>other</em> está incluido en el conjunto.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set</span> <span class="pre">&gt;</span> <span class="pre">other</span></span></dt>
<dd><p>Comprueba si el conjunto es un superconjunto propio de <em>other</em>, es decir, <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">&gt;=</span> <span class="pre">other</span> <span class="pre">and</span> <span class="pre">set</span> <span class="pre">!=</span> <span class="pre">other</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frozenset.union">
<span class="sig-name descname"><span class="pre">union</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">others</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.union" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set</span> <span class="pre">|</span> <span class="pre">other</span> <span class="pre">|</span> <span class="pre">...</span></span></dt>
<dd><p>Retorna un conjunto nuevo que contiene todos los elementos del conjunto y de <em>others</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frozenset.intersection">
<span class="sig-name descname"><span class="pre">intersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">others</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.intersection" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set</span> <span class="pre">&amp;</span> <span class="pre">other</span> <span class="pre">&amp;</span> <span class="pre">...</span></span></dt>
<dd><p>Retorna un conjunto nuevo que contiene todos los elementos que están a la vez en conjunto y en <em>others</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frozenset.difference">
<span class="sig-name descname"><span class="pre">difference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">others</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.difference" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set</span> <span class="pre">-</span> <span class="pre">other</span> <span class="pre">-</span> <span class="pre">...</span></span></dt>
<dd><p>Retorna un conjunto nuevo que contiene todos los elementos del conjunto y que no están incluidos en <em>others</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frozenset.symmetric_difference">
<span class="sig-name descname"><span class="pre">symmetric_difference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.symmetric_difference" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set</span> <span class="pre">^</span> <span class="pre">other</span></span></dt>
<dd><p>Retorna un conjunto nuevo que contiene elementos que están incluidos en el conjunto o en <em>others</em>, pero no en los dos a la vez.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frozenset.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.copy" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia superficial del conjunto.</p>
</dd></dl>

<p>Hay que señalar que las versiones de las operaciones que son métodos (no los operadores) como <a class="reference internal" href="#frozenset.union" title="frozenset.union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">union()</span></code></a>, <a class="reference internal" href="#frozenset.intersection" title="frozenset.intersection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">intersection()</span></code></a>, <a class="reference internal" href="#frozenset.difference" title="frozenset.difference"><code class="xref py py-meth docutils literal notranslate"><span class="pre">difference()</span></code></a>, <a class="reference internal" href="#frozenset.symmetric_difference" title="frozenset.symmetric_difference"><code class="xref py py-meth docutils literal notranslate"><span class="pre">symmetric_difference()</span></code></a>, <a class="reference internal" href="#frozenset.issubset" title="frozenset.issubset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">issubset()</span></code></a>, y <a class="reference internal" href="#frozenset.issuperset" title="frozenset.issuperset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">issuperset()</span></code></a> aceptan cualquier iterable como parámetro. Por el contrario, los operadores requieren que los argumentos sean siempre conjuntos. Esto evita ciertas construcciones propensas a errores como <code class="docutils literal notranslate"><span class="pre">set('abc')</span> <span class="pre">&amp;</span> <span class="pre">'cbs'</span></code>, favoreciendo el uso de formas más legibles como <code class="docutils literal notranslate"><span class="pre">set('abc').intersection('cbs')</span></code>.</p>
<p>Ambas clases <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> y <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> soportan comparaciones entre sí. Dos conjuntos son iguales si y solo si cada elemento de cada conjunto está incluido en el otro (cada uno de ellos es subconjunto del otro). Un conjunto es menor que otro si y solo si el primero es un subconjunto propio del segundo (es un subconjunto, pero no son iguales). Un conjunto es mayor que otro si y solo si el primero es un superconjunto propio del segundo (es un superconjunto, pero no son iguales).</p>
<p>Las instancias de <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> se comparan con las instancias de <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> en base a sus elementos. Por ejemplo <code class="docutils literal notranslate"><span class="pre">set('abc')</span> <span class="pre">==</span> <span class="pre">frozenset('abc')</span></code> retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> y lo mismo hace <code class="docutils literal notranslate"><span class="pre">set('abc')</span> <span class="pre">in</span> <span class="pre">set([frozenset('abc')])</span></code>.</p>
<p>Las comparaciones de subconjunto e igualdad no son tan generales que permitan una función de ordenación total. Por ejemplo, dos conjuntos cualesquiera que no estén vacíos y que sean disjuntos no son iguales y tampoco son subconjuntos uno del otro, así que todas estas operaciones retornan <code class="docutils literal notranslate"><span class="pre">False</span></code>: <code class="docutils literal notranslate"><span class="pre">a&lt;b</span></code>, <code class="docutils literal notranslate"><span class="pre">a==b</span></code> o <code class="docutils literal notranslate"><span class="pre">a&gt;b</span></code>.</p>
<p>Como los conjuntos solo definen un orden parcial (relaciones de conjuntos), la salida del método <a class="reference internal" href="#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> no está definida para listas de conjuntos.</p>
<p>Los elementos de un conjunto, al igual que las claves de un diccionario, deben ser <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>.</p>
<p>Las operaciones binarias que mezclan instancias de <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> y <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> retornan el tipo del primer operando. Por ejemplo: <code class="docutils literal notranslate"><span class="pre">frozenset('ab')</span> <span class="pre">|</span> <span class="pre">set('bc')</span></code> retornará una instancia de <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>.</p>
<p>La siguiente tabla muestra las operaciones disponibles para la clase <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> que no son aplicables a los conjuntos inmutables <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>:</p>
<dl class="py method">
<dt class="sig sig-object py" id="frozenset.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">others</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.update" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set</span> <span class="pre">|=</span> <span class="pre">other</span> <span class="pre">|</span> <span class="pre">...</span></span></dt>
<dd><p>Actualiza el conjunto, añadiendo los elementos que se encuentren en <em>others</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frozenset.intersection_update">
<span class="sig-name descname"><span class="pre">intersection_update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">others</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.intersection_update" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set</span> <span class="pre">&amp;=</span> <span class="pre">other</span> <span class="pre">&amp;</span> <span class="pre">...</span></span></dt>
<dd><p>Actualiza el conjunto, manteniendo solo los elementos que se encuentren en si mismo y en <em>others</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frozenset.difference_update">
<span class="sig-name descname"><span class="pre">difference_update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">others</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.difference_update" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set</span> <span class="pre">-=</span> <span class="pre">other</span> <span class="pre">|</span> <span class="pre">...</span></span></dt>
<dd><p>Actualiza el conjunto, eliminado los elementos que se encuentren en <em>others</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frozenset.symmetric_difference_update">
<span class="sig-name descname"><span class="pre">symmetric_difference_update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.symmetric_difference_update" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">set</span> <span class="pre">^=</span> <span class="pre">other</span></span></dt>
<dd><p>Actualiza el conjunto, manteniendo solo los elementos que se encuentren en el conjunto o en <em>others</em>, pero no en los dos a la vez.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frozenset.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elem</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.add" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Añade al conjunto el elemento <em>elem</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frozenset.remove">
<span class="sig-name descname"><span class="pre">remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elem</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.remove" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Elimina del conjunto el elemento <em>elem</em>. Lanza la excepción <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> si <em>elem</em> no estaba incluido en el conjunto.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frozenset.discard">
<span class="sig-name descname"><span class="pre">discard</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">elem</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.discard" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Elimina del conjunto el elemento <em>elem</em>, si estuviera incluido.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frozenset.pop">
<span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.pop" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Elimina y retorna un elemento cualquiera del conjunto. Lanza la excepción <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> si el conjunto está vacío.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="frozenset.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.clear" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Elimina todos los elementos del conjunto.</p>
</dd></dl>

<p>Hay que señalar que los métodos (no los operadores) <a class="reference internal" href="#frozenset.update" title="frozenset.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a>, <a class="reference internal" href="#frozenset.intersection_update" title="frozenset.intersection_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">intersection_update()</span></code></a>, <a class="reference internal" href="#frozenset.difference_update" title="frozenset.difference_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">difference_update()</span></code></a>, y <a class="reference internal" href="#frozenset.symmetric_difference_update" title="frozenset.symmetric_difference_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">symmetric_difference_update()</span></code></a> aceptan cualquier iterable como parámetro.</p>
<p>Nótese que el parámetro <em>elem</em> de los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code>, <a class="reference internal" href="#frozenset.remove" title="frozenset.remove"><code class="xref py py-meth docutils literal notranslate"><span class="pre">remove()</span></code></a> y <a class="reference internal" href="#frozenset.discard" title="frozenset.discard"><code class="xref py py-meth docutils literal notranslate"><span class="pre">discard()</span></code></a> puede ser un conjunto. Para soportar la búsqueda por un <em>frozenset</em> equivalente se crea uno temporal a partir de <em>elem</em>.</p>
</dd></dl>

</section>
<section id="mapping-types-dict">
<span id="typesmapping"></span><h2>Tipos mapa — <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a><a class="headerlink" href="#mapping-types-dict" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-51">Un objeto de tipo <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a> relaciona valores (que deben ser <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>) con objetos de cualquier tipo. Los mapas son objetos mutables. En este momento solo hay un tipo estándar de mapa, los <em class="dfn">dictionary</em>. (Para otros tipos contenedores, véanse las clases incorporadas <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>, y <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, así como el módulo <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a>).</p>
<p>A dictionary’s keys are <em>almost</em> arbitrary values.  Values that are not
<a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>, that is, values containing lists, dictionaries or other
mutable types (that are compared by value rather than by object identity) may
not be used as keys.
Values that compare equal (such as <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">1.0</span></code>, and <code class="docutils literal notranslate"><span class="pre">True</span></code>)
can be used interchangeably to index the same dictionary entry.</p>
<dl class="py class">
<dt class="sig sig-object py" id="dict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dict" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Retorna un diccionario creado a partir de un parámetro opcional por posición, y por una serie de parámetros por nombre, también opcionales.</p>
<p>Los diccionarios se pueden construir de diferentes formas:</p>
<ul class="simple">
<li><p>Usando una lista separada por comas de pares <code class="docutils literal notranslate"><span class="pre">key:</span> <span class="pre">value</span></code> entre llaves: <code class="docutils literal notranslate"><span class="pre">{'jack':</span> <span class="pre">4098,</span> <span class="pre">'sjoerd':</span> <span class="pre">4127}</span></code> o <code class="docutils literal notranslate"><span class="pre">{4098:</span> <span class="pre">'jack',</span> <span class="pre">4127:</span> <span class="pre">'sjoerd'}</span></code></p></li>
<li><p>Usando una comprensión de diccionario: <code class="docutils literal notranslate"><span class="pre">{}</span></code>, <code class="docutils literal notranslate"><span class="pre">{x:</span> <span class="pre">x</span> <span class="pre">**</span> <span class="pre">2</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(10)}</span></code></p></li>
<li><p>Usando un constructor de tipo: <code class="docutils literal notranslate"><span class="pre">dict()</span></code>, <code class="docutils literal notranslate"><span class="pre">dict([('foo',</span> <span class="pre">100),</span> <span class="pre">('bar',</span> <span class="pre">200)])</span></code>, <code class="docutils literal notranslate"><span class="pre">dict(foo=100,</span> <span class="pre">bar=200)</span></code></p></li>
</ul>
<p>Si no se especifica el parámetro por posición, se crea un diccionario vacío. Si se pasa un parámetro por posición y es un objeto de tipo mapa, se crea el diccionario a partir de las parejas clave-valor definidos en el mapa. Si no fuera un mapa, se espera que el parámetro sea un objeto <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a>. Cada elemento del iterable debe ser una dupla (una tupla de dos elementos); el primer componente de la dupla se usará como clave y el segundo como valor a almacenar en el nuevo diccionario. Si una clave aparece más de una vez, el último valor será el que se almacene en el diccionario resultante.</p>
<p>Si se usan parámetros por nombre, los nombres de los parámetros y los valores asociados se añaden al diccionario creado a partir del parámetro por posición. Si un valor de clave ya estaba presente, el valor pasado con el parámetro por nombre reemplazará el valor del parámetro por posición.</p>
<p>A modo de ejemplo, los siguientes ejemplos retornan todos el mismo diccionario <code class="docutils literal notranslate"><span class="pre">{&quot;one&quot;:</span> <span class="pre">1,</span> <span class="pre">&quot;two&quot;:</span> <span class="pre">2,</span> <span class="pre">&quot;three&quot;:</span> <span class="pre">3}</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">one</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">two</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">three</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;one&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;three&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">({</span><span class="s1">&#39;three&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">({</span><span class="s1">&#39;one&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="n">two</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="o">==</span> <span class="n">c</span> <span class="o">==</span> <span class="n">d</span> <span class="o">==</span> <span class="n">e</span> <span class="o">==</span> <span class="n">f</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Si queremos definir claves con parámetros por nombre, como en el primer ejemplo, entonces los valores de clave solo puede ser cadenas de texto conteniendo identificadores de Python válidos. En los otros casos, se puede usar cualquier valor como clave.</p>
<p>Estas son las operaciones soportados por los diccionarios (y que, por tanto, deberían ser soportados por los tipos de mapa personalizados):</p>
<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">list(d)</span></span></dt>
<dd><p>Retorna una lista de todas las claves usadas en el diccionario <em>d</em>.</p>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">len(d)</span></span></dt>
<dd><p>Retorna el número de elementos almacenados en el diccionario <em>d</em>.</p>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">d[key]</span></span></dt>
<dd><p>Retorna el elemento dentro de <em>d</em> almacenado bajo la clave <em>key</em>. Lanza una excepción de tipo <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> si la clave <em>key</em> no se encuentra en el diccionario <em>d</em>.</p>
<p id="index-52">Si una subclase de un diccionario define el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__missing__()</span></code> y <em>key</em> no está presente, la operación <code class="docutils literal notranslate"><span class="pre">d[key]</span></code> llama a este método pasando como parámetro el valor de <em>key</em>. La operación <code class="docutils literal notranslate"><span class="pre">d[key]</span></code> o bien retorna un valor o lanza la excepción que sea retornada por la llamada a <code class="docutils literal notranslate"><span class="pre">__missing__(key)</span></code>. Ninguna otra operación o método llama a <code class="xref py py-meth docutils literal notranslate"><span class="pre">__missing__()</span></code>. Si el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__missing__()</span></code> no está definido, se lanza <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>. Si se define <code class="xref py py-meth docutils literal notranslate"><span class="pre">__missing__()</span></code>, debe ser de forma obligatoria un método, no puede ser una variable de instancia:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Counter</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">]</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">]</span>
<span class="go">1</span>
</pre></div>
</div>
<p>El ejemplo anterior muestra parte de la implementación de la clase <a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a>. Otro ejemplo de uso del método <code class="docutils literal notranslate"><span class="pre">__missing__</span></code> se puede encontrar en la clase <a class="reference internal" href="collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a>.</p>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">d[key]</span> <span class="pre">=</span> <span class="pre">value</span></span></dt>
<dd><p>Asigna el valor <em>value</em> a <code class="docutils literal notranslate"><span class="pre">d[key]</span></code>.</p>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">del</span> <span class="pre">d[key]</span></span></dt>
<dd><p>Elimina <code class="docutils literal notranslate"><span class="pre">d[key]</span></code> de <em>d</em>. Lanza una excepción <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> si <em>key</em> no está en el mapa.</p>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">key</span> <span class="pre">in</span> <span class="pre">d</span></span></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si <em>d</em> tiene una entrada en la clave <em>key</em>, <code class="docutils literal notranslate"><span class="pre">False</span></code> en caso contrario.</p>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">key</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">d</span></span></dt>
<dd><p>Equivale a <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">key</span> <span class="pre">in</span> <span class="pre">d</span></code>.</p>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">iter(d)</span></span></dt>
<dd><p>Retorna un iterador que recorre todas las claves de un diccionario. Es una forma abreviada de <code class="docutils literal notranslate"><span class="pre">iter(d.keys())</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dict.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.clear" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Elimina todos los elementos del diccionario.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dict.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.copy" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una copia superficial del diccionario.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dict.fromkeys">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fromkeys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.fromkeys" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crea un nuevo diccionario con las claves obtenidos a partir del <em>iterable</em> y con valor <em>value</em>.</p>
<p>El método <a class="reference internal" href="#dict.fromkeys" title="dict.fromkeys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fromkeys()</span></code></a> es un método de clase que retorna un diccionario nuevo. El valor de <em>value</em> por defecto es <code class="docutils literal notranslate"><span class="pre">None</span></code>. Todos los valores harán referencia a una única instancia, por lo que en general no tiene sentido que <em>value</em> sea un objeto mutable, como una lista vacía. Para poder obtener valores diferentes, se puede usar mejor un <a class="reference internal" href="../reference/expressions.html#dict"><span class="std std-ref">diccionario por comprensión</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dict.get">
<span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">default</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.get" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el elemento dentro de <em>d</em> almacenado bajo la clave <em>key</em>, si <em>key</em> está en el diccionario; si no, retorna <em>default</em>. El valor de <em>default</em> por defecto es <code class="docutils literal notranslate"><span class="pre">None</span></code>, por lo que esta función nunca lanza la excepción <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dict.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.items" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una nueva vista de los elementos del diccionario (pares <code class="docutils literal notranslate"><span class="pre">(key,</span> <span class="pre">value)</span></code>). Véase la <a class="reference internal" href="#dict-views"><span class="std std-ref">documentación de los objetos vistas</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dict.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.keys" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una nueva vista de las claves del diccionario. Véase la <a class="reference internal" href="#dict-views"><span class="std std-ref">documentación de las vistas</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dict.pop">
<span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">default</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.pop" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si <em>key</em> está en el diccionario, lo elimina del diccionario y retorna su valor; si no está, retorna <em>default</em>. Si no se especifica valor para <em>default</em> y la <em>key</em> no se encuentra en el diccionario, se lanza la excepción <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dict.popitem">
<span class="sig-name descname"><span class="pre">popitem</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.popitem" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Elimina y retorna una pareja <code class="docutils literal notranslate"><span class="pre">(key,</span> <span class="pre">value)</span></code> del diccionario. Las parejas se retornan en el orden <abbr title="*last-in, first-out*: Último en entrar, primero en salir">LIFO</abbr>.</p>
<p>El método <a class="reference internal" href="#dict.popitem" title="dict.popitem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">popitem()</span></code></a> es útil para recorrer y a la vez vaciar un diccionario, un proceso usado a menudo en algoritmos de conjuntos. Si el diccionario está vacío, llamar a <a class="reference internal" href="#dict.popitem" title="dict.popitem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">popitem()</span></code></a> lanza la excepción <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>El orden <em>LIFO</em> ahora está garantizado. En versiones anteriores, el método <a class="reference internal" href="#dict.popitem" title="dict.popitem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">popitem()</span></code></a> retorna una pareja clave/valor arbitraria.</p>
</div>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">reversed(d)</span></span></dt>
<dd><p>Retorna un iterador que recorre las claves en orden inverso. Es una forma abreviada de <code class="docutils literal notranslate"><span class="pre">reversed(d.keys())</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dict.setdefault">
<span class="sig-name descname"><span class="pre">setdefault</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">default</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.setdefault" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Si <em>key</em> está incluida en el diccionario, retorna el valor almacenado. Si no, inserta con la clave <em>key</em> el valor definido en <em>default</em> y retorna <em>default</em>. El valor por defecto de <em>default</em> es <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dict.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.update" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Actualiza el diccionario con las parejas clave/valor obtenidas de <em>other</em>, escribiendo encima de las claves existentes. Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>El método <a class="reference internal" href="#dict.update" title="dict.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a> acepta tanto un diccionario como un iterable que retorna parejas de claves/valor (ya sea como tuplas o como otros iterables de longitud 2). Si se especifican parámetros por nombre, el diccionario se actualiza con esas combinaciones de clave/valor: <code class="docutils literal notranslate"><span class="pre">d.update(red=1,</span> <span class="pre">blue=2)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dict.values">
<span class="sig-name descname"><span class="pre">values</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dict.values" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una nueva vista de los valores del diccionario. Véase la <a class="reference internal" href="#dict-views"><span class="std std-ref">documentación sobre objetos vistas</span></a>.</p>
<p>Una comparación de igualdad entre una vista <code class="docutils literal notranslate"><span class="pre">dict.values()</span></code> y otra siempre retornará <code class="docutils literal notranslate"><span class="pre">False</span></code>. Esto también pasa cuando se compara <code class="docutils literal notranslate"><span class="pre">dict.values()</span></code> consigo mismo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="o">==</span> <span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">d</span> <span class="pre">|</span> <span class="pre">other</span></span></dt>
<dd><p>Crea un nuevo diccionario con las claves y valores fusionados de <em>d</em> y <em>other</em>, por lo cual ambos deben ser diccionarios. Los valores de <em>other</em> tienen prioridad cuando <em>d</em> y <em>other</em> tienen claves compartidas.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">d</span> <span class="pre">|=</span> <span class="pre">other</span></span></dt>
<dd><p>Actualiza el diccionario <em>d</em> con las claves y valores de <em>other</em>, el cual podría ser ya sea un a <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a> o un <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> de pares clave/valor. Los valores de <em>other</em> tienen prioridad cuando <em>d</em> y <em>other</em> tienen claves compartidas.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

<p>Los diccionarios se consideran iguales si y solo si tienen el mismo conjunto de parejas <code class="docutils literal notranslate"><span class="pre">(key,</span> <span class="pre">value)</span></code> (independiente de su orden). Los intentos de comparar usando los operadores “&lt;”, “&lt;=”, “&gt;=”, “&gt;” lanzan una excepción de tipo <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<p>Los diccionarios mantienen de forma interna el orden de inserción. Actualizar una clave no modifica ese orden. Las claves que vuelven a ser insertadas después de haber sido borradas se añaden al final.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;one&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;two&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;three&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;four&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">{&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3, &#39;four&#39;: 4}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">[&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="go">[1, 2, 3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;one&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">{&#39;one&#39;: 42, &#39;two&#39;: 2, &#39;three&#39;: 3, &#39;four&#39;: 4}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;two&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;two&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">{&#39;one&#39;: 42, &#39;three&#39;: 3, &#39;four&#39;: 4, &#39;two&#39;: None}</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Se garantiza que el orden del diccionario es el de inserción. Este comportamiento era un detalle de implementación en CPython desde la versión 3.6.</p>
</div>
<p>Tanto los diccionarios como las vistas basadas en diccionarios son reversibles:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;one&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;two&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;three&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;four&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">{&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3, &#39;four&#39;: 4}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
<span class="go">[&#39;four&#39;, &#39;three&#39;, &#39;two&#39;, &#39;one&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
<span class="go">[4, 3, 2, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
<span class="go">[(&#39;four&#39;, 4), (&#39;three&#39;, 3), (&#39;two&#39;, 2), (&#39;one&#39;, 1)]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Los diccionarios son ahora reversibles.</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Se puede usar un objeto de tipo <a class="reference internal" href="types.html#types.MappingProxyType" title="types.MappingProxyType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.MappingProxyType</span></code></a> para crear una vista de solo lectura de un objeto <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>.</p>
</div>
<section id="dictionary-view-objects">
<span id="dict-views"></span><h3>Objetos tipos vista de diccionario<a class="headerlink" href="#dictionary-view-objects" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Los objetos retornados por los métodos <a class="reference internal" href="#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.keys()</span></code></a>, <a class="reference internal" href="#dict.values" title="dict.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.values()</span></code></a> y <a class="reference internal" href="#dict.items" title="dict.items"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.items()</span></code></a> son objetos tipo vista o <em>view</em>. Estos objetos proporcionan una vista dinámica del contenido del diccionario, lo que significa que si el diccionario cambia, las vistas reflejan estos cambios.</p>
<p>Las vistas de un diccionario pueden ser iteradas para retornar sus datos respectivos, y soportan operaciones de comprobación de pertenencia:</p>
<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">len(dictview)</span></span></dt>
<dd><p>Retorna el número de entradas en un diccionario.</p>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">iter(dictview)</span></span></dt>
<dd><p>Retorna un iterador sobre las claves, valores o elementos (representados en forma de tuplas <code class="docutils literal notranslate"><span class="pre">(key,</span> <span class="pre">value)</span></code>) de un diccionario.</p>
<p>Las claves y los valores se iteran en orden de inserción. Esto permite la creación de parejas <code class="docutils literal notranslate"><span class="pre">(value,</span> <span class="pre">key)</span></code> usando la función <a class="reference internal" href="functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a>: <code class="docutils literal notranslate"><span class="pre">pairs</span> <span class="pre">=</span> <span class="pre">zip(d.values(),</span> <span class="pre">d.keys())</span></code>. Otra forma de crear la misma lista es <code class="docutils literal notranslate"><span class="pre">pairs</span> <span class="pre">=</span> <span class="pre">[(v,</span> <span class="pre">k)</span> <span class="pre">for</span> <span class="pre">(k,</span> <span class="pre">v)</span> <span class="pre">in</span> <span class="pre">d.items()]</span></code>.</p>
<p>Iterar sobre un diccionario a la vez que se borran o añaden entradas puede lanzar una excepción de tipo <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>, o puede provocar que no se iteren sobre todas las entradas.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Se garantiza que el orden de los diccionarios es el de inserción.</p>
</div>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">dictview</span></span></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si <em>x</em> está incluido en las claves, los valores o los elementos del diccionario (en el último caso, <em>x</em> debe ser una tupla <code class="docutils literal notranslate"><span class="pre">(key,</span> <span class="pre">value)</span></code>).</p>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">reversed(dictview)</span></span></dt>
<dd><p>Retorna un iterador inverso sobre las claves, los valores o los elementos del diccionario. El orden de la vista será el inverso del orden de inserción.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Las vistas de un diccionario no son reversibles.</p>
</div>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">dictview.mapping</span></span></dt>
<dd><p>Retorna un <a class="reference internal" href="types.html#types.MappingProxyType" title="types.MappingProxyType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.MappingProxyType</span></code></a> que envuelve el diccionario original al que se refiere la vista.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</dd></dl>

<p>Keys views are set-like since their entries are unique and <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>.  If all
values are hashable, so that <code class="docutils literal notranslate"><span class="pre">(key,</span> <span class="pre">value)</span></code> pairs are unique and hashable,
then the items view is also set-like.  (Values views are not treated as set-like
since the entries are generally not unique.)  For set-like views, all of the
operations defined for the abstract base class <a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Set</span></code></a> are
available (for example, <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, or <code class="docutils literal notranslate"><span class="pre">^</span></code>).</p>
<p>Un ejemplo de uso de una vista de diccionario:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dishes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;eggs&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;sausage&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;spam&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">=</span> <span class="n">dishes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">dishes</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># iteration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">n</span> <span class="o">+=</span> <span class="n">val</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">504</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># keys and values are iterated over in the same order (insertion order)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="go">[&#39;eggs&#39;, &#39;sausage&#39;, &#39;bacon&#39;, &#39;spam&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="go">[2, 1, 1, 500]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># view objects are dynamic and reflect dict changes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">dishes</span><span class="p">[</span><span class="s1">&#39;eggs&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">dishes</span><span class="p">[</span><span class="s1">&#39;sausage&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
<span class="go">[&#39;bacon&#39;, &#39;spam&#39;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># set operations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">&amp;</span> <span class="p">{</span><span class="s1">&#39;eggs&#39;</span><span class="p">,</span> <span class="s1">&#39;bacon&#39;</span><span class="p">,</span> <span class="s1">&#39;salad&#39;</span><span class="p">}</span>
<span class="go">{&#39;bacon&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">^</span> <span class="p">{</span><span class="s1">&#39;sausage&#39;</span><span class="p">,</span> <span class="s1">&#39;juice&#39;</span><span class="p">}</span>
<span class="go">{&#39;juice&#39;, &#39;sausage&#39;, &#39;bacon&#39;, &#39;spam&#39;}</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># get back a read-only proxy for the original dictionary</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span><span class="o">.</span><span class="n">mapping</span>
<span class="go">mappingproxy({&#39;bacon&#39;: 1, &#39;spam&#39;: 500})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span><span class="o">.</span><span class="n">mapping</span><span class="p">[</span><span class="s1">&#39;spam&#39;</span><span class="p">]</span>
<span class="go">500</span>
</pre></div>
</div>
</section>
</section>
<section id="context-manager-types">
<span id="typecontextmanager"></span><h2>Tipos gestores de contexto<a class="headerlink" href="#context-manager-types" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-53">La expresión <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> de Python soporta el concepto de un contexto en tiempo de ejecución definido mediante un gestor de contexto. Para implementar esto, se permite al usuario crear clases para definir estos contextos definiendo dos métodos, uno a ejecutar antes de entrar del bloque de código y otro a ejecutar justo después de salir del mismo:</p>
<dl class="py method">
<dt class="sig sig-object py" id="contextmanager.__enter__">
<span class="sig-prename descclassname"><span class="pre">contextmanager.</span></span><span class="sig-name descname"><span class="pre">__enter__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#contextmanager.__enter__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Entra en el contexto en tiempo de ejecución, y retorna o bien este objeto u otro relacionado con el contexto. El valor retornado por este método se vincula al identificador que viene tras la palabra clave <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> usada en la sentencia <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> que define el contexto.</p>
<p>Un ejemplo de gestor de contexto que se retorna a si mismo es un objeto de tipo <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>. Los objetos de tipo <code class="docutils literal notranslate"><span class="pre">File</span></code> se retornan a si mismo en la llamada a <code class="docutils literal notranslate"><span class="pre">__enter__()</span></code>, lo que permite que <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> sea usado como gestores de contexto en una sentencia <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>.</p>
<p>Un ejemplo de gestor de contexto que retorna otro objeto relacionado en el que define la función <a class="reference internal" href="decimal.html#decimal.localcontext" title="decimal.localcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">decimal.localcontext()</span></code></a>. Este gestor define el contexto de uso en operaciones decimales a partir de una copia del contexto original, y retorna esa copia. De esta manera se puede cambiar el contexto decimal dentro del cuerpo del <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> sin afectar al código fuera de <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="contextmanager.__exit__">
<span class="sig-prename descclassname"><span class="pre">contextmanager.</span></span><span class="sig-name descname"><span class="pre">__exit__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exc_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc_val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc_tb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#contextmanager.__exit__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Sale del contexto y retorna un indicador booleano que indica si se debe ignorar cualquier posible excepción que hubiera ocurrido dentro del mismo. Si se produce una excepción mientras se ejecutan las sentencias definidas en el cuerpo de la sentencia <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>, los parámetros de esta función contienen el tipo y valor de la excepción, así como la información relativa a la traza de ejecución. Si no se produce ninguna excepción, los tres parámetros valen <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Si este método retorna un valor <code class="docutils literal notranslate"><span class="pre">True</span></code>, la sentencia <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> ignora la excepción y el flujo del programa continua con la primera sentencia inmediatamente después de la sentencia <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code>. En caso contrario la excepción producida continua propagándose después de que este método termine de ejecutarse. Cualquier excepción que pudieran producirse dentro de este método reemplaza a la excepción que se hubiera producido en el cuerpo del <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code>.</p>
<p>La excepción pasada nunca debe volver a lanzarse explícitamente; en vez de eso, el método debería retornar un valor falso para indicar que el método ha terminado de ejecutarse sin problemas y que no se desea suprimir la excepción. Esto permite a los gestores de contexto detectar fácilmente si el método <a class="reference internal" href="#contextmanager.__exit__" title="contextmanager.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> ha podido terminar o no.</p>
</dd></dl>

<p>Python define varios gestores de contexto para facilitar la sincronía entre hilos, asegurarse del cierre de ficheros y otros objetos similares y para modificar de forma simple el contexto para las expresiones aritméticas con decimales. Los tipos específicos no se tratan especialmente fuera de su implementación del protocolo de administración de contexto. Véase el módulo <a class="reference internal" href="contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code></a> para algunos ejemplos.</p>
<p>Los <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a> de Python y el decorador definidos en la clase <a class="reference internal" href="contextlib.html#contextlib.contextmanager" title="contextlib.contextmanager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.contextmanager</span></code></a> permiten implementar de forma sencilla estos protocolos. Si una función generadora se decora con la clase <a class="reference internal" href="contextlib.html#contextlib.contextmanager" title="contextlib.contextmanager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.contextmanager</span></code></a>, retornará un gestor de contexto que incluye los métodos necesarios <a class="reference internal" href="#contextmanager.__enter__" title="contextmanager.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> y <a class="reference internal" href="#contextmanager.__exit__" title="contextmanager.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a>, en vez del iterador que se produciría si no se decora la función generadora.</p>
<p>Nótese que no hay una ranura específica para ninguno de estos métodos en la estructura usada para los objetos Python en el nivel de la API de Python/C. Objetos que quieran definir estos métodos deben implementarlos como métodos normales de Python. Comparado con la complejidad de definir un contexto en tiempo de ejecución, lo complejidad de una búsqueda simple en un diccionario es mínima.</p>
</section>
<section id="type-annotation-types-generic-alias-union">
<h2>Tipos de anotaciones de type — <a class="reference internal" href="#types-genericalias"><span class="std std-ref">alias genérico</span></a>, <a class="reference internal" href="#types-union"><span class="std std-ref">Union</span></a><a class="headerlink" href="#type-annotation-types-generic-alias-union" title="Enlazar permanentemente con este título">¶</a></h2>
<p id="index-54">Los tipos principales integrados para <a class="reference internal" href="../glossary.html#term-annotation"><span class="xref std std-term">anotaciones de tipo</span></a> son <a class="reference internal" href="#types-genericalias"><span class="std std-ref">alias genérico</span></a> y <a class="reference internal" href="#types-union"><span class="std std-ref">Union</span></a>.</p>
<section id="generic-alias-type">
<span id="types-genericalias"></span><h3>Tipo Alias Genérico<a class="headerlink" href="#generic-alias-type" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-55">Los objetos <code class="docutils literal notranslate"><span class="pre">GenericAlias</span></code> generalmente se crean para <a class="reference internal" href="../reference/expressions.html#subscriptions"><span class="std std-ref">suscribir</span></a> a una clase. Se utilizan con mayor frecuencia con <a class="reference internal" href="../reference/datamodel.html#sequence-types"><span class="std std-ref">clases contenedoras</span></a>, como <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> o <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">list[int]</span></code> es un objeto <code class="docutils literal notranslate"><span class="pre">GenericAlias</span></code> que se creó para suscribir la clase <code class="docutils literal notranslate"><span class="pre">list</span></code> con el argumento <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>. Los objetos <code class="docutils literal notranslate"><span class="pre">GenericAlias</span></code> están pensados principalmente para usar con <a class="reference internal" href="../glossary.html#term-annotation"><span class="xref std std-term">anotaciones de tipo</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Generalmente solo es posible suscribir a una clase si ésta implementa el método especial <a class="reference internal" href="../reference/datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>.</p>
</div>
<p>El objeto <code class="docutils literal notranslate"><span class="pre">GenericAlias</span></code> actúa como <em>proxy</em> para <a class="reference internal" href="../glossary.html#term-generic-type"><span class="xref std std-term">tipo genérico</span></a>, implementando <em>parameterized generics</em>.</p>
<p>Para una clase contenedora, el argumento (o los argumentos) proporcionado(s) a una <a class="reference internal" href="../reference/expressions.html#subscriptions"><span class="std std-ref">suscripción</span></a> de la clase puede indicar el tipo (o tipos) de los elementos que contiene un objeto. Por ejemplo, se puede usar <code class="docutils literal notranslate"><span class="pre">set[bytes]</span></code> en anotaciones de tipo para significar un <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> en el que todos los elementos son del tipo <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
<p>Para una clase que define el método <a class="reference internal" href="../reference/datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> pero no es un contenedor, el argumento (o los argumentos) proporcionado(s) a una suscripción de la clase a menudo indicarán el tipo (o los tipos) de retorno de uno o más métodos definidos en un objeto. Por ejemplo, las <a class="reference internal" href="re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">expresiones</span> <span class="pre">regulares</span></code></a> se pueden usar tanto para el tipo de datos <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> y el tipo de datos <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>:</p>
<ul class="simple">
<li><p>Si <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">re.search('foo',</span> <span class="pre">'foo')</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> será un objeto <a class="reference internal" href="re.html#match-objects"><span class="std std-ref">re.Match</span></a> donde los valores de retorno de <code class="docutils literal notranslate"><span class="pre">x.group(0)</span></code> y <code class="docutils literal notranslate"><span class="pre">x[0]</span></code> serán de tipo <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>. Podemos representar este tipo de objeto en anotaciones de type con el <code class="docutils literal notranslate"><span class="pre">GenericAlias</span></code> de <code class="docutils literal notranslate"><span class="pre">re.Match[str]</span></code>.</p></li>
<li><p>Si <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">re.search(b'bar',</span> <span class="pre">b'bar')</span></code>, (nótese que <code class="docutils literal notranslate"><span class="pre">b</span></code> es para <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>), <code class="docutils literal notranslate"><span class="pre">y</span></code> también será una instancia de <code class="docutils literal notranslate"><span class="pre">re.Match</span></code>, pero los valores de retorno de <code class="docutils literal notranslate"><span class="pre">y.group(0)</span></code> y <code class="docutils literal notranslate"><span class="pre">y[0]</span></code> serán de tipo <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. En anotaciones de type, representaríamos esta variedad de objetos <a class="reference internal" href="re.html#match-objects"><span class="std std-ref">re.Match</span></a> con <code class="docutils literal notranslate"><span class="pre">re.Match[bytes]</span></code>.</p></li>
</ul>
<p>Los objetos <code class="docutils literal notranslate"><span class="pre">GenericAlias</span></code> son instancias de la clase <a class="reference internal" href="types.html#types.GenericAlias" title="types.GenericAlias"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.GenericAlias</span></code></a>, que también se puede usar para crear directamente objetos <code class="docutils literal notranslate"><span class="pre">GenericAlias</span></code>.</p>
<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">T[X,</span> <span class="pre">Y,</span> <span class="pre">...]</span></span></dt>
<dd><p>Crea un <code class="docutils literal notranslate"><span class="pre">GenericAlias</span></code> que representa un tipo <code class="docutils literal notranslate"><span class="pre">T</span></code> parametrizado por tipos <em>X</em>, <em>Y</em> y más dependiendo de la <code class="docutils literal notranslate"><span class="pre">T</span></code> usada. Por ejemplo, una función espera un <a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> que contenga elementos <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">average</span><span class="p">(</span><span class="n">values</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</pre></div>
</div>
<p>Otro ejemplo para el <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a> de objetos, usando un <a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>, el cual es un tipo genérico que espera dos parámetros de tipo que representan el tipo de la clave y el tipo del valor. En este ejemplo, la función espera un <code class="docutils literal notranslate"><span class="pre">dict</span></code> con claves de tipo <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> y valores de tipo <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">send_post_request</span><span class="p">(</span><span class="n">url</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">body</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<p>Las funciones integradas <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> y <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> no aceptan tipos <code class="docutils literal notranslate"><span class="pre">GenericAlias</span></code> como segundo argumento:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">isinstance() argument 2 cannot be a parameterized generic</span>
</pre></div>
</div>
<p>Python en tiempo de ejecución no hace cumplir las <a class="reference internal" href="../glossary.html#term-annotation"><span class="xref std std-term">anotaciones de tipo</span></a>. Esto se extiende para tipos genéricos y sus parámetros. Cuando se crea un objeto contenedor desde un <code class="docutils literal notranslate"><span class="pre">GenericAlias</span></code>, los elementos del contenedor no se verifican con su tipo. Por ejemplo, el siguiente código no es recomendado en lo absoluto, pero correrá sin errores:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">[1, 2, 3]</span>
</pre></div>
</div>
<p>Además, los genéricos parametrizados borran parámetros de type durante la creación de objetos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">&lt;class &#39;types.GenericAlias&#39;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="n">t</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="go">&lt;class &#39;list&#39;&gt;</span>
</pre></div>
</div>
<p>Llamando a <a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> o <a class="reference internal" href="#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> en un genérico se muestra el tipo parametrizado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">repr</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span>
<span class="go">&#39;list[int]&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span>
<span class="go">&#39;list[int]&#39;</span>
</pre></div>
</div>
<p>El método <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> de contenedores genéricos lanzarán una excepción para rechazar los errores como <code class="docutils literal notranslate"><span class="pre">dict[str][str]</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">][</span><span class="nb">str</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">There are no type variables left in dict[str]</span>
</pre></div>
</div>
<p>Sin embargo, estas expresiones son válidas cuando se usan <a class="reference internal" href="typing.html#generics"><span class="std std-ref">variables de type</span></a>. El índice debe tener tantos elementos como los elementos de variable de type en los <a class="reference internal" href="#genericalias.__args__" title="genericalias.__args__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__args__</span></code></a> del objeto <code class="docutils literal notranslate"><span class="pre">GenericAlias</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Y</span><span class="p">][</span><span class="nb">int</span><span class="p">]</span>
<span class="go">dict[str, int]</span>
</pre></div>
</div>
<section id="standard-generic-classes">
<h4>Clases genéricas estándar<a class="headerlink" href="#standard-generic-classes" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Las siguientes clases de la biblioteca estándar soportan genéricos parametrizados. Esta lista no es exhaustiva.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a></p></li>
<li><p><a class="reference internal" href="#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a></p></li>
<li><p><a class="reference internal" href="#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a></p></li>
<li><p><a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a></p></li>
<li><p><a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a></p></li>
<li><p><a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.deque</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.html#collections.ChainMap" title="collections.ChainMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.ChainMap</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.Awaitable" title="collections.abc.Awaitable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Awaitable</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Coroutine</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterable</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterator</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.AsyncGenerator" title="collections.abc.AsyncGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncGenerator</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterable</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterator</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.Generator" title="collections.abc.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Generator</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.Reversible" title="collections.abc.Reversible"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Reversible</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Container</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Collection</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Set</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSet</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSequence</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.ByteString" title="collections.abc.ByteString"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ByteString</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MappingView</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.KeysView" title="collections.abc.KeysView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.KeysView</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.ItemsView" title="collections.abc.ItemsView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ItemsView</span></code></a></p></li>
<li><p><a class="reference internal" href="collections.abc.html#collections.abc.ValuesView" title="collections.abc.ValuesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ValuesView</span></code></a></p></li>
<li><p><a class="reference internal" href="contextlib.html#contextlib.AbstractContextManager" title="contextlib.AbstractContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractContextManager</span></code></a></p></li>
<li><p><a class="reference internal" href="contextlib.html#contextlib.AbstractAsyncContextManager" title="contextlib.AbstractAsyncContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractAsyncContextManager</span></code></a></p></li>
<li><p><a class="reference internal" href="dataclasses.html#dataclasses.Field" title="dataclasses.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">dataclasses.Field</span></code></a></p></li>
<li><p><a class="reference internal" href="functools.html#functools.cached_property" title="functools.cached_property"><code class="xref py py-class docutils literal notranslate"><span class="pre">functools.cached_property</span></code></a></p></li>
<li><p><a class="reference internal" href="functools.html#functools.partialmethod" title="functools.partialmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">functools.partialmethod</span></code></a></p></li>
<li><p><a class="reference internal" href="os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a></p></li>
<li><p><a class="reference internal" href="queue.html#queue.LifoQueue" title="queue.LifoQueue"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.LifoQueue</span></code></a></p></li>
<li><p><a class="reference internal" href="queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.Queue</span></code></a></p></li>
<li><p><a class="reference internal" href="queue.html#queue.PriorityQueue" title="queue.PriorityQueue"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.PriorityQueue</span></code></a></p></li>
<li><p><a class="reference internal" href="queue.html#queue.SimpleQueue" title="queue.SimpleQueue"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.SimpleQueue</span></code></a></p></li>
<li><p><a class="reference internal" href="re.html#re-objects"><span class="std std-ref">re.Pattern</span></a></p></li>
<li><p><a class="reference internal" href="re.html#match-objects"><span class="std std-ref">re.Match</span></a></p></li>
<li><p><a class="reference internal" href="shelve.html#shelve.BsdDbShelf" title="shelve.BsdDbShelf"><code class="xref py py-class docutils literal notranslate"><span class="pre">shelve.BsdDbShelf</span></code></a></p></li>
<li><p><a class="reference internal" href="shelve.html#shelve.DbfilenameShelf" title="shelve.DbfilenameShelf"><code class="xref py py-class docutils literal notranslate"><span class="pre">shelve.DbfilenameShelf</span></code></a></p></li>
<li><p><a class="reference internal" href="shelve.html#shelve.Shelf" title="shelve.Shelf"><code class="xref py py-class docutils literal notranslate"><span class="pre">shelve.Shelf</span></code></a></p></li>
<li><p><a class="reference internal" href="types.html#types.MappingProxyType" title="types.MappingProxyType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.MappingProxyType</span></code></a></p></li>
<li><p><a class="reference internal" href="weakref.html#weakref.WeakKeyDictionary" title="weakref.WeakKeyDictionary"><code class="xref py py-class docutils literal notranslate"><span class="pre">weakref.WeakKeyDictionary</span></code></a></p></li>
<li><p><a class="reference internal" href="weakref.html#weakref.WeakMethod" title="weakref.WeakMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">weakref.WeakMethod</span></code></a></p></li>
<li><p><a class="reference internal" href="weakref.html#weakref.WeakSet" title="weakref.WeakSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">weakref.WeakSet</span></code></a></p></li>
<li><p><a class="reference internal" href="weakref.html#weakref.WeakValueDictionary" title="weakref.WeakValueDictionary"><code class="xref py py-class docutils literal notranslate"><span class="pre">weakref.WeakValueDictionary</span></code></a></p></li>
</ul>
</section>
<section id="special-attributes-of-genericalias-objects">
<h4>Atributos especiales de los objetos <code class="docutils literal notranslate"><span class="pre">GenericAlias</span></code><a class="headerlink" href="#special-attributes-of-genericalias-objects" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Todos los genéricos parametrizados implementan atributos especiales de solo lectura.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="genericalias.__origin__">
<span class="sig-prename descclassname"><span class="pre">genericalias.</span></span><span class="sig-name descname"><span class="pre">__origin__</span></span><a class="headerlink" href="#genericalias.__origin__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este atributo apunta a la clase genérica no parametrizada:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">.</span><span class="n">__origin__</span>
<span class="go">&lt;class &#39;list&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="genericalias.__args__">
<span class="sig-prename descclassname"><span class="pre">genericalias.</span></span><span class="sig-name descname"><span class="pre">__args__</span></span><a class="headerlink" href="#genericalias.__args__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este atributo es una clase <a class="reference internal" href="#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> (posiblemente de longitud 1) de tipos genéricos pasados al método original <a class="reference internal" href="../reference/datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> de la clase genérica:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span><span class="o">.</span><span class="n">__args__</span>
<span class="go">(&lt;class &#39;str&#39;&gt;, list[int])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="genericalias.__parameters__">
<span class="sig-prename descclassname"><span class="pre">genericalias.</span></span><span class="sig-name descname"><span class="pre">__parameters__</span></span><a class="headerlink" href="#genericalias.__parameters__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este atributo es una tupla (posiblemente vacía) computada perezosamente con las variables de tipo únicas encontradas en <code class="docutils literal notranslate"><span class="pre">__args__</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="o">.</span><span class="n">__parameters__</span>
<span class="go">(~T,)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Un objeto <code class="docutils literal notranslate"><span class="pre">GenericAlias</span></code> con <a class="reference internal" href="typing.html#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.ParamSpec</span></code></a> parámetros puede no tener los <code class="docutils literal notranslate"><span class="pre">__parameters__</span></code> correctos después de la sustitución porque <a class="reference internal" href="typing.html#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.ParamSpec</span></code></a> está destinado principalmente a la verificación de tipos estáticos.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="genericalias.__unpacked__">
<span class="sig-prename descclassname"><span class="pre">genericalias.</span></span><span class="sig-name descname"><span class="pre">__unpacked__</span></span><a class="headerlink" href="#genericalias.__unpacked__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un booleano que es verdadero si el alias ha sido desempaquetado usando el operador <code class="docutils literal notranslate"><span class="pre">*</span></code> (véase <a class="reference internal" href="typing.html#typing.TypeVarTuple" title="typing.TypeVarTuple"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeVarTuple</span></code></a>).</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.11.</span></p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt><span class="target" id="index-56"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> - Type Hints</dt><dd><p>Presentación del marco de trabajo de Python para anotaciones de tipo.</p>
</dd>
<dt><span class="target" id="index-80"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> - Sugerencias de tipo genéricas en colecciones estándar</dt><dd><p>Introducción a la capacidad de parametrizar de forma nativa clases de la biblioteca estándar, siempre que implementen el método de clase especial <a class="reference internal" href="../reference/datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>.</p>
</dd>
<dt><a class="reference internal" href="typing.html#generics"><span class="std std-ref">Genéricos</span></a>, <a class="reference internal" href="typing.html#user-defined-generics"><span class="std std-ref">tipos genéricos definidos por el usuario</span></a> y <a class="reference internal" href="typing.html#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span></code></a></dt><dd><p>Documentación sobre cómo implementar clases genéricas que se pueden parametrizar en tiempo de ejecución y que los validadores estático de tipos pueden entender.</p>
</dd>
</dl>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</section>
</section>
<section id="union-type">
<span id="types-union"></span><h3>Tipo de conversión<a class="headerlink" href="#union-type" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-58">Un objeto de conversión contiene el valor de la operación <code class="docutils literal notranslate"><span class="pre">|</span></code> (bit a bit o) en varios <a class="reference internal" href="#bltin-type-objects"><span class="std std-ref">objetos de tipo</span></a>. Estos tipos están destinados principalmente a <a class="reference internal" href="../glossary.html#term-annotation"><span class="xref std std-term">anotaciones de tipo</span></a>. La expresión de tipo de conversión permite una sintaxis de sugerencia de tipo más limpia en comparación con <a class="reference internal" href="typing.html#typing.Union" title="typing.Union"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.Union</span></code></a>.</p>
<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">Y</span> <span class="pre">|</span> <span class="pre">...</span></span></dt>
<dd><p>Define un objeto de conversión que contiene tipos <em>X</em>, <em>Y</em>, etc. <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">Y</span></code> significa X o Y. Es equivalente a <code class="docutils literal notranslate"><span class="pre">typing.Union[X,</span> <span class="pre">Y]</span></code>. Por ejemplo, la siguiente función espera un argumento de tipo <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> or <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">number</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">number</span> <span class="o">**</span> <span class="mi">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">union_object</span> <span class="pre">==</span> <span class="pre">other</span></span></dt>
<dd><p>Los objetos de conversión se pueden probar para determinar su igualdad con otros objetos de conversión. Detalles:</p>
<ul>
<li><p>Las conversiones de conversión se aplanan:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">==</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">float</span>
</pre></div>
</div>
</li>
<li><p>Se eliminan los tipos redundantes:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">==</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span>
</pre></div>
</div>
</li>
<li><p>Al comparar conversiones, se ignora el orden:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">==</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span>
</pre></div>
</div>
</li>
<li><p>Es compatible con <a class="reference internal" href="typing.html#typing.Union" title="typing.Union"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.Union</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">==</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>Los tipos opcionales se pueden escribir como una unión con <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">==</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
</pre></div>
</div>
</li>
</ul>
</dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">isinstance(obj,</span> <span class="pre">union_object)</span></span></dt>
<dd></dd></dl>

<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">issubclass(obj,</span> <span class="pre">union_object)</span></span></dt>
<dd><p>Las llamadas a <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> y <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> también son compatibles con un objeto de conversión:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Sin embargo, los objetos de unión que contienen <a class="reference internal" href="#types-genericalias"><span class="std std-ref">genéricos parametrizados</span></a> no se pueden utilizar:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">isinstance() argument 2 cannot contain a parameterized generic</span>
</pre></div>
</div>
</dd></dl>

<p>El tipo expuesto por el usuario para el objeto de conversión puede ser accedido desde <a class="reference internal" href="types.html#types.UnionType" title="types.UnionType"><code class="xref py py-data docutils literal notranslate"><span class="pre">types.UnionType</span></code></a> y usado por chequeos <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a>. Un objeto no puede ser instancia por el tipo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">types</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">cannot create &#39;types.UnionType&#39; instances</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Se agregó el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__or__()</span></code> para objetos de tipo para admitir la sintaxis <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">Y</span></code>. Si una metaclase implementa <code class="xref py py-meth docutils literal notranslate"><span class="pre">__or__()</span></code>, la Conversión puede anularlo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">M</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="s2">&quot;Hello&quot;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">M</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">|</span> <span class="nb">int</span>
<span class="go">&#39;Hello&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span> <span class="o">|</span> <span class="n">C</span>
<span class="go">int | __main__.C</span>
</pre></div>
</div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p><span class="target" id="index-81"></span><a class="pep reference external" href="https://peps.python.org/pep-0604/"><strong>PEP 604</strong></a> — PEP propone la sintaxis <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">Y</span></code> y tipo Conversión.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.10.</span></p>
</div>
</section>
</section>
<section id="other-built-in-types">
<span id="typesother"></span><h2>Otros tipos predefinidos<a class="headerlink" href="#other-built-in-types" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El intérprete soporta otros tipos de objetos variados. La mayoría de ellos solo implementan una o dos operaciones.</p>
<section id="modules">
<span id="typesmodules"></span><h3>Módulos<a class="headerlink" href="#modules" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La única operación especial que implementan los módulos es el acceso como atributos: <code class="docutils literal notranslate"><span class="pre">m.name</span></code>, donde <em>m</em> es un módulo y <em>name</em> accede a un nombre definido en la tabla de símbolos del módulo <em>m</em>. También se puede asignar valores a los atributos de un módulo (nótese que la sentencia <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> no es, estrictamente hablando, una operación del objeto de tipo módulo; la sentencia <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">foo</span></code> no requiere la existencia de un módulo llamado <em>foo</em>, sino una <em>definición</em> (externa) de un módulo <em>foo</em> en alguna parte).</p>
<p>Un atributo especial de cada módulo es <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>. Es un diccionario que contiene la tabla de símbolos del módulo. Cambiar el diccionario cambiará por tanto el contenido de la tabla de símbolos, pero no es posible realizar una asignación directa al atributo <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> (se puede realizar una asignación como <code class="docutils literal notranslate"><span class="pre">m.__dict__['a']</span> <span class="pre">=</span> <span class="pre">1</span></code>, que define el valor de <code class="docutils literal notranslate"><span class="pre">m.a</span></code> como <code class="docutils literal notranslate"><span class="pre">1</span></code>, pero no se puede hacer <code class="docutils literal notranslate"><span class="pre">m.__dict__</span> <span class="pre">=</span> <span class="pre">{}</span></code>). No se recomienda manipular los contenidos del atributo <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> directamente.</p>
<p>Los módulos incluidos en el intérprete se escriben así: <code class="docutils literal notranslate"><span class="pre">&lt;module</span> <span class="pre">'sys'</span> <span class="pre">(built-in)&gt;</span></code>. Si se cargan desde un archivo, se escriben como <code class="docutils literal notranslate"><span class="pre">&lt;module</span> <span class="pre">'os'</span> <span class="pre">from</span> <span class="pre">'/usr/local/lib/pythonX.Y/os.pyc'&gt;</span></code>.</p>
</section>
<section id="classes-and-class-instances">
<span id="typesobjects"></span><h3>Clases e instancias de clase<a class="headerlink" href="#classes-and-class-instances" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Véase <a class="reference internal" href="../reference/datamodel.html#objects"><span class="std std-ref">Objetos, valores y tipos</span></a> y <a class="reference internal" href="../reference/compound_stmts.html#class"><span class="std std-ref">Definiciones de clase</span></a> para más información.</p>
</section>
<section id="functions">
<span id="typesfunctions"></span><h3>Funciones<a class="headerlink" href="#functions" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Los objetos de tipo función se crean mediante definiciones de función. La única operación posible con un objeto de tipo función es llamarla: <code class="docutils literal notranslate"><span class="pre">func(argument-list)</span></code>.</p>
<p>Hay dos tipos de funciones: Las funciones básicas o predefinidas y las funciones definidas por el usuario. Las dos soportan la misma operación (ser llamadas), pero la implementación es diferente, de ahí que se consideren de distintos tipo.</p>
<p>Véase <a class="reference internal" href="../reference/compound_stmts.html#function"><span class="std std-ref">Definiciones de funciones</span></a> para más información.</p>
</section>
<section id="methods">
<span id="typesmethods"></span><h3>Métodos<a class="headerlink" href="#methods" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-60">Los métodos son funciones que se llaman usando la notación de atributos. Hay de dos tipos: métodos básicos o predefinidos (como el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code> en las listas) y métodos de instancia de clase. Los métodos básicos o predefinidos se describen junto con los tipos que los soportan.</p>
<p>Si se accede a un método (una función definida dentro de un espacio de nombres de una clase) a través de una instancia, se obtiene un objeto especial, un <em class="dfn">bound method</em> (también llamado <em class="dfn">instance method</em>). Cuando se llama, se añade automáticamente el parámetro <code class="docutils literal notranslate"><span class="pre">self</span></code> a la lista de parámetros. Los métodos ligados tienen dos atributos especiales de solo lectura: <code class="docutils literal notranslate"><span class="pre">m.__self__</span></code> es el objeto sobre el que está operando el método, y <code class="docutils literal notranslate"><span class="pre">m.__func__</span></code> es la función que implementa el método. Llamar <code class="docutils literal notranslate"><span class="pre">m(arg-1,</span> <span class="pre">arg-2,</span> <span class="pre">...,</span> <span class="pre">arg-n)</span></code> es completamente equivalente a llamar <code class="docutils literal notranslate"><span class="pre">m.__func__(m.__self__,</span> <span class="pre">arg-1,</span> <span class="pre">arg-2,</span> <span class="pre">...,</span> <span class="pre">arg-n)</span></code>.</p>
<p>Al igual que los objetos de tipo función, los métodos ligados o de instancia soportan asignación de atributos arbitrarios. Sin embargo, como los atributos de los métodos se almacenan en la función subyacente (<code class="docutils literal notranslate"><span class="pre">meth.__func__</span></code>), definir cualquier atributo en métodos ligados está desaconsejado. Intentar asignar un atributo a un método produce que se lance una excepción de tipo <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Para poder definir un atributo a un método, este debe ser definido explícitamente en la función subyacente:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">whoami</span> <span class="o">=</span> <span class="s1">&#39;my name is method&#39;</span>  <span class="c1"># can&#39;t set on the method</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;method&#39; object has no attribute &#39;whoami&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="vm">__func__</span><span class="o">.</span><span class="n">whoami</span> <span class="o">=</span> <span class="s1">&#39;my name is method&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">whoami</span>
<span class="go">&#39;my name is method&#39;</span>
</pre></div>
</div>
<p>Véase <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">Jerarquía de tipos estándar</span></a> para más información.</p>
</section>
<section id="code-objects">
<span id="bltin-code-objects"></span><span id="index-61"></span><h3>Objetos código<a class="headerlink" href="#code-objects" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-62">Los objetos de tipo código son usados por la implementación del lenguaje para representar código ejecutable «pseudo-compilado», como por ejemplo el cuerpo de una función. A diferencia de los objetos de tipo función, no contienen una referencia a un entorno global de ejecución. Los objetos de tipo código se pueden obtener usando la función básica <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> o se pueden extraer a partir de objetos de tipo función a través de su atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__code__</span></code>. Para más detalle véase el módulo <a class="reference internal" href="code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code class="xref py py-mod docutils literal notranslate"><span class="pre">code</span></code></a>.</p>
<p>Al acceder a <code class="docutils literal notranslate"><span class="pre">__code__</span></code> se lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">evento de auditoría</span></a> <code class="docutils literal notranslate"><span class="pre">object.__getattr__</span></code> con argumentos <code class="docutils literal notranslate"><span class="pre">obj</span></code> y <code class="docutils literal notranslate"><span class="pre">&quot;__code__&quot;</span></code>.</p>
<p id="index-63">Un objeto de tipo código puede ser evaluado o ejecutando pasándolo como parámetros a las funciones incorporadas <a class="reference internal" href="functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> o <a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> (que también aceptan código Python en forma de cadena de caracteres).</p>
<p>Véase <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">Jerarquía de tipos estándar</span></a> para más información.</p>
</section>
<section id="type-objects">
<span id="bltin-type-objects"></span><h3>Objetos Tipo<a class="headerlink" href="#type-objects" title="Enlazar permanentemente con este título">¶</a></h3>
<p id="index-64">Los objetos de tipo Tipo (<em>Type</em>) representan a los distintos tipos de datos. El tipo de un objeto particular puede ser consultado usando la función incorporada <a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a>. Los objetos Tipo no tienen ninguna operación especial. El módulo <a class="reference internal" href="types.html#module-types" title="types: Names for built-in types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">types</span></code></a> define nombres para todos los tipos básicos definidos en la biblioteca estándar.</p>
<p>Los tipos se escriben de la siguiente forma: <code class="docutils literal notranslate"><span class="pre">&lt;class</span> <span class="pre">'int'&gt;</span></code>.</p>
</section>
<section id="the-null-object">
<span id="bltin-null-object"></span><h3>El objeto nulo (<em>Null</em>)<a class="headerlink" href="#the-null-object" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Todas las funciones que no definen de forma explícita un valor de retorno retornan este objeto. Los objetos nulos no soportan ninguna operación especial. Solo existe un único objeto nulo, llamado <code class="docutils literal notranslate"><span class="pre">None</span></code> (un nombre predefinido o básico). La expresión <code class="docutils literal notranslate"><span class="pre">type(None)()</span></code> produce el mismo objeto <code class="docutils literal notranslate"><span class="pre">None</span></code>, esto se conoce como <em>Singleton</em>.</p>
<p>Se escribe <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</section>
<section id="the-ellipsis-object">
<span id="bltin-ellipsis-object"></span><span id="index-65"></span><h3>El objeto puntos suspensivos (<em>Ellipsis</em>)<a class="headerlink" href="#the-ellipsis-object" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Este objeto es usado a menudo en operaciones de segmentado (véase <a class="reference internal" href="../reference/expressions.html#slicings"><span class="std std-ref">Segmentos</span></a>). No soporta ninguna operación especial. Solo existe un único objeto de puntos suspensivos, llamado <a class="reference internal" href="constants.html#Ellipsis" title="Ellipsis"><code class="xref py py-const docutils literal notranslate"><span class="pre">Ellipsis</span></code></a> (un nombre predefinido o básico). La expresión <code class="docutils literal notranslate"><span class="pre">type(Ellipsis)()</span></code> produce el mismo objeto <a class="reference internal" href="constants.html#Ellipsis" title="Ellipsis"><code class="xref py py-const docutils literal notranslate"><span class="pre">Ellipsis</span></code></a>, esto se conoce como <em>Singleton</em>.</p>
<p>Se puede escribir como <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code> o <code class="docutils literal notranslate"><span class="pre">...</span></code>.</p>
</section>
<section id="the-notimplemented-object">
<span id="bltin-notimplemented-object"></span><h3>El objeto <em>NotImplemented</em><a class="headerlink" href="#the-notimplemented-object" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Este objeto se retorna en todas las operaciones binarias y comparaciones cuando se intenta operar con tipos que no están soportados. Véase <a class="reference internal" href="../reference/expressions.html#comparisons"><span class="std std-ref">Comparaciones</span></a> para más información. Solo existe un objeto de tipo <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code>. La expresión <code class="docutils literal notranslate"><span class="pre">type(NotImplemented)()</span></code> produce el mismo objeto, esto se conoce como <em>Singleton</em>.</p>
<p>Se escribe <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code>.</p>
</section>
<section id="boolean-values">
<span id="bltin-boolean-values"></span><h3>Valores booleanos<a class="headerlink" href="#boolean-values" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Los valores booleanos o lógicos son los dos objetos constantes <code class="docutils literal notranslate"><span class="pre">False</span></code> y <code class="docutils literal notranslate"><span class="pre">True</span></code>. Se usan para representar valores de verdad (aunque otros valores pueden ser considerados también como verdaderos o falsos). En contextos numéricos (por ejemplo, cuando se usan como argumentos de una operación aritmética) se comportan como los números enteros 0 y 1, respectivamente. Se puede usar la función incorporada <a class="reference internal" href="functions.html#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a> para convertir valores de cualquiera tipo a Booleanos, si dicho valor puede ser interpretado como valores verdaderos/falsos (véase la sección <a class="reference internal" href="#truth"><span class="std std-ref">Evaluar como valor verdadero/falso</span></a> anterior).</p>
<p id="index-66">Se escriben <code class="docutils literal notranslate"><span class="pre">False</span></code> y <code class="docutils literal notranslate"><span class="pre">True</span></code>, respectivamente.</p>
</section>
<section id="internal-objects">
<span id="typesinternal"></span><h3>Objetos internos<a class="headerlink" href="#internal-objects" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Véase la sección <a class="reference internal" href="../reference/datamodel.html#types"><span class="std std-ref">Jerarquía de tipos estándar</span></a> para saber más de estos objetos. Se describen los objetos marco de pila, los objetos de traza de ejecución (<em>traceback</em>) y los objetos de tipo segmento (<em>slice</em>).</p>
</section>
</section>
<section id="special-attributes">
<span id="specialattrs"></span><h2>Atributos especiales<a class="headerlink" href="#special-attributes" title="Enlazar permanentemente con este título">¶</a></h2>
<p>La implementación añade unos cuantos atributos de solo lectura a varios tipos de objetos, cuando resulta relevante. Algunos de estos atributos son reportados por la función incorporada <a class="reference internal" href="functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="object.__dict__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__dict__</span></span><a class="headerlink" href="#object.__dict__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un diccionario u otro tipo de mapa usado para almacenar los atributos de un objeto (si son modificables).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="instance.__class__">
<span class="sig-prename descclassname"><span class="pre">instance.</span></span><span class="sig-name descname"><span class="pre">__class__</span></span><a class="headerlink" href="#instance.__class__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La clase a la que pertenece una instancia.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="class.__bases__">
<span class="sig-prename descclassname"><span class="pre">class.</span></span><span class="sig-name descname"><span class="pre">__bases__</span></span><a class="headerlink" href="#class.__bases__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La tupla de clases base de las que deriva una clase.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="definition.__name__">
<span class="sig-prename descclassname"><span class="pre">definition.</span></span><span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#definition.__name__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El nombre de la clase, función, método, descriptor o instancia generadora.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="definition.__qualname__">
<span class="sig-prename descclassname"><span class="pre">definition.</span></span><span class="sig-name descname"><span class="pre">__qualname__</span></span><a class="headerlink" href="#definition.__qualname__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El nombre calificado (<a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">qualified name</span></a>) de la clase, función, método, descriptor o instancia generadora.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="class.__mro__">
<span class="sig-prename descclassname"><span class="pre">class.</span></span><span class="sig-name descname"><span class="pre">__mro__</span></span><a class="headerlink" href="#class.__mro__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este atributo es una tupla de las clases que serán consideradas cuando se busque en las clases base para resolver un método.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="class.mro">
<span class="sig-prename descclassname"><span class="pre">class.</span></span><span class="sig-name descname"><span class="pre">mro</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#class.mro" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método puede ser reescrito por una metaclase para personalizar el orden de resolución de métodos para sus instancias. Es llamado en la creación de la clase, y el resultado se almacena en el atributo <a class="reference internal" href="#class.__mro__" title="class.__mro__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__mro__</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="class.__subclasses__">
<span class="sig-prename descclassname"><span class="pre">class.</span></span><span class="sig-name descname"><span class="pre">__subclasses__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#class.__subclasses__" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Cada clase mantiene una lista de referencias débiles a sus subclases inmediatamente anteriores. Este método retorna una lista de todas las referencias que todavía estén vivas. La lista está en orden de definición. Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">()</span>
<span class="go">[&lt;class &#39;bool&#39;&gt;]</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="integer-string-conversion-length-limitation">
<span id="int-max-str-digits"></span><h2>Limitación de longitud de conversión de cadena de tipo entero<a class="headerlink" href="#integer-string-conversion-length-limitation" title="Enlazar permanentemente con este título">¶</a></h2>
<p>CPython tiene un límite global para conversiones entre <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> y <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> para mitigar los ataques de denegación de servicio. Este límite <em>solo</em> se aplica a decimales u otras bases numéricas que no sean potencias de dos. Las conversiones hexadecimales, octales y binarias son ilimitadas. Se puede configurar el límite.</p>
<p>The <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> type in CPython is an arbitrary length number stored in binary
form (commonly known as a «bignum»). There exists no algorithm that can convert
a string to a binary integer or a binary integer to a string in linear time,
<em>unless</em> the base is a power of 2. Even the best known algorithms for base 10
have sub-quadratic complexity. Converting a large value such as <code class="docutils literal notranslate"><span class="pre">int('1'</span> <span class="pre">*</span>
<span class="pre">500_000)</span></code> can take over a second on a fast CPU.</p>
<p>Limitar el tamaño de la conversión ofrece una forma práctica para evitar <a class="reference external" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-10735">CVE-2020-10735</a>.</p>
<p>El límite se aplica al número de caracteres de dígitos en la cadena de entrada o salida cuando estaría involucrado un algoritmo de conversión no lineal. Los guiones bajos y el signo no se cuentan para el límite.</p>
<p>Cuando una operación excede el límite, se lanza una excepción <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">set_int_max_str_digits</span><span class="p">(</span><span class="mi">4300</span><span class="p">)</span>  <span class="c1"># Illustrative, this is the default.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="s1">&#39;2&#39;</span> <span class="o">*</span> <span class="mi">5432</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Exceeds the limit (4300 digits) for integer string conversion: value has 5432 digits; use sys.set_int_max_str_digits() to increase the limit.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="s1">&#39;2&#39;</span> <span class="o">*</span> <span class="mi">4300</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="go">4300</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i_squared</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i_squared</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Exceeds the limit (4300 digits) for integer string conversion: value has 8599 digits; use sys.set_int_max_str_digits() to increase the limit.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">i_squared</span><span class="p">))</span>
<span class="go">7144</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">int</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">i_squared</span><span class="p">),</span> <span class="n">base</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span> <span class="o">==</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span>  <span class="c1"># Hexadecimal is unlimited.</span>
</pre></div>
</div>
<p>El límite predeterminado es de 4300 dígitos como se indica en <a class="reference internal" href="sys.html#sys.int_info" title="sys.int_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.int_info.default_max_str_digits</span></code></a>. El límite más bajo que se puede configurar es de 640 dígitos como se indica en <a class="reference internal" href="sys.html#sys.int_info" title="sys.int_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.int_info.str_digits_check_threshold</span></code></a>.</p>
<p>Verificación:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">sys</span><span class="o">.</span><span class="n">int_info</span><span class="o">.</span><span class="n">default_max_str_digits</span> <span class="o">==</span> <span class="mi">4300</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">int_info</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">sys</span><span class="o">.</span><span class="n">int_info</span><span class="o">.</span><span class="n">str_digits_check_threshold</span> <span class="o">==</span> <span class="mi">640</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">int_info</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="s1">&#39;578966293710682886880994035146873798396722250538762761564&#39;</span>
<span class="gp">... </span>          <span class="s1">&#39;9252925514383915483333812743580549779436104706260696366600&#39;</span>
<span class="gp">... </span>          <span class="s1">&#39;571186405732&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="mi">53</span><span class="p">,</span> <span class="s1">&#39;big&#39;</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.11.</span></p>
</div>
<section id="affected-apis">
<h3>APIs afectadas<a class="headerlink" href="#affected-apis" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La limitación solo se aplica a conversiones potencialmente lentas entre <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> y <a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> o <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">int(string)</span></code> con base predeterminada a 10.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int(string,</span> <span class="pre">base)</span></code> para todas las bases que no sean una potencia de 2.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">str(integer)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">repr(integer)</span></code>.</p></li>
<li><p>cualquier otra conversión de cadena a base 10, por ejemplo, <code class="docutils literal notranslate"><span class="pre">f&quot;{integer}&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;{}&quot;.format(integer)</span></code> o <code class="docutils literal notranslate"><span class="pre">b&quot;%d&quot;</span> <span class="pre">%</span> <span class="pre">integer</span></code>.</p></li>
</ul>
<p>Las limitaciones no se aplican a funciones con un algoritmo lineal:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">int(string,</span> <span class="pre">base)</span></code> con base 2, 4, 8, 16 o 32.</p></li>
<li><p><a class="reference internal" href="#int.from_bytes" title="int.from_bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">int.from_bytes()</span></code></a> y <a class="reference internal" href="#int.to_bytes" title="int.to_bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">int.to_bytes()</span></code></a>.</p></li>
<li><p><a class="reference internal" href="functions.html#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a>, <a class="reference internal" href="functions.html#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a>, <a class="reference internal" href="functions.html#bin" title="bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin()</span></code></a>.</p></li>
<li><p><a class="reference internal" href="string.html#formatspec"><span class="std std-ref">Especificación de formato Mini-Lenguaje</span></a> para números hexadecimales, octales y binarios.</p></li>
<li><p><a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> a <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>.</p></li>
<li><p><a class="reference internal" href="#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> a <a class="reference internal" href="decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">decimal.Decimal</span></code></a>.</p></li>
</ul>
</section>
<section id="configuring-the-limit">
<h3>Configuración del límite<a class="headerlink" href="#configuring-the-limit" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Antes de que se inicie Python, puedes usar una variable de entorno o un indicador de línea de comandos del intérprete para configurar el límite:</p>
<ul class="simple">
<li><p><span class="target" id="index-82"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONINTMAXSTRDIGITS"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONINTMAXSTRDIGITS</span></code></a>, por ejemplo, <code class="docutils literal notranslate"><span class="pre">PYTHONINTMAXSTRDIGITS=640</span> <span class="pre">python3</span></code> para configurar el límite a 640 o <code class="docutils literal notranslate"><span class="pre">PYTHONINTMAXSTRDIGITS=0</span> <span class="pre">python3</span></code> para desactivar la limitación.</p></li>
<li><p><a class="reference internal" href="../using/cmdline.html#cmdoption-X"><code class="xref std std-option docutils literal notranslate"><span class="pre">-X</span> <span class="pre">int_max_str_digits</span></code></a>, por ejemplo, <code class="docutils literal notranslate"><span class="pre">python3</span> <span class="pre">-X</span> <span class="pre">int_max_str_digits=640</span></code></p></li>
<li><p><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.flags.int_max_str_digits</span></code> contains the value of
<span class="target" id="index-68"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONINTMAXSTRDIGITS"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONINTMAXSTRDIGITS</span></code></a> or <a class="reference internal" href="../using/cmdline.html#cmdoption-X"><code class="xref std std-option docutils literal notranslate"><span class="pre">-X</span> <span class="pre">int_max_str_digits</span></code></a>.
If both the env var and the <code class="docutils literal notranslate"><span class="pre">-X</span></code> option are set, the <code class="docutils literal notranslate"><span class="pre">-X</span></code> option takes
precedence. A value of <em>-1</em> indicates that both were unset, thus a value of
<code class="xref py py-data docutils literal notranslate"><span class="pre">sys.int_info.default_max_str_digits</span></code> was used during initialization.</p></li>
</ul>
<p>Desde el código, puedes inspeccionar el límite actual y configurar uno nuevo al usar estas APIs de <a class="reference internal" href="sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="sys.html#sys.get_int_max_str_digits" title="sys.get_int_max_str_digits"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.get_int_max_str_digits()</span></code></a> y <a class="reference internal" href="sys.html#sys.set_int_max_str_digits" title="sys.set_int_max_str_digits"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.set_int_max_str_digits()</span></code></a> son un getter y un setter para el límite de todo el intérprete. Los subintérpretes tienen su propio límite.</p></li>
</ul>
<p>La información sobre el valor predeterminado y mínimo se puede encontrar en <a class="reference internal" href="sys.html#sys.int_info" title="sys.int_info"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.int_info</span></code></a>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="sys.html#sys.int_info" title="sys.int_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.int_info.default_max_str_digits</span></code></a> es el límite predeterminado compilado.</p></li>
<li><p><a class="reference internal" href="sys.html#sys.int_info" title="sys.int_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.int_info.str_digits_check_threshold</span></code></a> es el valor más bajo aceptado para el límite (aparte de 0, que lo desactiva).</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.11.</span></p>
</div>
<div class="admonition caution">
<p class="admonition-title">Prudencia</p>
<p>Configurar un límite bajo <em>puede</em> generar problemas. Si bien es raro, existe un código que contiene constantes enteras en decimal en su origen que excede el umbral mínimo. Una consecuencia de configurar el límite es que el código fuente de Python que contiene literales enteros decimales más grandes que el límite encontrará un error durante el análisis, generalmente en el momento de inicio o en el momento de importación o incluso en el momento de instalación - en cualquier momento y actualizado, <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> no existe ya para el código. Una solución para la fuente que contiene constantes tan grandes es convertirlas a la forma hexadecimal <code class="docutils literal notranslate"><span class="pre">0x</span></code> ya que no tiene límite.</p>
<p>Prueba tu aplicación minuciosamente si utilizas un límite bajo. Asegúrate de que tus pruebas se ejecuten con el límite configurado temprano a través del entorno o del indicador para que se aplique durante el inicio e incluso durante cualquier paso de instalación que pueda invocar a Python para precompilar las fuentes <code class="docutils literal notranslate"><span class="pre">.py</span></code> a los archivos <code class="docutils literal notranslate"><span class="pre">.pyc</span></code>.</p>
</div>
</section>
<section id="recommended-configuration">
<h3>Configuración recomendada<a class="headerlink" href="#recommended-configuration" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Se espera que el valor predeterminado <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.int_info.default_max_str_digits</span></code> sea razonable para la mayoría de las aplicaciones. Si tu aplicación requiere un límite diferente, configúralo desde el punto de entrada principal utilizando el código independiente de la versión de Python, ya que estas APIs se agregaron en versiones de parches de seguridad en versiones anteriores a la 3.11.</p>
<p>Por ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="s2">&quot;set_int_max_str_digits&quot;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">upper_bound</span> <span class="o">=</span> <span class="mi">68000</span>
<span class="gp">... </span>    <span class="n">lower_bound</span> <span class="o">=</span> <span class="mi">4004</span>
<span class="gp">... </span>    <span class="n">current_limit</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">get_int_max_str_digits</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">current_limit</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">current_limit</span> <span class="o">&gt;</span> <span class="n">upper_bound</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">sys</span><span class="o">.</span><span class="n">set_int_max_str_digits</span><span class="p">(</span><span class="n">upper_bound</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">elif</span> <span class="n">current_limit</span> <span class="o">&lt;</span> <span class="n">lower_bound</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">sys</span><span class="o">.</span><span class="n">set_int_max_str_digits</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">)</span>
</pre></div>
</div>
<p>Si necesitas deshabilitarlo por completo, configúralo en <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p class="rubric">Notas al pie</p>
<dl class="footnote brackets">
<dt class="label" id="id12"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Se puede consultar información adicional sobre estos métodos especiales en el manual de referencia de Python (<a class="reference internal" href="../reference/datamodel.html#customization"><span class="std std-ref">Personalización básica</span></a>).</p>
</dd>
<dt class="label" id="id13"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>En consecuencia, la lista <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2]</span></code> se considera igual que <code class="docutils literal notranslate"><span class="pre">[1.0,</span> <span class="pre">2.0]</span></code>, y de forma similar para las tuplas.</p>
</dd>
<dt class="label" id="id14"><span class="brackets"><a class="fn-backref" href="#id4">3</a></span></dt>
<dd><p>Deben haberlo hecho, ya que el analizador no puede decir el tipo de operandos.</p>
</dd>
<dt class="label" id="id15"><span class="brackets">4</span><span class="fn-backref">(<a href="#id6">1</a>,<a href="#id7">2</a>,<a href="#id8">3</a>,<a href="#id9">4</a>)</span></dt>
<dd><p>Los caracteres con versiones mayúsculas/minúsculas son aquellos cuya categoría general corresponde con «Lu» (Letra, Mayúscula), «Ll» (Letra, minúscula) o «Lt» (Letra, <em>titlecase</em>).</p>
</dd>
<dt class="label" id="id16"><span class="brackets">5</span><span class="fn-backref">(<a href="#id10">1</a>,<a href="#id11">2</a>)</span></dt>
<dd><p>Para formatear solo una tupla se debe, por tanto, usar una tupla conteniendo un único elemento, que sería la tupla a ser formateada.</p>
</dd>
</dl>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">Tipos integrados</a><ul>
<li><a class="reference internal" href="#truth-value-testing">Evaluar como valor verdadero/falso</a></li>
<li><a class="reference internal" href="#boolean-operations-and-or-not">Operaciones booleanas — <code class="xref std std-keyword docutils literal notranslate"><span class="pre">and</span></code>, <code class="xref std std-keyword docutils literal notranslate"><span class="pre">or</span></code>, <code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span></code></a></li>
<li><a class="reference internal" href="#comparisons">Comparaciones</a></li>
<li><a class="reference internal" href="#numeric-types-int-float-complex">Tipos numéricos — <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a><ul>
<li><a class="reference internal" href="#bitwise-operations-on-integer-types">Operaciones de bits en números enteros</a></li>
<li><a class="reference internal" href="#additional-methods-on-integer-types">Métodos adicionales de los enteros</a></li>
<li><a class="reference internal" href="#additional-methods-on-float">Métodos adicionales de float</a></li>
<li><a class="reference internal" href="#hashing-of-numeric-types">Calculo del <em>hash</em> de tipos numéricos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#iterator-types">Tipos de iteradores</a><ul>
<li><a class="reference internal" href="#generator-types">Tipos generador</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sequence-types-list-tuple-range">Tipos secuencia — <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">range</span></code></a><ul>
<li><a class="reference internal" href="#common-sequence-operations">Operaciones comunes de las secuencias</a></li>
<li><a class="reference internal" href="#immutable-sequence-types">Tipos de secuencia inmutables</a></li>
<li><a class="reference internal" href="#mutable-sequence-types">Tipos de secuencia mutables</a></li>
<li><a class="reference internal" href="#lists">Listas</a></li>
<li><a class="reference internal" href="#tuples">Tuplas</a></li>
<li><a class="reference internal" href="#ranges">Rangos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#text-sequence-type-str">Cadenas de caracteres — <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a><ul>
<li><a class="reference internal" href="#string-methods">Métodos de las cadenas de caracteres</a></li>
<li><a class="reference internal" href="#printf-style-string-formatting">Formateo de cadenas al estilo <code class="docutils literal notranslate"><span class="pre">*printf*</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#binary-sequence-types-bytes-bytearray-memoryview">Tipos de secuencias binarias — <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code> y <code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a><ul>
<li><a class="reference internal" href="#bytes-objects">Objetos de tipo Bytes</a></li>
<li><a class="reference internal" href="#bytearray-objects">Objetos de tipo <em>Bytearray</em></a></li>
<li><a class="reference internal" href="#bytes-and-bytearray-operations">Operaciones de <em>bytes</em> y <em>bytearray</em></a></li>
<li><a class="reference internal" href="#printf-style-bytes-formatting">Usando el formateo tipo <code class="docutils literal notranslate"><span class="pre">printf</span></code> con bytes</a></li>
<li><a class="reference internal" href="#memory-views">Vistas de memoria</a></li>
</ul>
</li>
<li><a class="reference internal" href="#set-types-set-frozenset">Conjuntos — <code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a></li>
<li><a class="reference internal" href="#mapping-types-dict">Tipos mapa — <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a><ul>
<li><a class="reference internal" href="#dictionary-view-objects">Objetos tipos vista de diccionario</a></li>
</ul>
</li>
<li><a class="reference internal" href="#context-manager-types">Tipos gestores de contexto</a></li>
<li><a class="reference internal" href="#type-annotation-types-generic-alias-union">Tipos de anotaciones de type — <span class="xref std std-ref">alias genérico</span>, <span class="xref std std-ref">Union</span></a><ul>
<li><a class="reference internal" href="#generic-alias-type">Tipo Alias Genérico</a><ul>
<li><a class="reference internal" href="#standard-generic-classes">Clases genéricas estándar</a></li>
<li><a class="reference internal" href="#special-attributes-of-genericalias-objects">Atributos especiales de los objetos <code class="docutils literal notranslate"><span class="pre">GenericAlias</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#union-type">Tipo de conversión</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-built-in-types">Otros tipos predefinidos</a><ul>
<li><a class="reference internal" href="#modules">Módulos</a></li>
<li><a class="reference internal" href="#classes-and-class-instances">Clases e instancias de clase</a></li>
<li><a class="reference internal" href="#functions">Funciones</a></li>
<li><a class="reference internal" href="#methods">Métodos</a></li>
<li><a class="reference internal" href="#code-objects">Objetos código</a></li>
<li><a class="reference internal" href="#type-objects">Objetos Tipo</a></li>
<li><a class="reference internal" href="#the-null-object">El objeto nulo (<em>Null</em>)</a></li>
<li><a class="reference internal" href="#the-ellipsis-object">El objeto puntos suspensivos (<em>Ellipsis</em>)</a></li>
<li><a class="reference internal" href="#the-notimplemented-object">El objeto <em>NotImplemented</em></a></li>
<li><a class="reference internal" href="#boolean-values">Valores booleanos</a></li>
<li><a class="reference internal" href="#internal-objects">Objetos internos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-attributes">Atributos especiales</a></li>
<li><a class="reference internal" href="#integer-string-conversion-length-limitation">Limitación de longitud de conversión de cadena de tipo entero</a><ul>
<li><a class="reference internal" href="#affected-apis">APIs afectadas</a></li>
<li><a class="reference internal" href="#configuring-the-limit">Configuración del límite</a></li>
<li><a class="reference internal" href="#recommended-configuration">Configuración recomendada</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="constants.html"
                          title="capítulo anterior">Constantes incorporadas</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="exceptions.html"
                          title="próximo capítulo">Excepciones incorporadas</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/library/stdtypes.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="exceptions.html" title="Excepciones incorporadas"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="constants.html" title="Constantes incorporadas"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Tipos integrados</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 23, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>