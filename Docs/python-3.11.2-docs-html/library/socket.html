
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta property="og:title" content="socket — interfaz de red de bajo nivel" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/socket.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Código fuente: Lib/socket.py Este módulo proporciona acceso a la interfaz BSD socket. Está disponible en todos los sistemas Unix modernos, Windows, MacOS y probablemente plataformas adicionales. Av..." />
<meta property="og:image" content="https://docs.python.org/3/_static/og-image.png" />
<meta property="og:image:alt" content="Python documentation" />
<meta name="description" content="Código fuente: Lib/socket.py Este módulo proporciona acceso a la interfaz BSD socket. Está disponible en todos los sistemas Unix modernos, Windows, MacOS y probablemente plataformas adicionales. Av..." />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta name="theme-color" content="#3776ab" />

    <title>socket — interfaz de red de bajo nivel &#8212; documentación de Python - 3.11.2</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?digest=2d3badd06fe70b34b68db01f99471ce1624ffe4a" />
    
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.11.2"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="ssl —Empaquetador o wrapper TLS/SSL para objetos de tipo socket" href="ssl.html" />
    <link rel="prev" title="Desarrollando con asyncio" href="asyncio-dev.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/socket.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code> — interfaz de red de bajo nivel</a><ul>
<li><a class="reference internal" href="#socket-families">Familias Socket</a></li>
<li><a class="reference internal" href="#module-contents">Contenido del módulo</a><ul>
<li><a class="reference internal" href="#exceptions">Excepciones</a></li>
<li><a class="reference internal" href="#constants">Constantes</a></li>
<li><a class="reference internal" href="#functions">Funciones</a><ul>
<li><a class="reference internal" href="#creating-sockets">Creación de sockets</a></li>
<li><a class="reference internal" href="#other-functions">Otras funciones</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#socket-objects">Objetos Socket</a></li>
<li><a class="reference internal" href="#notes-on-socket-timeouts">Notas sobre los tiempos de espera del socket</a><ul>
<li><a class="reference internal" href="#timeouts-and-the-connect-method">Tiempos de espera y el método <code class="docutils literal notranslate"><span class="pre">connect</span></code></a></li>
<li><a class="reference internal" href="#timeouts-and-the-accept-method">Tiempos de espera y el método <code class="docutils literal notranslate"><span class="pre">accept</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#example">Ejemplo</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="asyncio-dev.html"
                          title="capítulo anterior">Desarrollando con asyncio</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="ssl.html"
                          title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code> —Empaquetador o wrapper TLS/SSL para objetos de tipo socket</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/library/socket.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="ssl.html" title="ssl —Empaquetador o wrapper TLS/SSL para objetos de tipo socket"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="asyncio-dev.html" title="Desarrollando con asyncio"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" accesskey="U">Comunicación en redes y entre procesos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code> — interfaz de red de bajo nivel</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-socket">
<span id="socket-low-level-networking-interface"></span><h1><a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> — interfaz de red de bajo nivel<a class="headerlink" href="#module-socket" title="Enlazar permanentemente con este título">¶</a></h1>
<p><strong>Código fuente:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.11/Lib/socket.py">Lib/socket.py</a></p>
<hr class="docutils" />
<p>Este módulo proporciona acceso a la interfaz BSD <em>socket</em>. Está disponible en todos los sistemas Unix modernos, Windows, MacOS y probablemente plataformas adicionales.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Algunos comportamientos pueden depender de la plataforma, ya que las llamadas se realizan a las API de socket del sistema operativo.</p>
</div>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not Emscripten, not WASI.</p>
<p>Este módulo no funciona o no está disponible en las plataformas WebAssembly <code class="docutils literal notranslate"><span class="pre">wasm32-emscripten</span></code> y <code class="docutils literal notranslate"><span class="pre">wasm32-wasi</span></code>. Véase <a class="reference internal" href="intro.html#wasm-availability"><span class="std std-ref">Plataformas WebAssembly</span></a> para más información.</p>
</div>
<p id="index-0">La interfaz de Python es una transcripción sencilla de la llamada al sistema Unix y la interfaz de la biblioteca para sockets al estilo orientado a objetos de Python: la función <code class="xref py py-func docutils literal notranslate"><span class="pre">socket()</span></code> devuelve a <em class="dfn">socket object</em> cuyos métodos implementan las diversas llamadas al sistema de socket. Los tipos de parámetros tienen un nivel algo más alto que en la interfaz C: como con <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> en las operaciones en los archivos Python, la asignación del buffer en las operaciones de recepción es automática y la longitud del buffer está implícita en las operaciones de envío.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt>Módulo <a class="reference internal" href="socketserver.html#module-socketserver" title="socketserver: A framework for network servers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socketserver</span></code></a></dt><dd><p>Clases que simplifican la escritura de servidores de red.</p>
</dd>
<dt>Módulo <a class="reference internal" href="ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a></dt><dd><p>Un contenedor TLS/SSL para objetos de socket.</p>
</dd>
</dl>
</div>
<section id="socket-families">
<h2>Familias Socket<a class="headerlink" href="#socket-families" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Dependiendo del sistema y de las opciones de compilación, este módulo admite varias familias de sockets.</p>
<p>El formato de dirección requerido por un objeto de socket determinado se selecciona automáticamente en función de la familia de direcciones especificada cuando se creó el objeto de socket.  Las direcciones de socket se representan de la siguiente manera:</p>
<ul>
<li><p>La dirección de un socket <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a> enlazado a un nodo del sistema de archivos es representado como una cadena de caracteres, utilizando la codificación del sistema de archivos y el controlador de errores <code class="docutils literal notranslate"><span class="pre">'surrogateescape'</span></code> (Observar <span class="target" id="index-29"></span><a class="pep reference external" href="https://peps.python.org/pep-0383/"><strong>PEP 383</strong></a>). Una dirección en el espacio de nombre abstracto de Linux es devuelvo como un <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> con un byte inicial nulo; tenga en cuenta que los sockets en este nombre de espacio puede comunicarse con sockets normales del sistema de archivos, así que los programas destinados a correr en Linux podrían necesitar tratar con ambos tipos de direcciones. Se puede pasar un objeto similar a una cadena de caracteres o bytes para cualquier tipo de dirección al pasarlo como argumento.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Anteriormente, se suponía que las rutas de socket <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a> utilizaban codificación UTF-8.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Ahora se acepta la grabación <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>.</p>
</div>
</li>
</ul>
<ul id="host-port">
<li><p>Se utiliza un par <code class="docutils literal notranslate"><span class="pre">(host,</span> <span class="pre">port)</span></code> para la familia de direcciones <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a>, donde <em>host</em> es una cadena que representa un nombre de host en notación de dominio de Internet como <code class="docutils literal notranslate"><span class="pre">'daring.cwi.nl'</span></code> o una dirección IPv4 como <code class="docutils literal notranslate"><span class="pre">'100.50.200.5'</span></code>, y <em>port</em> es un número entero.</p>
<ul class="simple">
<li><p>Para direcciones IPv4, se aceptan dos formas especiales en lugar de una dirección de host: <code class="docutils literal notranslate"><span class="pre">’’</span></code> representa <code class="xref py py-const docutils literal notranslate"><span class="pre">INADDR_ANY</span></code>, que se utiliza para enlazar a todas las interfaces, y la cadena de caracteres <code class="docutils literal notranslate"><span class="pre">'&lt;broadcast&gt;'</span></code> representa <code class="xref py py-const docutils literal notranslate"><span class="pre">INADDR_BROADCAST</span></code>. Este comportamiento no es compatible con IPv6, por lo tanto, es posible que desee evitarlos sí tiene la intención de admitir IPv6 con sus programas Python.</p></li>
</ul>
</li>
<li><p>Para la familia de direcciones <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a>, se utiliza una <code class="docutils literal notranslate"><span class="pre">(host,</span> <span class="pre">port,</span> <span class="pre">flowinfo,</span> <span class="pre">scope_id)</span></code> de cuatro tuplas, donde <em>flowinfo</em> y <em>scope_id</em> representan los miembros <code class="docutils literal notranslate"><span class="pre">sin6_flowinfo</span></code> y <code class="docutils literal notranslate"><span class="pre">sin6_scope_id</span></code> en <code class="xref py py-const docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr_in6</span></code> en C. Para los métodos de los módulos <a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a>, <em>flowinfo</em> y <em>scope_id</em> pueden ser omitidos solo por compatibilidad con versiones anteriores. Sin embargo la omisión de <em>scope_id</em> puede causar problemas en la manipulación de direcciones IPv6 con ámbito.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Para direcciones de multidifusión (con <em>scopeid</em> significativo) <em>address</em> puede no contener la parte <code class="docutils literal notranslate"><span class="pre">%scope</span></code> (o <code class="docutils literal notranslate"><span class="pre">zone</span> <span class="pre">id</span></code>). Esta información es superflua y puede omitirse de forma segura (recomendado).</p>
</div>
</li>
<li><p><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_NETLINK</span></code> sockets se representan como pares <code class="docutils literal notranslate"><span class="pre">(pid,</span> <span class="pre">groups)</span></code>.</p></li>
<li><p>La compatibilidad con LINUX solo para TIPC está disponible mediante la familia de direcciones <code class="xref py py-const docutils literal notranslate"><span class="pre">AF_TIPC</span></code>.  TIPC es un protocolo en red abierto y no basado en IP diseñado para su uso en entornos informáticos agrupados.  Las direcciones se representan mediante una tupla y los campos dependen del tipo de dirección. El formulario de tupla general es <code class="docutils literal notranslate"><span class="pre">(addr_type,</span> <span class="pre">v1,</span> <span class="pre">v2,</span> <span class="pre">v3</span> <span class="pre">[,</span> <span class="pre">scope])</span></code>, donde:</p>
<ul>
<li><p><em>addr_type</em> es uno de <code class="xref py py-const docutils literal notranslate"><span class="pre">TIPC_ADDR_NAMESEQ</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">TIPC_ADDR_NAME</span></code>, o <code class="xref py py-const docutils literal notranslate"><span class="pre">TIPC_ADDR_ID</span></code>.</p></li>
<li><p><em>scope</em> es una de <code class="xref py py-const docutils literal notranslate"><span class="pre">TIPC_ZONE_SCOPE</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">TIPC_CLUSTER_SCOPE</span></code>, y <code class="xref py py-const docutils literal notranslate"><span class="pre">TIPC_NODE_SCOPE</span></code>.</p></li>
<li><p>Si <em>addr_type</em> es <code class="xref py py-const docutils literal notranslate"><span class="pre">TIPC_ADDR_NAME</span></code>, entonces <em>v1</em> es el tipo de servidor, <em>v2</em> es el identificador de puerto, y <em>v3</em> debe ser 0.</p>
<p>Si <em>addr_type</em> es <code class="xref py py-const docutils literal notranslate"><span class="pre">TIPC_ADDR_NAMESEQ</span></code>, entonces  <em>v1</em> es el tipo de servidor, <em>v2</em> es el numero de puerto inferior, y <em>v3</em> es el numero de puerto superior.</p>
<p>Si <em>addr_type</em> es <code class="xref py py-const docutils literal notranslate"><span class="pre">TIPC_ADDR_ID</span></code>, <em>v1</em> es el nodo, <em>v2</em> es la referencia y <em>v3</em> debe establecerse en 0.</p>
</li>
</ul>
</li>
<li><p>Una tupla <code class="docutils literal notranslate"><span class="pre">(interface,</span> <span class="pre">)</span></code> es usada para la dirección de familia <a class="reference internal" href="#socket.AF_CAN" title="socket.AF_CAN"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_CAN</span></code></a>, donde <em>interface</em> es una cadena de caracteres representando a un nombre de interfaz de red como <code class="docutils literal notranslate"><span class="pre">’can0’</span></code>. La interfaz de red llamada <code class="docutils literal notranslate"><span class="pre">''</span></code> puede ser usada para recibir paquetes de todas las interfaces de red de esta familia.</p>
<ul class="simple">
<li><p>Protocolo <a class="reference internal" href="#socket.CAN_ISOTP" title="socket.CAN_ISOTP"><code class="xref py py-const docutils literal notranslate"><span class="pre">CAN_ISOTP</span></code></a> requiere una tupla <code class="docutils literal notranslate"><span class="pre">(interface,</span> <span class="pre">rx_addr,</span> <span class="pre">tx_addr)</span></code> donde ambos tiene parámetros adicionales son enteres largos sin símbolos que representan una identificador CAN (estándar o extendido).</p></li>
<li><p>Protocolo <a class="reference internal" href="#socket.CAN_J1939" title="socket.CAN_J1939"><code class="xref py py-const docutils literal notranslate"><span class="pre">CAN_J1939</span></code></a> requiere una tupla <code class="docutils literal notranslate"><span class="pre">(interface,</span> <span class="pre">name,</span> <span class="pre">pgn,</span> <span class="pre">addr)</span></code> donde los parámetros adicionales son números enteros sin signo de 64 bits representando el nombre ECU, los enteros sin signo de 32-bits representan el numero de grupo de parámetros(PGN), y los enteros de 8-bit representan la dirección.</p></li>
</ul>
</li>
<li><p>Se utiliza una cadena o una tupla <code class="docutils literal notranslate"><span class="pre">(id,</span> <span class="pre">unit)</span></code> para el protocolo <code class="xref py py-const docutils literal notranslate"><span class="pre">SYSPROTO_CONTROL</span></code> de la familia <code class="xref py py-const docutils literal notranslate"><span class="pre">PF_SYSTEM</span></code>. La cadena es el nombre de un control de kernel mediante un ID asignado dinámicamente. La tupla se puede utilizar si se conoce el ID y el número de unidad del control del kernel o si se utiliza un ID registrado.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</li>
<li><p><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_BLUETOOTH</span></code> admite los siguientes protocolos y formatos de dirección:</p>
<ul>
<li><p><code class="xref py py-const docutils literal notranslate"><span class="pre">BTPROTO_L2CAP</span></code> acepta <code class="docutils literal notranslate"><span class="pre">(bdaddr,</span> <span class="pre">psm)</span></code> donde <code class="docutils literal notranslate"><span class="pre">bdaddr</span></code> es la dirección Bluetooth como una cadena de caracteres y <code class="docutils literal notranslate"><span class="pre">psm</span></code> es un entero.</p></li>
<li><p><code class="xref py py-const docutils literal notranslate"><span class="pre">BTPROTO_RFCOMM</span></code> acepta <code class="docutils literal notranslate"><span class="pre">(bdaddr,</span> <span class="pre">channel)</span></code> donde <code class="docutils literal notranslate"><span class="pre">bdaddr</span></code> es la dirección Bluetooth como una cadena de caracteres y <code class="docutils literal notranslate"><span class="pre">channel</span></code> es un entero.</p></li>
<li><p><code class="xref py py-const docutils literal notranslate"><span class="pre">BTPROTO_HCI</span></code> acepta <code class="docutils literal notranslate"><span class="pre">(device_id,)</span></code> donde <code class="docutils literal notranslate"><span class="pre">device_id</span></code> es un numero entero o una cadena de caracteres con la dirección Bluetooth de la interfaz. (Esto depende de tu OS; NetBSD y DragonFlyBSD supone una dirección Bluetooth mientras todo lo demás espera un entero.)</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Se ha añadido compatibilidad con NetBSD y DragonFlyBSD.</p>
</div>
</li>
<li><p><code class="xref py py-const docutils literal notranslate"><span class="pre">BTPROTO_SCO</span></code> acepta <code class="docutils literal notranslate"><span class="pre">bdaddr</span></code> donde <code class="docutils literal notranslate"><span class="pre">bdaddr</span></code> es un objeto <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> que contiene la dirección Bluetooth en un formato cadena. (ex. <code class="docutils literal notranslate"><span class="pre">b’12:23:34:45:56:67’</span></code>) este protocolo no es admitido bajo FreeBSD.</p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#socket.AF_ALG" title="socket.AF_ALG"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_ALG</span></code></a> es una interfaz basada en socket sólo Linux para la criptografía del núcleo. Un socket de algoritmo se configura con una tupla de dos a cuatro elementos <code class="docutils literal notranslate"><span class="pre">(type,</span> <span class="pre">name</span> <span class="pre">[,</span> <span class="pre">feat</span> <span class="pre">[,</span> <span class="pre">mask]])</span></code>, donde:</p>
<ul class="simple">
<li><p><em>type</em> es el tipo de algoritmos como cadenas de caracteres, e.g. <code class="docutils literal notranslate"><span class="pre">aead</span></code>, <code class="docutils literal notranslate"><span class="pre">hash</span></code>, <code class="docutils literal notranslate"><span class="pre">skcipher</span></code> o <code class="docutils literal notranslate"><span class="pre">rng</span></code>.</p></li>
<li><p><em>name</em> es el nombre del algoritmo y el modo de operación como cadena de caracteres, e.g. <code class="docutils literal notranslate"><span class="pre">sha256</span></code>, <code class="docutils literal notranslate"><span class="pre">hmac(sha256)</span></code>, <code class="docutils literal notranslate"><span class="pre">cbc(aes)</span></code> o <code class="docutils literal notranslate"><span class="pre">drbg_nopr_ctr_aes256</span></code>.</p></li>
<li><p><em>feat</em> y <em>mask</em> son enteros de 32 bits sin signo.</p></li>
</ul>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux &gt;= 2.6.38.</p>
<p>Algunos tipos de algoritmos requieren Kernels mas recientes.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.</span></p>
</div>
</li>
<li><p><a class="reference internal" href="#socket.AF_VSOCK" title="socket.AF_VSOCK"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_VSOCK</span></code></a> permite comunicación entre maquinas virtuales y sus hosts. Los sockets están representando como una tupla <code class="docutils literal notranslate"><span class="pre">(CID,</span> <span class="pre">port)</span></code> donde el contexto del ID o CID y el puerto son enteros.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux &gt;= 3.9</p>
<p>Véase <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/vsock(7)">vsock(7)</a></em></p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</li>
<li><p><a class="reference internal" href="#socket.AF_PACKET" title="socket.AF_PACKET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_PACKET</span></code></a> es una interfaz de bajo nivel directa con los dispositivos de red. Los paquetes están representados por la tupla <code class="docutils literal notranslate"><span class="pre">(ifname,</span> <span class="pre">proto[,</span> <span class="pre">pkttype[,</span> <span class="pre">hatype[,</span> <span class="pre">addr]]])</span></code> donde:</p>
<ul class="simple">
<li><p><em>ifname</em> - Cadena que especifica el nombre del dispositivo.</p></li>
<li><p><em>proto</em> - Un entero en orden de byte de red que especifica el número de protocolo Ethernet.</p></li>
<li><p><em>pkttype</em> - Entero opcional especificando el tipo de paquete:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">PACKET_HOST</span></code> (por defecto) - Paquetes diseccionado al local host.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PACKET_BROADCAST</span></code> - Paquete de transmisión de la capa física.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PACKET_MULTICAST</span></code> - Paquete enviado a una dirección de multidifusión de capa física.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PACKET_OTHERHOST</span></code> - Paquete a otro host que haya sido capturado por un controlador de dispositivo en modo promiscuo.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PACKET_OUTGOING</span></code> - Paquete originalmente desde el local host que se enlaza de nuevo a un conector de paquetes.</p></li>
</ul>
</li>
<li><p><em>hatype</em> - Entero opcional que especifica el tipo de dirección de hardware ARP.</p></li>
<li><p><em>addr</em> - Objeto opcional en forma de bytes que especifica la dirección física del hardware, cuya interpretación depende del dispositivo.</p></li>
</ul>
<blockquote>
<div><div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux &gt;= 2.2.</p>
</div>
</div></blockquote>
</li>
<li><p><a class="reference internal" href="#socket.AF_QIPCRTR" title="socket.AF_QIPCRTR"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_QIPCRTR</span></code></a> es una interfaz basada en sockets solo para Linux para comunicarse con servicios que se ejecutan en co-procesadores en plataformas Qualcomm. La familia de direcciones se representa como una tupla <code class="docutils literal notranslate"><span class="pre">(node,</span> <span class="pre">port)</span></code> donde el <em>node</em> y <em>port</em> son enteros no negativos.</p>
<blockquote>
<div><div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux &gt;= 4.7.</p>
</div>
</div></blockquote>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</li>
<li><p><code class="xref py py-const docutils literal notranslate"><span class="pre">IPPROTO_UDPLITE</span></code> es una variante de UDO que te permite especificar que porción del paquete es cubierta con la suma de comprobación. Esto agrega dos opciones al socket que pueden cambiar. <code class="docutils literal notranslate"><span class="pre">self.setsockopt(IPPROTO_UDPLITE,</span> <span class="pre">UDPLITE_SEND_CSCOV,</span> <span class="pre">length)</span></code> cambiara que parte de los paquetes salientes están cubierta por la suma de comprobación y <code class="docutils literal notranslate"><span class="pre">self.setsockopt(IPPROTO_UDPLITE,</span> <span class="pre">UDPLITE_RECV_CSCOV,</span> <span class="pre">length)</span></code> filtrara los paquetes que permitirá cubrir una pequeña parte de tu datos. En ambos casos <code class="docutils literal notranslate"><span class="pre">length</span></code> deben estar en <code class="docutils literal notranslate"><span class="pre">range(8,</span> <span class="pre">2**16,</span> <span class="pre">8)</span></code>.</p>
<p>Tal socket debe construirse como <code class="docutils literal notranslate"><span class="pre">socket(AF_INET,</span> <span class="pre">SOCK_DGRAM,</span> <span class="pre">IPPROTO_UDPLITE)</span></code> para IPV4 o <code class="docutils literal notranslate"><span class="pre">socket(AF_INET6,</span> <span class="pre">SOCK_DGRAM,</span> <span class="pre">IPPROTO_UDPLITE)</span></code> para IPV6.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux &gt;= 2.6.20, FreeBSD &gt;= 10.1</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</li>
</ul>
<p>Si utiliza un nombre de host en la parte <em>host</em> de la dirección de socket IPv4/v6, el programa puede mostrar un comportamiento no determinista, ya que Python utiliza la primera dirección devuelta por la resolución DNS.  La dirección del socket se resolverá de manera diferente en una dirección IPv4/v6 real, dependiendo de los resultados de la resolución DNS y/o la configuración del host.  Para un comportamiento determinista, utilice una dirección numérica en la parte <em>host</em>.</p>
<p>Todos los errores generan excepciones. Las excepciones normales para tipos de argumentos inválidos y condiciones de falta de memoria pueden ser lanzadas. Los errores relacionados con la semántica de los sockets o de las direcciones lanzan <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> o una de sus subclases.</p>
<p>El modo de no bloqueo es compatible a través de <a class="reference internal" href="#socket.socket.setblocking" title="socket.socket.setblocking"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setblocking()</span></code></a>.  Se admite una generalización de esto basada en los tiempos de espera a través de <a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">settimeout()</span></code></a>.</p>
</section>
<section id="module-contents">
<h2>Contenido del módulo<a class="headerlink" href="#module-contents" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El módulo <a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> exporta los siguientes elementos.</p>
<section id="exceptions">
<h3>Excepciones<a class="headerlink" href="#exceptions" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py exception">
<dt class="sig sig-object py" id="socket.error">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">error</span></span><a class="headerlink" href="#socket.error" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un alias en desuso de <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Siguiendo <span class="target" id="index-30"></span><a class="pep reference external" href="https://peps.python.org/pep-3151/"><strong>PEP 3151</strong></a>, es clase fue creada como un alias de <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="socket.herror">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">herror</span></span><a class="headerlink" href="#socket.herror" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una subclase de <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>, esta excepción se produce para los errores relacionados con la dirección, es decir, para las funciones que utilizan <em>h_errno</em> en la API de POSIX C, incluidas <a class="reference internal" href="#socket.gethostbyname_ex" title="socket.gethostbyname_ex"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostbyname_ex()</span></code></a> y <a class="reference internal" href="#socket.gethostbyaddr" title="socket.gethostbyaddr"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostbyaddr()</span></code></a>. El valor adjunto es un par <code class="docutils literal notranslate"><span class="pre">(h_errno,</span> <span class="pre">string)</span></code> que representa un error devuelto por una llamada a la biblioteca.  <em>h_errno</em> es un valor numérico, mientras que <em>string</em> representa la descripción de <em>h_errno</em>, devuelta por la función <code class="xref c c-func docutils literal notranslate"><span class="pre">hstrerror()</span></code> C.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Esta clase fue creada como una subclase de <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="socket.gaierror">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">gaierror</span></span><a class="headerlink" href="#socket.gaierror" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una subclase de <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>, esta excepción se genera por errores relacionados a la dirección por <a class="reference internal" href="#socket.getaddrinfo" title="socket.getaddrinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> y <a class="reference internal" href="#socket.getnameinfo" title="socket.getnameinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getnameinfo()</span></code></a>. El valor de acompañamiento es un par <code class="docutils literal notranslate"><span class="pre">(error,</span> <span class="pre">string)</span></code> representado un error retornado por una llamada de librería. <em>string</em> representa la descripción del <em>error</em>, tal como es retornado por la función C <code class="xref c c-func docutils literal notranslate"><span class="pre">gai_strerror()</span></code>. El valor numérico <em>error</em> coincide con una de las constantes <code class="xref py py-const docutils literal notranslate"><span class="pre">EAI_*</span></code> definidas en este modulo.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Esta clase fue creada como una subclase de <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="socket.timeout">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">timeout</span></span><a class="headerlink" href="#socket.timeout" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un alias obsoleto de <a class="reference internal" href="exceptions.html#TimeoutError" title="TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TimeoutError</span></code></a>.</p>
<p>Una subclase de <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>, esta excepción se genera cuando ocurre un <em>timeout</em> en un socket que ha tenido tiempos de espera habilitados a través de una llamada previa a <a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">settimeout()</span></code></a> ( o implícitamente mediante <a class="reference internal" href="#socket.setdefaulttimeout" title="socket.setdefaulttimeout"><code class="xref py py-func docutils literal notranslate"><span class="pre">setdefaulttimeout()</span></code></a>). El valor del acompañamiento es una cadena de caracteres cuyo valor es actualmente siempre “tiempo de espera”.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Esta clase fue creada como una subclase de <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Esta clase se convirtió en un alias de <a class="reference internal" href="exceptions.html#TimeoutError" title="TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TimeoutError</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="constants">
<h3>Constantes<a class="headerlink" href="#constants" title="Enlazar permanentemente con este título">¶</a></h3>
<blockquote>
<div><p>Las constantes AF_* y SOCK_* ahora son colecciones: <code class="xref py py-class docutils literal notranslate"><span class="pre">AddressFamily</span></code> y <code class="xref py py-class docutils literal notranslate"><span class="pre">SocketKind</span></code> <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntEnum</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</div></blockquote>
<dl class="py data">
<dt class="sig sig-object py" id="socket.AF_UNIX">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">AF_UNIX</span></span><a class="headerlink" href="#socket.AF_UNIX" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="socket.AF_INET">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">AF_INET</span></span><a class="headerlink" href="#socket.AF_INET" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="socket.AF_INET6">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">AF_INET6</span></span><a class="headerlink" href="#socket.AF_INET6" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Estas constantes representan la familias de direcciones (y protocolos), usados para el primer argumento para <code class="xref py py-func docutils literal notranslate"><span class="pre">socket()</span></code>. Si la constante <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a> no esta definida entonces este protocolo no es compatible. Mas constantes podrían estar disponibles dependiendo del sistema.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="socket.SOCK_STREAM">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">SOCK_STREAM</span></span><a class="headerlink" href="#socket.SOCK_STREAM" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="socket.SOCK_DGRAM">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">SOCK_DGRAM</span></span><a class="headerlink" href="#socket.SOCK_DGRAM" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="socket.SOCK_RAW">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">SOCK_RAW</span></span><a class="headerlink" href="#socket.SOCK_RAW" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="socket.SOCK_RDM">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">SOCK_RDM</span></span><a class="headerlink" href="#socket.SOCK_RDM" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="socket.SOCK_SEQPACKET">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">SOCK_SEQPACKET</span></span><a class="headerlink" href="#socket.SOCK_SEQPACKET" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Estas constantes representan los tipos de socket, usadas por el segundo argumento para <code class="xref py py-func docutils literal notranslate"><span class="pre">socket()</span></code>. Mas constante podrían estar disponibles dependiendo del sistema. ( Solamente <a class="reference internal" href="#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a> y <a class="reference internal" href="#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_DGRAM</span></code></a> parecen ser útiles en general.)</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="socket.SOCK_CLOEXEC">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">SOCK_CLOEXEC</span></span><a class="headerlink" href="#socket.SOCK_CLOEXEC" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="socket.SOCK_NONBLOCK">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">SOCK_NONBLOCK</span></span><a class="headerlink" href="#socket.SOCK_NONBLOCK" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Estas dos constantes, si se definen, se pueden combinar con los tipos de socket y le permiten establecer algunas banderas atómicamente (evitando así posibles condiciones de carrera y la necesidad de llamadas separadas).</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p><a class="reference external" href="http://udrepper.livejournal.com/20407.html">Secure File Descriptor Handling</a> para una explicación más completa.</p>
</div>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux &gt;= 2.6.27.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SO_*</span></span></dt>
<dt class="sig sig-object py" id="socket.SOMAXCONN">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">SOMAXCONN</span></span><a class="headerlink" href="#socket.SOMAXCONN" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MSG_*</span></span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SOL_*</span></span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SCM_*</span></span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IPPROTO_*</span></span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IPPORT_*</span></span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">INADDR_*</span></span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IP_*</span></span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IPV6_*</span></span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EAI_*</span></span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AI_*</span></span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">NI_*</span></span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TCP_*</span></span></dt>
<dd><p>Muchas constantes de estos formularios, documentadas en la documentación de Unix en sockets y/o el protocolo IP, también se definen en el módulo de socket. Generalmente se utilizan en argumentos de los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">setsockopt()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">getsockopt()</span></code> de objetos socket.  En la mayoría de los casos, solo se definen los símbolos definidos en los archivos de encabezado Unix; para algunos símbolos, se proporcionan valores predeterminados.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span><code class="docutils literal notranslate"><span class="pre">SO_DOMAIN</span></code>, <code class="docutils literal notranslate"><span class="pre">SO_PROTOCOL</span></code>, <code class="docutils literal notranslate"><span class="pre">SO_PEERSEC</span></code>, <code class="docutils literal notranslate"><span class="pre">SO_PASSSEC</span></code>, <code class="docutils literal notranslate"><span class="pre">TCP_USER_TIMEOUT</span></code>, <code class="docutils literal notranslate"><span class="pre">TCP_CONGESTION</span></code> han sido agregados.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6.5: </span>En Windows, <code class="docutils literal notranslate"><span class="pre">TCP_FASTOPEN</span></code>, <code class="docutils literal notranslate"><span class="pre">TCP_KEEPCNT</span></code> aparecen si el tiempo de ejecución de Windows lo admite.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span><code class="docutils literal notranslate"><span class="pre">TCP_NOTSENT_LOWAT</span></code> ha sido agregada.</p>
<p>En Windows, <code class="docutils literal notranslate"><span class="pre">TCP_KEEPIDLE</span></code>, <code class="docutils literal notranslate"><span class="pre">TCP_KEEPINTVL</span></code> aparecen si el tiempo de ejecución de Windows lo admite.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Se agregó <code class="docutils literal notranslate"><span class="pre">IP_RECVTOS</span></code>. Se agregó <code class="docutils literal notranslate"><span class="pre">TCP_KEEPALIVE</span></code>. En MacOS, esta constante se puede utilizar de la misma forma que <code class="docutils literal notranslate"><span class="pre">TCP_KEEPIDLE</span></code> en Linux.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Se agregó <code class="docutils literal notranslate"><span class="pre">TCP_CONNECTION_INFO</span></code>. En MacOS esta constante se puede utilizar de la misma manera que <code class="docutils literal notranslate"><span class="pre">TCP_INFO</span></code> se utiliza en Linux y BSD.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="socket.AF_CAN">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">AF_CAN</span></span><a class="headerlink" href="#socket.AF_CAN" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="socket.PF_CAN">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">PF_CAN</span></span><a class="headerlink" href="#socket.PF_CAN" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SOL_CAN_*</span></span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CAN_*</span></span></dt>
<dd><p>Muchas constantes de estos formularios, documentadas en la documentación de Linux, también se definen en el módulo de socket.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux &gt;= 2.6.25, NetBSD &gt;= 8.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Se ha agregado compatibilidad con NetBSD.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="socket.CAN_BCM">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">CAN_BCM</span></span><a class="headerlink" href="#socket.CAN_BCM" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CAN_BCM_*</span></span></dt>
<dd><p>CAN_BCM, en la familia de protocolo CAN, es el protocolo del administrador de difusión (BCM. Las constantes del administrador de difusión, documentada en la documentación de Linux, también esta definidos en el modulo socket.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux &gt;= 2.6.25.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>El indicador <code class="xref py py-data docutils literal notranslate"><span class="pre">CAN_BCM_CAN_FD_FRAME</span></code> esta solamente disponible en Linux &gt;= 4.8.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="socket.CAN_RAW_FD_FRAMES">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">CAN_RAW_FD_FRAMES</span></span><a class="headerlink" href="#socket.CAN_RAW_FD_FRAMES" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Habilita la compatibilidad con CAN FD en un socket CAN_RAW. Esta opción está deshabilitada de forma predeterminada. Esto permite que la aplicación envíe tramas CAN y CAN FD; sin embargo, debe aceptar las tramas CAN y CAN FD al leer desde el socket.</p>
<p>Esta constante se documenta en la documentación de Linux.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux &gt;= 3.6.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="socket.CAN_RAW_JOIN_FILTERS">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">CAN_RAW_JOIN_FILTERS</span></span><a class="headerlink" href="#socket.CAN_RAW_JOIN_FILTERS" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Se une a los filtros CAN aplicados de modo que solo las tramas CAN que coinciden con todos los filtros CAN dados se pasan al espacio del usuario.</p>
<p>Esta constante se documenta en la documentación de Linux.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux &gt;= 4.1.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="socket.CAN_ISOTP">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">CAN_ISOTP</span></span><a class="headerlink" href="#socket.CAN_ISOTP" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>CAN_ISOTP, en el protocolo de familia CAN, es el protocolo  ISO-TP (ISO 15765-2). Constantes ISO-TP, documentadas en la documentación Linux.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux &gt;= 2.6.25.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="socket.CAN_J1939">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">CAN_J1939</span></span><a class="headerlink" href="#socket.CAN_J1939" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>CAN_J1939, en el protocolo de familias CAN, es el protocolo SAE J1939. Constantes J1939, documentadas en el documentación Linux.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux &gt;= 5.4.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="socket.AF_PACKET">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">AF_PACKET</span></span><a class="headerlink" href="#socket.AF_PACKET" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="socket.PF_PACKET">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">PF_PACKET</span></span><a class="headerlink" href="#socket.PF_PACKET" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PACKET_*</span></span></dt>
<dd><p>Muchas constantes de estos formularios, documentadas en la documentación de Linux, también se definen en el módulo de socket.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux &gt;= 2.2.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="socket.AF_RDS">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">AF_RDS</span></span><a class="headerlink" href="#socket.AF_RDS" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="socket.PF_RDS">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">PF_RDS</span></span><a class="headerlink" href="#socket.PF_RDS" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="socket.SOL_RDS">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">SOL_RDS</span></span><a class="headerlink" href="#socket.SOL_RDS" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RDS_*</span></span></dt>
<dd><p>Muchas constantes de estos formularios, documentadas en la documentación de Linux, también se definen en el módulo de socket.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux &gt;= 2.6.30.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="socket.SIO_RCVALL">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">SIO_RCVALL</span></span><a class="headerlink" href="#socket.SIO_RCVALL" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="socket.SIO_KEEPALIVE_VALS">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">SIO_KEEPALIVE_VALS</span></span><a class="headerlink" href="#socket.SIO_KEEPALIVE_VALS" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="socket.SIO_LOOPBACK_FAST_PATH">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">SIO_LOOPBACK_FAST_PATH</span></span><a class="headerlink" href="#socket.SIO_LOOPBACK_FAST_PATH" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RCVALL_*</span></span></dt>
<dd><p>Constantes para Windows’ WSAIoctl(). Las constantes se utiliza como argumentos al método <a class="reference internal" href="#socket.socket.ioctl" title="socket.socket.ioctl"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ioctl()</span></code></a> de objetos de sockets.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span><code class="docutils literal notranslate"><span class="pre">SIO_LOOPBACK_FAST_PATH</span></code> ha sido agregado.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TIPC_*</span></span></dt>
<dd><p>LAS constantes relacionadas con TIPC, que coinciden con las exportadas por la API de socket de C. Consulte la documentación de TIPC para obtener más información.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="socket.AF_ALG">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">AF_ALG</span></span><a class="headerlink" href="#socket.AF_ALG" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="socket.SOL_ALG">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">SOL_ALG</span></span><a class="headerlink" href="#socket.SOL_ALG" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ALG_*</span></span></dt>
<dd><p>Constantes para la criptográfica del Kernel de Linux.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux &gt;= 2.6.38.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="socket.AF_VSOCK">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">AF_VSOCK</span></span><a class="headerlink" href="#socket.AF_VSOCK" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="socket.IOCTL_VM_SOCKETS_GET_LOCAL_CID">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">IOCTL_VM_SOCKETS_GET_LOCAL_CID</span></span><a class="headerlink" href="#socket.IOCTL_VM_SOCKETS_GET_LOCAL_CID" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VMADDR*</span></span></dt>
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SO_VM*</span></span></dt>
<dd><p>Constantes para la comunicación host/invitado de Linux.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux &gt;= 4.8.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="socket.AF_LINK">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">AF_LINK</span></span><a class="headerlink" href="#socket.AF_LINK" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: BSD, macOS.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="socket.has_ipv6">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">has_ipv6</span></span><a class="headerlink" href="#socket.has_ipv6" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta constante contiene un valor booleano que indica si IPv6 se admite en esta plataforma.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="socket.BDADDR_ANY">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">BDADDR_ANY</span></span><a class="headerlink" href="#socket.BDADDR_ANY" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="socket.BDADDR_LOCAL">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">BDADDR_LOCAL</span></span><a class="headerlink" href="#socket.BDADDR_LOCAL" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Estas son constantes de cadenas que contienen direcciones Bluetooth con significados especiales. Por ejemplo <a class="reference internal" href="#socket.BDADDR_ANY" title="socket.BDADDR_ANY"><code class="xref py py-const docutils literal notranslate"><span class="pre">BDADDR_ANY</span></code></a> son usados para indicar cualquier dirección al especificar el socket vinculante con <code class="xref py py-const docutils literal notranslate"><span class="pre">BTPROTO_RFCOMM</span></code>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="socket.HCI_FILTER">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">HCI_FILTER</span></span><a class="headerlink" href="#socket.HCI_FILTER" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="socket.HCI_TIME_STAMP">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">HCI_TIME_STAMP</span></span><a class="headerlink" href="#socket.HCI_TIME_STAMP" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="socket.HCI_DATA_DIR">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">HCI_DATA_DIR</span></span><a class="headerlink" href="#socket.HCI_DATA_DIR" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Para usar con <code class="xref py py-const docutils literal notranslate"><span class="pre">BTPROTO_HCI</span></code>. <a class="reference internal" href="#socket.HCI_FILTER" title="socket.HCI_FILTER"><code class="xref py py-const docutils literal notranslate"><span class="pre">HCI_FILTER</span></code></a> no esta disponible para NetBSD o DragonFlyBSD. <a class="reference internal" href="#socket.HCI_TIME_STAMP" title="socket.HCI_TIME_STAMP"><code class="xref py py-const docutils literal notranslate"><span class="pre">HCI_TIME_STAMP</span></code></a> y <a class="reference internal" href="#socket.HCI_DATA_DIR" title="socket.HCI_DATA_DIR"><code class="xref py py-const docutils literal notranslate"><span class="pre">HCI_DATA_DIR</span></code></a> no esta disponible para FreeBSD, NetBSD, o DragonFlyBSD.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="socket.AF_QIPCRTR">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">AF_QIPCRTR</span></span><a class="headerlink" href="#socket.AF_QIPCRTR" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Constante para el protocolo de router IPC de Qualcomm, que se utiliza para comunicarse con procesadores remotos que brindan servicios.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux &gt;= 4.7.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="socket.SCM_CREDS2">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">SCM_CREDS2</span></span><a class="headerlink" href="#socket.SCM_CREDS2" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="socket.LOCAL_CREDS">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">LOCAL_CREDS</span></span><a class="headerlink" href="#socket.LOCAL_CREDS" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py" id="socket.LOCAL_CREDS_PERSISTENT">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">LOCAL_CREDS_PERSISTENT</span></span><a class="headerlink" href="#socket.LOCAL_CREDS_PERSISTENT" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>LOCAL_CREDS y LOCAL_CREDS_PERSISTENT pueden usarse con sockets SOCK_DGRAM, SOCK_STREAM, equivalente a Linux/DragonFlyBSD SO_PASSCRED, mientras que LOCAL_CREDS envía las credenciales en la primera lectura, LOCAL_CREDS_PERSISTENT envía para cada lectura, SCM_CREDS2 debe entonces ser usado para este último para el tipo de mensaje.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.11.</span></p>
</div>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: FreeBSD.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="socket.SO_INCOMING_CPU">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">SO_INCOMING_CPU</span></span><a class="headerlink" href="#socket.SO_INCOMING_CPU" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><blockquote>
<div><p>Constante para optimizar la localidad CPU, a ser usada en conjunto con <code class="xref py py-data docutils literal notranslate"><span class="pre">SO_REUSEPORT</span></code>.</p>
</div></blockquote>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.11.</span></p>
</div>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux &gt;= 3.9</p>
</div>
</dd></dl>

</section>
<section id="functions">
<h3>Funciones<a class="headerlink" href="#functions" title="Enlazar permanentemente con este título">¶</a></h3>
<section id="creating-sockets">
<h4>Creación de sockets<a class="headerlink" href="#creating-sockets" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Todas las siguientes funciones crean <a class="reference internal" href="#socket-objects"><span class="std std-ref">socket objects</span></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="socket.socket">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">socket</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">family</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">AF_INET</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">SOCK_STREAM</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fileno</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Crear un nuevo socket usando la dirección de familia dada, tipo de socket y el numero de protocolo. La dirección de familia debería ser <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a> (por defecto), <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a>, <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>, <a class="reference internal" href="#socket.AF_CAN" title="socket.AF_CAN"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_CAN</span></code></a>, <a class="reference internal" href="#socket.AF_PACKET" title="socket.AF_PACKET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_PACKET</span></code></a>, o <a class="reference internal" href="#socket.AF_RDS" title="socket.AF_RDS"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_RDS</span></code></a>. El tipo de socket debería ser <a class="reference internal" href="#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a> (por defecto), <a class="reference internal" href="#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_DGRAM</span></code></a>, <a class="reference internal" href="#socket.SOCK_RAW" title="socket.SOCK_RAW"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_RAW</span></code></a> o quizás una de las otras constantes <code class="docutils literal notranslate"><span class="pre">SOCK_</span></code>. El numero de protocolo es usualmente cero u omitirse o en el caso donde la familia de dirección es <a class="reference internal" href="#socket.AF_CAN" title="socket.AF_CAN"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_CAN</span></code></a> el protocolo debería ser uno de <code class="xref py py-const docutils literal notranslate"><span class="pre">CAN_RAW</span></code>, <a class="reference internal" href="#socket.CAN_BCM" title="socket.CAN_BCM"><code class="xref py py-const docutils literal notranslate"><span class="pre">CAN_BCM</span></code></a>, <a class="reference internal" href="#socket.CAN_ISOTP" title="socket.CAN_ISOTP"><code class="xref py py-const docutils literal notranslate"><span class="pre">CAN_ISOTP</span></code></a> o <a class="reference internal" href="#socket.CAN_J1939" title="socket.CAN_J1939"><code class="xref py py-const docutils literal notranslate"><span class="pre">CAN_J1939</span></code></a>.</p>
<p>Si <em>fileno</em> esta especificado, el valor de <em>family</em>, <em>type</em>, y <em>proto</em> son detectados automáticamente por el descriptor especificado de archivo. La detección automática se puede anular llamado la función con los argumentos explícitos <em>family</em>, <em>type</em>, o <em>proto</em>. Esto solamente afecta como Python representa e.g. el valor de retorno de  <a class="reference internal" href="#socket.socket.getpeername" title="socket.socket.getpeername"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.getpeername()</span></code></a> pero no del recurso actual del OS. Diferente a  <a class="reference internal" href="#socket.fromfd" title="socket.fromfd"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.fromfd()</span></code></a>, <em>fileno</em> retornara el mismo socket y no un duplicado. Esto puede ayudar a cerrar un socket desconectado usando <a class="reference internal" href="#socket.close" title="socket.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.close()</span></code></a>.</p>
<p>El socket recién creado es <a class="reference internal" href="os.html#fd-inheritance"><span class="std std-ref">non-inheritable</span></a>.</p>
<p class="audit-hook">Genera un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">socket.__new__</span></code> con los argumentos <code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">family</span></code>, <code class="docutils literal notranslate"><span class="pre">type</span></code>, <code class="docutils literal notranslate"><span class="pre">protocol</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Se añadió la familia AF_CAN. Se añadió la familia AF_RDS.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>El protocolo CAN_BCM ha sido agregado.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Los sockets devueltos ahora no son heredables.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>El protocolo CAN_ISOTP ha sido agregado.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Cuando las banderas bit <a class="reference internal" href="#socket.SOCK_NONBLOCK" title="socket.SOCK_NONBLOCK"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_NONBLOCK</span></code></a> or <a class="reference internal" href="#socket.SOCK_CLOEXEC" title="socket.SOCK_CLOEXEC"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_CLOEXEC</span></code></a> están aplicadas a <em>type</em>, se borran, y <a class="reference internal" href="#socket.socket.type" title="socket.socket.type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">socket.type</span></code></a> no las reflejará. Igual se pasan a la llamada <cite>socket ()</cite> del sistema subyacente. Por lo tanto,</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span>
    <span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span>
    <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span> <span class="o">|</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_NONBLOCK</span><span class="p">)</span>
</pre></div>
</div>
<p>seguirá creando un socket sin bloqueo en los sistemas operativos que admiten <code class="docutils literal notranslate"><span class="pre">SOCK_NONBLOCK</span></code>, pero <code class="docutils literal notranslate"><span class="pre">sock.type</span></code> se establecerá en <code class="docutils literal notranslate"><span class="pre">socket.SOCK_STREAM</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.9: </span>El protocolo CAN_J1939 ha sido agregado.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Se agregó el protocolo IPPROTO_MPTCP.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.socketpair">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">socketpair</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">family</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">proto</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socketpair" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Cree un par de objetos de socket conectados utilizando la familia de direcciones, el tipo de socket y el número de protocolo especificados.  La familia de direcciones, el tipo de socket y el número de protocolo son los siguientes para la función <code class="xref py py-func docutils literal notranslate"><span class="pre">socket()</span></code> anterior. La familia predeterminada es <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a> si se define en la plataforma; de lo contrario, el valor predeterminado es <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a>.</p>
<p>Los sockets creados recientemente son <a class="reference internal" href="os.html#fd-inheritance"><span class="std std-ref">non-inheritable</span></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Los objetos de socket devueltos ahora admiten toda la API de socket, en lugar de un subconjunto.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Los sockets devueltos ahora no son heredables.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Se ha agregado compatibilidad con Windows.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.create_connection">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">create_connection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">GLOBAL_DEFAULT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_address</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.create_connection" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Se conecta a un servicio TCP que esté escuchando en Internet <em>address</em> (un <code class="docutils literal notranslate"><span class="pre">(host,</span> <span class="pre">port)</span></code> de 2 tuplas) y retorna el objeto de socket. Esta es una función de nivel superior que <a class="reference internal" href="#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.connect()</span></code></a>: si <em>host</em> es un nombre de host no numérico, intentará resolverlo para <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET</span></code></a> y <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET6</span></code></a>, y luego intentará conectarse a todas las direcciones posibles sucesivamente hasta que la conexión se realice correctamente. Esto facilita la escritura de clientes que sean compatibles con IPv4 e IPv6.</p>
<p>Pasando el parámetro opcional <em>timeout</em> establece el tiempo de espera dentro de la instancia del socket. Si no es proporcionado <em>timeout</em>, la configuración global de tiempo de espera predeterminada retornada por <a class="reference internal" href="#socket.getdefaulttimeout" title="socket.getdefaulttimeout"><code class="xref py py-func docutils literal notranslate"><span class="pre">getdefaulttimeout()</span></code></a> es usada.</p>
<p>Si se suministra, <em>source_address</em> debe ser una “”(host, puerto)”” de 2 tuplas para que el socket se enlace como su dirección de origen antes de conectarse.  Si el host o el puerto son “” o 0 respectivamente, se utilizará el comportamiento predeterminado del sistema operativo.</p>
<p>Cuando una conexión no puede ser creada, se lanza una exception. Por defecto, es la excepción de la última dirección en la lista. Si <em>all_errors</em> es <code class="docutils literal notranslate"><span class="pre">True</span></code>, es un <a class="reference internal" href="exceptions.html#ExceptionGroup" title="ExceptionGroup"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a> conteniendo los errores de todos los intentos.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span><em>source_address</em> ha sido agregado.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span><em>all_errors</em> ha sido agregado.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.create_server">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">create_server</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">family</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">AF_INET</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backlog</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reuse_port</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dualstack_ipv6</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.create_server" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Función de conveniencia que crea un socket TCP enlazado a <em>address</em> (una tupla de 2 <code class="docutils literal notranslate"><span class="pre">(host,</span> <span class="pre">puerto)</span></code>) y devuelve el objeto de socket.</p>
<p><em>family</em> should be either <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET</span></code></a> or <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-data docutils literal notranslate"><span class="pre">AF_INET6</span></code></a>.
<em>backlog</em> is the queue size passed to <a class="reference internal" href="#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.listen()</span></code></a>; if not specified
, a default reasonable value is chosen.
<em>reuse_port</em> dictates whether to set the <code class="xref py py-data docutils literal notranslate"><span class="pre">SO_REUSEPORT</span></code> socket option.</p>
<p>Si <em>dualstack_ipv6</em> es true y la plataforma lo admite el socket podrá aceptar conexiones IPv4 e IPv6, de lo contrario lanzará <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>. Se supone que la mayoría de las plataformas POSIX y Windows admiten esta funcionalidad. Cuando esta funcionalidad está habilitada, la dirección devuelta por <a class="reference internal" href="#socket.socket.getpeername" title="socket.socket.getpeername"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.getpeername()</span></code></a> cuando se produce una conexión IPv4 será una dirección IPv6 representada como una dirección IPv4 asignada6. Si <em>dualstack_ipv6</em> es false, deshabilitará explícitamente esta funcionalidad en las plataformas que la habilitan de forma predeterminada (por ejemplo, Linux). Este parámetro se puede utilizar junto con <a class="reference internal" href="#socket.has_dualstack_ipv6" title="socket.has_dualstack_ipv6"><code class="xref py py-func docutils literal notranslate"><span class="pre">has_dualstack_ipv6()</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>

<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="mi">8080</span><span class="p">)</span>  <span class="c1"># all interfaces, port 8080</span>
<span class="k">if</span> <span class="n">socket</span><span class="o">.</span><span class="n">has_dualstack_ipv6</span><span class="p">():</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">create_server</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET6</span><span class="p">,</span> <span class="n">dualstack_ipv6</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">create_server</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En plataformas POSIX la opción del socket <code class="xref py py-data docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code> está configurado para inmediatamente rehusar los sockets previos que estaban vinculados la misma <em>address</em> y permanecer en estado TIME_WAIT.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.has_dualstack_ipv6">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">has_dualstack_ipv6</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.has_dualstack_ipv6" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si la plataforma admite la creación de un socket TCP que pueda manejar conexiones IPv4 e IPv6.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.fromfd">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">fromfd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">family</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.fromfd" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Duplica el descriptor de archivo <em>fd</em> (un entero retornado por el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">fileno()</span></code> de un objeto archivo) y crea un objeto socket a partir del resultado.  La familia de direcciones, el tipo de socket y el número de protocolo son como para la función <code class="xref py py-func docutils literal notranslate"><span class="pre">socket()</span></code> anterior. El descriptor de archivo debe hacer referencia a un socket, pero esto no se comprueba — las operaciones posteriores en el objeto pueden fallar si el descriptor de archivo no es válido. Esta función rara vez se necesita, pero se puede usar para obtener o establecer opciones de socket en un socket pasado a un programa como entrada o salida estándar (como un servidor iniciado por el demonio inet de Unix).  Se supone que el socket está en modo de bloqueo.</p>
<p>El socket recién creado es <a class="reference internal" href="os.html#fd-inheritance"><span class="std std-ref">non-inheritable</span></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Los sockets devueltos ahora no son heredables.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.fromshare">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">fromshare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.fromshare" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Cree una instancia de un socket a partir de los datos obtenidos del método <a class="reference internal" href="#socket.socket.share" title="socket.socket.share"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.share()</span></code></a>.  Se supone que el socket está en modo de bloqueo.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="socket.SocketType">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">SocketType</span></span><a class="headerlink" href="#socket.SocketType" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este es un tipo de objeto Python que representa el tipo de objeto del socket. Es lo mismo que decir <code class="docutils literal notranslate"><span class="pre">type(socket(…))</span></code>.</p>
</dd></dl>

</section>
<section id="other-functions">
<h4>Otras funciones<a class="headerlink" href="#other-functions" title="Enlazar permanentemente con este título">¶</a></h4>
<p>El modulo <a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> también ofrece varios servicios de red relacionados:</p>
<dl class="py function">
<dt class="sig sig-object py" id="socket.close">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fd</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.close" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Cierre un descriptor de archivo de socket. Esto es como <a class="reference internal" href="os.html#os.close" title="os.close"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.close()</span></code></a>, pero para sockets. En algunas plataformas (la mayoría notable de Windows) <a class="reference internal" href="os.html#os.close" title="os.close"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.close()</span></code></a> no funciona para descriptores de archivos de socket.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.getaddrinfo">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">getaddrinfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">host</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">family</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.getaddrinfo" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Traduce el argumento <em>host</em>/<em>port</em> dentro de una secuencia de 5 tuplas que contiene todo los argumentos necesarios para crear un socket conectado a ese servicio. <em>host</em> es un nombre de dominio, una cadena en representación de una dirección IPV4/IPV6 o <code class="docutils literal notranslate"><span class="pre">None</span></code>. <em>port</em> es una nombre de una cadena de servicio como <code class="docutils literal notranslate"><span class="pre">'http'</span></code>, un numero de puerto numérico o <code class="docutils literal notranslate"><span class="pre">None</span></code>. Pasando <code class="docutils literal notranslate"><span class="pre">None</span></code> como el valor del  <em>host</em> y <em>port</em>, pasando <code class="docutils literal notranslate"><span class="pre">NULL</span></code> a la API C subyacente.</p>
<p>Los argumentos <em>family</em>, <em>type</em> y <em>proto</em> se puede especificar opcionalmente para reducir la lista de direcciones retornadas. Pasando cero como un valor para cada uno de estos argumentos se selecciona la gama completa de resultados. El argumento <em>flags</em> puede ser uno o varios de los argumentos <code class="docutils literal notranslate"><span class="pre">AI_*</span></code>, y pueden influenciar como los resultados son computados y devueltos. Por ejemplo, <code class="xref py py-const docutils literal notranslate"><span class="pre">AI_NUMERICHOST</span></code> desactivará la resolución de nombres de dominio y lanzará un error sí <em>host</em> es un nombre de dominio.</p>
<p>La función devuelve una lista de 5 tuplas con la siguiente estructura:</p>
<p><code class="docutils literal notranslate"><span class="pre">(family,</span> <span class="pre">type,</span> <span class="pre">proto,</span> <span class="pre">canonname,</span> <span class="pre">sockaddr)</span></code></p>
<p>En estas tuplas, <em>family</em>, <em>type</em>, <em>proto</em> son todos enteros y están destinados a ser pasados por la función <code class="xref py py-func docutils literal notranslate"><span class="pre">socket()</span></code>.  <em>canonname</em> debe ser una cadena que representa el nombre canónico del <em>host</em> si <code class="xref py py-const docutils literal notranslate"><span class="pre">AI_CANONNAME</span></code> es parte de el argumento <em>flags</em>; de lo contrario <em>canonname</em> estará vacía.  <em>sockaddr</em> es un tupla describiendo una dirección de socket, cuyo formato depende del devuelto <em>family</em> (una <code class="docutils literal notranslate"><span class="pre">(address,</span> <span class="pre">port)</span></code> tupla de 2 para <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a>, una <code class="docutils literal notranslate"><span class="pre">(address,</span> <span class="pre">port,</span> <span class="pre">flowinfo,</span> <span class="pre">scope_id)</span></code> una tupla de 4 para una <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a>), y está destinado a ser pasado a el método <a class="reference internal" href="#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.connect()</span></code></a>.</p>
<p class="audit-hook">Genera un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">socket.getaddrinfo</span></code> con los argumentos <code class="docutils literal notranslate"><span class="pre">host</span></code>, <code class="docutils literal notranslate"><span class="pre">port</span></code>, <code class="docutils literal notranslate"><span class="pre">family</span></code>, <code class="docutils literal notranslate"><span class="pre">type</span></code>, <code class="docutils literal notranslate"><span class="pre">protocol</span></code>.</p>
<p>En el ejemplo siguiente se obtiene información de dirección para una conexión TCP hipotética a <code class="docutils literal notranslate"><span class="pre">example.org</span></code> en el puerto 80 (los resultados pueden diferir en el sistema si IPv6 no está habilitado):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span><span class="s2">&quot;example.org&quot;</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="n">proto</span><span class="o">=</span><span class="n">socket</span><span class="o">.</span><span class="n">IPPROTO_TCP</span><span class="p">)</span>
<span class="go">[(socket.AF_INET6, socket.SOCK_STREAM,</span>
<span class="go"> 6, &#39;&#39;, (&#39;2606:2800:220:1:248:1893:25c8:1946&#39;, 80, 0, 0)),</span>
<span class="go"> (socket.AF_INET, socket.SOCK_STREAM,</span>
<span class="go"> 6, &#39;&#39;, (&#39;93.184.216.34&#39;, 80))]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>los parámetros ahora se pueden pasar mediante argumentos de palabra clave.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>para direcciones de multidifusión IPv6, la cadena que representa una dirección no contendrá partes <code class="docutils literal notranslate"><span class="pre">%scope_id</span></code>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.getfqdn">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">getfqdn</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.getfqdn" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un nombre de dominio completo para <em>name</em>. Si <em>name</em> se omite o está vacío, se interpreta como el host local. Para encontrar el nombre completo, se comprueba el nombre de host retornado por <a class="reference internal" href="#socket.gethostbyaddr" title="socket.gethostbyaddr"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostbyaddr()</span></code></a>, seguido de los alias del host, si están disponibles. Se selecciona el primer nombre que incluye un punto. En caso de que no haya disponible un nombre de dominio completo y se haya proporcionado <em>name</em>, se retorna sin cambios. Si <em>name</em> estaba vacío o era igual a <code class="docutils literal notranslate"><span class="pre">'0.0.0.0'</span></code>, se retorna el nombre de host de <a class="reference internal" href="#socket.gethostname" title="socket.gethostname"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostname()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.gethostbyname">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">gethostbyname</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hostname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.gethostbyname" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Traduce un nombre de host a un formato de dirección IPV4. La dirección IPV4 es retornada como una cadena, como <code class="docutils literal notranslate"><span class="pre">’100.50.200.5’</span></code>. Si el nombre de host es una dirección IPV4 en sí, se devuelve sin cambios. Observa <a class="reference internal" href="#socket.gethostbyname_ex" title="socket.gethostbyname_ex"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostbyname_ex()</span></code></a> para una interfaz mas completa. <a class="reference internal" href="#socket.gethostbyname" title="socket.gethostbyname"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostbyname()</span></code></a> no soporta la resolución de nombres IPV6, y <a class="reference internal" href="#socket.getaddrinfo" title="socket.getaddrinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> debe utilizarse en su lugar para compatibilidad con doble pila IPv4/v6.</p>
<p class="audit-hook">Genera un evento <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing</span></a> <code class="docutils literal notranslate"><span class="pre">socket.gethostbyname</span></code> con el argumento <code class="docutils literal notranslate"><span class="pre">hostname</span></code>.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not WASI.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.gethostbyname_ex">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">gethostbyname_ex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hostname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.gethostbyname_ex" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Traduce un nombre de host al formato de dirección IPv4, interfaz ampliada. Retorna un triple <code class="docutils literal notranslate"><span class="pre">(hostname,</span> <span class="pre">aliaslist,</span> <span class="pre">ipaddrlist)</span></code> donde <em>hostname</em> es el nombre de host principal del host, <em>aliaslist</em> es una lista (posiblemente vacía) de nombres de host alternativos para la misma dirección y <em>ipaddrlist</em> es una lista de direcciones IPv4 para la misma interfaz en el mismo host (a menudo, pero no siempre una sola dirección). <a class="reference internal" href="#socket.gethostbyname_ex" title="socket.gethostbyname_ex"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostbyname_ex()</span></code></a> no es compatible con la resolución de nombres IPv6 y, en su lugar, se debe utilizar <a class="reference internal" href="#socket.getaddrinfo" title="socket.getaddrinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> para el soporte de pila dual IPv4 / v6.</p>
<p class="audit-hook">Genera un evento <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing</span></a> <code class="docutils literal notranslate"><span class="pre">socket.gethostbyname</span></code> con el argumento <code class="docutils literal notranslate"><span class="pre">hostname</span></code>.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not WASI.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.gethostname">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">gethostname</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.gethostname" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una cadena que contenga el nombre de host de la máquina donde se está ejecutando actualmente el intérprete de Python.</p>
<p class="audit-hook">Genera un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">socket.gethostname</span></code> sin argumentos.</p>
<p>Nota: <a class="reference internal" href="#socket.gethostname" title="socket.gethostname"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostname()</span></code></a> no siempre retorna el nombre de dominio completo, usa <a class="reference internal" href="#socket.getfqdn" title="socket.getfqdn"><code class="xref py py-func docutils literal notranslate"><span class="pre">getfqdn()</span></code></a> para eso.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not WASI.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.gethostbyaddr">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">gethostbyaddr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ip_address</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.gethostbyaddr" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un triple <code class="docutils literal notranslate"><span class="pre">(hostname,</span> <span class="pre">aliaslist,</span> <span class="pre">ipaddrlist)</span></code> donde <em>hostname</em> es el nombre del host primario respondiendo de la misma <em>ip_address</em>, <em>aliaslist</em> es una (posiblemente vacía) lista de nombres de hosts alternativa, y <em>ipaddrlist</em> es una lista de direcciones IPV4/IPV6 para la misma interfaz y en el mismo host ( lo más probable es que contenga solo una dirección ). Para encontrar el nombre de dominio completo, use la función <a class="reference internal" href="#socket.getfqdn" title="socket.getfqdn"><code class="xref py py-func docutils literal notranslate"><span class="pre">getfqdn()</span></code></a>. <a class="reference internal" href="#socket.gethostbyaddr" title="socket.gethostbyaddr"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostbyaddr()</span></code></a> admite tanto IPv4 como IPv6.</p>
<p class="audit-hook">Generar un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">socket.gethostbyaddr</span></code> con los argumentos <code class="docutils literal notranslate"><span class="pre">ip_address</span></code>.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not WASI.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.getnameinfo">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">getnameinfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sockaddr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.getnameinfo" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Traduce una dirección de socket  <em>sockaddr</em> en una 2-tupla <code class="docutils literal notranslate"><span class="pre">(host,</span> <span class="pre">port)</span></code>. Dependiendo de la configuraciones de <em>flags</em>, el resultado puede contener un nombre de dominio completo o una representación numérica de la dirección en <em>host</em>. De igual manera, <em>port</em> puede contener un nombre de puerto de cadena de caracteres o un numero de puerto numérico.</p>
<p>Para las direcciones IPv6, <code class="docutils literal notranslate"><span class="pre">%scope</span></code> se anexa a la parte del host si <em>sockaddr</em> contiene <em>scopeid</em> significativo. Generalmente esto sucede para las direcciones de multidifusión.</p>
<p>Para mas información sobre <em>flags</em> pueden consultar <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/getnameinfo(3)">getnameinfo(3)</a></em>.</p>
<p class="audit-hook">Plantea un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">socket.getnameinfo</span></code> con el argumento <code class="docutils literal notranslate"><span class="pre">sockaddr</span></code>.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not WASI.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.getprotobyname">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">getprotobyname</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocolname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.getprotobyname" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Traduzca un nombre de protocolo de Internet (por ejemplo, <code class="docutils literal notranslate"><span class="pre">'icmp'</span></code>) a una constante adecuada para pasar como tercer argumento (opcional) a la función <code class="xref py py-func docutils literal notranslate"><span class="pre">socket()</span></code>. Esto normalmente sólo es necesario para sockets abiertos en modo «raw» (<a class="reference internal" href="#socket.SOCK_RAW" title="socket.SOCK_RAW"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_RAW</span></code></a>); para los modos de conexión normales, el protocolo correcto se elige automáticamente si el protocolo se omite o se pone a cero.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not WASI.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.getservbyname">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">getservbyname</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">servicename</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">protocolname</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.getservbyname" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Traduzca un nombre de servicio de Internet y un nombre de protocolo a un número de puerto para ese servicio. El nombre de protocolo opcional, si se proporciona, debe ser <code class="docutils literal notranslate"><span class="pre">'tcp'</span></code> o <code class="docutils literal notranslate"><span class="pre">'udp'</span></code>; de lo contrario, cualquier protocolo coincidirá.</p>
<p class="audit-hook">Genera un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">socket.getservbyname</span></code> con los argumentos <code class="docutils literal notranslate"><span class="pre">servicename</span></code>, <code class="docutils literal notranslate"><span class="pre">protocolname</span></code>.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not WASI.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.getservbyport">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">getservbyport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">port</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">protocolname</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.getservbyport" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Traduzca un número de puerto de Internet y un nombre de protocolo a un nombre de servicio para ese servicio. El nombre de protocolo opcional, si se proporciona, debe ser <code class="docutils literal notranslate"><span class="pre">'tcp'</span></code> o <code class="docutils literal notranslate"><span class="pre">'udp'</span></code>; de lo contrario, cualquier protocolo coincidirá.</p>
<p class="audit-hook">Genera un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">socket.getservbyport</span></code> con los argumentos <code class="docutils literal notranslate"><span class="pre">port</span></code>, <code class="docutils literal notranslate"><span class="pre">protocolname</span></code>.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not WASI.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.ntohl">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">ntohl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.ntohl" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierta enteros positivos de 32 bits de red a orden de bytes de host.  En equipos donde el orden de bytes de host es el mismo que el orden de bytes de red, se trata de un no-op; de lo contrario, realiza una operación de intercambio de 4 bytes.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.ntohs">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">ntohs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.ntohs" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierta enteros positivos de 16 bits de red a orden de bytes de host.  En equipos donde el orden de bytes de host es el mismo que el orden de bytes de red, se trata de un no-op; de lo contrario, realiza una operación de intercambio de 2 bytes.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Lanza <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a> si <em>x</em> no cabe en un entero sin signo de 16 bits.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.htonl">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">htonl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.htonl" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierta enteros positivos de 32 bits del host al orden de bytes de red.  En equipos donde el orden de bytes de host es el mismo que el orden de bytes de red, se trata de un no-op; de lo contrario, realiza una operación de intercambio de 4 bytes.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.htons">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">htons</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.htons" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierta enteros positivos de 16 bits del host al orden de bytes de red.  En equipos donde el orden de bytes de host es el mismo que el orden de bytes de red, se trata de un no-op; de lo contrario, realiza una operación de intercambio de 2 bytes.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Lanza <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a> si <em>x</em> no cabe en un entero sin signo de 16 bits.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.inet_aton">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">inet_aton</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ip_string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.inet_aton" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierte una dirección IPv4 desde el formato de cadena de cuatro puntos (por ejemplo, ‘123.45.67.89’) a formato binario empaquetado de 32 bits, como un objeto de bytes de cuatro caracteres de longitud. Esto es útil cuando se convierte con un programa que usa la librería estándar C y necesita objetos de tipo <code class="xref c c-struct docutils literal notranslate"><span class="pre">in_addr</span></code>, que es el tipo C para el binario empaquetado de 32 bits que devuelve esta función.</p>
<p>Ademas <code class="xref py py-func docutils literal notranslate"><span class="pre">inet_aton`acepta</span> <span class="pre">cadena</span> <span class="pre">de</span> <span class="pre">caracteres</span> <span class="pre">con</span> <span class="pre">menos</span> <span class="pre">de</span> <span class="pre">tres</span> <span class="pre">puntos,</span> <span class="pre">observar</span> <span class="pre">la</span> <span class="pre">pagina</span> <span class="pre">del</span> <span class="pre">manual</span> <span class="pre">Unix</span> <span class="pre">:manpage:`inet(3)()</span></code> para mas detalles.</p>
<p>Si la cadena de dirección IPv4 es pasada a esta función es invalido, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> se lanzará. Tenga en cuenta que exactamente lo que es valido depende de la implementación C de <code class="xref c c-func docutils literal notranslate"><span class="pre">inet_aton()</span></code>.</p>
<p><a class="reference internal" href="#socket.inet_aton" title="socket.inet_aton"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_aton()</span></code></a> no admite IPV6, y <a class="reference internal" href="#socket.inet_pton" title="socket.inet_pton"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_pton()</span></code></a> deberían utilizarse en su lugar para compatibilidad con doble pilas IPV4/v6.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.inet_ntoa">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">inet_ntoa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">packed_ip</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.inet_ntoa" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierte una dirección IPv4 empaquetada de 32 bits (un <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> cuatro bytes de longitud) a su representación estándar de cadena de cuatro puntos (por ejemplo ‘123.45.67.89’). Esto es útil cuando convertimos con un programa que usa la librería estándar C y necesita objetos de tipo <code class="xref c c-struct docutils literal notranslate"><span class="pre">in_addr</span></code>, que es el tipo C para los datos binarios empaquetados de 32 bits que esta función toma como argumento.</p>
<p>Si la secuencia de byte pasada a esta función no es exactamente 4 bytes de longitud  <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> podría generarse <a class="reference internal" href="#socket.inet_ntoa" title="socket.inet_ntoa"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_ntoa()</span></code></a> no soporta IPV6, y <a class="reference internal" href="#socket.inet_ntop" title="socket.inet_ntop"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_ntop()</span></code></a> debe utilizarse en su lugar para compatibilidad con doble pila IPv4 / v6.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Ahora se acepta la grabación <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.inet_pton">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">inet_pton</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address_family</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip_string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.inet_pton" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierte una dirección IP desde su formato de cadena específico de la familia a un formato binario empaquetado. <a class="reference internal" href="#socket.inet_pton" title="socket.inet_pton"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_pton()</span></code></a> es útil cuando una librería o protocolo de red llama desde un objeto de tipo <code class="xref c c-struct docutils literal notranslate"><span class="pre">in_addr</span></code> (similar a <a class="reference internal" href="#socket.inet_aton" title="socket.inet_aton"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_aton()</span></code></a>) o <code class="xref c c-struct docutils literal notranslate"><span class="pre">in6_addr</span></code>.</p>
<p>Los Valores soportados para <em>address_family</em> son actualmente <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a> y <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a>. Si la cadena de dirección IP <em>ip_string</em> no es válida, <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> se genera. Tenga en cuenta que exactamente lo que es válido depende tanto del valor de <em>address_family</em> como de la implementación subyacente de <code class="xref c c-func docutils literal notranslate"><span class="pre">inet_pton()</span></code>.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix, Windows.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Se ha añadido compatibilidad con Windows</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.inet_ntop">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">inet_ntop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address_family</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">packed_ip</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.inet_ntop" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierte una dirección IP empaquetada (un <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> de algún numero de bytes) a su representación estándar de cadena específica de la familia (por ejemplo <code class="docutils literal notranslate"><span class="pre">’7.10.0.5’</span></code> o <code class="docutils literal notranslate"><span class="pre">’5aef:2b::8’</span></code>). <a class="reference internal" href="#socket.inet_ntop" title="socket.inet_ntop"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_ntop()</span></code></a> es útil cuando una librería o protocolo de red retorna un objeto de tipo <code class="xref c c-struct docutils literal notranslate"><span class="pre">in_addr</span></code> (similar para <a class="reference internal" href="#socket.inet_ntoa" title="socket.inet_ntoa"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_ntoa()</span></code></a>) o <code class="xref c c-struct docutils literal notranslate"><span class="pre">in6_addr</span></code>.</p>
<p>Los valores soportados para <em>address_family</em> actualmente son <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a> y <a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a>. Si los objetos de bytes <em>packed_ip</em> no tienen la longitud correcta para la familia de direcciones especificas, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> podría generarse. <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> se genera para errores desde la llamada a <a class="reference internal" href="#socket.inet_ntop" title="socket.inet_ntop"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_ntop()</span></code></a>.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix, Windows.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Se ha añadido compatibilidad con Windows</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Ahora se acepta la grabación <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.CMSG_LEN">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">CMSG_LEN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.CMSG_LEN" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la longitud total, sin relleno de arrastre, de un elemento de datos auxiliares con datos asociados del <em>length</em>. Este valor se puede utilizar a menudo como tamaño de búfer para <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a> para recibir un solo valor de datos auxiliares, pero <span class="target" id="index-31"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3542.html"><strong>RFC 3542</strong></a> requiere aplicaciones portables para usar <a class="reference internal" href="#socket.CMSG_SPACE" title="socket.CMSG_SPACE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CMSG_SPACE()</span></code></a> y así incluir espacio para el relleno, incluso cuando el elemento será el último en el búfer. Genera  <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a> si <em>length</em> está fuera del rango de valores permitido.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix, not Emscripten, not WASI.</p>
<p>La mayoría de las plataformas Unix.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.CMSG_SPACE">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">CMSG_SPACE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.CMSG_SPACE" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el tamaño del buffer necesario por <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a> para recibir un elemento de datos auxiliares con datos asociados del <em>length</em> dado, junto con cualquier relleno final. El espacio de buffer necesario para recibir múltiples elementos es la suma de los valores de <a class="reference internal" href="#socket.CMSG_SPACE" title="socket.CMSG_SPACE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CMSG_SPACE()</span></code></a> para los datos asociados con la longitudes. Genera <a class="reference internal" href="exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a> si <em>length</em> está fuera del rango de valores permitido.</p>
<p>Tenga en cuenta que algunos sistemas pueden admitir datos auxiliares sin proporcionar esta función.  Tenga en cuenta también que establecer el tamaño del búfer utilizando los resultados de esta función puede no limitar con precisión la cantidad de datos auxiliares que se pueden recibir, ya que los datos adicionales pueden caber en el área de relleno.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix, not Emscripten, not WASI.</p>
<p>la mayoría de las plataformas Unix.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.getdefaulttimeout">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">getdefaulttimeout</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.getdefaulttimeout" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el tiempo de espera por defecto en segundos (flotante) para los objetos de un nuevo socket. Un valor de <code class="docutils literal notranslate"><span class="pre">None</span></code> indicada que los objetos del nuevo socket no tiene un tiempo de espera. Cuando el modulo socket es importado primero, por defecto es <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.setdefaulttimeout">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">setdefaulttimeout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">timeout</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.setdefaulttimeout" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Selecciona el tiempo de espera por defecto en segundos (flotante ) para los objetos nuevos del socket. Cuando el modulo socket es importado primero, el valor por defecto es <code class="docutils literal notranslate"><span class="pre">None</span></code>. Observar <a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">settimeout()</span></code></a> para posible valores y sus respectivos significados.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.sethostname">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">sethostname</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.sethostname" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece el nombre de host de la maquina en <em>name</em>. Esto genera un  <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> si no tiene suficientes derechos.</p>
<p class="audit-hook">Plantea un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">socket.sethostname</span></code> con el argumento <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.if_nameindex">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">if_nameindex</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.if_nameindex" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una lista de tuplas de información de interfaz de red (índice int, cadena de nombre). <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> si se produce un error en la llamada del sistema.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix, Windows, not Emscripten, not WASI.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Se ha agregado compatibilidad con Windows.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En Windows las interfaces de redes tienen diferentes nombres en diferentes contextos (todos los nombres son ejemplos):</p>
<ul class="simple">
<li><p>UUID: <code class="docutils literal notranslate"><span class="pre">{FB605B73-AAC2-49A6-9A2F-25416AEA0573}</span></code></p></li>
<li><p>nombre: <code class="docutils literal notranslate"><span class="pre">ethernet_32770</span></code></p></li>
<li><p>nombre amigable: <code class="docutils literal notranslate"><span class="pre">vEthernet</span> <span class="pre">(nat)</span></code></p></li>
<li><p>descripción: <code class="docutils literal notranslate"><span class="pre">Hyper-V</span> <span class="pre">Virtual</span> <span class="pre">Ethernet</span> <span class="pre">Adapter</span></code></p></li>
</ul>
<p>Esta función retorna los nombres del segundo formulario de la lista, en este caso de ejemplo <code class="docutils literal notranslate"><span class="pre">ethernet_32770</span></code>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.if_nametoindex">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">if_nametoindex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">if_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.if_nametoindex" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un número de índice de interfaz de red correspondiente a un nombre de interfaz. <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> si no existe ninguna interfaz con el nombre especificado.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix, Windows, not Emscripten, not WASI.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Se ha agregado compatibilidad con Windows.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>“”Interface name” es un nombre como se documenta en <a class="reference internal" href="#socket.if_nameindex" title="socket.if_nameindex"><code class="xref py py-func docutils literal notranslate"><span class="pre">if_nameindex()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.if_indextoname">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">if_indextoname</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">if_index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.if_indextoname" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un nombre de interfaz de red correspondiente a un número de índice de interfaz. <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> si no existe ninguna interfaz con el índice dado.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix, Windows, not Emscripten, not WASI.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Se ha agregado compatibilidad con Windows.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>“”Interface name” es un nombre como se documenta en <a class="reference internal" href="#socket.if_nameindex" title="socket.if_nameindex"><code class="xref py py-func docutils literal notranslate"><span class="pre">if_nameindex()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.send_fds">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">send_fds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fds</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.send_fds" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Envíe la lista de descriptores de archivo <em>fds</em> a través de un conector <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a> <em>sock</em>. El parámetro <em>fds</em> es una secuencia de descriptores de archivo. Consulte <code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmsg()</span></code> para obtener la documentación de estos parámetros.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix, Windows, not Emscripten, not WASI.</p>
<p>Plataformas Unix que soporten <a class="reference internal" href="#socket.socket.sendmsg" title="socket.socket.sendmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmsg()</span></code></a> y el mecanismo <code class="xref py py-const docutils literal notranslate"><span class="pre">SCM_RIGHTS</span></code>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="socket.recv_fds">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">recv_fds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bufsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxfds</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.recv_fds" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Reciba descriptores de archivo hasta <em>maxfds</em> desde un socket <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a> <em>sock</em>. Retorna <code class="docutils literal notranslate"><span class="pre">(msg,</span> <span class="pre">list(fds),</span> <span class="pre">flags,</span> <span class="pre">addr)</span></code>. Consulte <code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code> para obtener la documentación de estos parámetros.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix, Windows, not Emscripten, not WASI.</p>
<p>Plataformas Unix que soporten <a class="reference internal" href="#socket.socket.sendmsg" title="socket.socket.sendmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmsg()</span></code></a> y el mecanismo <code class="xref py py-const docutils literal notranslate"><span class="pre">SCM_RIGHTS</span></code>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.9.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Cualquier número entero truncado al final de la lista de descriptores de archivo.</p>
</div>
</dd></dl>

</section>
</section>
</section>
<section id="socket-objects">
<span id="id1"></span><h2>Objetos Socket<a class="headerlink" href="#socket-objects" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los objetos socket tienen los siguientes métodos. Excepto para <a class="reference internal" href="#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a>, esto corresponde al sistema de llamadas Unix para sockets.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>El soporte para el protocolo <a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">context manager</span></a> ha sido agregado. Salir del gestor de contexto es equivalente para el llamado <a class="reference internal" href="#socket.close" title="socket.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.accept">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">accept</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.accept" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Acepta una conexión. El socket debe estar vinculado a una dirección y estar escuchando las conexiones. El valor de retorno es el par <code class="docutils literal notranslate"><span class="pre">(conn,</span> <span class="pre">address)</span></code> cuando <em>conn</em> es un <em>new</em> objeto socket usado para enviar y recibir información en la conexión, y <em>address</em> es la dirección vinculada al socket en el extremo de la conexión.</p>
<p>El socket recién creado es <a class="reference internal" href="os.html#fd-inheritance"><span class="std std-ref">non-inheritable</span></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>El socket ahora no es heredable.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Si se interrumpe la llamada del sistema y el controlador de señal no genera una excepción, el método ahora vuelve a intentar la llamada del sistema en lugar de generar una excepción <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> (consulte <span class="target" id="index-32"></span><a class="pep reference external" href="https://peps.python.org/pep-0475/"><strong>PEP 475</strong></a> para la lógica).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.bind">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">bind</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.bind" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Enlaza el socket a <em>address</em>. El socket no debe estar ya unido. (El formato de <em>address</em> depende de la familia de direcciones, consulte más arriba).</p>
<p class="audit-hook">Genera un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">socket.getaddrinfo</span></code> con los argumentos <code class="docutils literal notranslate"><span class="pre">host</span></code>, <code class="docutils literal notranslate"><span class="pre">port</span></code>, <code class="docutils literal notranslate"><span class="pre">family</span></code>, <code class="docutils literal notranslate"><span class="pre">type</span></code>, <code class="docutils literal notranslate"><span class="pre">protocol</span></code>.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not WASI.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.close">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.close" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Marca el socket cerrado. El recurso del sistema subyacente (ej. un descriptor de archivo) también se cierra cuando todos los objetos de archivo de <a class="reference internal" href="#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a> están cerrados. Una vez que eso suceda, todas las operaciones futuras en el objeto socket fallarán. El extremo remoto no recibirá más datos (después de que se vacíen los datos en cola).</p>
<p>Los sockets se cierran automáticamente cuando se recogen basura, pero se recomienda <code class="xref py py-meth docutils literal notranslate"><span class="pre">cerrarlos()</span></code> explícitamente, o usar una instrucción <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> alrededor de ellos.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span><a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> ahora se lanza si se produce un error cuando se realiza la llamada <code class="xref c c-func docutils literal notranslate"><span class="pre">close()</span></code> subyacente.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p><a class="reference internal" href="#socket.close" title="socket.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> libera el recurso asociado a una conexión, pero no necesariamente cierra la conexión inmediatamente.  Si desea cerrar la conexión a tiempo, llame a <a class="reference internal" href="#socket.socket.shutdown" title="socket.socket.shutdown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shutdown()</span></code></a> antes de <a class="reference internal" href="#socket.close" title="socket.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.connect">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">connect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.connect" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Conectar a un socket remoto en <em>address</em>. (El formato de <em>address</em> depende de la familia de direcciones — ver arriba.)</p>
<p>Si la conexión es interrumpida por una señal, el método espera hasta que se complete la conexión, o lanza un <a class="reference internal" href="exceptions.html#TimeoutError" title="TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TimeoutError</span></code></a> en el tiempo de espera, si el manejador de señales no lanza una excepción y el socket se bloquea o tiene un tiempo de espera. Para sockets sin bloqueo, el método lanza una excepción <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> si la conexión es interrumpida por una señal (o la excepción lanzada por el manejador de señales).</p>
<p class="audit-hook">Genera un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">socket.connect</span></code> con los argumentos <code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">address</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>El método ahora espera hasta que se completa la conexión en lugar de generar una excepción <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> si la conexión se interrumpe por una señal, el controlador de señal no genera una excepción y el socket está bloqueando o tiene un tiempo de espera (consulte el <span class="target" id="index-33"></span><a class="pep reference external" href="https://peps.python.org/pep-0475/"><strong>PEP 475</strong></a> para la razón de ser).</p>
</div>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not WASI.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.connect_ex">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">connect_ex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.connect_ex" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Similar a <code class="docutils literal notranslate"><span class="pre">connect(address)</span></code>, pero retorna un indicador de error en lugar de generar una excepción para los errores retornados por la llamada de nivel C <code class="xref c c-func docutils literal notranslate"><span class="pre">connect()</span></code> (otros problemas, como “host no encontrado”, aún pueden generar excepciones). El indicador de error es <code class="docutils literal notranslate"><span class="pre">0</span></code> si la operación tuvo éxito, caso contrario es el valor de la variable <code class="xref c c-data docutils literal notranslate"><span class="pre">errno</span></code>. Esto es útil para admitir, por ejemplo, conexiones asincrónicas.</p>
<p class="audit-hook">Genera un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">socket.connect</span></code> con los argumentos <code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">address</span></code>.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not WASI.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.detach">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">detach</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.detach" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Coloque el objeto de socket en estado cerrado sin cerrar realmente el descriptor de archivo subyacente.  Se devuelve el descriptor de archivo y se puede reutilizar para otros fines.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.dup">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">dup</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.dup" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Duplica el socket.</p>
<p>El socket recién creado es <a class="reference internal" href="os.html#fd-inheritance"><span class="std std-ref">non-inheritable</span></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>El socket ahora no es heredable.</p>
</div>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not WASI.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.fileno">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">fileno</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.fileno" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un archivo descriptor del socket (un entero pequeño), o -1 si falla. Esto es útil con <a class="reference internal" href="select.html#select.select" title="select.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select.select()</span></code></a>.</p>
<p>En Windows el pequeño entero retornado por este método no puede ser usado donde un descriptor de un archivo pueda ser usado (como una <a class="reference internal" href="os.html#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fdopen()</span></code></a>). Unix no tiene esta limitación.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.get_inheritable">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">get_inheritable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.get_inheritable" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Obtiene el <a class="reference internal" href="os.html#fd-inheritance"><span class="std std-ref">inheritable flag</span></a> del descriptor del archivo del socket o el controlador del socket: <code class="docutils literal notranslate"><span class="pre">True</span></code> si el socket puede ser heredada en procesos secundarios, <code class="docutils literal notranslate"><span class="pre">False</span></code> si falla.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.getpeername">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">getpeername</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.getpeername" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la dirección remota a la que esta conectado el socket. Esto es útil para averiguar el número de puerto de un socket IPv4/v6 remoto, por ejemplo. (El formato de la dirección devuelta depende de la familia de direcciones, consulte más arriba). En algunos sistemas, esta función no es compatible.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.getsockname">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">getsockname</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.getsockname" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la dirección del propio socket. Esto es útil para descubrir el numero de puerto de un socket IPv4/IPv6, por ejemplo. (El formato de la dirección devuelta depende de la familia de direcciones, consulte más arriba).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.getsockopt">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">getsockopt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optname</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">buflen</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.getsockopt" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el valor de la opción de socket dada (consulte la página de comando man de Unix <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/getsockopt(2)">getsockopt(2)</a></em>).  Las constantes simbólicas necesarias (<code class="xref py py-const docutils literal notranslate"><span class="pre">SO_*</span></code> etc.) se definen en este módulo.  Si <em>buflen</em> está ausente, se asume una opción de entero y la función retorna su valor entero.  Si <em>buflen</em> está presente, especifica la longitud máxima del búfer utilizado para recibir la opción y este búfer se devuelve como un objeto bytes.  Depende del autor de la llamada descodificar el contenido del búfer (consulte el módulo integrado opcional <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> para obtener una manera de decodificar las estructuras C codificadas como cadenas de bytes).</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not WASI.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.getblocking">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">getblocking</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.getblocking" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si el socket está en modo de bloqueo, <code class="docutils literal notranslate"><span class="pre">False</span></code> si está en sin bloqueo.</p>
<p>Esto es equivalente a comprobar <code class="docutils literal notranslate"><span class="pre">socket.gettimeout()</span> <span class="pre">==</span> <span class="pre">0</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.gettimeout">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">gettimeout</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.gettimeout" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el tiempo de espera en segundos (flotante) asociado con las operaciones del socket, o <code class="docutils literal notranslate"><span class="pre">None</span></code> si el tiempo de espera no es seleccionado. Esto refleja la ultima llamada al <a class="reference internal" href="#socket.socket.setblocking" title="socket.socket.setblocking"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setblocking()</span></code></a> o <a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">settimeout()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.ioctl">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">ioctl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">control</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">option</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.ioctl" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">plataforma</dt>
<dd class="field-odd"><p>Windows</p>
</dd>
</dl>
<p>El método <a class="reference internal" href="#socket.socket.ioctl" title="socket.socket.ioctl"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ioctl()</span></code></a> es una interfaz limitada para el sistema de interfaces WSAIoctl. Por favor refiérase a <a class="reference external" href="https://msdn.microsoft.com/en-us/library/ms741621%28VS.85%29.aspx">Win32 documentation</a> para mas información.</p>
<p>En otras plataformas, las funciones genéricas <a class="reference internal" href="fcntl.html#fcntl.fcntl" title="fcntl.fcntl"><code class="xref py py-func docutils literal notranslate"><span class="pre">fcntl.fcntl()</span></code></a> y <a class="reference internal" href="fcntl.html#fcntl.ioctl" title="fcntl.ioctl"><code class="xref py py-func docutils literal notranslate"><span class="pre">fcntl.ioctl()</span></code></a> podrían ser usadas; ellas aceptan un objeto socket como su primer argumento.</p>
<p>Actualmente solo el siguiente control de códigos está soportados: <code class="docutils literal notranslate"><span class="pre">SIO_RCVALL</span></code>, <code class="docutils literal notranslate"><span class="pre">SIO_KEEPALIVE_VALS</span></code>, y <code class="docutils literal notranslate"><span class="pre">SIO_LOOPBACK_FAST_PATH</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span><code class="docutils literal notranslate"><span class="pre">SIO_LOOPBACK_FAST_PATH</span></code> ha sido agregado.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.listen">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">listen</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">backlog</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.listen" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Habilita un servidor para aceptar conexiones. Si <em>backlog</em> es especifico, debe ser al menos 0 (si es menor, se establece en 0); especifica el número de conexiones no aceptadas que permitirá el sistema antes de rechazar nuevas conexiones. Si no se especifica, se elige un valor razonable predeterminado.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not WASI.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>El parámetro <em>backlog</em> ahora es opcional.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.makefile">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">makefile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffering</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">newline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.makefile" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p id="index-6">Retorna un <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a> asociado con el socket. El tipo exacto retornado depende de los argumentos dados a <a class="reference internal" href="#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a>. Estos argumentos se interpretan de la misma forma que la función <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>, excepto que los únicos valores de <em>mode</em> admitidos son <code class="docutils literal notranslate"><span class="pre">’r’</span></code> (default), <code class="docutils literal notranslate"><span class="pre">’w’</span></code> and <code class="docutils literal notranslate"><span class="pre">’b’</span></code>.</p>
<p>El socket debe estar en modo de bloqueo; puede tener un tiempo de espera, pero el búfer interno del objeto de archivo puede terminar en un estado incoherente si se produce un tiempo de espera.</p>
<p>Cerrar el objeto de archivo devuelto por <a class="reference internal" href="#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a> no cerrará el socket original a menos que se hayan cerrado todos los demás objetos de archivo y <a class="reference internal" href="#socket.close" title="socket.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.close()</span></code></a> se haya llamado al objeto socket.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En Windows, el objeto similar a un archivo creado por <a class="reference internal" href="#socket.socket.makefile" title="socket.socket.makefile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a> no se puede utilizar cuando se espera un objeto de archivo con un descriptor de archivo, como los argumentos de secuencia de <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subprocess.Popen()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.recv">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">recv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bufsize</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.recv" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Recibir datos del socket.  El valor devuelto es un objeto bytes que representa los datos recibidos.  <em>bufsize</em> especifica la cantidad máxima de datos que se recibirán a la vez.  Consulte la página del manual de Unix <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/recv(2)">recv(2)</a></em> para conocer el significado del argumento opcional <em>flags</em>; por defecto es cero.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Para una mejor coincidencia con las realidades de hardware y red, el valor de <em>bufsize</em> debe ser una potencia relativamente pequeña de 2, por ejemplo, 4096.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Si se interrumpe la llamada del sistema y el controlador de señal no genera una excepción, el método ahora vuelve a intentar la llamada del sistema en lugar de generar una excepción <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> (consulte <span class="target" id="index-34"></span><a class="pep reference external" href="https://peps.python.org/pep-0475/"><strong>PEP 475</strong></a> para la lógica).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.recvfrom">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">recvfrom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bufsize</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.recvfrom" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Recibe datos desde el socket. El valor de retorno es un par <code class="docutils literal notranslate"><span class="pre">(bytes,</span> <span class="pre">address)</span></code> donde <em>bytes</em> es un objeto de bytes que representa los datos recibidos y <em>address</em> es la dirección de el socket enviando los datos. Observar la pagina del manual Unix <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/recv(2)">recv(2)</a></em> para el significado del argumento opcional <em>flags</em>; por defecto es cero. (El formato de <em>address</em> depende de la familia de direcciones, consulte más arriba).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Si se interrumpe la llamada del sistema y el controlador de señal no genera una excepción, el método ahora vuelve a intentar la llamada del sistema en lugar de generar una excepción <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> (consulte <span class="target" id="index-35"></span><a class="pep reference external" href="https://peps.python.org/pep-0475/"><strong>PEP 475</strong></a> para la lógica).</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Para direcciones IPv6 de multidifusión, el primer elemento de <em>address</em> ya no contiene la parte <code class="docutils literal notranslate"><span class="pre">%scope_id</span></code>. Para obtener la dirección IPV6 completa, use <a class="reference internal" href="#socket.getnameinfo" title="socket.getnameinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getnameinfo()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.recvmsg">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">recvmsg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bufsize</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">ancbufsize</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.recvmsg" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Reciba datos normales (hasta <em>bufsize</em> bytes) y datos auxiliares del socket.  El argumento <em>ancbufsize</em> establece el tamaño en bytes del búfer interno utilizado para recibir los datos auxiliares; el valor predeterminado es 0, lo que significa que no se recibirán datos auxiliares.  Los tamaños de búfer adecuados para los datos auxiliares se pueden calcular mediante <a class="reference internal" href="#socket.CMSG_SPACE" title="socket.CMSG_SPACE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CMSG_SPACE()</span></code></a> o <a class="reference internal" href="#socket.CMSG_LEN" title="socket.CMSG_LEN"><code class="xref py py-func docutils literal notranslate"><span class="pre">CMSG_LEN()</span></code></a>, y los elementos que no caben en el búfer pueden truncarse o descartarse.  El valor predeterminado del argumento <em>flags</em> es 0 y tiene el mismo significado que para <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a>.</p>
<p>El valor de retorno es una tupla de 4: <code class="docutils literal notranslate"><span class="pre">(data,</span> <span class="pre">ancdata,</span> <span class="pre">msg_flags,</span> <span class="pre">address)</span></code>. El valor <em>data</em> es un objeto <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> que contiene los datos no auxiliares recibidos. El valor <em>ancdata</em> es una lista de cero o mas tuplas <code class="docutils literal notranslate"><span class="pre">(cmsg_level,</span> <span class="pre">cmsg_type,</span> <span class="pre">cmsg_data)</span></code> representado los datos auxiliares (control de mensajes) recibidos: <em>cmsg_level</em> y <em>cmsg_type</em> son enteros especificando el nivel de protocolo y tipo específico de protocolo respectivamente, y <em>cmsg_data</em> es un objeto <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> sosteniendo los datos asociados. El valor <em>msg_flags</em> es el OR bit a bit de varios indicadores que indican condiciones en el mensaje recibido; consulte la documentación de su sistema para obtener más detalles. Si la toma de recepción no está conectada, <em>address</em> es la dirección de el socket enviado, si está disponible; de lo contrario, su valor no se especifica.</p>
<p>En algunos sistemas, <a class="reference internal" href="#socket.socket.sendmsg" title="socket.socket.sendmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmsg()</span></code></a> y <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a> pueden utilizarse para pasar descriptores de fichero entre procesos a través de un socket <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>.  Cuando se utiliza esta funcionalidad (a menudo está restringida a los sockets <a class="reference internal" href="#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>), <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a> devolverá, en sus datos auxiliares, elementos del formulario <code class="docutils literal notranslate"><span class="pre">(socket.SOL_SOCKET,</span> <span class="pre">socket.SCM_RIGHTS,</span> <span class="pre">fds)</span></code>, donde <em>fds</em> es un objeto <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> que representa los nuevos descriptores de archivo como una arreglo binario del tipo nativo C <span class="c-expr sig sig-inline c"><span class="kt">int</span></span>.  Si <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a> lanza una excepción después del retorno de la llamada al sistema, primero intentará cerrar cualquier descriptor de fichero recibido a través de este mecanismo.</p>
<p>Algunos sistemas no indican la longitud truncada de los elementos de datos auxiliares que solo se han recibido parcialmente.  Si un elemento parece extenderse más allá del final del búfer, <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a> emitirá un <a class="reference internal" href="exceptions.html#RuntimeWarning" title="RuntimeWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeWarning</span></code></a>, y devolverá la parte de él que está dentro del búfer siempre que no se haya truncado antes del inicio de sus datos asociados.</p>
<p>En sistemas donde soporta el mecanismo <code class="xref py py-const docutils literal notranslate"><span class="pre">SCM_RIGHTS</span></code>, la siguiente función recibirá un descriptor de archivos <em>maxfds</em>, devolviendo el mensaje de datos y un lista que contiene los descriptores (mientras se ignoran las condiciones inesperadas, como la recepción de mensajes de control no relacionados). Ver también <a class="reference internal" href="#socket.socket.sendmsg" title="socket.socket.sendmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmsg()</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">array</span>

<span class="k">def</span> <span class="nf">recv_fds</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msglen</span><span class="p">,</span> <span class="n">maxfds</span><span class="p">):</span>
    <span class="n">fds</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>   <span class="c1"># Array of ints</span>
    <span class="n">msg</span><span class="p">,</span> <span class="n">ancdata</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recvmsg</span><span class="p">(</span><span class="n">msglen</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">CMSG_LEN</span><span class="p">(</span><span class="n">maxfds</span> <span class="o">*</span> <span class="n">fds</span><span class="o">.</span><span class="n">itemsize</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">cmsg_level</span><span class="p">,</span> <span class="n">cmsg_type</span><span class="p">,</span> <span class="n">cmsg_data</span> <span class="ow">in</span> <span class="n">ancdata</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cmsg_level</span> <span class="o">==</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span> <span class="ow">and</span> <span class="n">cmsg_type</span> <span class="o">==</span> <span class="n">socket</span><span class="o">.</span><span class="n">SCM_RIGHTS</span><span class="p">:</span>
            <span class="c1"># Append data, ignoring any truncated integers at the end.</span>
            <span class="n">fds</span><span class="o">.</span><span class="n">frombytes</span><span class="p">(</span><span class="n">cmsg_data</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">cmsg_data</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cmsg_data</span><span class="p">)</span> <span class="o">%</span> <span class="n">fds</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">msg</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">fds</span><span class="p">)</span>
</pre></div>
</div>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p>
<p>La mayoría de las plataformas Unix.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Si se interrumpe la llamada del sistema y el controlador de señal no genera una excepción, el método ahora vuelve a intentar la llamada del sistema en lugar de generar una excepción <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> (consulte <span class="target" id="index-36"></span><a class="pep reference external" href="https://peps.python.org/pep-0475/"><strong>PEP 475</strong></a> para la lógica).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.recvmsg_into">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">recvmsg_into</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffers</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">ancbufsize</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.recvmsg_into" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Recibir datos normales y datos auxiliares desde el socket, comportándose como <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a> lo haría, pero dispersar los datos no auxiliares en una serie de buffers en lugar de devolver un nuevo objeto bytes.  El argumento <em>buffers</em> debe ser un iterable de objetos que exportan buffers de escritura (por ejemplo, objetos <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>); estos se llenarán con fragmentos sucesivos de los datos no auxiliares hasta que se hayan escrito todos o no haya más buffers.  El sistema operativo puede establecer un límite (<a class="reference internal" href="os.html#os.sysconf" title="os.sysconf"><code class="xref py py-func docutils literal notranslate"><span class="pre">sysconf()</span></code></a> valor <code class="docutils literal notranslate"><span class="pre">SC_IOV_MAX</span></code>) en el número de buffers que se pueden utilizar.  Los argumentos <em>ancbufsize</em> y <em>flags</em> tienen el mismo significado que para <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a>.</p>
<p>El valor de retorno es tupla de 4: <code class="docutils literal notranslate"><span class="pre">(nbytes,</span> <span class="pre">ancdata,</span> <span class="pre">msg_flags,</span> <span class="pre">address)</span></code>, donde <em>nbytes</em> es el numero total de bytes de datos no auxiliares escrito dentro de los bufetes, y <em>ancdata</em>, <em>msg_flags</em> y <em>address</em> son lo mismo que para <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a>.</p>
<p>Ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">socket</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socketpair</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b1</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;----&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;0123456789&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b3</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;--------------&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Mary had a little lamb&#39;</span><span class="p">)</span>
<span class="go">22</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span><span class="o">.</span><span class="n">recvmsg_into</span><span class="p">([</span><span class="n">b1</span><span class="p">,</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b2</span><span class="p">)[</span><span class="mi">2</span><span class="p">:</span><span class="mi">9</span><span class="p">],</span> <span class="n">b3</span><span class="p">])</span>
<span class="go">(22, [], 0, None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">]</span>
<span class="go">[bytearray(b&#39;Mary&#39;), bytearray(b&#39;01 had a 9&#39;), bytearray(b&#39;little lamb---&#39;)]</span>
</pre></div>
</div>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p>
<p>La mayoría de las plataformas Unix.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.recvfrom_into">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">recvfrom_into</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">nbytes</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.recvfrom_into" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Reciba datos del socket, escribiéndolo en <em>buffer</em> en lugar de crear una nueva cadena de bytes.  El valor devuelto es un par <code class="docutils literal notranslate"><span class="pre">(nbytes,</span> <span class="pre">address)</span></code> donde <em>nbytes</em> es el número de bytes recibidos y <em>address</em> es la dirección del socket que envía los datos.  Consulte la página del manual de Unix <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/recv(2)">recv(2)</a></em> para conocer el significado del argumento opcional <em>flags</em>; por defecto es cero.  (El formato de <em>address</em> depende de la familia de direcciones — ver arriba.)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.recv_into">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">recv_into</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">nbytes</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.recv_into" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Recibe hasta <em>nbytes</em> bytes desde el socket, almacenado los datos en un búfer en lugar de crear una nueva cadena de bytes. Si <em>nbytes</em> no esta especificado (o 0), recibir hasta el tamaño disponible en el búfer dado. Retorna  el número de bytes recibidos. Ver la página del manual de Unix <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/recv(2)">recv(2)</a></em> para el significado del argumento opcional <em>flags</em>; por defecto es cero.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.send">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">send</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bytes</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.send" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Enviar datos al socket.  El socket debe estar conectado a un socket remoto.  El argumento opcional <em>flags</em> tiene el mismo significado que para <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a> arriba. Retorna el número de bytes enviados. Las aplicaciones son responsables de comprobar que se han enviado todos los datos; si sólo se transmitieron algunos de los datos, la aplicación debe intentar la entrega de los datos restantes. Para obtener más información sobre este tema, consulte <a class="reference internal" href="../howto/sockets.html#socket-howto"><span class="std std-ref">HOW TO - Programación con sockets</span></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Si se interrumpe la llamada del sistema y el controlador de señal no genera una excepción, el método ahora vuelve a intentar la llamada del sistema en lugar de generar una excepción <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> (consulte <span class="target" id="index-37"></span><a class="pep reference external" href="https://peps.python.org/pep-0475/"><strong>PEP 475</strong></a> para la lógica).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.sendall">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">sendall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bytes</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.sendall" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Enviar datos al socket.  El socket debe estar conectado a un socket remoto.  El argumento opcional <em>flags</em> tiene el mismo significado que para <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a> arriba. A diferencia de <a class="reference internal" href="#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a>, este método continúa enviando datos desde <em>bytes</em> hasta que se han enviado todos los datos o se produce un error.  <code class="docutils literal notranslate"><span class="pre">Ninguno</span></code> se devuelve en caso de éxito.  Por error, se genera una excepción y no hay forma de determinar cuántos datos, si los hay, se enviaron correctamente.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>El tiempo de espera del socket no se restablece más cada vez que los datos se envían correctamente. El tiempo de espera del socket es ahora la duración total máxima para enviar todos los datos.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Si se interrumpe la llamada del sistema y el controlador de señal no genera una excepción, el método ahora vuelve a intentar la llamada del sistema en lugar de generar una excepción <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> (consulte <span class="target" id="index-38"></span><a class="pep reference external" href="https://peps.python.org/pep-0475/"><strong>PEP 475</strong></a> para la lógica).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.sendto">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">sendto</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bytes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.sendto" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">sendto</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bytes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Enviar datos al socket.  El socket no debe estar conectado a un socket remoto, ya que el socket de destino se especifica mediante <em>address</em>.  El argumento opcional <em>flags</em> tiene el mismo significado que para <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a> arriba.  Devolver el número de bytes enviados. (El formato de <em>address</em> depende de la familia de direcciones — ver arriba.)</p>
<p class="audit-hook">Genera un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">socket.sendto</span></code> con los argumentos <code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">address</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Si se interrumpe la llamada del sistema y el controlador de señal no genera una excepción, el método ahora vuelve a intentar la llamada del sistema en lugar de generar una excepción <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> (consulte <span class="target" id="index-39"></span><a class="pep reference external" href="https://peps.python.org/pep-0475/"><strong>PEP 475</strong></a> para la lógica).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.sendmsg">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">sendmsg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffers</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">ancdata</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.sendmsg" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Enviar datos normales y auxiliares al socket, recopilar los datos no auxiliares de una serie de buffers y concatenando en un único mensaje.  El argumento <em>buffers</em> especifica los datos no auxiliares como un iterable de <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-como objetos</span></a> (por ejemplo: objetos <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>); el sistema operativo puede establecer un límite (<a class="reference internal" href="os.html#os.sysconf" title="os.sysconf"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.sysconf()</span></code></a> valor <code class="docutils literal notranslate"><span class="pre">SC_IOV_MAX</span></code>) en el número de buffers que se pueden utilizar.  El argumento <em>ancdata</em> especifica los datos auxiliares (mensajes de control) como un iterable de cero o más tuplas <code class="docutils literal notranslate"><span class="pre">(cmsg_level,</span> <span class="pre">cmsg_type,</span> <span class="pre">cmsg_data)</span></code>, donde <em>cmsg_level</em> y <em>cmsg_type</em> son enteros que especifican el nivel de protocolo y el tipo específico del protocolo respectivamente, y <em>cmsg_data</em> es un objeto similar a bytes que contiene los datos asociados.  Tenga en cuenta que algunos sistemas (en particular, sistemas sin <a class="reference internal" href="#socket.CMSG_SPACE" title="socket.CMSG_SPACE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CMSG_SPACE()</span></code></a>) pueden admitir el envío de solo un mensaje de control por llamada.  El valor predeterminado del argumento <em>flags</em> es 0 y tiene el mismo significado que para <a class="reference internal" href="#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a>.  Si se proporciona <em>address</em> y no <code class="docutils literal notranslate"><span class="pre">None</span></code>, establece una dirección de destino para el mensaje.  El valor devuelto es el número de bytes de datos no auxiliares enviados.</p>
<p>La siguiente función envía la lista de descriptores de archivos <em>fds</em> sobre un socket <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>, estos sistemas pueden soportar la mecánica <code class="xref py py-const docutils literal notranslate"><span class="pre">SCM_RIGHTS</span></code>. Observar también <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">array</span>

<span class="k">def</span> <span class="nf">send_fds</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">fds</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sock</span><span class="o">.</span><span class="n">sendmsg</span><span class="p">([</span><span class="n">msg</span><span class="p">],</span> <span class="p">[(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SCM_RIGHTS</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">fds</span><span class="p">))])</span>
</pre></div>
</div>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix, not WASI.</p>
<p>La mayoría de las plataformas Unix.</p>
</div>
<p class="audit-hook">Genera un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">socket.sendmsg</span></code> con los argumentos <code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">address</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Si se interrumpe la llamada del sistema y el controlador de señal no genera una excepción, el método ahora vuelve a intentar la llamada del sistema en lugar de generar una excepción <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> (consulte <span class="target" id="index-40"></span><a class="pep reference external" href="https://peps.python.org/pep-0475/"><strong>PEP 475</strong></a> para la lógica).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.sendmsg_afalg">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">sendmsg_afalg</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <span class="optional">]</span><em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">op</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">iv</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">assoclen</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.sendmsg_afalg" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Versión especializada de <a class="reference internal" href="#socket.socket.sendmsg" title="socket.socket.sendmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmsg()</span></code></a> para el socket <a class="reference internal" href="#socket.AF_ALG" title="socket.AF_ALG"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_ALG</span></code></a>. Modo de ajuste, IV, longitud de datos asociados a AEAD y banderas para el socket <a class="reference internal" href="#socket.AF_ALG" title="socket.AF_ALG"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_ALG</span></code></a>.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Linux &gt;= 2.6.38.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.6.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.sendfile">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">sendfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.sendfile" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Enviar un archivo hasta que se alcance EOF mediante el uso de alto rendimiento <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.sendfile</span></code></a> y devolver el número total de bytes que se enviaron. <em>file</em> debe ser un objeto de archivo normal abierto en modo binario. Si <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.sendfile</span></code></a> no está disponible (por ejemplo, Windows) o <em>file</em> no es un archivo normal <a class="reference internal" href="#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> se utilizará en su lugar. <em>offset</em> indica desde dónde empezar a leer el archivo. Si se especifica, <em>count</em> es el número total de bytes para transmitir en lugar de enviar el archivo hasta que se alcance EOF. La posición del archivo se actualiza a la vuelta o también en caso de error en cuyo caso <a class="reference internal" href="io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">file.tell()</span></code></a> se puede utilizar para averiguar el número de bytes que se enviaron. El socket debe ser de tipo <a class="reference internal" href="#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a> No se admiten sockets sin bloqueo.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.5.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.set_inheritable">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">set_inheritable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inheritable</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.set_inheritable" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Selecciona el <a class="reference internal" href="os.html#fd-inheritance"><span class="std std-ref">inheritable flag</span></a> descriptor del archivo del socket o el controlador del socket.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.setblocking">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">setblocking</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">flag</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.setblocking" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establecer el modo de bloqueo o no bloqueo del socket: si <em>flag</em> es false, el socket se establece en modo sin bloqueo, de lo contrario en modo de bloqueo.</p>
<p>El método es una abreviatura para ciertas llamadas <a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">settimeout()</span></code></a>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sock.setblocking(True)</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">sock.settimeout(None)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sock.setblocking(False)</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">sock.settimeout(0.0)</span></code></p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>El método ya no aplica la bandera <a class="reference internal" href="#socket.SOCK_NONBLOCK" title="socket.SOCK_NONBLOCK"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_NONBLOCK</span></code></a> en <a class="reference internal" href="#socket.socket.type" title="socket.socket.type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">socket.type</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.settimeout">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">settimeout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.settimeout" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Establece un tiempo de espera para bloquear las operaciones de socket. El argumento <em>value</em> puede ser un número de punto flotante no negativo que exprese segundos, o <code class="docutils literal notranslate"><span class="pre">None</span></code>. Si se da un valor distinto de cero, las operaciones subsiguientes de socket lanzarán una excepción <a class="reference internal" href="#socket.timeout" title="socket.timeout"><code class="xref py py-exc docutils literal notranslate"><span class="pre">timeout</span></code></a> si el período de tiempo de espera <em>value</em> ha transcurrido antes de que se complete la operación. Si se da cero, el socket se pone en modo sin bloqueo. Si se da <code class="docutils literal notranslate"><span class="pre">None</span></code>, el enchufe se pone en modo de bloqueo.</p>
<p>Para obtener más información, consulte las notas <a class="reference internal" href="#socket-timeouts"><span class="std std-ref">notas sobre los tiempos de espera del socket</span></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>El método ya no cambia la bandera <a class="reference internal" href="#socket.SOCK_NONBLOCK" title="socket.SOCK_NONBLOCK"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_NONBLOCK</span></code></a> en  <a class="reference internal" href="#socket.socket.type" title="socket.socket.type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">socket.type</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.setsockopt">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">setsockopt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="functions.html#int" title="int"><span class="pre">int</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.setsockopt" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">setsockopt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">buffer</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">setsockopt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optlen:</span> <span class="pre">int</span></span></em><span class="sig-paren">)</span></dt>
<dd><p id="index-14">Establece el valor de la opción de socket dada (consulte la página de manual de Unix <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/setsockopt(2)">setsockopt(2)</a></em>). Las constantes simbólicas necesarias se definen en el modulo <a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> (<code class="xref py py-const docutils literal notranslate"><span class="pre">SO_*</span></code> etc.). El valor puede ser un entero, <code class="docutils literal notranslate"><span class="pre">None</span></code> o un <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> representan un buffer. En el último caso, depende de la persona que llama asegurarse de que la cadena de bytes contenga los bits adecuados (consulte el módulo integrado opcional <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> para una forma de codificar estructuras C como cadenas de bytes). Cuando <em>value</em> se establece en <code class="docutils literal notranslate"><span class="pre">None</span></code>, el argumento <em>optlen</em> es requerido. Esto es equivalente a llamar a una función C <code class="xref c c-func docutils literal notranslate"><span class="pre">setsockopt()</span></code> con <code class="docutils literal notranslate"><span class="pre">optval=NULL</span></code> y <code class="docutils literal notranslate"><span class="pre">optlen=optlen</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Ahora se acepta la grabación <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>setsockopt(level, optname, None, optlen: int) form added.</p>
</div>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not WASI.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.shutdown">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">shutdown</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">how</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.shutdown" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Apague una o ambas mitades de la conexión. Si <em>how</em> es <code class="xref py py-const docutils literal notranslate"><span class="pre">SHUT_RD</span></code>, más recibe no se permiten. Si <em>how</em> es  <code class="xref py py-const docutils literal notranslate"><span class="pre">SHUT_WR</span></code>, mas recibe no se permiten. Si <em>how</em> es <code class="xref py py-const docutils literal notranslate"><span class="pre">SHUT_RDWR</span></code>, más recibe no se permiten.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: not WASI.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="socket.socket.share">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">share</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">process_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.share" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Duplica un socket y lo prepara para compartirlo con el proceso de destino. El proceso de destino debe estar provisto de <em>process_id</em>. el objeto de bytes resultante luego se puede pasar al proceso de destino usando alguna forma de comunicación entre procesos y el socket se puede recrear allí usando  <a class="reference internal" href="#socket.fromshare" title="socket.fromshare"><code class="xref py py-func docutils literal notranslate"><span class="pre">fromshare()</span></code></a>. Una vez que se ha llamado a este método, es seguro cerrar el socket ya que el sistema operativo ya lo ha duplicado para el proceso de destino.</p>
<div class="availability docutils container">
<p><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.3.</span></p>
</div>
</dd></dl>

<p>Tenga en cuenta que no hay métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> o <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code>; use <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a> y <a class="reference internal" href="#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> sin el argumento <em>flags</em> en su lugar.</p>
<p>Los objetos de socket también tienen estos atributos (de solo lectura) que corresponden a los valores dados al constructor <a class="reference internal" href="#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="socket.socket.family">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">family</span></span><a class="headerlink" href="#socket.socket.family" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>La familia socket.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="socket.socket.type">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">type</span></span><a class="headerlink" href="#socket.socket.type" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El tipo de socket.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="socket.socket.proto">
<span class="sig-prename descclassname"><span class="pre">socket.</span></span><span class="sig-name descname"><span class="pre">proto</span></span><a class="headerlink" href="#socket.socket.proto" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>The socket protocol.</p>
</dd></dl>

</section>
<section id="notes-on-socket-timeouts">
<span id="socket-timeouts"></span><h2>Notas sobre los tiempos de espera del socket<a class="headerlink" href="#notes-on-socket-timeouts" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Un objeto de socket puede estar en uno de los tres modos: bloqueo, no bloqueo o tiempo de espera.  Los sockets se crean de forma predeterminada siempre en modo de bloqueo, pero esto se puede cambiar llamando a <a class="reference internal" href="#socket.setdefaulttimeout" title="socket.setdefaulttimeout"><code class="xref py py-func docutils literal notranslate"><span class="pre">setdefaulttimeout()</span></code></a>.</p>
<ul class="simple">
<li><p>En el modo <em>bloqueo</em>, las operaciones se bloquean hasta que se completan o el sistema devuelve un error (como tiempo de espera de conexión agotado).</p></li>
<li><p>En el modo <em>sin bloqueo</em>, las operaciones fallan (con un error que, por desgracia, depende del sistema) si no se pueden completar inmediatamente: las funciones de <a class="reference internal" href="select.html#module-select" title="select: Wait for I/O completion on multiple streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">select</span></code></a> se pueden utilizar para saber cuándo y si un socket está disponible para leer o escribir.</p></li>
<li><p>En <em>timeout mode</em>, las operaciones fallan si no se puede completan el tiempo de espera especifico para el socket (ellos lanzan una excepción <a class="reference internal" href="#socket.timeout" title="socket.timeout"><code class="xref py py-exc docutils literal notranslate"><span class="pre">timeout</span></code></a>) o si el sistema devuelve un error.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En el nivel del sistema operativo, los sockets en el <em>timeout mode</em> se establecen internamente en modo sin bloqueo.  Además, los modos de bloqueo y tiempo de espera se comparten entre descriptores de archivo y objetos de socket que hacen referencia al mismo punto de conexión de red. Este detalle de implementación puede tener consecuencias visibles si, por ejemplo, decide utilizar el <a class="reference internal" href="#socket.socket.fileno" title="socket.socket.fileno"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fileno()</span></code></a> de un socket.</p>
</div>
<section id="timeouts-and-the-connect-method">
<h3>Tiempos de espera y el método <code class="docutils literal notranslate"><span class="pre">connect</span></code><a class="headerlink" href="#timeouts-and-the-connect-method" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La operación <a class="reference internal" href="#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a> también está sujeta a la configuración de tiempo de espera, y en general se recomienda llamar a <a class="reference internal" href="#socket.socket.settimeout" title="socket.socket.settimeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">settimeout()</span></code></a> antes de llamar a <a class="reference internal" href="#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a> o pasar un parámetro de tiempo de espera a <a class="reference internal" href="#socket.create_connection" title="socket.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_connection()</span></code></a>.  Sin embargo, la pila de red del sistema también puede devolver un error de tiempo de espera de conexión propio independientemente de cualquier configuración de tiempo de espera del socket de Python.</p>
</section>
<section id="timeouts-and-the-accept-method">
<h3>Tiempos de espera y el método <code class="docutils literal notranslate"><span class="pre">accept</span></code><a class="headerlink" href="#timeouts-and-the-accept-method" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Si <a class="reference internal" href="#socket.getdefaulttimeout" title="socket.getdefaulttimeout"><code class="xref py py-func docutils literal notranslate"><span class="pre">getdefaulttimeout()</span></code></a> no es una <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>, los sockets devuelto por el método <a class="reference internal" href="#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a> heredan ese tiempo de espera. De lo contrario, el comportamiento depende de la configuración de la toma de escucha:</p>
<ul class="simple">
<li><p>si los sockets están escuchando en <em>blocking mode</em> o en el <em>timeout mode</em>, el socket devuelve el <a class="reference internal" href="#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a> en un <em>blocking mode</em>;</p></li>
<li><p>si los sockets están escuchando en <em>non-blocking mode</em>, ya sea el socket devuelto por <a class="reference internal" href="#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a> es un modo de bloqueo o no bloque depende del sistema operativo. Si desea garantizar un comportamiento multiplataforma, se recomienda que se anule manualmente esta configuración.</p></li>
</ul>
</section>
</section>
<section id="example">
<span id="socket-example"></span><h2>Ejemplo<a class="headerlink" href="#example" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Aquí están cuatro programas mínimos usando el protocolo TCP/IP: un servidor que hace eco de todos los datos que reciban de vuelta ( Servicio a un solo cliente), y un cliente usando esto. Recuerde que un servidor debe llevar a cabo la secuencia <code class="xref py py-func docutils literal notranslate"><span class="pre">socket()</span></code>, <a class="reference internal" href="#socket.socket.bind" title="socket.socket.bind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bind()</span></code></a>, <a class="reference internal" href="#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">listen()</span></code></a>, <a class="reference internal" href="#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a> (posiblemente repitiendo la <a class="reference internal" href="#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a> para un servicio mas que un cliente), mientras un cliente solamente necesita la secuencia <code class="xref py py-func docutils literal notranslate"><span class="pre">socket()</span></code>, <a class="reference internal" href="#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a>. También recuerde que el servidor no <a class="reference internal" href="#socket.socket.sendall" title="socket.socket.sendall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendall()</span></code></a>/<a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a> en el socket esta escuchando pero en el nuevo socket devuelto por <a class="reference internal" href="#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a>.</p>
<p>Los dos primeros ejemplos solo admiten IPv4.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Echo server program</span>
<span class="kn">import</span> <span class="nn">socket</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>                 <span class="c1"># Symbolic name meaning all available interfaces</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">50007</span>              <span class="c1"># Arbitrary non-privileged port</span>
<span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
    <span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">))</span>
    <span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">conn</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">conn</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Connected by&#39;</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span> <span class="k">break</span>
            <span class="n">conn</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Echo client program</span>
<span class="kn">import</span> <span class="nn">socket</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="s1">&#39;daring.cwi.nl&#39;</span>    <span class="c1"># The remote host</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">50007</span>              <span class="c1"># The same port as used by the server</span>
<span class="k">with</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
    <span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">))</span>
    <span class="n">s</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello, world&#39;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Received&#39;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</pre></div>
</div>
<p>Los dos ejemplos siguientes son idénticos a los dos anteriores, pero admiten IPv4 e IPv6. El lado del servidor escuchará la primera familia de direcciones disponible (debe escuchar ambas en su lugar). En la mayoría de los sistemas listos para IPv6, IPv6 tendrá prioridad y es posible que el servidor no acepte tráfico IPv4. El lado del cliente intentará conectarse a todas las direcciones devueltas como resultado de la resolución de nombres y enviará el tráfico al primero conectado correctamente.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Echo server program</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="kc">None</span>               <span class="c1"># Symbolic name meaning all available interfaces</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">50007</span>              <span class="c1"># Arbitrary non-privileged port</span>
<span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">AF_UNSPEC</span><span class="p">,</span>
                              <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">AI_PASSIVE</span><span class="p">):</span>
    <span class="n">af</span><span class="p">,</span> <span class="n">socktype</span><span class="p">,</span> <span class="n">proto</span><span class="p">,</span> <span class="n">canonname</span><span class="p">,</span> <span class="n">sa</span> <span class="o">=</span> <span class="n">res</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">socktype</span><span class="p">,</span> <span class="n">proto</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">continue</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">sa</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">continue</span>
    <span class="k">break</span>
<span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;could not open socket&#39;</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">conn</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
<span class="k">with</span> <span class="n">conn</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Connected by&#39;</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span> <span class="k">break</span>
        <span class="n">conn</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Echo client program</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="s1">&#39;daring.cwi.nl&#39;</span>    <span class="c1"># The remote host</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">50007</span>              <span class="c1"># The same port as used by the server</span>
<span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">AF_UNSPEC</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">):</span>
    <span class="n">af</span><span class="p">,</span> <span class="n">socktype</span><span class="p">,</span> <span class="n">proto</span><span class="p">,</span> <span class="n">canonname</span><span class="p">,</span> <span class="n">sa</span> <span class="o">=</span> <span class="n">res</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">socktype</span><span class="p">,</span> <span class="n">proto</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">continue</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">sa</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">continue</span>
    <span class="k">break</span>
<span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;could not open socket&#39;</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">with</span> <span class="n">s</span><span class="p">:</span>
    <span class="n">s</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Hello, world&#39;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Received&#39;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</pre></div>
</div>
<p>El siguiente ejemplo muestra cómo escribir un rastreador de red muy simple con sockets sin procesar en Windows. El ejemplo requiere privilegios de administrador para modificar la interfaz:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>

<span class="c1"># the public network interface</span>
<span class="n">HOST</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">gethostbyname</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">gethostname</span><span class="p">())</span>

<span class="c1"># create a raw socket and bind it to the public interface</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_RAW</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">IPPROTO_IP</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1"># Include IP headers</span>
<span class="n">s</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">IPPROTO_IP</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">IP_HDRINCL</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># receive all packets</span>
<span class="n">s</span><span class="o">.</span><span class="n">ioctl</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SIO_RCVALL</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">RCVALL_ON</span><span class="p">)</span>

<span class="c1"># receive a packet</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="mi">65565</span><span class="p">))</span>

<span class="c1"># disabled promiscuous mode</span>
<span class="n">s</span><span class="o">.</span><span class="n">ioctl</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SIO_RCVALL</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">RCVALL_OFF</span><span class="p">)</span>
</pre></div>
</div>
<p>En el ejemplo siguiente se muestra cómo utilizar la interfaz de socket para comunicarse con una red CAN mediante el protocolo de socket sin procesar. Para utilizar CAN con el protocolo de gestor de difusión en su lugar, abra un socket con:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_CAN</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_DGRAM</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">CAN_BCM</span><span class="p">)</span>
</pre></div>
</div>
<p>Después de enlazar (<code class="xref py py-const docutils literal notranslate"><span class="pre">CAN_RAW</span></code>) o conectar (<a class="reference internal" href="#socket.CAN_BCM" title="socket.CAN_BCM"><code class="xref py py-const docutils literal notranslate"><span class="pre">CAN_BCM</span></code></a>) el socket, puede usar las operaciones <a class="reference internal" href="#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.send()</span></code></a> y <a class="reference internal" href="#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recv()</span></code></a> (y sus contrapartes) en el objeto de socket como de costumbre.</p>
<p>Este último ejemplo puede requerir privilegios especiales:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">struct</span>


<span class="c1"># CAN frame packing/unpacking (see &#39;struct can_frame&#39; in &lt;linux/can.h&gt;)</span>

<span class="n">can_frame_fmt</span> <span class="o">=</span> <span class="s2">&quot;=IB3x8s&quot;</span>
<span class="n">can_frame_size</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="n">can_frame_fmt</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">build_can_frame</span><span class="p">(</span><span class="n">can_id</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">can_dlc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">can_frame_fmt</span><span class="p">,</span> <span class="n">can_id</span><span class="p">,</span> <span class="n">can_dlc</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">dissect_can_frame</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
    <span class="n">can_id</span><span class="p">,</span> <span class="n">can_dlc</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">can_frame_fmt</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">can_id</span><span class="p">,</span> <span class="n">can_dlc</span><span class="p">,</span> <span class="n">data</span><span class="p">[:</span><span class="n">can_dlc</span><span class="p">])</span>


<span class="c1"># create a raw socket and bind it to the &#39;vcan0&#39; interface</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_CAN</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_RAW</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">CAN_RAW</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;vcan0&#39;</span><span class="p">,))</span>

<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">cf</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="n">can_frame_size</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Received: can_id=</span><span class="si">%x</span><span class="s1">, can_dlc=</span><span class="si">%x</span><span class="s1">, data=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">dissect_can_frame</span><span class="p">(</span><span class="n">cf</span><span class="p">))</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">cf</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error sending CAN frame&#39;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">build_can_frame</span><span class="p">(</span><span class="mh">0x01</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x01\x02\x03</span><span class="s1">&#39;</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error sending CAN frame&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Ejecutar un ejemplo varias veces con un retraso demasiado pequeño entre ejecuciones, podría dar lugar a este error:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ne">OSError</span><span class="p">:</span> <span class="p">[</span><span class="n">Errno</span> <span class="mi">98</span><span class="p">]</span> <span class="n">Address</span> <span class="n">already</span> <span class="ow">in</span> <span class="n">use</span>
</pre></div>
</div>
<p>Esto se debe a que la ejecución anterior ha dejado el socket en un estado <code class="docutils literal notranslate"><span class="pre">TIME_WAIT</span></code> y no se puede reutilizar inmediatamente.</p>
<p>Este es una bandera <a class="reference internal" href="#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> para establecer, en orden para prevenir esto, <code class="xref py py-data docutils literal notranslate"><span class="pre">socket.SO_REUSEADDR</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">))</span>
</pre></div>
</div>
<p>el indicador <code class="xref py py-data docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code> indica al kernel que reutilice un socket local en estado <code class="docutils literal notranslate"><span class="pre">TIME_WAIT</span></code>, sin esperar a que expire su tiempo de espera natural.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p>Para obtener una introducción a la programación de sockets (en C), consulte los siguientes documentos:</p>
<ul class="simple">
<li><p><em>An Introductory 4.3BSD Interprocess Communication Tutorial</em>, por Stuart Sechrest</p></li>
<li><p><em>An Advanced 4.3BSD Interprocess Communication Tutorial</em>, por Samuel J.  Leffler et al,</p></li>
</ul>
<p>ambos en el manual del programador de Unix, documentos suplementarios 1 ( secciones  PS1:7 y PS1:8). La plataforma especifica material de referencia para las diversas llamadas al sistema también son una valiosa fuente de información en los detalles de la semántica del socket. Para Unix, referencia a las paginas del manual, para Windows, observa la especificación WinSock (o WinSock 2). Para APIS listas IPV6, los lectores pueden querer referirse al titulado Extensiones básicas de interfaz de socket para IPv6 <span class="target" id="index-41"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3493.html"><strong>RFC 3493</strong></a> .</p>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code> — interfaz de red de bajo nivel</a><ul>
<li><a class="reference internal" href="#socket-families">Familias Socket</a></li>
<li><a class="reference internal" href="#module-contents">Contenido del módulo</a><ul>
<li><a class="reference internal" href="#exceptions">Excepciones</a></li>
<li><a class="reference internal" href="#constants">Constantes</a></li>
<li><a class="reference internal" href="#functions">Funciones</a><ul>
<li><a class="reference internal" href="#creating-sockets">Creación de sockets</a></li>
<li><a class="reference internal" href="#other-functions">Otras funciones</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#socket-objects">Objetos Socket</a></li>
<li><a class="reference internal" href="#notes-on-socket-timeouts">Notas sobre los tiempos de espera del socket</a><ul>
<li><a class="reference internal" href="#timeouts-and-the-connect-method">Tiempos de espera y el método <code class="docutils literal notranslate"><span class="pre">connect</span></code></a></li>
<li><a class="reference internal" href="#timeouts-and-the-accept-method">Tiempos de espera y el método <code class="docutils literal notranslate"><span class="pre">accept</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#example">Ejemplo</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="asyncio-dev.html"
                          title="capítulo anterior">Desarrollando con asyncio</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="ssl.html"
                          title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code> —Empaquetador o wrapper TLS/SSL para objetos de tipo socket</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.11/Doc/library/socket.rst"
            rel="nofollow">Ver fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="ssl.html" title="ssl —Empaquetador o wrapper TLS/SSL para objetos de tipo socket"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="asyncio-dev.html" title="Desarrollando con asyncio"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.11.2 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >Comunicación en redes y entre procesos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code> — interfaz de red de bajo nivel</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 23, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.5.0.
    </div>

  </body>
</html>