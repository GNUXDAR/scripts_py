
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>audioop — Manipula datos de audio sin procesar &#8212; documentación de Python - 3.10.10</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.10.10"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="cgi — Soporte de Interfaz de Entrada Común (CGI)" href="cgi.html" />
    <link rel="prev" title="asyncore — controlador de socket asincrónico" href="asyncore.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/audioop.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h4>Tema anterior</h4>
  <p class="topless"><a href="asyncore.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncore</span></code> — controlador de socket asincrónico</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="cgi.html"
                        title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cgi</span></code> — Soporte de Interfaz de Entrada Común (CGI)</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/audioop.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="cgi.html" title="cgi — Soporte de Interfaz de Entrada Común (CGI)"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="asyncore.html" title="asyncore — controlador de socket asincrónico"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La Biblioteca Estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="superseded.html" accesskey="U">Módulos Reemplazados</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code> — Manipula datos de audio sin procesar</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-audioop">
<span id="audioop-manipulate-raw-audio-data"></span><h1><a class="reference internal" href="#module-audioop" title="audioop: Manipulate raw audio data. (obsoleto)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code></a> — Manipula datos de audio sin procesar<a class="headerlink" href="#module-audioop" title="Enlazar permanentemente con este título">¶</a></h1>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.11: </span>The <a class="reference internal" href="#module-audioop" title="audioop: Manipulate raw audio data. (obsoleto)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code></a> module is deprecated
(see <span class="target" id="index-0"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0594#audioop"><strong>PEP 594</strong></a> for details).</p>
</div>
<hr class="docutils" />
<p>El módulo <a class="reference internal" href="#module-audioop" title="audioop: Manipulate raw audio data. (obsoleto)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code></a> contiene algunas operaciones útiles sobre fragmentos de sonido. Opera en fragmentos de sonido que consisten en muestras de enteros de 8, 16, 24, o 32 bits, guardados en <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objetos parecidos a bytes</span></a>. Todos los elementos escalares son enteros, a menos que se especifique lo contrario.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>La compatibilidad para muestras de 24-bit fue añadida. Todas las funciones ahora aceptan cualquier <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>. La entrada de cadenas de caracteres ahora resulta en un error inmediato.</p>
</div>
<p id="index-1">Este módulo proporciona compatibilidad con las codificaciones a-LAW, u-LAW e Intel/DVI ADPCM.</p>
<p>Algunas de las operaciones más complicadas sólo toman muestras de 16-bit, si no, el tamaño de la entrada (en bytes) siempre es un parámetro de la operación.</p>
<p>El módulo define las siguientes variables y funciones:</p>
<dl class="py exception">
<dt id="audioop.error">
<em class="property">exception </em><code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">error</code><a class="headerlink" href="#audioop.error" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta excepción es lanzada en todos los errores, tal como números desconocidos de bytes por entrada, etc.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.add">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment1</span></em>, <em class="sig-param"><span class="n">fragment2</span></em>, <em class="sig-param"><span class="n">width</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.add" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un fragmento que es la adición de dos entradas pasadas como parámetros. <em>width</em> es la longitud de la muestra en bytes, o <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">3</span></code>, o <code class="docutils literal notranslate"><span class="pre">4</span></code>. Ambos fragmentos deben tener la misma longitud.  Las muestras son truncadas en caso de desbordamiento.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.adpcm2lin">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">adpcm2lin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">adpcmfragment</span></em>, <em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">state</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.adpcm2lin" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Decodifica un fragmento codificado con Intel/DVI ADPCM en un fragmento lineal.  Véase la descripción de <a class="reference internal" href="#audioop.lin2adpcm" title="audioop.lin2adpcm"><code class="xref py py-func docutils literal notranslate"><span class="pre">lin2adpcm()</span></code></a> por detalles sobre la codificación ADPCM. Retorna una tupla <code class="docutils literal notranslate"><span class="pre">(sample,</span> <span class="pre">newstate)</span></code> donde la entrada tiene la longitud especificada en <em>width</em>.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.alaw2lin">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">alaw2lin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">width</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.alaw2lin" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierte los fragmentos de sonido codificados con a-LAW en fragmentos de sonido linealmente codificados. La codificación a-LAW siempre usa muestras de 8 bits, por lo que <em>width</em> hace referencia sólo a la longitud de la entrada del fragmento de salida aquí.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.avg">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">avg</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">width</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.avg" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el promedio de todas las muestras en el fragmento.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.avgpp">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">avgpp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">width</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.avgpp" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el promedio del valor de pico a pico de todas las muestras en el fragmento. No se hace ningún filtrado, por lo que la utilidad de esta rutina es cuestionable.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.bias">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">bias</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">bias</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.bias" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un fragmento que es el fragmento original con un <em>bias</em> añadido a cada muestra.  Las muestras se envuelven en caso de desbordamiento.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.byteswap">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">byteswap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">width</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.byteswap" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Intercambia los bytes («Byteswap») de todas las muestras en un fragmento y retorna el fragmento modificado. Convierte muestras <em>big-endian</em> en <em>little-endian</em> y viceversa.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="audioop.cross">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">cross</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">width</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.cross" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el número de cruces por 0 en el fragmento pasado como un argumento.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.findfactor">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">findfactor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">reference</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.findfactor" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un factor <em>F</em> tal que <code class="docutils literal notranslate"><span class="pre">rms(add(fragment,</span> <span class="pre">mul(reference,</span> <span class="pre">-F)))</span></code> sea mínimo, i.e., retorna el factor con el cual debes multiplicar la <em>reference</em> para hacerlo coincidir tanto como sea posible a <em>fragment</em>.  Los fragmentos deben contener muestras de 2-byte.</p>
<p>El tiempo tomado por esta rutina es proporcional a <code class="docutils literal notranslate"><span class="pre">len(fragment</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.findfit">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">findfit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">reference</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.findfit" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Intenta hacer coincidir <em>reference</em> tanto bien como sea posible a un <em>fragment</em> (que debe ser el fragmento más largo).  Esto es (conceptualmente) hecho al tomar segmentos de <em>fragment</em>, usando <a class="reference internal" href="#audioop.findfactor" title="audioop.findfactor"><code class="xref py py-func docutils literal notranslate"><span class="pre">findfactor()</span></code></a> para computar la mejor coincidencia, y minimizando el resultado.  Los fragmentos deben contener muestras de 2-byte. Retorna una tupla <code class="docutils literal notranslate"><span class="pre">(offset,</span> <span class="pre">factor)</span></code> donde <em>offset</em> (entero) es el <em>offset</em> en <em>fragment</em> donde la coincidencia más óptima empezó y <em>factor</em> es el (número flotante) factor según <a class="reference internal" href="#audioop.findfactor" title="audioop.findfactor"><code class="xref py py-func docutils literal notranslate"><span class="pre">findfactor()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.findmax">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">findmax</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">length</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.findmax" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Inspecciona <em>fragment</em> por un segmento de longitud <em>length</em> muestras (¡no bytes!) con la energía máxima, i.e., retorna <em>i</em> por el cual <code class="docutils literal notranslate"><span class="pre">rms(fragment[i*2:(i+length)*2])</span></code> es máximo.  Los fragmentos deben contener muestras de 2 bytes.</p>
<p>La rutina tarda proporcionalmente a <code class="docutils literal notranslate"><span class="pre">len(fragment)</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.getsample">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">getsample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.getsample" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el valor de la muestra <em>index</em> del fragmento.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.lin2adpcm">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">lin2adpcm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">state</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.lin2adpcm" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierte las muestras en codificaciones Intel/DVI ADPCM de 4 bits. La codificación ADPCM es un esquema de codificación adaptativo a través del cual cada número de 4 bits es la diferencia entre una muestra y la siguiente, dividido por un paso (inconsistente). El algoritmo de Intel/DVI ADPCM ha sido seleccionado para su uso por el <em>IMA</em>, por lo que bien puede convertirse en un estándar.</p>
<p><em>state</em> es una tupla que contiene el estado del codificador. El codificador retorna una tupla <code class="docutils literal notranslate"><span class="pre">(adpcmfrag,</span> <span class="pre">newstate)</span></code>, y el <em>newstate</em> debe pasarse a la siguiente llamada de <a class="reference internal" href="#audioop.lin2adpcm" title="audioop.lin2adpcm"><code class="xref py py-func docutils literal notranslate"><span class="pre">lin2adpcm()</span></code></a>. En la llamada inicial, se puede pasar <code class="docutils literal notranslate"><span class="pre">None</span></code> como estado. <em>adpcmfrag</em> es el fragmento codificado ADPCM empaquetado 2 valores de 4 bits por byte.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.lin2alaw">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">lin2alaw</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">width</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.lin2alaw" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierte las muestras en el fragmento de audio en una codificación a-LAW y los retorna como un objeto de bytes. a-LAW es un formato de codificación de audio a través del cual obtienes un rango dinámico de cerca de 13 bits usando sólo muestras de 8 bits. Es usado por el hardware de audio Sun, entre otros.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.lin2lin">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">lin2lin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">newwidth</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.lin2lin" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierte muestras entre formatos de 1, 2, 3, y 4 bytes.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En algunos formatos de audio, como archivos .WAV, las entradas de 16, 24, y 32 bits tienen signo, pero las entradas de 8 bits no tienen signo. Por lo que cuando se convierta en entradas de 8 bits  para estas entradas, también necesitas añadir 128 al resultado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">new_frames</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">lin2lin</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">old_width</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">new_frames</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">bias</span><span class="p">(</span><span class="n">new_frames</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>
</pre></div>
</div>
<p>Lo mismo, al revés, tiene que ser aplicado cuando se convierta muestras de 8 bits en muestras de 16, 24, o 32 bits.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="audioop.lin2ulaw">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">lin2ulaw</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">width</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.lin2ulaw" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierte muestras en el fragmento de audio en codificaciones u-LAW y lo retorna como un objeto de bytes.  u-LAW es un formato de codificación de audio a través del cual obtienes un rango dinámico de cerca de 14 bits usando sólo muestras de 8 bits.  Es usado por el hardware de audio Sun, entre otros.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.max">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">max</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">width</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.max" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el máximo de los <em>valores absolutos</em> de las entradas en un fragmento.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.maxpp">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">maxpp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">width</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.maxpp" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el valor de pico a pico máximo en el fragmento de sonido.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.minmax">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">minmax</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">width</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.minmax" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna una tupla que consiste de los valores mínimos y máximos de todas las entradas en el fragmento de sonido.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.mul">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">mul</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">factor</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.mul" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un fragmento que tiene todas las entradas en el fragmento original multiplicado por el valor de punto flotante <em>factor</em>.  Las muestras son truncadas en caso de desbordamiento.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.ratecv">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">ratecv</code><span class="sig-paren">(</span><em class="sig-param">fragment</em>, <em class="sig-param">width</em>, <em class="sig-param">nchannels</em>, <em class="sig-param">inrate</em>, <em class="sig-param">outrate</em>, <em class="sig-param">state</em><span class="optional">[</span>, <em class="sig-param">weightA</em><span class="optional">[</span>, <em class="sig-param">weightB</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#audioop.ratecv" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierte el ratio de fotogramas del fragmento de entrada.</p>
<p><em>state</em> es una tupla que contiene el estado del convertidor.  El convertidor retorna una tupla <code class="docutils literal notranslate"><span class="pre">(newfragment,</span> <span class="pre">newstate)</span></code>, y <em>newstate</em> debe ser pasado a la siguiente llamada de <a class="reference internal" href="#audioop.ratecv" title="audioop.ratecv"><code class="xref py py-func docutils literal notranslate"><span class="pre">ratecv()</span></code></a>.  La llamada inicial debe pasar <code class="docutils literal notranslate"><span class="pre">None</span></code> como el estado.</p>
<p>Los argumentos <em>weightA</em> y <em>weightB</em> son parámetros para un filtro digital simple y sus valores por defecto son <code class="docutils literal notranslate"><span class="pre">1</span></code> y <code class="docutils literal notranslate"><span class="pre">0</span></code> respectivamente.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.reverse">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">reverse</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">width</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.reverse" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Invierte las entradas en un fragmento y retorna el fragmento modificado.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.rms">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">rms</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">width</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.rms" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la media cuadrática del fragmento, i.e. <code class="docutils literal notranslate"><span class="pre">sqrt(sum(S_i^2)/n)</span></code>.</p>
<p>Este es una medida del poder en una señal de audio.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.tomono">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">tomono</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">lfactor</span></em>, <em class="sig-param"><span class="n">rfactor</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.tomono" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierte un fragmento estéreo en una fragmento mono. El canal izquierdo es multiplicado por <em>Ifactor</em> y el derecho por <em>rfactor</em> antes de añadir los dos canales para dar una señal mono.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.tostereo">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">tostereo</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">lfactor</span></em>, <em class="sig-param"><span class="n">rfactor</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.tostereo" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Genera un fragmento estéreo de un fragmento mono.  Cada par de muestras en el fragmento estéreo son computados de la entrada mono, a través del cual las muestras del canal izquierdo son multiplicadas por <em>Ifactor</em> y del canal derecho por <em>rfactor</em>.</p>
</dd></dl>

<dl class="py function">
<dt id="audioop.ulaw2lin">
<code class="sig-prename descclassname">audioop.</code><code class="sig-name descname">ulaw2lin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fragment</span></em>, <em class="sig-param"><span class="n">width</span></em><span class="sig-paren">)</span><a class="headerlink" href="#audioop.ulaw2lin" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Convierte los fragmentos de sonido en codificaciones u-LAW en fragmentos de sonidos linealmente codificados.  Las codificaciones u-LAW siempre usan muestras de 8 bits, por lo que <em>width</em> hace referencia  a la longitud de la muestra del fragmento de salida aquí.</p>
</dd></dl>

<p>Note que operaciones tales como <a class="reference internal" href="#audioop.mul" title="audioop.mul"><code class="xref py py-func docutils literal notranslate"><span class="pre">mul()</span></code></a> o <a class="reference internal" href="#audioop.max" title="audioop.max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a> no hacen distinción entre fragmentos mono y estéreo, i.e. todas las muestras son tratadas iguales.  Si este es un problema, el fragmento estéreo debe ser dividido en dos fragmentos mono primero y recombinado después.  Aquí hay un ejemplo de como hacerlo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mul_stereo</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">lfactor</span><span class="p">,</span> <span class="n">rfactor</span><span class="p">):</span>
    <span class="n">lsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">tomono</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">tomono</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">lsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">lsample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">lfactor</span><span class="p">)</span>
    <span class="n">rsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">rsample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">rfactor</span><span class="p">)</span>
    <span class="n">lsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">tostereo</span><span class="p">(</span><span class="n">lsample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rsample</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">tostereo</span><span class="p">(</span><span class="n">rsample</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">audioop</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lsample</span><span class="p">,</span> <span class="n">rsample</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
</pre></div>
</div>
<p>Si usas el codificador ADPCM para construir paquetes de redes y quieres que tu protocolo no tenga estado (<em>stateless</em>) (i.e. para ser capaz de tolerar pérdida de paquetes) no sólo debes transmitir los datos pero también el estado. Note que debes enviar el estado inicial (<em>initial</em>) (el que pasas a <a class="reference internal" href="#audioop.lin2adpcm" title="audioop.lin2adpcm"><code class="xref py py-func docutils literal notranslate"><span class="pre">lin2adpcm()</span></code></a>) junto con el decodificador, no el estado final (como es retornado por el codificador).  Si quieres usar un <a class="reference internal" href="struct.html#struct.Struct" title="struct.Struct"><code class="xref py py-class docutils literal notranslate"><span class="pre">struct.Struct</span></code></a> para almacenar el estado en binario puedes codificar el primer elemento (el valor predicho) en 16 bits y el segundo (el índice delta) en 8.</p>
<p>Los codificadores ADPCM nunca se han probado en contra de otros codificadores ADPCM, sólo contra ellos mismos. Bien puede ser que malinterpreté los estándares en cuyo caso ellos no serán interoperables con los estándares respectivos.</p>
<p>La rutinas <code class="xref py py-func docutils literal notranslate"><span class="pre">find*()</span></code> pueden parecer un poco raras a primera vista.  Sirven principalmente para hacer echo de la cancelación.  Una manera razonablemente rápida para hacerlo es coger la pieza más energética de la muestra de la salida, localizarla en la muestra de la entrada y substraer la muestra de la salida completa de la muestra de entrada:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">echocancel</span><span class="p">(</span><span class="n">outputdata</span><span class="p">,</span> <span class="n">inputdata</span><span class="p">):</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">findmax</span><span class="p">(</span><span class="n">outputdata</span><span class="p">,</span> <span class="mi">800</span><span class="p">)</span>    <span class="c1"># one tenth second</span>
    <span class="n">out_test</span> <span class="o">=</span> <span class="n">outputdata</span><span class="p">[</span><span class="n">pos</span><span class="o">*</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">in_test</span> <span class="o">=</span> <span class="n">inputdata</span><span class="p">[</span><span class="n">pos</span><span class="o">*</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">ipos</span><span class="p">,</span> <span class="n">factor</span> <span class="o">=</span> <span class="n">audioop</span><span class="o">.</span><span class="n">findfit</span><span class="p">(</span><span class="n">in_test</span><span class="p">,</span> <span class="n">out_test</span><span class="p">)</span>
    <span class="c1"># Optional (for better cancellation):</span>
    <span class="c1"># factor = audioop.findfactor(in_test[ipos*2:ipos*2+len(out_test)],</span>
    <span class="c1">#              out_test)</span>
    <span class="n">prefill</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="o">*</span><span class="p">(</span><span class="n">pos</span><span class="o">+</span><span class="n">ipos</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
    <span class="n">postfill</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inputdata</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">prefill</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">outputdata</span><span class="p">))</span>
    <span class="n">outputdata</span> <span class="o">=</span> <span class="n">prefill</span> <span class="o">+</span> <span class="n">audioop</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">outputdata</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">factor</span><span class="p">)</span> <span class="o">+</span> <span class="n">postfill</span>
    <span class="k">return</span> <span class="n">audioop</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">inputdata</span><span class="p">,</span> <span class="n">outputdata</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Tema anterior</h4>
  <p class="topless"><a href="asyncore.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncore</span></code> — controlador de socket asincrónico</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="cgi.html"
                        title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cgi</span></code> — Soporte de Interfaz de Entrada Común (CGI)</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/audioop.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="cgi.html" title="cgi — Soporte de Interfaz de Entrada Común (CGI)"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="asyncore.html" title="asyncore — controlador de socket asincrónico"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La Biblioteca Estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="superseded.html" >Módulos Reemplazados</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code> — Manipula datos de audio sin procesar</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 27, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>