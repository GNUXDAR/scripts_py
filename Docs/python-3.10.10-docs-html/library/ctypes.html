
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>ctypes — Una biblioteca de funciones foráneas para Python &#8212; documentación de Python - 3.10.10</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pydoctheme.css?2022.1" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/translations.js"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.10.10"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="Ejecución concurrente" href="concurrency.html" />
    <link rel="prev" title="errno — Símbolos estándar del sistema errno" href="errno.html" />
    <link rel="canonical" href="https://docs.python.org/3/library/ctypes.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script> 

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <label for="menuToggler" class="toggler__label">
        <span></span>
    </label>
    <nav class="nav-content" role="navigation">
         <a href="https://www.python.org/" class="nav-logo">
             <img src="../_static/py.svg" alt="Logo"/>
         </a>
        <div class="version_switcher_placeholder"></div>
        <form role="search" class="search" action="../search.html" method="get">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                <path fill-rule="nonzero"
                        d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="#444"></path>
            </svg>
            <input type="text" name="q" aria-label="Búsqueda rápida"/>
            <input type="submit" value="Ir"/>
        </form>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code> — Una biblioteca de funciones foráneas para Python</a><ul>
<li><a class="reference internal" href="#ctypes-tutorial">tutorial de ctypes</a><ul>
<li><a class="reference internal" href="#loading-dynamic-link-libraries">Carga de bibliotecas de enlaces dinámicos</a></li>
<li><a class="reference internal" href="#accessing-functions-from-loaded-dlls">Acceder a las funciones de los dll cargados</a></li>
<li><a class="reference internal" href="#calling-functions">Funciones de llamada</a></li>
<li><a class="reference internal" href="#fundamental-data-types">Tipos de datos fundamentales</a></li>
<li><a class="reference internal" href="#calling-functions-continued">Funciones de llamada, continuación</a></li>
<li><a class="reference internal" href="#calling-variadic-functions">Calling variadic functions</a></li>
<li><a class="reference internal" href="#calling-functions-with-your-own-custom-data-types">Funciones de llamada con sus propios tipos de datos personalizados</a></li>
<li><a class="reference internal" href="#specifying-the-required-argument-types-function-prototypes">Especificar los tipos de argumentos requeridos (prototipos de funciones)</a></li>
<li><a class="reference internal" href="#return-types">Tipos de retorno</a></li>
<li><a class="reference internal" href="#passing-pointers-or-passing-parameters-by-reference">Pasar los punteros (o: pasar los parámetros por referencia)</a></li>
<li><a class="reference internal" href="#structures-and-unions">Estructuras y uniones</a></li>
<li><a class="reference internal" href="#structure-union-alignment-and-byte-order">Alineación de estructura/unión y orden de bytes</a></li>
<li><a class="reference internal" href="#bit-fields-in-structures-and-unions">Campos de bits en estructuras y uniones</a></li>
<li><a class="reference internal" href="#arrays">Arreglos</a></li>
<li><a class="reference internal" href="#pointers">Punteros</a></li>
<li><a class="reference internal" href="#type-conversions">Conversiones de tipos</a></li>
<li><a class="reference internal" href="#incomplete-types">Tipos incompletos</a></li>
<li><a class="reference internal" href="#callback-functions">Funciones de retrollamadas (<em>callback</em>)</a></li>
<li><a class="reference internal" href="#accessing-values-exported-from-dlls">Acceder a los valores exportados de los dlls</a></li>
<li><a class="reference internal" href="#surprises">Sorpresas</a></li>
<li><a class="reference internal" href="#variable-sized-data-types">Tipos de datos de tamaño variable</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ctypes-reference">referencia ctypes</a><ul>
<li><a class="reference internal" href="#finding-shared-libraries">Encontrar bibliotecas compartidas</a></li>
<li><a class="reference internal" href="#loading-shared-libraries">Cargando bibliotecas compartidas</a></li>
<li><a class="reference internal" href="#foreign-functions">Funciones foráneas</a></li>
<li><a class="reference internal" href="#function-prototypes">Prototipos de funciones</a></li>
<li><a class="reference internal" href="#utility-functions">Funciones de utilidad</a></li>
<li><a class="reference internal" href="#data-types">Tipos de datos</a></li>
<li><a class="reference internal" href="#ctypes-fundamental-data-types-2">Tipos de datos fundamentales</a></li>
<li><a class="reference internal" href="#structured-data-types">Tipos de datos estructurados</a></li>
<li><a class="reference internal" href="#arrays-and-pointers">Arreglos y punteros</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="errno.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">errno</span></code> — Símbolos estándar del sistema errno</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="concurrency.html"
                        title="próximo capítulo">Ejecución concurrente</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/ctypes.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="concurrency.html" title="Ejecución concurrente"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="errno.html" title="errno — Símbolos estándar del sistema errno"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La Biblioteca Estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" accesskey="U">Servicios genéricos del sistema operativo</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code> — Una biblioteca de funciones foráneas para Python</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-ctypes">
<span id="ctypes-a-foreign-function-library-for-python"></span><h1><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> — Una biblioteca de funciones foráneas para Python<a class="headerlink" href="#module-ctypes" title="Enlazar permanentemente con este título">¶</a></h1>
<p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.10/Lib/ctypes">Lib/ctypes</a></p>
<hr class="docutils" />
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> es una biblioteca de funciones foráneas para Python. Proporciona tipos de datos compatibles con C y permite llamar a funciones en archivos DLL o bibliotecas compartidas. Se puede utilizar para envolver estas bibliotecas en Python puro.</p>
<section id="ctypes-tutorial">
<span id="ctypes-ctypes-tutorial"></span><h2>tutorial de ctypes<a class="headerlink" href="#ctypes-tutorial" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Nota: Los ejemplos de código en este tutorial usan <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> para asegurarse de que realmente funcionen. Dado que algunos ejemplos de código se comportan de manera diferente en Linux, Windows o macOS, contienen directivas doctest en los comentarios.</p>
<p>Nota: Algunos ejemplos de código hacen referencia al tipo ctypes <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>. En las plataformas donde <code class="docutils literal notranslate"><span class="pre">sizeof(long)</span> <span class="pre">==</span> <span class="pre">sizeof(int)</span></code> es un alias de <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a>. Por lo tanto, no debe confundirse si <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a> se imprime si espera <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a> — son en realidad del mismo tipo.</p>
<section id="loading-dynamic-link-libraries">
<span id="ctypes-loading-dynamic-link-libraries"></span><h3>Carga de bibliotecas de enlaces dinámicos<a class="headerlink" href="#loading-dynamic-link-libraries" title="Enlazar permanentemente con este título">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> exporta los objetos <em>cdll</em> y en Windows <em>windll</em> y <em>oledll</em>, para cargar bibliotecas de enlaces dinámicos.</p>
<p>Las bibliotecas se cargan accediendo a ellas como atributos de estos objetos. <em>cdll</em> carga bibliotecas que exportan funciones utilizando la convención de llamada estándar <code class="docutils literal notranslate"><span class="pre">cdecl</span></code>, mientras que las bibliotecas <em>windll</em> llaman a funciones mediante la convención de llamada <code class="docutils literal notranslate"><span class="pre">stdcall</span></code>. <em>oledll</em> también utiliza la convención de llamada <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> y asume que las funciones retornan un código de error Windows <code class="xref c c-type docutils literal notranslate"><span class="pre">HRESULT</span></code>. El código de error se utiliza para generar automáticamente una excepción <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a> cuando se produce un error en la llamada a la función.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Los errores de Windows solían generar <a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">WindowsError</span></code></a>, que ahora es un alias de <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>.</p>
</div>
<p>Estos son algunos ejemplos para Windows. Tener en cuenta que “”msvcrt”” es la biblioteca estándar de MS C que contiene la mayoría de las funciones C estándar y utiliza la convención de llamada cdecl:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">)</span>  
<span class="go">&lt;WinDLL &#39;kernel32&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span><span class="p">)</span>      
<span class="go">&lt;CDLL &#39;msvcrt&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span>      
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Windows agrega automáticamente la extensión común <code class="docutils literal notranslate"><span class="pre">.dll</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Acceder a la biblioteca estándar de C a través de <code class="docutils literal notranslate"><span class="pre">cdll.msvcrt</span></code> utilizará una versión obsoleta de la biblioteca que puede ser incompatible con la utilizada por Python. Cuando sea posible, use la funcionalidad nativa de Python, o bien importe y use el módulo <code class="docutils literal notranslate"><span class="pre">msvcrt</span></code>.</p>
</div>
<p>En Linux, se requiere especificar el nombre de archivo <em>incluyendo</em> la extensión para cargar una biblioteca, por lo que no se puede utilizar el acceso por atributos para cargar las bibliotecas. Se debe usar el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadLibrary()</span></code> de los cargadores de dll, o se debe cargar la biblioteca creando una instancia de CDLL llamando al constructor:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>  
<span class="go">&lt;CDLL &#39;libc.so.6&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">CDLL</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>       
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span>                           
<span class="go">&lt;CDLL &#39;libc.so.6&#39;, handle ... at ...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="accessing-functions-from-loaded-dlls">
<span id="ctypes-accessing-functions-from-loaded-dlls"></span><h3>Acceder a las funciones de los dll cargados<a class="headerlink" href="#accessing-functions-from-loaded-dlls" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Las funciones se acceden como atributos de los objetos dll:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">printf</span>
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">)</span>  
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">MyOwnFunction</span><span class="p">)</span>     
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;ctypes.py&quot;</span>, line <span class="m">239</span>, in <span class="n">__getattr__</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">_StdcallFuncPtr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">function &#39;MyOwnFunction&#39; not found</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Nótese que las dlls del sistema win32 como <code class="docutils literal notranslate"><span class="pre">kernel32</span></code> y <code class="docutils literal notranslate"><span class="pre">user32</span></code> a menudo exportan versiones ANSI y UNICODE de una función. La versión UNICODE se exporta con una <code class="docutils literal notranslate"><span class="pre">W</span></code> añadida al nombre, mientras que la versión ANSI se exporta con una <code class="docutils literal notranslate"><span class="pre">A</span></code> añadida al nombre. La función <code class="docutils literal notranslate"><span class="pre">GetModuleHandle</span></code> de win32, que retorna un <em>manejador de módulo</em> para un nombre de módulo dado, tiene el siguiente prototipo de C, y se usa una macro para exponer uno de ellos como <code class="docutils literal notranslate"><span class="pre">GetModuleHandle</span></code> dependiendo de si UNICODE está definido o no:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">ANSI</span> <span class="n">version</span> <span class="o">*/</span>
<span class="n">HMODULE</span> <span class="n">GetModuleHandleA</span><span class="p">(</span><span class="n">LPCSTR</span> <span class="n">lpModuleName</span><span class="p">);</span>
<span class="o">/*</span> <span class="n">UNICODE</span> <span class="n">version</span> <span class="o">*/</span>
<span class="n">HMODULE</span> <span class="n">GetModuleHandleW</span><span class="p">(</span><span class="n">LPCWSTR</span> <span class="n">lpModuleName</span><span class="p">);</span>
</pre></div>
</div>
<p><em>windll</em> no intenta seleccionar una de ellas por arte de magia, se debe acceder a la versión que se necesita especificando <code class="docutils literal notranslate"><span class="pre">GetModuleHandleA</span></code> o <code class="docutils literal notranslate"><span class="pre">GetModuleHandleW</span></code> explícitamente, y luego llamarlo con bytes u objetos de cadena respectivamente.</p>
<p>A veces, las dlls exportan funciones con nombres que no son identificadores válidos de Python, como <code class="docutils literal notranslate"><span class="pre">&quot;??2&#64;YAPAXI&#64;Z&quot;</span></code>. En este caso tienes que usar <a class="reference internal" href="functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> para recuperar la función:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">getattr</span><span class="p">(</span><span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span><span class="p">,</span> <span class="s2">&quot;??2@YAPAXI@Z&quot;</span><span class="p">)</span>  
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>En Windows, algunas dlls exportan funciones no por nombre sino por ordinal. Se pueden acceder a estas funciones indexando el objeto dll con el número ordinal:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;ctypes.py&quot;</span>, line <span class="m">310</span>, in <span class="n">__getitem__</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">_StdcallFuncPtr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">function ordinal 0 not found</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="calling-functions">
<span id="ctypes-calling-functions"></span><h3>Funciones de llamada<a class="headerlink" href="#calling-functions" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Puedes llamar a estas funciones como cualquier otra función en Python. Este ejemplo utiliza la función <code class="docutils literal notranslate"><span class="pre">time()</span></code>, que retorna el tiempo del sistema en segundos desde la época de Unix, y la función <code class="docutils literal notranslate"><span class="pre">GetModuleHandleA()</span></code>, que retorna un manejador de módulo de win32.</p>
<p>Este ejemplo llama a ambas funciones con un puntero <code class="docutils literal notranslate"><span class="pre">NULL</span></code> (<code class="docutils literal notranslate"><span class="pre">None</span></code> debe ser usado como el puntero <code class="docutils literal notranslate"><span class="pre">NULL</span></code>):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>  
<span class="go">1150640792</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="kc">None</span><span class="p">)))</span>  
<span class="go">0x1d000000</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> es lanzado cuando se llama a una función <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> con la convención de llamada <code class="docutils literal notranslate"><span class="pre">cdecl</span></code>, o viceversa:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">Procedure probably called with not enough arguments (4 bytes missing)</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">windll</span><span class="o">.</span><span class="n">msvcrt</span><span class="o">.</span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;spam&quot;</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">Procedure probably called with too many arguments (4 bytes in excess)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Para saber la convención de llamada correcta, hay que mirar en el archivo de encabezado C o en la documentación de la función que se quiere llamar.</p>
<p>En Windows, <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> utiliza la gestión de excepciones estructurada de win32 para evitar que se produzcan fallos de protección general cuando se llaman funciones con valores de argumento inválidos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">OSError</span>: <span class="n">exception: access violation reading 0x00000020</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Sin embargo, hay suficientes maneras de bloquear Python con <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>, así que debes tener cuidado de todos modos. El módulo <a class="reference internal" href="faulthandler.html#module-faulthandler" title="faulthandler: Dump the Python traceback."><code class="xref py py-mod docutils literal notranslate"><span class="pre">faulthandler</span></code></a> puede ser útil para depurar bloqueos (por ejemplo, provenientes de fallos de segmentación producidos por llamadas erróneas a la biblioteca C).</p>
<p><code class="docutils literal notranslate"><span class="pre">None</span></code>, integers, bytes objects and (unicode) strings are the only native
Python objects that can directly be used as parameters in these function calls.
<code class="docutils literal notranslate"><span class="pre">None</span></code> is passed as a C <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer, bytes objects and strings are passed
as pointer to the memory block that contains their data (<code class="xref c c-expr docutils literal notranslate"><span class="pre">char</span><span class="pre">*</span></code> or
<code class="xref c c-expr docutils literal notranslate"><span class="pre">wchar_t</span><span class="pre">*</span></code>).  Python integers are passed as the platforms default C
<code class="xref c c-expr docutils literal notranslate"><span class="pre">int</span></code> type, their value is masked to fit into the C type.</p>
<p>Antes de pasar a llamar funciones con otros tipos de parámetros, tenemos que aprender más sobre los tipos de datos <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>.</p>
</section>
<section id="fundamental-data-types">
<span id="ctypes-fundamental-data-types"></span><h3>Tipos de datos fundamentales<a class="headerlink" href="#fundamental-data-types" title="Enlazar permanentemente con este título">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> define un número de tipos de datos primitivos compatibles con C:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 24%" />
<col style="width: 46%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>tipo ctypes</p></th>
<th class="head"><p>Tipo C</p></th>
<th class="head"><p>Tipo Python</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_bool" title="ctypes.c_bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_bool</span></code></a></p></td>
<td><p><code class="xref c c-expr docutils literal notranslate"><span class="pre">_Bool</span></code></p></td>
<td><p>bool (1)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_char" title="ctypes.c_char"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char</span></code></a></p></td>
<td><p><code class="xref c c-expr docutils literal notranslate"><span class="pre">char</span></code></p></td>
<td><p>Un objeto bytes de 1-caracter</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_wchar" title="ctypes.c_wchar"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar</span></code></a></p></td>
<td><p><code class="xref c c-expr docutils literal notranslate"><span class="pre">wchar_t</span></code></p></td>
<td><p>Una cadena de 1-caracter</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_byte" title="ctypes.c_byte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_byte</span></code></a></p></td>
<td><p><code class="xref c c-expr docutils literal notranslate"><span class="pre">char</span></code></p></td>
<td><p>entero</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_ubyte" title="ctypes.c_ubyte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ubyte</span></code></a></p></td>
<td><p><code class="xref c c-expr docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code></p></td>
<td><p>entero</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_short" title="ctypes.c_short"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_short</span></code></a></p></td>
<td><p><code class="xref c c-expr docutils literal notranslate"><span class="pre">short</span></code></p></td>
<td><p>entero</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_ushort" title="ctypes.c_ushort"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ushort</span></code></a></p></td>
<td><p><code class="xref c c-expr docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span></code></p></td>
<td><p>entero</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a></p></td>
<td><p><code class="xref c c-expr docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p>entero</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_uint" title="ctypes.c_uint"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_uint</span></code></a></p></td>
<td><p><code class="xref c c-expr docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code></p></td>
<td><p>entero</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a></p></td>
<td><p><code class="xref c c-expr docutils literal notranslate"><span class="pre">long</span></code></p></td>
<td><p>entero</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_ulong" title="ctypes.c_ulong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulong</span></code></a></p></td>
<td><p><code class="xref c c-expr docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code></p></td>
<td><p>entero</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_longlong" title="ctypes.c_longlong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longlong</span></code></a></p></td>
<td><p><code class="xref c c-expr docutils literal notranslate"><span class="pre">__int64</span></code> or <code class="xref c c-expr docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code></p></td>
<td><p>entero</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_ulonglong" title="ctypes.c_ulonglong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulonglong</span></code></a></p></td>
<td><p><code class="xref c c-expr docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">__int64</span></code> or
<code class="xref c c-expr docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code></p></td>
<td><p>entero</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_size_t" title="ctypes.c_size_t"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_size_t</span></code></a></p></td>
<td><p><code class="xref c c-expr docutils literal notranslate"><span class="pre">size_t</span></code></p></td>
<td><p>entero</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_ssize_t" title="ctypes.c_ssize_t"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ssize_t</span></code></a></p></td>
<td><p><code class="xref c c-expr docutils literal notranslate"><span class="pre">ssize_t</span></code> or
<code class="xref c c-expr docutils literal notranslate"><a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><span class="pre">Py_ssize_t</span></a></code></p></td>
<td><p>entero</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_float" title="ctypes.c_float"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_float</span></code></a></p></td>
<td><p><code class="xref c c-expr docutils literal notranslate"><span class="pre">float</span></code></p></td>
<td><p>flotante</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_double" title="ctypes.c_double"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_double</span></code></a></p></td>
<td><p><code class="xref c c-expr docutils literal notranslate"><span class="pre">double</span></code></p></td>
<td><p>flotante</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_longdouble" title="ctypes.c_longdouble"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longdouble</span></code></a></p></td>
<td><p><code class="xref c c-expr docutils literal notranslate"><span class="pre">long</span> <span class="pre">double</span></code></p></td>
<td><p>flotante</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a></p></td>
<td><p><code class="xref c c-expr docutils literal notranslate"><span class="pre">char</span><span class="pre">*</span></code> (NUL terminated)</p></td>
<td><p>objeto de bytes o <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctypes.c_wchar_p" title="ctypes.c_wchar_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar_p</span></code></a></p></td>
<td><p><code class="xref c c-expr docutils literal notranslate"><span class="pre">wchar_t</span><span class="pre">*</span></code> (NUL terminated)</p></td>
<td><p>cadena o <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_void_p</span></code></a></p></td>
<td><p><code class="xref c c-expr docutils literal notranslate"><span class="pre">void</span><span class="pre">*</span></code></p></td>
<td><p>entero o <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
</tbody>
</table>
<ol class="arabic simple">
<li><p>El constructor acepta cualquier objeto con valor verdadero.</p></li>
</ol>
<p>Todos estos tipos pueden ser creados llamándolos con un inicializador opcional del tipo y valor correctos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c_int</span><span class="p">()</span>
<span class="go">c_long(0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_wchar_p</span><span class="p">(</span><span class="s2">&quot;Hello, World&quot;</span><span class="p">)</span>
<span class="go">c_wchar_p(140018365411392)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_ushort</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">c_ushort(65533)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Dado que estos tipos son mutables, su valor también puede ser cambiado después:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(42)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">-99</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Asignando un nuevo valor a las instancias de los tipos de punteros <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a>, <a class="reference internal" href="#ctypes.c_wchar_p" title="ctypes.c_wchar_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar_p</span></code></a>, y <a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_void_p</span></code></a> cambia el <em>lugar de memoria</em> al que apuntan, <em>no el contenido</em> del bloque de memoria (por supuesto que no, porque los objetos de bytes de Python son inmutables):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Hello, World&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_s</span> <span class="o">=</span> <span class="n">c_wchar_p</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="p">)</span>
<span class="go">c_wchar_p(139966785747344)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">Hello World</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s2">&quot;Hi, there&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="p">)</span>              <span class="c1"># the memory location has changed</span>
<span class="go">c_wchar_p(139966783348904)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">Hi, there</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>                <span class="c1"># first object is unchanged</span>
<span class="go">Hello, World</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Sin embargo, debe tener cuidado de no pasarlos a funciones que esperan punteros a la memoria mutable. Si necesitas bloques de memoria mutables, ctypes tiene una función <a class="reference internal" href="#ctypes.create_string_buffer" title="ctypes.create_string_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_string_buffer()</span></code></a> que los crea de varias maneras. El contenido actual del bloque de memoria puede ser accedido (o cambiado) con la propiedad <code class="docutils literal notranslate"><span class="pre">raw</span></code>; si quieres acceder a él como cadena terminada NUL, usa la propiedad <code class="docutils literal notranslate"><span class="pre">value</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>            <span class="c1"># create a 3 byte buffer, initialized to NUL bytes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">3 b&#39;\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello&quot;</span><span class="p">)</span>     <span class="c1"># create a buffer containing a NUL terminated string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">6 b&#39;Hello\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">b&#39;Hello&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="c1"># create a 10 byte buffer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">10 b&#39;Hello\x00\x00\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;Hi&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">10 b&#39;Hi\x00lo\x00\x00\x00\x00\x00&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#ctypes.create_string_buffer" title="ctypes.create_string_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_string_buffer()</span></code></a> function replaces the <code class="xref py py-func docutils literal notranslate"><span class="pre">c_buffer()</span></code> function
(which is still available as an alias), as well as the <code class="xref py py-func docutils literal notranslate"><span class="pre">c_string()</span></code> function
from earlier ctypes releases.  To create a mutable memory block containing
unicode characters of the C type <code class="xref c c-expr docutils literal notranslate"><span class="pre">wchar_t</span></code> use the
<a class="reference internal" href="#ctypes.create_unicode_buffer" title="ctypes.create_unicode_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_unicode_buffer()</span></code></a> function.</p>
</section>
<section id="calling-functions-continued">
<span id="ctypes-calling-functions-continued"></span><h3>Funciones de llamada, continuación<a class="headerlink" href="#calling-functions-continued" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Note que printf imprime al canal de salida estándar real, <em>no</em> a <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a>, por lo que estos ejemplos sólo funcionarán en el prompt de la consola, no desde dentro de <em>IDLE</em> o <em>PythonWin</em>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">printf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello, </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;World!&quot;</span><span class="p">)</span>
<span class="go">Hello, World!</span>
<span class="go">14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello, %S</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;World!&quot;</span><span class="p">)</span>
<span class="go">Hello, World!</span>
<span class="go">14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
<span class="go">42 bottles of beer</span>
<span class="go">19</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mf">42.5</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ArgumentError</span>: <span class="n">argument 2: TypeError: Don&#39;t know how to convert parameter 2</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Como se ha mencionado antes, todos los tipos de Python, excepto los enteros, cadenas y objetos bytes, tienen que ser envueltos en su correspondiente tipo <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>, para que puedan ser convertidos al tipo de datos C requerido:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;An int </span><span class="si">%d</span><span class="s2">, a double </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">1234</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="mf">3.14</span><span class="p">))</span>
<span class="go">An int 1234, a double 3.140000</span>
<span class="go">31</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="calling-variadic-functions">
<span id="ctypes-calling-variadic-functions"></span><h3>Calling variadic functions<a class="headerlink" href="#calling-variadic-functions" title="Enlazar permanentemente con este título">¶</a></h3>
<p>On a lot of platforms calling variadic functions through ctypes is exactly the same
as calling functions with a fixed number of parameters. On some platforms, and in
particular ARM64 for Apple Platforms, the calling convention for variadic functions
is different than that for regular functions.</p>
<p>On those platforms it is required to specify the <em>argtypes</em> attribute for the
regular, non-variadic, function arguments:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">libc</span><span class="o">.</span><span class="n">printf</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">]</span>
</pre></div>
</div>
<p>Because specifying the attribute does inhibit portability it is advised to always
specify <code class="docutils literal notranslate"><span class="pre">argtypes</span></code> for all variadic functions.</p>
</section>
<section id="calling-functions-with-your-own-custom-data-types">
<span id="ctypes-calling-functions-with-own-custom-data-types"></span><h3>Funciones de llamada con sus propios tipos de datos personalizados<a class="headerlink" href="#calling-functions-with-your-own-custom-data-types" title="Enlazar permanentemente con este título">¶</a></h3>
<p>También puedes personalizar la conversión de argumentos de <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> para permitir que las instancias de tus propias clases se usen como argumentos de función. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> busca un atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> y lo usa como argumento de función. Por supuesto, debe ser uno de entero, cadena o bytes:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Bottles</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_as_parameter_</span> <span class="o">=</span> <span class="n">number</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bottles</span> <span class="o">=</span> <span class="n">Bottles</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">bottles</span><span class="p">)</span>
<span class="go">42 bottles of beer</span>
<span class="go">19</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Si no quieres almacenar los datos de la instancia en la variable de instancia <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code>, puedes definir una <a class="reference internal" href="functions.html#property" title="property"><code class="xref py py-class docutils literal notranslate"><span class="pre">property</span></code></a> que haga que el atributo esté disponible a petición.</p>
</section>
<section id="specifying-the-required-argument-types-function-prototypes">
<span id="ctypes-specifying-required-argument-types"></span><h3>Especificar los tipos de argumentos requeridos (prototipos de funciones)<a class="headerlink" href="#specifying-the-required-argument-types-function-prototypes" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Es posible especificar los tipos de argumentos necesarios de las funciones exportadas desde las DLL estableciendo el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code>.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> debe ser una secuencia de tipos de datos de C (la función <code class="docutils literal notranslate"><span class="pre">printf</span></code> probablemente no es un buen ejemplo aquí, porque toma un número variable y diferentes tipos de parámetros dependiendo del formato de la cadena, por otro lado esto es bastante útil para experimentar con esta característica):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="n">c_double</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;String &#39;</span><span class="si">%s</span><span class="s2">&#39;, Int </span><span class="si">%d</span><span class="s2">, Double </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;Hi&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">)</span>
<span class="go">String &#39;Hi&#39;, Int 10, Double 2.200000</span>
<span class="go">37</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>La especificación de un formato protege contra los tipos de argumentos incompatibles (al igual que un prototipo para una función C), e intenta convertir los argumentos en tipos válidos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ArgumentError</span>: <span class="n">argument 2: TypeError: wrong type</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">X 2 3.000000</span>
<span class="go">13</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Si has definido tus propias clases las cuales pasas a las llamadas a funciones, tienes que implementar un método de clase <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code> para que puedan ser usadas en la secuencia <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code>. El método de clase <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code> recibe el objeto Python que se le pasa a la llamada a función, debería hacer una comprobación de tipo o lo que sea necesario para asegurarse de que este objeto es aceptable, y luego retornar el objeto en sí, su atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code>, o lo que se quiera pasar como argumento de la función C en este caso. De nuevo, el resultado debe ser un entero, una cadena, unos bytes, una instancia <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>, o un objeto con el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code>.</p>
</section>
<section id="return-types">
<span id="ctypes-return-types"></span><h3>Tipos de retorno<a class="headerlink" href="#return-types" title="Enlazar permanentemente con este título">¶</a></h3>
<p>By default functions are assumed to return the C <code class="xref c c-expr docutils literal notranslate"><span class="pre">int</span></code> type.  Other
return types can be specified by setting the <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> attribute of the
function object.</p>
<p>Aquí hay un ejemplo más avanzado, utiliza la función <code class="docutils literal notranslate"><span class="pre">strchr</span></code>, que espera un puntero de cadena y un carácter, y retorna un puntero a una cadena:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">strchr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">))</span>  
<span class="go">8059983</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">c_char_p</span>    <span class="c1"># c_char_p is a pointer to a string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">))</span>
<span class="go">b&#39;def&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)))</span>
<span class="go">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Si quieres evitar las llamadas <code class="docutils literal notranslate"><span class="pre">ord(&quot;x&quot;)</span></code> de arriba, puedes establecer el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code>, y el segundo argumento se convertirá de un objeto de un solo carácter de bytes de Python a un char:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">c_char_p</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_char</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="go">&#39;def&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;def&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ArgumentError</span>: <span class="n">argument 2: TypeError: one character string expected</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;x&quot;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="go">&#39;def&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>También puedes usar un objeto Python invocable (una función o una clase, por ejemplo) como el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code>, si la función foránea retorna un número entero. El objeto invocable será llamado con el <em>entero</em> que la función C retorna, y el resultado de esta llamada será utilizado como resultado de la llamada a la función. Esto es útil para comprobar si hay valores de retorno de error y plantear automáticamente una excepción:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span> <span class="o">=</span> <span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">ValidHandle</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">value</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ValidHandle</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  
<span class="go">486539264</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="p">(</span><span class="s2">&quot;something silly&quot;</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">3</span>, in <span class="n">ValidHandle</span>
<span class="gr">OSError</span>: <span class="n">[Errno 126] The specified module could not be found.</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">WinError</span></code> es una función que llamará a la api Windows <code class="docutils literal notranslate"><span class="pre">FormatMessage</span></code> para obtener la representación de la cadena de un código de error, y retornará una excepción. <code class="docutils literal notranslate"><span class="pre">WinError</span></code> toma un parámetro de código de error opcional, si no se usa ninguno, llama a <code class="xref py py-func docutils literal notranslate"><span class="pre">GetLastError`()</span></code> para recuperarlo.</p>
<p>Tenga en cuenta que un mecanismo de comprobación de errores mucho más potente está disponible a través del atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code>; consulte el manual de referencia para obtener más detalles.</p>
</section>
<section id="passing-pointers-or-passing-parameters-by-reference">
<span id="ctypes-passing-pointers"></span><h3>Pasar los punteros (o: pasar los parámetros por referencia)<a class="headerlink" href="#passing-pointers-or-passing-parameters-by-reference" title="Enlazar permanentemente con este título">¶</a></h3>
<p>A veces una función api C espera un <em>puntero</em> a un tipo de datos como parámetro, probablemente para escribir en el lugar correspondiente, o si los datos son demasiado grandes para ser pasados por valor. Esto también se conoce cómo <em>pasar parámetros por referencia</em>.</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> exporta la función <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a> que se utiliza para pasar parámetros por referencia. El mismo efecto se puede conseguir con la función <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a>, aunque <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> hace mucho más trabajo ya que construye un objeto puntero real, por lo que es más rápido usar <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a> si no se necesita el objeto puntero en el propio Python:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">c_float</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\000</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">0 0.0 b&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">sscanf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;1 3.14 Hello&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%f</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">byref</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">byref</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">s</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">1 3.1400001049 b&#39;Hello&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="structures-and-unions">
<span id="ctypes-structures-unions"></span><h3>Estructuras y uniones<a class="headerlink" href="#structures-and-unions" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Las estructuras y uniones deben derivar de las clases base <a class="reference internal" href="#ctypes.Structure" title="ctypes.Structure"><code class="xref py py-class docutils literal notranslate"><span class="pre">Structure</span></code></a> y <a class="reference internal" href="#ctypes.Union" title="ctypes.Union"><code class="xref py py-class docutils literal notranslate"><span class="pre">Union</span></code></a> que se definen en el módulo <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>. Cada subclase debe definir un atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code>. <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> debe ser una lista de <em>2-tuplas</em>, que contenga un <em>nombre de campo</em> y un <em>tipo de campo</em>.</p>
<p>El tipo de campo debe ser un tipo <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> como <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>, o cualquier otro tipo <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> derivado: estructura, unión, matriz, puntero.</p>
<p>Aquí hay un ejemplo simple de una estructura POINT, que contiene dos enteros llamados <em>x</em> y <em>y</em>, y también muestra cómo inicializar una estructura en el constructor:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">10 20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">too many initializers</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Sin embargo, se pueden construir estructuras mucho más complicadas. Una estructura puede contener por sí misma otras estructuras usando una estructura como tipo de campo.</p>
<p>Aquí hay una estructura RECT que contiene dos POINTs llamados <em>upperleft</em> (superior izquierda)y <em>lowerright</em> (abajo a la derecha):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">RECT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;upperleft&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;lowerright&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">upperleft</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">upperleft</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">lowerright</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">lowerright</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Las estructuras anidadas también pueden ser inicializadas en el constructor de varias maneras:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p>El campo <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a> puede ser recuperado de la <em>class</em>, son útiles para la depuración porque pueden proporcionar información útil:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">POINT</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=0, size=4&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">POINT</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=4, size=4&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> no soporta el paso de uniones o estructuras con campos de bits a funciones por valor. Aunque esto puede funcionar en 32-bit x86, la biblioteca no garantiza que funcione en el caso general. Las uniones y estructuras con campos de bits siempre deben pasarse a las funciones por puntero.</p>
</div>
</section>
<section id="structure-union-alignment-and-byte-order">
<h3>Alineación de estructura/unión y orden de bytes<a class="headerlink" href="#structure-union-alignment-and-byte-order" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Por defecto, los campos de Estructura y Unión están alineados de la misma manera que lo hace el compilador C. Es posible anular este comportamiento especificando un atributo de clase <code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code> en la definición de la subclase. Este debe ser establecido como un entero positivo y especifica la alineación máxima de los campos. Esto es lo que <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">pack(n)</span></code> también hace en MSVC.</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> utiliza el orden de bytes nativos para las Estructuras y Uniones. Para construir estructuras con un orden de bytes no nativo, puedes usar una de las clases base <a class="reference internal" href="#ctypes.BigEndianStructure" title="ctypes.BigEndianStructure"><code class="xref py py-class docutils literal notranslate"><span class="pre">BigEndianStructure</span></code></a>, <a class="reference internal" href="#ctypes.LittleEndianStructure" title="ctypes.LittleEndianStructure"><code class="xref py py-class docutils literal notranslate"><span class="pre">LittleEndianStructure</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">BigEndianUnion</span></code>, y <code class="xref py py-class docutils literal notranslate"><span class="pre">LittleEndianUnion</span></code>. Estas clases no pueden contener campos puntero.</p>
</section>
<section id="bit-fields-in-structures-and-unions">
<span id="ctypes-bit-fields-in-structures-unions"></span><h3>Campos de bits en estructuras y uniones<a class="headerlink" href="#bit-fields-in-structures-and-unions" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Es posible crear estructuras y uniones que contengan campos de bits. Los campos de bits sólo son posibles para campos enteros, el ancho de bit se especifica como el tercer ítem en las tuplas <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Int</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;first_16&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;second_16&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="mi">16</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Int</span><span class="o">.</span><span class="n">first_16</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=0:0, bits=16&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Int</span><span class="o">.</span><span class="n">second_16</span><span class="p">)</span>
<span class="go">&lt;Field type=c_long, ofs=0:16, bits=16&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="arrays">
<span id="ctypes-arrays"></span><h3>Arreglos<a class="headerlink" href="#arrays" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Los arreglos son secuencias, que contienen un número fijo de instancias del mismo tipo.</p>
<p>La forma recomendada de crear tipos de arreglos es multiplicando un tipo de dato por un entero positivo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">TenPointsArrayType</span> <span class="o">=</span> <span class="n">POINT</span> <span class="o">*</span> <span class="mi">10</span>
</pre></div>
</div>
<p>Aquí hay un ejemplo de un tipo de datos algo artificial, una estructura que contiene 4 POINTs entre otras cosas:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyStruct</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">c_float</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;point_array&quot;</span><span class="p">,</span> <span class="n">POINT</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MyStruct</span><span class="p">()</span><span class="o">.</span><span class="n">point_array</span><span class="p">))</span>
<span class="go">4</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Las instancias se crean de la manera habitual, llamando a la clase:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span> <span class="o">=</span> <span class="n">TenPointsArrayType</span><span class="p">()</span>
<span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>El código anterior imprime una serie de líneas <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">0</span></code>, porque el contenido del arreglos se inicializa con ceros.</p>
<p>También se pueden especificar inicializadores del tipo correcto:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TenIntegers</span> <span class="o">=</span> <span class="n">c_int</span> <span class="o">*</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii</span> <span class="o">=</span> <span class="n">TenIntegers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
<span class="go">&lt;c_long_Array_10 object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ii</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1 2 3 4 5 6 7 8 9 10</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="pointers">
<span id="ctypes-pointers"></span><h3>Punteros<a class="headerlink" href="#pointers" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Las instancias de puntero se crean llamando a la función <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> en un tipo <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Las instancias del puntero tienen un atributo <a class="reference internal" href="#ctypes._Pointer.contents" title="ctypes._Pointer.contents"><code class="xref py py-attr docutils literal notranslate"><span class="pre">contents</span></code></a> que retorna el objeto al que apunta el puntero, el objeto <code class="docutils literal notranslate"><span class="pre">i</span></code> arriba:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_long(42)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Ten en cuenta que <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> no tiene OOR (original object return), construye un nuevo objeto equivalente cada vez que recuperas un atributo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="ow">is</span> <span class="n">i</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="ow">is</span> <span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Asignar otra instancia <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a> al atributo de contenido del puntero causaría que el puntero apunte al lugar de memoria donde se almacena:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="o">=</span> <span class="n">i</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_long(99)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Las instancias de puntero también pueden ser indexadas con números enteros:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">99</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Asignando a un índice entero cambia el valor señalado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(99)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">22</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(22)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>También es posible usar índices diferentes de 0, pero debes saber lo que estás haciendo, al igual que en C: Puedes acceder o cambiar arbitrariamente las ubicaciones de memoria. Generalmente sólo usas esta característica si recibes un puntero de una función C, y <em>sabes</em> que el puntero en realidad apunta a un arreglo en lugar de a un solo elemento.</p>
<p>Entre bastidores, la función <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> hace más que simplemente crear instancias de puntero, tiene que crear primero punteros <em>tipos</em>. Esto se hace con la función <a class="reference internal" href="#ctypes.POINTER" title="ctypes.POINTER"><code class="xref py py-func docutils literal notranslate"><span class="pre">POINTER()</span></code></a>, que acepta cualquier tipo de <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>, y retorna un nuevo tipo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span>
<span class="go">&lt;class &#39;ctypes.LP_c_long&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">expected c_long instead of int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span><span class="p">(</span><span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
<span class="go">&lt;ctypes.LP_c_long object at 0x...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Llamar al tipo de puntero sin un argumento crea un puntero <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. Los punteros <code class="docutils literal notranslate"><span class="pre">NULL</span></code> tienen un valor booleano falso..:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">null_ptr</span><span class="p">))</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> comprueba si hay <code class="docutils literal notranslate"><span class="pre">NULL</span></code> cuando los punteros de referencia (pero los punteros no válidos de referencia no-<code class="docutils literal notranslate"><span class="pre">NULL</span></code> se romperán en Python):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">....</span>
<span class="gr">ValueError</span>: <span class="n">NULL pointer access</span>
<span class="go">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1234</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">....</span>
<span class="gr">ValueError</span>: <span class="n">NULL pointer access</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="type-conversions">
<span id="ctypes-type-conversions"></span><h3>Conversiones de tipos<a class="headerlink" href="#type-conversions" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Por lo general, los ctypes hacen un control estricto de los tipos. Esto significa que si tienes <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code> en la lista <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> de una función o como el tipo de un campo miembro en una definición de estructura, sólo se aceptan instancias exactamente del mismo tipo. Hay algunas excepciones a esta regla, en las que ctypes acepta otros objetos. Por ejemplo, se pueden pasar instancias de arreglo compatibles en lugar de tipos de puntero. Así, para <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code>, ctypes acepta un arreglo de <em>c_int</em>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_int</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">count</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="gp">...</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Además, si se declara explícitamente que un argumento de función es de tipo puntero (como <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code>) en <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code>, se puede pasar un objeto de tipo puntero (<code class="docutils literal notranslate"><span class="pre">c_int</span></code> en este caso) a la función. ctypes aplicará la conversión <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a> requerida en este caso automáticamente.</p>
<p>Para poner un campo de tipo POINTER a <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, puedes asignar <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="kc">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>A veces se tienen instancias de tipos incompatibles. En C, puedes cambiar un tipo por otro tipo. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> proporciona una función <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> qué puede ser usada de la misma manera. La estructura <code class="docutils literal notranslate"><span class="pre">Bar</span></code> definida arriba acepta punteros <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code> o arreglos <code class="xref py py-class docutils literal notranslate"><span class="pre">c_int`</span></code> para su campo <code class="docutils literal notranslate"><span class="pre">values</span></code>, pero no instancias de otros tipos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">incompatible types, c_byte_Array_4 instance instead of LP_c_long instance</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Para estos casos, la función <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> es muy útil.</p>
<p>La función <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> puede ser usada para lanzar una instancia ctypes en un puntero a un tipo de datos ctypes diferente. <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> toma dos parámetros, un objeto ctypes que es o puede ser convertido en un puntero de algún tipo, y un tipo de puntero ctypes. retorna una instancia del segundo argumento, que hace referencia al mismo bloque de memoria que el primer argumento:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cast</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="go">&lt;ctypes.LP_c_long object at ...&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Así, <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> puede ser usado para asignar al campo <code class="docutils literal notranslate"><span class="pre">values</span></code> de <code class="docutils literal notranslate"><span class="pre">Bar</span></code> la estructura:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cast</span><span class="p">((</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)(),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">0</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="incomplete-types">
<span id="ctypes-incomplete-types"></span><h3>Tipos incompletos<a class="headerlink" href="#incomplete-types" title="Enlazar permanentemente con este título">¶</a></h3>
<p><em>Los Tipos Incompletos</em> son estructuras, uniones o matrices cuyos miembros aún no están especificados. En C, se especifican mediante declaraciones a futuro, que se definen más adelante:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">cell</span><span class="p">;</span> <span class="o">/*</span> <span class="n">forward</span> <span class="n">declaration</span> <span class="o">*/</span>

<span class="n">struct</span> <span class="n">cell</span> <span class="p">{</span>
    <span class="n">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="n">struct</span> <span class="n">cell</span> <span class="o">*</span><span class="nb">next</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>La traducción directa al código de ctypes sería esta, pero no funciona:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">cell</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">cell</span><span class="p">))]</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">cell</span>
<span class="gr">NameError</span>: <span class="n">name &#39;cell&#39; is not defined</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>porque la nueva <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">cell</span></code> no está disponible en la propia declaración de clase. En <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>, podemos definir la clase <code class="docutils literal notranslate"><span class="pre">cell</span></code> y establecer el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> más tarde, después de la declaración de clase:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">cell</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                 <span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">cell</span><span class="p">))]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Vamos a intentarlo. Creamos dos instancias de <code class="docutils literal notranslate"><span class="pre">cell</span></code>, y dejamos que se apunten una a la otra, y finalmente seguimos la cadena de punteros unas cuantas veces:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="n">cell</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;foo&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="n">cell</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">c1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">foo bar foo bar foo bar foo bar</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="callback-functions">
<span id="ctypes-callback-functions"></span><h3>Funciones de retrollamadas (<em>callback</em>)<a class="headerlink" href="#callback-functions" title="Enlazar permanentemente con este título">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> permite crear punteros de función invocables C a partir de los invocables de Python. A veces se llaman <em>funciones de retrollamada</em>.</p>
<p>Primero, debes crear una clase para la función de retrollamada. La clase conoce la convención de llamada, el tipo de retorno, y el número y tipos de argumentos que esta función recibirá.</p>
<p>La función de fábrica <code class="xref py py-func docutils literal notranslate"><span class="pre">CFUNCTYPE`()</span></code> crea tipos para las funciones de retrollamada usando la convención de llamada <code class="docutils literal notranslate"><span class="pre">cdecl</span></code>. En Windows, la función de fábrica <a class="reference internal" href="#ctypes.WINFUNCTYPE" title="ctypes.WINFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">WINFUNCTYPE()</span></code></a> crea tipos para funciones de retrollamadas usando la convención de llamadas <code class="docutils literal notranslate"><span class="pre">stdcall</span></code>.</p>
<p>Ambas funciones de fábrica se llaman con el tipo de resultado como primer argumento, y las funciones de llamada de retorno con los tipos de argumentos esperados como los argumentos restantes.</p>
<p>Presentaré un ejemplo aquí que utiliza la función <code class="xref c c-func docutils literal notranslate"><span class="pre">qsort()</span></code> de la biblioteca estándar de C, que se utiliza para ordenar los elementos con la ayuda de una función de retrollamada. <code class="xref c c-func docutils literal notranslate"><span class="pre">qsort()</span></code> se utilizará para ordenar un conjunto de números enteros:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">IntArray5</span> <span class="o">=</span> <span class="n">c_int</span> <span class="o">*</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ia</span> <span class="o">=</span> <span class="n">IntArray5</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">qsort</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="kc">None</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">qsort()</span></code> debe ser llamada con un puntero a los datos a ordenar, el número de elementos en el array de datos, el tamaño de un elemento, y un puntero a la función de comparación, la llamada de retorno. La llamada de retorno se llamará entonces con dos punteros a los ítems, y debe retornar un entero negativo si el primer ítem es más pequeño que el segundo, un cero si son iguales, y un entero positivo en caso contrario.</p>
<p>Así que nuestra función de retrollamada recibe punteros a números enteros, y debe retornar un número entero. Primero creamos el <code class="docutils literal notranslate"><span class="pre">tipo</span></code> para la función de retrollamada:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">CMPFUNC</span> <span class="o">=</span> <span class="n">CFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Para empezar, aquí hay una simple llamada que muestra los valores que se pasan:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="mi">0</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmp_func</span> <span class="o">=</span> <span class="n">CMPFUNC</span><span class="p">(</span><span class="n">py_cmp_func</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>El resultado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">cmp_func</span><span class="p">)</span>  
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 5 7</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Ahora podemos comparar los dos artículos y obtener un resultado útil:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">CMPFUNC</span><span class="p">(</span><span class="n">py_cmp_func</span><span class="p">))</span> 
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">py_cmp_func 5 7</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Como podemos comprobar fácilmente, nuestro arreglo está ordenado ahora:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ia</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1 5 7 33 99</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Las funciones de fabrica pueden ser usadas como decoradores de fabrica, así que podemos escribir:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@CFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">py_cmp_func</span><span class="p">)</span>
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">py_cmp_func 5 7</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Asegúrate de mantener las referencias a los objetos <a class="reference internal" href="#ctypes.CFUNCTYPE" title="ctypes.CFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CFUNCTYPE()</span></code></a> mientras se usen desde el código C. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> no lo hace, y si no lo haces, pueden ser basura recolectada, colapsando tu programa cuando se hace una llamada.</p>
<p>Además, nótese que sí se llama a la función de retrollamada en un hilo creado fuera del control de Python (por ejemplo, por el código foráneo que llama a la retrollamada), ctypes crea un nuevo hilo Python tonto en cada invocación. Este comportamiento es correcto para la mayoría de los propósitos, pero significa que los valores almacenados con <a class="reference internal" href="threading.html#threading.local" title="threading.local"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.local</span></code></a> <em>no</em> sobreviven a través de diferentes llamadas de retorno, incluso cuando esas llamadas se hacen desde el mismo hilo C.</p>
</div>
</section>
<section id="accessing-values-exported-from-dlls">
<span id="ctypes-accessing-values-exported-from-dlls"></span><h3>Acceder a los valores exportados de los dlls<a class="headerlink" href="#accessing-values-exported-from-dlls" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Algunas bibliotecas compartidas no sólo exportan funciones, sino también variables. Un ejemplo en la propia biblioteca de Python es el <a class="reference internal" href="../c-api/init.html#c.Py_OptimizeFlag" title="Py_OptimizeFlag"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_OptimizeFlag</span></code></a>, un entero establecido en 0, 1, o 2, dependiendo del flag <a class="reference internal" href="../using/cmdline.html#cmdoption-O"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a> o <a class="reference internal" href="../using/cmdline.html#cmdoption-OO"><code class="xref std std-option docutils literal notranslate"><span class="pre">-OO</span></code></a> dado en el inicio.</p>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> puede acceder a valores como este con los métodos de la clase <code class="xref py py-meth docutils literal notranslate"><span class="pre">in_dll()</span></code> del tipo. <em>pythonapi</em> es un símbolo predefinido que da acceso a la API de Python C:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">opt_flag</span> <span class="o">=</span> <span class="n">c_int</span><span class="o">.</span><span class="n">in_dll</span><span class="p">(</span><span class="n">pythonapi</span><span class="p">,</span> <span class="s2">&quot;Py_OptimizeFlag&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">opt_flag</span><span class="p">)</span>
<span class="go">c_long(0)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Si el intérprete se hubiera iniciado con <a class="reference internal" href="../using/cmdline.html#cmdoption-O"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a>, el ejemplo habría impreso <code class="docutils literal notranslate"><span class="pre">c_long(1)</span></code>, o <code class="docutils literal notranslate"><span class="pre">c_long(2)</span></code> si <a class="reference internal" href="../using/cmdline.html#cmdoption-OO"><code class="xref std std-option docutils literal notranslate"><span class="pre">-OO</span></code></a> se hubiera especificado.</p>
<p>Un ejemplo extendido que también demuestra el uso de punteros accediendo al puntero <a class="reference internal" href="../c-api/import.html#c.PyImport_FrozenModules" title="PyImport_FrozenModules"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyImport_FrozenModules</span></code></a> exportado por Python.</p>
<p>Citando los documentos para ese valor:</p>
<blockquote>
<div><p>This pointer is initialized to point to an array of <a class="reference internal" href="../c-api/import.html#c._frozen" title="_frozen"><code class="xref c c-struct docutils literal notranslate"><span class="pre">_frozen</span></code></a>
records, terminated by one whose members are all <code class="docutils literal notranslate"><span class="pre">NULL</span></code> or zero.  When a frozen
module is imported, it is searched in this table.  Third-party code could play
tricks with this to provide a dynamically created collection of frozen modules.</p>
</div></blockquote>
<p>Así que manipular este puntero podría incluso resultar útil. Para restringir el tamaño del ejemplo, sólo mostramos cómo esta tabla puede ser leída con <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">struct_frozen</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;code&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_ubyte</span><span class="p">)),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;size&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>We have defined the <a class="reference internal" href="../c-api/import.html#c._frozen" title="_frozen"><code class="xref c c-struct docutils literal notranslate"><span class="pre">_frozen</span></code></a> data type, so we can get the pointer
to the table:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">FrozenTable</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">struct_frozen</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="n">FrozenTable</span><span class="o">.</span><span class="n">in_dll</span><span class="p">(</span><span class="n">pythonapi</span><span class="p">,</span> <span class="s2">&quot;PyImport_FrozenModules&quot;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Como <cite>tabla`</cite> es un <code class="docutils literal notranslate"><span class="pre">puntero</span></code> al arreglo de registros <code class="docutils literal notranslate"><span class="pre">struct_frozen</span></code>, podemos iterar sobre ella, pero sólo tenemos que asegurarnos de que nuestro bucle termine, porque los punteros no tienen tamaño. Tarde o temprano, probablemente se caerá con una violación de acceso o lo que sea, así que es mejor salir del bucle cuando le demos a la entrada <code class="docutils literal notranslate"><span class="pre">NULL</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">break</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">),</span> <span class="n">item</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">_frozen_importlib 31764</span>
<span class="go">_frozen_importlib_external 41499</span>
<span class="go">__hello__ 161</span>
<span class="go">__phello__ -161</span>
<span class="go">__phello__.spam 161</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>El hecho de que la Python estándar tenga un módulo congelado y un paquete congelado (indicado por el miembro <code class="docutils literal notranslate"><span class="pre">tamaño</span></code> negativo) no se conoce bien, sólo se usa para hacer pruebas. Pruébalo con <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">__hello__</span></code> por ejemplo.</p>
</section>
<section id="surprises">
<span id="ctypes-surprises"></span><h3>Sorpresas<a class="headerlink" href="#surprises" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Hay algunas aristas en <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> en las que podrías esperar algo distinto de lo que realmente sucede.</p>
<p>Considere el siguiente ejemplo:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">RECT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">1 2 3 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># now swap the two points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">3 4 3 4</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Hm. Ciertamente esperábamos que la última declaración imprimiera <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">4</span> <span class="pre">1</span> <span class="pre">2</span></code>. ¿Qué ha pasado? Aquí están los pasos de la línea <code class="docutils literal notranslate"><span class="pre">rc.a,</span> <span class="pre">rc.b</span> <span class="pre">=</span> <span class="pre">rc.b,</span> <span class="pre">rc.a</span></code> arriba:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">temp0</span><span class="p">,</span> <span class="n">temp1</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">temp0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp1</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Note que <code class="docutils literal notranslate"><span class="pre">temp0</span></code> y <code class="docutils literal notranslate"><span class="pre">temp1</span></code> son objetos que todavía usan el buffer interno del objeto <code class="docutils literal notranslate"><span class="pre">rc</span></code> de arriba. Así que ejecutando <code class="docutils literal notranslate"><span class="pre">rc.a</span> <span class="pre">=</span> <span class="pre">temp0</span></code> copia el contenido del buffer de <code class="docutils literal notranslate"><span class="pre">temp0</span></code> en el buffer de <code class="docutils literal notranslate"><span class="pre">rc</span></code>. Esto, a su vez, cambia el contenido de <code class="docutils literal notranslate"><span class="pre">temp1</span></code>. Por lo tanto, la última asignación <code class="docutils literal notranslate"><span class="pre">rc.b</span> <span class="pre">=</span> <span class="pre">temp1</span></code>, no tiene el efecto esperado.</p>
<p>Tengan en cuenta que la recuperación de subobjetos de Estructuras, Uniones y Arreglos no <em>copia</em> el subobjeto, sino que recupera un objeto contenido que accede al búfer subyacente del objeto raíz.</p>
<p>Otro ejemplo que puede comportarse de manera diferente a lo que uno esperaría es este:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">c_char_p</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;abc def ghi&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span>
<span class="go">b&#39;abc def ghi&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="n">s</span><span class="o">.</span><span class="n">value</span>
<span class="go">False</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Los objetos instanciados desde <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a> sólo pueden tener su valor fijado en bytes o enteros.</p>
</div>
<p>¿Por qué está imprimiendo <code class="docutils literal notranslate"><span class="pre">False</span></code>? Las instancias ctypes son objetos que contienen un bloque de memoria más algunos <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a>s que acceden al contenido de la memoria. Almacenar un objeto Python en el bloque de memoria no almacena el objeto en sí mismo, en su lugar se almacenan los <code class="docutils literal notranslate"><span class="pre">contenidos</span></code> del objeto. ¡Acceder a los contenidos de nuevo construye un nuevo objeto Python cada vez!</p>
</section>
<section id="variable-sized-data-types">
<span id="ctypes-variable-sized-data-types"></span><h3>Tipos de datos de tamaño variable<a class="headerlink" href="#variable-sized-data-types" title="Enlazar permanentemente con este título">¶</a></h3>
<p><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> proporciona algo de soporte para matrices y estructuras de tamaño variable.</p>
<p>La función <a class="reference internal" href="#ctypes.resize" title="ctypes.resize"><code class="xref py py-func docutils literal notranslate"><span class="pre">resize()</span></code></a> puede ser usada para redimensionar el buffer de memoria de un objeto ctypes existente. La función toma el objeto como primer argumento, y el tamaño solicitado en bytes como segundo argumento. El bloque de memoria no puede hacerse más pequeño que el bloque de memoria natural especificado por el tipo de objeto, se lanza un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> si se intenta:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_short</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">short_array</span><span class="p">))</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">short_array</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">minimum size is 8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">short_array</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizeof</span><span class="p">(</span><span class="n">short_array</span><span class="p">)</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizeof</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">short_array</span><span class="p">))</span>
<span class="go">8</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Esto está bien, pero ¿cómo se puede acceder a los elementos adicionales contenidos en este arreglo?  Dado que el tipo todavía sabe sólo 4 elementos, obtenemos errores al acceder a otros elementos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span><span class="p">[:]</span>
<span class="go">[0, 0, 0, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">IndexError</span>: <span class="n">invalid index</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Otra forma de utilizar tipos de datos de tamaño variable con <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> es utilizar la naturaleza dinámica de Python, y (re)definir el tipo de datos después de que se conozca el tamaño requerido, caso por caso.</p>
</section>
</section>
<section id="ctypes-reference">
<span id="ctypes-ctypes-reference"></span><h2>referencia ctypes<a class="headerlink" href="#ctypes-reference" title="Enlazar permanentemente con este título">¶</a></h2>
<section id="finding-shared-libraries">
<span id="ctypes-finding-shared-libraries"></span><h3>Encontrar bibliotecas compartidas<a class="headerlink" href="#finding-shared-libraries" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Cuando se programa en un lenguaje compilado, se accede a las bibliotecas compartidas cuando se compila/enlaza un programa, y cuándo se ejecuta el programa.</p>
<p>El propósito de la función <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code> es localizar una biblioteca de forma similar a lo que hace el compilador o el cargador en tiempo de ejecución (en plataformas con varias versiones de una biblioteca compartida se debería cargar la más reciente), mientras que los cargadores de bibliotecas ctypes actúan como cuando se ejecuta un programa, y llaman directamente al cargador en tiempo de ejecución.</p>
<p>El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes.util</span></code> proporciona una función que puede ayudar a determinar la biblioteca a cargar.</p>
<dl class="py data">
<dt>
<code class="sig-prename descclassname">ctypes.util.</code><code class="sig-name descname">find_library</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span></dt>
<dd><p>Intenta encontrar una biblioteca y retornar un nombre. <em>name</em> es el nombre de la biblioteca sin ningún prefijo como <em>lib</em>, sufijo como <code class="docutils literal notranslate"><span class="pre">.so</span></code>, <code class="docutils literal notranslate"><span class="pre">.dylib</span></code> o número de versión (esta es la forma usada para la opción del enlazador posix <code class="xref std std-option docutils literal notranslate"><span class="pre">-l</span></code>). Si no se puede encontrar ninguna biblioteca, retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<p>La funcionalidad exacta depende del sistema.</p>
<p>En Linux, <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code> intenta ejecutar programas externos (<code class="docutils literal notranslate"><span class="pre">/sbin/ldconfig</span></code>, <code class="docutils literal notranslate"><span class="pre">gcc</span></code>, <code class="docutils literal notranslate"><span class="pre">objdump</span></code> y <code class="docutils literal notranslate"><span class="pre">ld</span></code>) para encontrar el archivo de la biblioteca. retorna el nombre del archivo de la biblioteca.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>En Linux, el valor de la variable de entorno <code class="docutils literal notranslate"><span class="pre">LD_LIBRARY_PATH</span></code> se utiliza cuando se buscan bibliotecas, si una biblioteca no puede ser encontrada por ningún otro medio.</p>
</div>
<p>Aquí hay algunos ejemplos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.util</span> <span class="kn">import</span> <span class="n">find_library</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
<span class="go">&#39;libm.so.6&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>
<span class="go">&#39;libc.so.6&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;bz2&quot;</span><span class="p">)</span>
<span class="go">&#39;libbz2.so.1.0&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>En macOS, <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code> prueba varios esquemas de nombres y rutas predefinidos para ubicar la biblioteca, y retorna un nombre de ruta completo si tiene éxito:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.util</span> <span class="kn">import</span> <span class="n">find_library</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libc.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libm.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;bz2&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libbz2.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;AGL&quot;</span><span class="p">)</span>
<span class="go">&#39;/System/Library/Frameworks/AGL.framework/AGL&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>En Windows, <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library`()</span></code> busca a lo largo de la ruta de búsqueda del sistema, y retorna la ruta completa, pero como no hay un esquema de nombres predefinido, una llamada como <code class="docutils literal notranslate"><span class="pre">find_library(&quot;c&quot;)</span></code> fallará y retornará <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Si envolvemos una biblioteca compartida con <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>, puede ser mejor determinar el nombre de la biblioteca compartida en tiempo de desarrollo, y codificarlo en el módulo de envoltura en lugar de usar <code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code> para localizar la biblioteca en tiempo de ejecución.</p>
</section>
<section id="loading-shared-libraries">
<span id="ctypes-loading-shared-libraries"></span><h3>Cargando bibliotecas compartidas<a class="headerlink" href="#loading-shared-libraries" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Hay varias maneras de cargar las bibliotecas compartidas en el proceso Python. Una forma es instanciar una de las siguientes clases:</p>
<dl class="py class">
<dt id="ctypes.CDLL">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">CDLL</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">DEFAULT_MODE</span></em>, <em class="sig-param"><span class="n">handle</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">use_errno</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">use_last_error</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">winmode</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.CDLL" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Instances of this class represent loaded shared libraries. Functions in these
libraries use the standard C calling convention, and are assumed to return
<code class="xref c c-expr docutils literal notranslate"><span class="pre">int</span></code>.</p>
<p>En Windows, la creación de una instancia <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a> puede fallar incluso si existe el nombre de la DLL. Cuando no se encuentra una DLL dependiente de la DLL cargada, se lanza un error <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> con el mensaje <em>«[WinError 126] No se pudo encontrar el módulo especificado».</em> Este mensaje de error no contiene el nombre de DLL que falta porque la API de Windows no devuelve esta información, lo que dificulta el diagnóstico de este error. Para resolver este error y determinar qué DLL no se encuentra, debe buscar la lista de DLL dependientes y determinar cuál no se encuentra utilizando las herramientas de depuración y seguimiento de Windows.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p><a class="reference external" href="https://docs.microsoft.com/cpp/build/reference/dependents">Herramienta Microsoft DUMPBIN</a> – Una herramienta para encontrar dependientes de DLL.</p>
</div>
<dl class="py class">
<dt id="ctypes.OleDLL">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">OleDLL</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">DEFAULT_MODE</span></em>, <em class="sig-param"><span class="n">handle</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">use_errno</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">use_last_error</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">winmode</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.OleDLL" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Sólo Windows: Las instancias de esta clase representan bibliotecas compartidas cargadas, las funciones en estas bibliotecas usan la convención de llamada <code class="docutils literal notranslate"><span class="pre">stdcall</span></code>, y se asume que retornan el código específico de windows <code class="xref py py-class docutils literal notranslate"><span class="pre">HRESULT`</span></code>. Los valores <code class="xref py py-class docutils literal notranslate"><span class="pre">HRESULT`</span></code> contienen información que especifica si la llamada a la función falló o tuvo éxito, junto con un código de error adicional. Si el valor de retorno señala un fracaso, se lanza automáticamente un <code class="xref py py-class docutils literal notranslate"><span class="pre">OSError`</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span><a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">WindowsError</span></code></a> solía ser lanzado.</p>
</div>
</dd></dl>

<dl class="py class">
<dt id="ctypes.WinDLL">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">WinDLL</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">DEFAULT_MODE</span></em>, <em class="sig-param"><span class="n">handle</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">use_errno</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">use_last_error</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">winmode</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WinDLL" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Windows only: Instances of this class represent loaded shared libraries,
functions in these libraries use the <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> calling convention, and are
assumed to return <code class="xref c c-expr docutils literal notranslate"><span class="pre">int</span></code> by default.</p>
</dd></dl>

<p>El termino Python <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">global interpreter lock</span></a> es lanzado antes de llamar a cualquier función exportada por estas librerías, y se requiere después.</p>
<dl class="py class">
<dt id="ctypes.PyDLL">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">PyDLL</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">DEFAULT_MODE</span></em>, <em class="sig-param"><span class="n">handle</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.PyDLL" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Las instancias de esta clase se comportan como instancias <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a> , excepto que el GIL de Python es <em>no</em> liberado durante la llamada a la función, y después de la ejecución de la función se comprueba si esta activo el flag de error de Python. Si el flag de error esta activado, se lanza una excepción Python.</p>
<p>Por lo tanto, esto sólo es útil para llamar directamente a las funciones api C de Python.</p>
</dd></dl>

<p>Todas estas clases pueden ser instanciadas llamándolas con al menos un argumento, la ruta de la biblioteca compartida.  Si tienes un manejador existente de una biblioteca compartida ya cargada, se puede pasar como el parámetro llamado <code class="docutils literal notranslate"><span class="pre">handle</span></code>, de lo contrario la función <code class="docutils literal notranslate"><span class="pre">dlopen</span></code> o <code class="docutils literal notranslate"><span class="pre">LoadLibrary</span></code> de la plataforma subyacente es utilizada para cargar la biblioteca en el proceso, y  obtener un manejador de la misma.</p>
<p>El parámetro <em>mode</em> puede utilizarse para especificar cómo se carga la biblioteca. Para más detalles, consulte la página <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/dlopen(3)">dlopen(3)</a></em> del manual. En Windows, <em>mode</em> es ignorado. En los sistemas posix, RTLD_NOW siempre se agrega, y no es configurable.</p>
<p>El parámetro <em>use_errno</em>, cuando se establece en true, habilita un mecanismo ctypes que permite acceder al número de error del sistema <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> de forma segura. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> mantiene una copia local del hilo de la variable del sistema <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a>; si llamas a funciones extranjeras creadas con <code class="docutils literal notranslate"><span class="pre">use_errno=True</span></code> entonces el valor <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> antes de la llamada a la función se intercambia con la copia privada de ctypes, lo mismo ocurre inmediatamente después de la llamada a la función.</p>
<p>La función <a class="reference internal" href="#ctypes.get_errno" title="ctypes.get_errno"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.get_errno()</span></code></a> retorna el valor de la copia privada de ctypes, y la función <a class="reference internal" href="#ctypes.set_errno" title="ctypes.set_errno"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.set_errno()</span></code></a> cambia la copia privada de ctypes a un nuevo valor y retorna el valor anterior.</p>
<p>El parámetro <em>use_last_error</em>, cuando se establece en true, habilita el mismo mecanismo para el código de error de Windows que es administrado por las funciones de la API de Windows <a class="reference internal" href="#ctypes.GetLastError" title="ctypes.GetLastError"><code class="xref py py-func docutils literal notranslate"><span class="pre">GetLastError()</span></code></a> y <code class="xref py py-func docutils literal notranslate"><span class="pre">SetLastError()</span></code>; <a class="reference internal" href="#ctypes.get_last_error" title="ctypes.get_last_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.get_last_error()</span></code></a> y <a class="reference internal" href="#ctypes.set_last_error" title="ctypes.set_last_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.set_last_error()</span></code></a> se utilizan para solicitar y cambiar la copia privada ctypes del código de error de Windows.</p>
<p>El parámetro <em>winmode</em> se utiliza en Windows para especificar cómo se carga la biblioteca (ya que <em>mode</em> se ignora). Toma cualquier valor que sea válido para el parámetro flags de la API de Win32 <code class="docutils literal notranslate"><span class="pre">LoadLibraryEx</span></code>. Cuando se omite, el valor por defecto es usar los flags que resultan en la carga de DLL más segura para evitar problemas como el secuestro de DLL. Pasar la ruta completa a la DLL es la forma más segura de asegurar que se cargan la biblioteca y las dependencias correctas.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Añadido el parámetro <em>winmode</em>.</p>
</div>
<dl class="py data">
<dt>
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">RTLD_GLOBAL</code></dt>
<dd><p>Flag para usar como parámetro <em>modo</em>. En las plataformas en las que esta bandera no está disponible, se define como el cero entero.</p>
</dd></dl>

<dl class="py data">
<dt>
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">RTLD_LOCAL</code></dt>
<dd><p>Flag para usar como parámetro <em>modo</em>. En las plataformas en las que esto no está disponible, es lo mismo que <em>RTLD_GLOBAL</em>.</p>
</dd></dl>

<dl class="py data">
<dt>
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">DEFAULT_MODE</code></dt>
<dd><p>El modo por defecto que se utiliza para cargar las bibliotecas compartidas. En OSX 10.3, esto es <em>RTLD_GLOBAL</em>, de lo contrario es lo mismo que <em>RTLD_LOCAL</em>.</p>
</dd></dl>

<p>Las instancias de estas clases no tienen métodos públicos. Se puede acceder a las funciones exportadas por la biblioteca compartida como atributos o por índice. Tenga en cuenta que al acceder a la función a través de un atributo se almacena en caché el resultado y, por lo tanto, al acceder a él repetidamente se retorna el mismo objeto cada vez. Por otro lado, acceder a ella a través de un índice retorna un nuevo objeto cada vez:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="n">CDLL</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">CDLL</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>  <span class="c1"># On Linux</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">time</span> <span class="o">==</span> <span class="n">libc</span><span class="o">.</span><span class="n">time</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">libc</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Los siguientes atributos públicos están disponibles, su nombre comienza con un guión bajo para no chocar con los nombres de las funciones exportadas:</p>
<dl class="py attribute">
<dt id="ctypes.PyDLL._handle">
<code class="sig-prename descclassname">PyDLL.</code><code class="sig-name descname">_handle</code><a class="headerlink" href="#ctypes.PyDLL._handle" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El manejador del sistema usado para acceder a la biblioteca.</p>
</dd></dl>

<dl class="py attribute">
<dt id="ctypes.PyDLL._name">
<code class="sig-prename descclassname">PyDLL.</code><code class="sig-name descname">_name</code><a class="headerlink" href="#ctypes.PyDLL._name" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El nombre de la biblioteca pasado en el constructor.</p>
</dd></dl>

<p>Las bibliotecas compartidas también pueden ser cargadas usando uno de los objetos prefabricados, que son instancias de la clase <a class="reference internal" href="#ctypes.LibraryLoader" title="ctypes.LibraryLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">LibraryLoader</span></code></a>, ya sea llamando al método <code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadLibrary()</span></code>, o recuperando la biblioteca como atributo de la instancia de carga.</p>
<dl class="py class">
<dt id="ctypes.LibraryLoader">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">LibraryLoader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dlltype</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LibraryLoader" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Clase que carga bibliotecas compartidas. <em>dlltype</em> debe ser uno de los tipos <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a>, <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyDLL</span></code></a>, <a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">WinDLL</span></code></a>, o <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">OleDLL</span></code></a>.</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code> tiene un comportamiento especial: Permite cargar una biblioteca compartida accediendo a ella como atributo de una instancia de carga de biblioteca. El resultado se almacena en caché, de modo que los accesos repetidos a los atributos retornan la misma biblioteca cada vez.</p>
<dl class="py method">
<dt id="ctypes.LibraryLoader.LoadLibrary">
<code class="sig-name descname">LoadLibrary</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LibraryLoader.LoadLibrary" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Carga una biblioteca compartida en el proceso y la retorna. Este método siempre retorna una nueva instancia de la biblioteca.</p>
</dd></dl>

</dd></dl>

<p>Estos cargadores prefabricados de bibliotecas están disponibles:</p>
<dl class="py data">
<dt>
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">cdll</code></dt>
<dd><p>Crea instancias de <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a>.</p>
</dd></dl>

<dl class="py data">
<dt>
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">windll</code></dt>
<dd><p>Sólo Windows: Crea instancias de <a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">WinDLL</span></code></a>.</p>
</dd></dl>

<dl class="py data">
<dt>
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">oledll</code></dt>
<dd><p>Sólo Windows: Crea instancias de <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">OleDLL</span></code></a>.</p>
</dd></dl>

<dl class="py data">
<dt>
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">pydll</code></dt>
<dd><p>Crea instancias de <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyDLL</span></code></a>.</p>
</dd></dl>

<p>Para acceder directamente a la API C de Python, se dispone de un objeto de biblioteca compartida de Python listo-para-usar:</p>
<dl class="py data">
<dt>
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">pythonapi</code></dt>
<dd><p>An instance of <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyDLL</span></code></a> that exposes Python C API functions as
attributes.  Note that all these functions are assumed to return C
<code class="xref c c-expr docutils literal notranslate"><span class="pre">int</span></code>, which is of course not always the truth, so you have to assign
the correct <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> attribute to use these functions.</p>
</dd></dl>

<p class="audit-hook">Lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.dlopen</span></code> con argumento <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
<p class="audit-hook"><p>Al acceder a una función en una biblioteca cargada se lanza un evento de auditoría <code class="docutils literal notranslate"><span class="pre">ctypes.dlsym</span></code> con argumentos <code class="docutils literal notranslate"><span class="pre">library</span></code> (el objeto de la biblioteca) y <code class="docutils literal notranslate"><span class="pre">name</span></code> (el nombre del símbolo como cadena o entero).</p>
</p>
<p class="audit-hook"><p>En los casos en los que sólo está disponible el manejador de la biblioteca en lugar del objeto, al acceder a una función se produce un evento de auditoría <code class="docutils literal notranslate"><span class="pre">ctypes.dlsym/handle</span></code> con los argumentos <code class="docutils literal notranslate"><span class="pre">handle</span></code> (el manejador de la biblioteca en bruto) y <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
</p>
</section>
<section id="foreign-functions">
<span id="ctypes-foreign-functions"></span><h3>Funciones foráneas<a class="headerlink" href="#foreign-functions" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Como se explicó en la sección anterior, se puede acceder a las funciones foráneas como atributos de las bibliotecas compartidas cargadas. Los objetos de función creados de esta forma aceptan por defecto cualquier número de argumentos, aceptan cualquier instancia de datos ctypes como argumentos y retornan el tipo de resultado por defecto especificado por el cargador de la biblioteca. Son instancias de una clase privada:</p>
<dl class="py class">
<dt id="ctypes._FuncPtr">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">_FuncPtr</code><a class="headerlink" href="#ctypes._FuncPtr" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Clase base para funciones foráneas C invocables.</p>
<p>Las instancias de funciones foráneas también son tipos de datos compatibles con C; representan punteros de funciones C.</p>
<p>Este comportamiento puede personalizarse asignando a los atributos especiales del objeto de la función foránea.</p>
<dl class="py attribute">
<dt id="ctypes._FuncPtr.restype">
<code class="sig-name descname">restype</code><a class="headerlink" href="#ctypes._FuncPtr.restype" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Assign a ctypes type to specify the result type of the foreign function.
Use <code class="docutils literal notranslate"><span class="pre">None</span></code> for <code class="xref c c-expr docutils literal notranslate"><span class="pre">void</span></code>, a function not returning anything.</p>
<p>It is possible to assign a callable Python object that is not a ctypes
type, in this case the function is assumed to return a C <code class="xref c c-expr docutils literal notranslate"><span class="pre">int</span></code>, and
the callable will be called with this integer, allowing further
processing or error checking.  Using this is deprecated, for more flexible
post processing or error checking use a ctypes data type as
<a class="reference internal" href="#ctypes._FuncPtr.restype" title="ctypes._FuncPtr.restype"><code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code></a> and assign a callable to the <a class="reference internal" href="#ctypes._FuncPtr.errcheck" title="ctypes._FuncPtr.errcheck"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code></a> attribute.</p>
</dd></dl>

<dl class="py attribute">
<dt id="ctypes._FuncPtr.argtypes">
<code class="sig-name descname">argtypes</code><a class="headerlink" href="#ctypes._FuncPtr.argtypes" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Asigne una tupla de tipos ctypes para especificar los tipos de argumentos que acepta la función. Las funciones que utilizan la convención de llamada <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> sólo pueden ser llamadas con el mismo número de argumentos que la longitud de esta tupla; las funciones que utilizan la convención de llamada C aceptan también argumentos adicionales no especificados.</p>
<p>Cuando se llama a una función foránea, cada argumento real se pasa al método de la clase <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code> de los elementos de la tupla <a class="reference internal" href="#ctypes._FuncPtr.argtypes" title="ctypes._FuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a>, este método permite adaptar el argumento real a un objeto que la función externa acepta. Por ejemplo, un elemento <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a> de la tupla <a class="reference internal" href="#ctypes._FuncPtr.argtypes" title="ctypes._FuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> convertirá una cadena pasada como argumento en un objeto de bytes utilizando reglas de conversión ctypes.</p>
<p>Nuevo: Ahora es posible poner en argtypes elementos que no son de tipo ctypes, pero cada elemento debe tener un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code> que retorne un valor utilizable como argumento (entero, cadena, instancia ctypes). Esto permite definir adaptadores que pueden adaptar objetos personalizados como parámetros de la función.</p>
</dd></dl>

<dl class="py attribute">
<dt id="ctypes._FuncPtr.errcheck">
<code class="sig-name descname">errcheck</code><a class="headerlink" href="#ctypes._FuncPtr.errcheck" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Asigne una función Python u otra llamada a este atributo. El invocable será llamado con tres o más argumentos:</p>
<dl class="py function">
<dt>
<code class="sig-name descname">callable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">result</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">arguments</span></em><span class="sig-paren">)</span></dt>
<dd><p><em>result</em> es lo que retorna la función externa, como se especifica en el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code>.</p>
<p><em>func</em> es el propio objeto de la función foránea, lo que permite reutilizar el mismo objeto invocable para comprobar o postprocesar los resultados de varias funciones.</p>
<p><em>arguments</em> es una tupla que contiene los parámetros originalmente pasados a la llamada de la función, esto permite especializar el comportamiento en los argumentos utilizados.</p>
</dd></dl>

<p>El objeto que retorna esta función será retornado por la llamada de la función foránea, pero también puede comprobar el valor del resultado y hacer una excepción si la llamada de la función foránea ha fallado.</p>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt id="ctypes.ArgumentError">
<em class="property">exception </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">ArgumentError</code><a class="headerlink" href="#ctypes.ArgumentError" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta excepción se lanza cuando una llamada a una función foránea no puede convertir uno de los argumentos pasados.</p>
</dd></dl>

<p class="audit-hook"><p>En Windows, cuando una llamada a una función foránea plantea una excepción de sistema (por ejemplo, debido a una violación de acceso), será capturada y sustituida por una excepción Python adecuada. Además, un evento de auditoría <code class="docutils literal notranslate"><span class="pre">ctypes.seh_exception</span></code> con el argumento <code class="docutils literal notranslate"><span class="pre">code</span></code> será levantado, permitiendo que un gancho de auditoría reemplace la excepción con la suya propia.</p>
</p>
<p class="audit-hook"><p>Algunas formas de invocar llamadas a funciones foráneas pueden lanzar un evento de auditoría <code class="docutils literal notranslate"><span class="pre">ctypes.call_function</span></code> con los argumentos <code class="docutils literal notranslate"><span class="pre">function</span> <span class="pre">pointer</span></code> y <code class="docutils literal notranslate"><span class="pre">arguments</span></code>.</p>
</p>
</section>
<section id="function-prototypes">
<span id="ctypes-function-prototypes"></span><h3>Prototipos de funciones<a class="headerlink" href="#function-prototypes" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Las funciones foráneas también pueden crearse mediante la instanciación de prototipos de funciones. Los prototipos de funciones son similares a los prototipos de funciones en C; describen una función (tipo de retorno, tipos de argumentos, convención de llamada) sin definir una implementación. Las funciones de fábrica deben ser llamadas con el tipo de resultado deseado y los tipos de argumento de la función, y pueden ser usadas como fábricas de decoradores, y como tales, ser aplicadas a las funciones a través de la sintaxis <code class="docutils literal notranslate"><span class="pre">&#64;wrapper</span></code>. Ver <a class="reference internal" href="#ctypes-callback-functions"><span class="std std-ref">Funciones de retrollamadas (callback)</span></a> para ejemplos.</p>
<dl class="py function">
<dt id="ctypes.CFUNCTYPE">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">CFUNCTYPE</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">restype</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">argtypes</span></em>, <em class="sig-param"><span class="n">use_errno</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">use_last_error</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.CFUNCTYPE" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El prototipo de función retornado crea funciones que usan la convención de llamada C estándar. La función liberará el GIL durante la llamada. Si <em>use_errno</em> se configura a true, la copia privada de ctypes de la variable del sistema <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> se intercambia con el valor real <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> antes y después de la llamada; <em>use_last_error</em> hace lo mismo con el código de error de Windows.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.WINFUNCTYPE">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">WINFUNCTYPE</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">restype</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">argtypes</span></em>, <em class="sig-param"><span class="n">use_errno</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">use_last_error</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WINFUNCTYPE" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Windows only: The returned function prototype creates functions that use the
<code class="docutils literal notranslate"><span class="pre">stdcall</span></code> calling convention.  The function will
release the GIL during the call.  <em>use_errno</em> and <em>use_last_error</em> have the
same meaning as above.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.PYFUNCTYPE">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">PYFUNCTYPE</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">restype</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">argtypes</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.PYFUNCTYPE" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>El prototipo de función retornado crea funciones que usan la convención de llamadas de Python. La función <em>no</em> liberará el GIL durante la llamada.</p>
</dd></dl>

<p>Los prototipos de funciones creados por estas funciones de fábrica pueden ser instanciados de diferentes maneras, dependiendo del tipo y el número de los parámetros en la llamada:</p>
<blockquote>
<div><dl class="py function">
<dt>
<code class="sig-name descname">prototype</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">address</span></em><span class="sig-paren">)</span></dt>
<dd><p>Retorna una función foránea en la dirección especificada que debe ser un número entero.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">prototype</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">callable</span></em><span class="sig-paren">)</span></dt>
<dd><p>Crear una función de llamada C (una función de retrollamada) a partir de un <em>callable</em> Python.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">prototype</code><span class="sig-paren">(</span><em class="sig-param">func_spec</em><span class="optional">[</span>, <em class="sig-param">paramflags</em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Retorna una función foránea exportada por una biblioteca compartida. <em>func_spec</em> debe ser un 2-tupla <code class="docutils literal notranslate"><span class="pre">(name_or_ordinal,</span> <span class="pre">library)</span></code>. El primer elemento es el nombre de la función exportada como cadena, o el ordinal de la función exportada como entero pequeño. El segundo elemento es la instancia de la biblioteca compartida.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">prototype</code><span class="sig-paren">(</span><em class="sig-param">vtbl_index</em>, <em class="sig-param">name</em><span class="optional">[</span>, <em class="sig-param">paramflags</em><span class="optional">[</span>, <em class="sig-param">iid</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p>Retorna una función foránea que llamará a un método COM. <em>vtbl_index</em> es el índice de la tabla de funciones virtuales, un pequeño entero no negativo. <em>name</em> es el nombre del método COM. <em>iid</em> es un puntero opcional para el identificador de la interfaz que se utiliza en el informe de errores extendido.</p>
<p>Los métodos COM usan una convención especial de llamadas: Requieren un puntero a la interfaz COM como primer argumento, además de los parámetros que se especifican en la tupla <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code>.</p>
</dd></dl>

<p>El parámetro opcional <em>paramflags</em> crea envoltorios de funciones foráneas con mucha más funcionalidad que las características descritas anteriormente.</p>
<p><em>paramflags</em> deben ser una tupla de la misma longitud que <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code>.</p>
<p>Cada elemento de esta tupla contiene más información sobre un parámetro, debe ser una tupla que contenga uno, dos o tres elementos.</p>
<p>El primer elemento es un entero que contiene una combinación de flags de dirección para el parámetro:</p>
<blockquote>
<div><dl class="simple">
<dt>1</dt><dd><p>Especifica un parámetro de entrada a la función.</p>
</dd>
<dt>2</dt><dd><p>Parámetro de salida. La función foránea rellena un valor.</p>
</dd>
<dt>4</dt><dd><p>Parámetro de entrada que por defecto es el cero entero.</p>
</dd>
</dl>
</div></blockquote>
<p>El segundo elemento opcional es el nombre del parámetro como cadena. Si se especifica esto, se puede llamar a la función foránea con parámetros con nombre.</p>
<p>El tercer elemento opcional es el valor por defecto de este parámetro.</p>
</div></blockquote>
<p>Este ejemplo demuestra cómo envolver la función <code class="docutils literal notranslate"><span class="pre">MessageBoxW</span></code> de Windows para que soporte los parámetros por defecto y los argumentos con nombre. La declaración C del archivo de cabecera de Windows es esta:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">WINUSERAPI</span> <span class="nb">int</span> <span class="n">WINAPI</span>
<span class="n">MessageBoxW</span><span class="p">(</span>
    <span class="n">HWND</span> <span class="n">hWnd</span><span class="p">,</span>
    <span class="n">LPCWSTR</span> <span class="n">lpText</span><span class="p">,</span>
    <span class="n">LPCWSTR</span> <span class="n">lpCaption</span><span class="p">,</span>
    <span class="n">UINT</span> <span class="n">uType</span><span class="p">);</span>
</pre></div>
</div>
<p>Aquí está el envoltorio con <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="n">c_int</span><span class="p">,</span> <span class="n">WINFUNCTYPE</span><span class="p">,</span> <span class="n">windll</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.wintypes</span> <span class="kn">import</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">UINT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prototype</span> <span class="o">=</span> <span class="n">WINFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">UINT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paramflags</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;hwnd&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="s2">&quot;Hi&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;caption&quot;</span><span class="p">,</span> <span class="s2">&quot;Hello from ctypes&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;flags&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span> <span class="o">=</span> <span class="n">prototype</span><span class="p">((</span><span class="s2">&quot;MessageBoxW&quot;</span><span class="p">,</span> <span class="n">windll</span><span class="o">.</span><span class="n">user32</span><span class="p">),</span> <span class="n">paramflags</span><span class="p">)</span>
</pre></div>
</div>
<p>La función foránea de <code class="docutils literal notranslate"><span class="pre">MessageBox</span></code> puede ser llamada de esta manera:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s2">&quot;Spam, spam, spam&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s2">&quot;foo bar&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Un segundo ejemplo demuestra los parámetros de salida. La función <code class="docutils literal notranslate"><span class="pre">GetWindowRect</span></code> de win32 retorna las dimensiones de una ventana especificada copiándolas en la estructura <code class="docutils literal notranslate"><span class="pre">RECT</span></code> que la persona que llama tiene que suministrar. Aquí está la declaración C:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">WINUSERAPI</span> <span class="n">BOOL</span> <span class="n">WINAPI</span>
<span class="n">GetWindowRect</span><span class="p">(</span>
     <span class="n">HWND</span> <span class="n">hWnd</span><span class="p">,</span>
     <span class="n">LPRECT</span> <span class="n">lpRect</span><span class="p">);</span>
</pre></div>
</div>
<p>Aquí está el envoltorio con <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="n">POINTER</span><span class="p">,</span> <span class="n">WINFUNCTYPE</span><span class="p">,</span> <span class="n">windll</span><span class="p">,</span> <span class="n">WinError</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes.wintypes</span> <span class="kn">import</span> <span class="n">BOOL</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">RECT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prototype</span> <span class="o">=</span> <span class="n">WINFUNCTYPE</span><span class="p">(</span><span class="n">BOOL</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">RECT</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paramflags</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;hwnd&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;lprect&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span> <span class="o">=</span> <span class="n">prototype</span><span class="p">((</span><span class="s2">&quot;GetWindowRect&quot;</span><span class="p">,</span> <span class="n">windll</span><span class="o">.</span><span class="n">user32</span><span class="p">),</span> <span class="n">paramflags</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Las funciones con parámetros de salida retornarán automáticamente el valor del parámetro de salida si hay uno solo, o una tupla que contiene los valores del parámetro de salida cuando hay más de uno, por lo que la función GetWindowRect retorna ahora una instancia RECT, cuando se llama.</p>
<p>Los parámetros de salida pueden combinarse con el protocolo <code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code> para hacer un mayor procesamiento de la salida y la comprobación de errores. La función api de win32 <code class="docutils literal notranslate"><span class="pre">GetWindowRect</span></code> retorna un <code class="docutils literal notranslate"><span class="pre">BOOL</span></code> para señalar el éxito o el fracaso, por lo que esta función podría hacer la comprobación de errores, y plantea una excepción cuando la llamada api ha fallado:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">errcheck</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">args</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span><span class="o">.</span><span class="n">errcheck</span> <span class="o">=</span> <span class="n">errcheck</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Si la función <code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code> retorna la tupla de argumentos que recibe sin cambios, <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> continúa el procesamiento normal que hace en los parámetros de salida. Si quieres retornar una tupla de coordenadas de ventana en lugar de una instancia <code class="docutils literal notranslate"><span class="pre">RECT</span></code>, puedes recuperar los campos de la función y retornarlos en su lugar, el procesamiento normal ya no tendrá lugar:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">errcheck</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">rc</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">right</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span><span class="o">.</span><span class="n">errcheck</span> <span class="o">=</span> <span class="n">errcheck</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="utility-functions">
<span id="ctypes-utility-functions"></span><h3>Funciones de utilidad<a class="headerlink" href="#utility-functions" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py function">
<dt id="ctypes.addressof">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">addressof</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.addressof" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna la dirección del buffer de memoria como un entero. <em>obj</em> debe ser una instancia de tipo ctypes.</p>
<p class="audit-hook">Lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.addressof</span></code> con el argumento <code class="docutils literal notranslate"><span class="pre">obj</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.alignment">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">alignment</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj_or_type</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.alignment" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna los requerimientos de alineación de un tipo de ctypes. <em>obj_or_type</em> debe ser un tipo o instancia ctypes.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.byref">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">byref</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="optional">[</span>, <em class="sig-param">offset</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.byref" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna un puntero ligero a <em>obj</em>, que debe ser un ejemplo de un tipo de ctypes. <em>offset</em> es por defecto cero, y debe ser un entero que se añadirá al valor del puntero interno.</p>
<p><code class="docutils literal notranslate"><span class="pre">byref(obj,</span> <span class="pre">offset)</span></code> corresponde a este código C:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
</pre></div>
</div>
<p>El objeto retornado sólo puede ser utilizado como un parámetro de llamada de función foránea. Se comporta de manera similar a <code class="docutils literal notranslate"><span class="pre">pointer(obj)</span></code>, pero la construcción es mucho más rápida.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.cast">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">cast</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">type</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.cast" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta función es similar a la del operador de reparto en C. retorna una nueva instancia de <em>type</em> que apunta al mismo bloque de memoria que <em>obj</em>. <em>type</em> debe ser un tipo de puntero, y <em>obj</em> debe ser un objeto que pueda ser interpretado como un puntero.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.create_string_buffer">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">create_string_buffer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">init_or_size</span></em>, <em class="sig-param"><span class="n">size</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.create_string_buffer" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta función crea un búfer de caracteres mutables. El objeto retornado es un arreglo de ctypes de <a class="reference internal" href="#ctypes.c_char" title="ctypes.c_char"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char</span></code></a>.</p>
<p><em>init_or_size</em> debe ser un número entero que especifique el tamaño del arreglo, o un objeto de bytes que se utilizará para inicializar los elementos del arreglo.</p>
<p>Si se especifica un objeto bytes como primer argumento, el buffer se hace un elemento más grande que su longitud, de modo que el último elemento del arreglo es un carácter de terminación NUL. Se puede pasar un entero como segundo argumento que permite especificar el tamaño del arreglo si no se debe utilizar la longitud de los bytes.</p>
<p class="audit-hook">Lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.create_string_buffer</span></code> con argumentos <code class="docutils literal notranslate"><span class="pre">init</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.create_unicode_buffer">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">create_unicode_buffer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">init_or_size</span></em>, <em class="sig-param"><span class="n">size</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.create_unicode_buffer" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta función crea un búfer de caracteres unicode mutable. El objeto retornado es un arreglo de ctypes de <a class="reference internal" href="#ctypes.c_wchar" title="ctypes.c_wchar"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar</span></code></a>.</p>
<p><em>init_or_size</em> debe ser un entero que especifique el tamaño del arreglo, o una cadena que se utilizará para inicializar los elementos del arreglo.</p>
<p>Si se especifica una cadena como primer argumento, el búfer se hace un elemento más grande que la longitud de la cadena, de modo que el último elemento del arreglo es un carácter de terminación NUL. Se puede pasar un entero como segundo argumento que permite especificar el tamaño del arreglo si no se debe utilizar la longitud de la cadena.</p>
<p class="audit-hook">Lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.create_unicode_buffer</span></code> con argumentos <code class="docutils literal notranslate"><span class="pre">init</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.DllCanUnloadNow">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">DllCanUnloadNow</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.DllCanUnloadNow" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Sólo Windows: Esta función es un gancho que permite implementar servidores COM en proceso con ctypes. Se llama desde la función DllCanUnloadNow que la extensión _ctypes dll exporta.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.DllGetClassObject">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">DllGetClassObject</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.DllGetClassObject" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Sólo Windows: Esta función es un gancho que permite implementar servidores COM en proceso con ctypes. Se llama desde la función DllGetClassObject que la extensión <code class="docutils literal notranslate"><span class="pre">_ctypes</span></code> exporta.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.util.find_library">
<code class="sig-prename descclassname">ctypes.util.</code><code class="sig-name descname">find_library</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.util.find_library" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Intenta encontrar una biblioteca y retornar un nombre de ruta. <em>name</em> es el nombre de la biblioteca sin ningún prefijo como <code class="docutils literal notranslate"><span class="pre">lib</span></code>, sufijo como <code class="docutils literal notranslate"><span class="pre">.so</span></code>, <code class="docutils literal notranslate"><span class="pre">.dylib</span></code> o número de versión (esta es la forma usada para la opción del enlazador posix <code class="xref std std-option docutils literal notranslate"><span class="pre">-l</span></code>). Si no se puede encontrar ninguna biblioteca, retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>La funcionalidad exacta depende del sistema.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.util.find_msvcrt">
<code class="sig-prename descclassname">ctypes.util.</code><code class="sig-name descname">find_msvcrt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.util.find_msvcrt" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Sólo Windows: retorna el nombre de archivo de la biblioteca de tiempo de ejecución de VC usada por Python, y por los módulos de extensión. Si no se puede determinar el nombre de la biblioteca, se retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Si necesita liberar memoria, por ejemplo, asignada por un módulo de extensión con una llamada al <code class="docutils literal notranslate"><span class="pre">free(void</span> <span class="pre">*)</span></code>, es importante que utilice la función en la misma biblioteca que asignó la memoria.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.FormatError">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">FormatError</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">code</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.FormatError" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Sólo Windows: retorna una descripción textual del código de error <em>code</em>. Si no se especifica ningún código de error, se utiliza el último código de error llamando a la función de api de Windows GetLastError.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.GetLastError">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">GetLastError</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.GetLastError" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Windows only: Returns the last error code set by Windows in the calling thread.
This function calls the Windows <code class="docutils literal notranslate"><span class="pre">GetLastError()</span></code> function directly,
it does not return the ctypes-private copy of the error code.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.get_errno">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">get_errno</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.get_errno" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el valor actual de la copia ctypes-private de la variable de sistema <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> en el hilo de llamada.</p>
<p class="audit-hook">Lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.get_errno</span></code> sin argumentos.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.get_last_error">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">get_last_error</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.get_last_error" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Sólo Windows: retorna el valor actual de la copia ctypes-private de la variable de sistema <code class="xref py py-data docutils literal notranslate"><span class="pre">LastError</span></code> en el hilo de llamada.</p>
<p class="audit-hook">Lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.get_last_error</span></code> sin argumentos.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.memmove">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">memmove</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dst</span></em>, <em class="sig-param"><span class="n">src</span></em>, <em class="sig-param"><span class="n">count</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.memmove" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Igual que la función de la biblioteca estándar  de C <em>memmove</em>: copia <em>count</em> bytes de <em>src</em> a <em>dst</em>. <em>dst</em> y <em>src</em> deben ser enteros o instancias ctypes que pueden ser convertidos en punteros.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.memset">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">memset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dst</span></em>, <em class="sig-param"><span class="n">c</span></em>, <em class="sig-param"><span class="n">count</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.memset" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Igual que la función de la biblioteca estándar de C <em>memset</em> C: llena el bloque de memoria en la dirección <em>dst</em> con <em>count</em> bytes de valor <em>c</em>. <em>dst</em> debe ser un número entero que especifique una dirección, o una instancia ctypes.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.POINTER">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">POINTER</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">type</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.POINTER" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta función de fábrica crea y retorna un nuevo tipo de puntero ctypes. Los tipos de puntero se almacenan en caché y se reutilizan internamente, por lo que llamar a esta función repetidamente es barato. <em>type</em> debe ser un tipo ctypes.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.pointer">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">pointer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.pointer" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta función crea una nueva instancia de puntero, apuntando a <em>obj</em>. El objeto retornado es del tipo <code class="docutils literal notranslate"><span class="pre">POINTER(tipo(obj))</span></code>.</p>
<p>Nota: Si sólo quieres pasar un puntero a un objeto a una llamada de función foránea, deberías usar <code class="docutils literal notranslate"><span class="pre">byref(obj)</span></code> que es mucho más rápido.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.resize">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">resize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">size</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.resize" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta función redimensiona el búfer de memoria interna de <em>obj</em>, que debe ser una instancia de tipo ctypes. No es posible hacer el buffer más pequeño que el tamaño nativo del tipo de objetos, como lo indica <code class="docutils literal notranslate"><span class="pre">size</span> <span class="pre">of</span> <span class="pre">(type(obj))</span></code>, pero es posible agrandar el buffer.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.set_errno">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">set_errno</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.set_errno" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Poner el valor actual de la copia ctypes-private de la variable del sistema <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> en el hilo de llamada a <em>valor</em> y retornar el valor anterior.</p>
<p class="audit-hook">Lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.set_errno</span></code> con argumento <code class="docutils literal notranslate"><span class="pre">errno</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.set_last_error">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">set_last_error</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.set_last_error" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Sólo para Windows: pone el valor actual de la copia ctypes-private de la variable del sistema <code class="xref py py-data docutils literal notranslate"><span class="pre">LastError</span></code> en el hilo de llamada a <em>valor</em> y retorna el valor anterior.</p>
<p class="audit-hook">Lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.set_last_error</span></code> con argumento <code class="docutils literal notranslate"><span class="pre">error</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.sizeof">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">sizeof</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj_or_type</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.sizeof" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el tamaño en bytes de un buffer de memoria tipo ctypes o instancia. Hace lo mismo que el operador C <code class="docutils literal notranslate"><span class="pre">sizeof</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.string_at">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">string_at</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">address</span></em>, <em class="sig-param"><span class="n">size</span><span class="o">=</span><span class="default_value">- 1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.string_at" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta función retorna la cadena C que comienza en la dirección de memoria <em>address</em> como un objeto de bytes. Si se especifica el tamaño, se utiliza como tamaño, de lo contrario se asume que la cadena tiene un final cero.</p>
<p class="audit-hook">Lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.string_at</span></code> con argumentos <code class="docutils literal notranslate"><span class="pre">address</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="ctypes.WinError">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">WinError</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">code</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">descr</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WinError" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Sólo para Windows: esta función es probablemente la cosa peor nombrada de los ctypes. Crea una instancia de OSError. Si no se especifica el <em>code</em>, se llama a <code class="docutils literal notranslate"><span class="pre">GetLastError</span></code> para determinar el código de error. Si no se especifica <em>descr</em>, se llama a <code class="xref py py-func docutils literal notranslate"><span class="pre">FormatError`()</span></code> para obtener una descripción textual del error.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Una instancia de <a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">WindowsError</span></code></a> solía ser creada.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="ctypes.wstring_at">
<code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">wstring_at</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">address</span></em>, <em class="sig-param"><span class="n">size</span><span class="o">=</span><span class="default_value">- 1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.wstring_at" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta función retorna la cadena de caracteres anchos que comienza en la dirección de memoria <em>address</em> como una cadena. Si se especifica <em>size</em>, se utiliza como el número de caracteres de la cadena, de lo contrario se asume que la cadena tiene un final cero.</p>
<p class="audit-hook">Lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.wstring_at</span></code> con argumentos <code class="docutils literal notranslate"><span class="pre">address</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>.</p>
</dd></dl>

</section>
<section id="data-types">
<span id="ctypes-data-types"></span><h3>Tipos de datos<a class="headerlink" href="#data-types" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py class">
<dt id="ctypes._CData">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">_CData</code><a class="headerlink" href="#ctypes._CData" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta clase no pública es la clase de base común de todos los tipos de datos de los ctypes. Entre otras cosas, todas las instancias de tipo ctypes contienen un bloque de memoria que contiene datos compatibles con C; la dirección del bloque de memoria es retornada por la función de ayuda <a class="reference internal" href="#ctypes.addressof" title="ctypes.addressof"><code class="xref py py-func docutils literal notranslate"><span class="pre">addressof()</span></code></a>. Otra variable de instancia se expone como <code class="xref py py-attr docutils literal notranslate"><span class="pre">_objetos</span></code>; ésta contiene otros objetos de Python que deben mantenerse vivos en caso de que el bloque de memoria contenga punteros.</p>
<p>Métodos comunes de tipos de datos ctypes, estos son todos métodos de clase (para ser exactos, son métodos del <a class="reference internal" href="../glossary.html#term-metaclass"><span class="xref std std-term">metaclass</span></a>):</p>
<dl class="py method">
<dt id="ctypes._CData.from_buffer">
<code class="sig-name descname">from_buffer</code><span class="sig-paren">(</span><em class="sig-param">source</em><span class="optional">[</span>, <em class="sig-param">offset</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_buffer" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método retorna una instancia ctypes que comparte el buffer del objeto <em>source</em>. El objeto <em>source</em> debe soportar la interfaz del buffer de escritura. El parámetro opcional <em>offset</em> especifica un offset en el buffer de la fuente en bytes; el valor por defecto es cero. Si el buffer de la fuente no es lo suficientemente grande se lanza un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
<p class="audit-hook">Lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.cdata/buffer</span></code> con argumentos <code class="docutils literal notranslate"><span class="pre">pointer</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>, <code class="docutils literal notranslate"><span class="pre">offset</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="ctypes._CData.from_buffer_copy">
<code class="sig-name descname">from_buffer_copy</code><span class="sig-paren">(</span><em class="sig-param">source</em><span class="optional">[</span>, <em class="sig-param">offset</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_buffer_copy" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método crea una instancia ctypes, copiando el buffer del buffer de objetos <em>source</em> que debe ser legible. El parámetro opcional <em>offset</em> especifica un offset en el buffer de origen en bytes; el valor por defecto es cero. Si el buffer de fuente no es lo suficientemente grande se lanza un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
<p class="audit-hook">Lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.cdata/buffer</span></code> con argumentos <code class="docutils literal notranslate"><span class="pre">pointer</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>, <code class="docutils literal notranslate"><span class="pre">offset</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="ctypes._CData.from_address">
<code class="sig-name descname">from_address</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">address</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_address" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método retorna una instancia de tipo ctypes utilizando la memoria especificada por <em>address</em> que debe ser un entero.</p>
<p class="audit-hook">Lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.cdata</span></code> con argumento <code class="docutils literal notranslate"><span class="pre">address</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="ctypes._CData.from_param">
<code class="sig-name descname">from_param</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_param" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método adapta el <em>obj</em> a un tipo de ctypes. Se llama con el objeto real usado en una llamada a una función externa cuando el tipo está presente en la tupla <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> de la función foránea; debe retornar un objeto que pueda ser usado como parámetro de llamada a la función.</p>
<p>Todos los tipos de datos ctypes tienen una implementación por defecto de este método de clase que normalmente retorna <em>obj</em> si es una instancia del tipo. Algunos tipos aceptan también otros objetos.</p>
</dd></dl>

<dl class="py method">
<dt id="ctypes._CData.in_dll">
<code class="sig-name descname">in_dll</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">library</span></em>, <em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.in_dll" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este método retorna una instancia de tipo ctypes exportada por una biblioteca compartida. <em>name</em> es el nombre del símbolo que exporta los datos, <em>library</em> es la biblioteca compartida cargada.</p>
</dd></dl>

<p>Variables de instancia común de los tipos de datos de ctypes:</p>
<dl class="py attribute">
<dt id="ctypes._CData._b_base_">
<code class="sig-name descname">_b_base_</code><a class="headerlink" href="#ctypes._CData._b_base_" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>A veces, las instancias de datos ctypes no poseen el bloque de memoria que contienen, sino que comparten parte del bloque de memoria de un objeto base. El miembro de sólo lectura <a class="reference internal" href="#ctypes._CData._b_base_" title="ctypes._CData._b_base_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_b_base_</span></code></a> es el objeto raíz ctypes que posee el bloque de memoria.</p>
</dd></dl>

<dl class="py attribute">
<dt id="ctypes._CData._b_needsfree_">
<code class="sig-name descname">_b_needsfree_</code><a class="headerlink" href="#ctypes._CData._b_needsfree_" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta variable de sólo lectura es verdadera cuando la instancia de datos ctypes ha sido asignada a el propio bloque de memoria, falsa en caso contrario.</p>
</dd></dl>

<dl class="py attribute">
<dt id="ctypes._CData._objects">
<code class="sig-name descname">_objects</code><a class="headerlink" href="#ctypes._CData._objects" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este miembro es <code class="docutils literal notranslate"><span class="pre">None</span></code> o un diccionario que contiene objetos de Python que deben mantenerse vivos para que el contenido del bloque de memoria sea válido. Este objeto sólo se expone para su depuración; nunca modifique el contenido de este diccionario.</p>
</dd></dl>

</dd></dl>

</section>
<section id="ctypes-fundamental-data-types-2">
<span id="id1"></span><h3>Tipos de datos fundamentales<a class="headerlink" href="#ctypes-fundamental-data-types-2" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py class">
<dt id="ctypes._SimpleCData">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">_SimpleCData</code><a class="headerlink" href="#ctypes._SimpleCData" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Esta clase no pública es la clase base de todos los tipos de datos de ctypes fundamentales. Se menciona aquí porque contiene los atributos comunes de los tipos de datos de ctypes fundamentales. <a class="reference internal" href="#ctypes._SimpleCData" title="ctypes._SimpleCData"><code class="xref py py-class docutils literal notranslate"><span class="pre">_SimpleCData</span></code></a> es una subclase de <a class="reference internal" href="#ctypes._CData" title="ctypes._CData"><code class="xref py py-class docutils literal notranslate"><span class="pre">_CData</span></code></a>, por lo que hereda sus métodos y atributos. Los tipos de datos ctypes que no son y no contienen punteros ahora pueden ser archivados.</p>
<p>Los instancias tienen un solo atributo:</p>
<dl class="py attribute">
<dt id="ctypes._SimpleCData.value">
<code class="sig-name descname">value</code><a class="headerlink" href="#ctypes._SimpleCData.value" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Este atributo contiene el valor real de la instancia. Para los tipos enteros y punteros, es un entero, para los tipos de caracteres, es un objeto o cadena de bytes de un solo carácter, para los tipos de punteros de caracteres es un objeto o cadena de bytes de Python.</p>
<p>Cuando el atributo <code class="docutils literal notranslate"><span class="pre">value</span></code> se recupera de una instancia ctypes, normalmente se retorna un nuevo objeto cada vez. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> <em>no</em> implementa el retorno del objeto original, siempre se construye un nuevo objeto. Lo mismo ocurre con todas las demás instancias de objetos ctypes.</p>
</dd></dl>

</dd></dl>

<p>Los tipos de datos fundamentales, cuando se retornan como resultados de llamadas de funciones foráneas, o, por ejemplo, al recuperar miembros de campo de estructura o elementos de arreglos, se convierten de forma transparente a tipos nativos de Python. En otras palabras, si una función externa tiene un <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> de <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a>, siempre recibirá un objeto de bytes Python, <em>no</em> una instancia de <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a>.</p>
<p>Las subclases de los tipos de datos fundamentales <em>no</em> heredan este comportamiento. Así, si una función externa <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> es una subclase de <a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_void_p</span></code></a>, recibirás una instancia de esta subclase desde la llamada a la función. Por supuesto, puedes obtener el valor del puntero accediendo al atributo <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<p>Estos son los tipos de datos fundamentales de ctypes:</p>
<dl class="py class">
<dt id="ctypes.c_byte">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_byte</code><a class="headerlink" href="#ctypes.c_byte" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-expr docutils literal notranslate"><span class="pre">signed</span> <span class="pre">char</span></code> datatype, and interprets the value as
small integer.  The constructor accepts an optional integer initializer; no
overflow checking is done.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_char">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_char</code><a class="headerlink" href="#ctypes.c_char" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-expr docutils literal notranslate"><span class="pre">char</span></code> datatype, and interprets the value as a single
character.  The constructor accepts an optional string initializer, the
length of the string must be exactly one character.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_char_p">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_char_p</code><a class="headerlink" href="#ctypes.c_char_p" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-expr docutils literal notranslate"><span class="pre">char</span><span class="pre">*</span></code> datatype when it points to a zero-terminated
string.  For a general character pointer that may also point to binary data,
<code class="docutils literal notranslate"><span class="pre">POINTER(c_char)</span></code> must be used.  The constructor accepts an integer
address, or a bytes object.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_double">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_double</code><a class="headerlink" href="#ctypes.c_double" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-expr docutils literal notranslate"><span class="pre">double</span></code> datatype.  The constructor accepts an
optional float initializer.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_longdouble">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_longdouble</code><a class="headerlink" href="#ctypes.c_longdouble" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-expr docutils literal notranslate"><span class="pre">long</span> <span class="pre">double</span></code> datatype.  The constructor accepts an
optional float initializer.  On platforms where <code class="docutils literal notranslate"><span class="pre">sizeof(long</span> <span class="pre">double)</span> <span class="pre">==</span>
<span class="pre">sizeof(double)</span></code> it is an alias to <a class="reference internal" href="#ctypes.c_double" title="ctypes.c_double"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_double</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_float">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_float</code><a class="headerlink" href="#ctypes.c_float" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-expr docutils literal notranslate"><span class="pre">float</span></code> datatype.  The constructor accepts an
optional float initializer.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_int">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_int</code><a class="headerlink" href="#ctypes.c_int" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-expr docutils literal notranslate"><span class="pre">signed</span> <span class="pre">int</span></code> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.  On platforms
where <code class="docutils literal notranslate"><span class="pre">sizeof(int)</span> <span class="pre">==</span> <span class="pre">sizeof(long)</span></code> it is an alias to <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_int8">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_int8</code><a class="headerlink" href="#ctypes.c_int8" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C 8-bit <code class="xref c c-expr docutils literal notranslate"><span class="pre">signed</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_byte" title="ctypes.c_byte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_byte</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_int16">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_int16</code><a class="headerlink" href="#ctypes.c_int16" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C 16-bit <code class="xref c c-expr docutils literal notranslate"><span class="pre">signed</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_short" title="ctypes.c_short"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_short</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_int32">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_int32</code><a class="headerlink" href="#ctypes.c_int32" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C 32-bit <code class="xref c c-expr docutils literal notranslate"><span class="pre">signed</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_int64">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_int64</code><a class="headerlink" href="#ctypes.c_int64" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C 64-bit <code class="xref c c-expr docutils literal notranslate"><span class="pre">signed</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_longlong" title="ctypes.c_longlong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longlong</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_long">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_long</code><a class="headerlink" href="#ctypes.c_long" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-expr docutils literal notranslate"><span class="pre">signed</span> <span class="pre">long</span></code> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_longlong">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_longlong</code><a class="headerlink" href="#ctypes.c_longlong" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-expr docutils literal notranslate"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">long</span></code> datatype.  The constructor accepts
an optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_short">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_short</code><a class="headerlink" href="#ctypes.c_short" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-expr docutils literal notranslate"><span class="pre">signed</span> <span class="pre">short</span></code> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_size_t">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_size_t</code><a class="headerlink" href="#ctypes.c_size_t" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Representa el tipo de datos C <code class="xref c c-type docutils literal notranslate"><span class="pre">size_t</span></code>.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_ssize_t">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_ssize_t</code><a class="headerlink" href="#ctypes.c_ssize_t" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Representa el tipo de datos C <code class="xref c c-type docutils literal notranslate"><span class="pre">ssize_t</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Nuevo en la versión 3.2.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_ubyte">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_ubyte</code><a class="headerlink" href="#ctypes.c_ubyte" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-expr docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code> datatype, it interprets the value as
small integer.  The constructor accepts an optional integer initializer; no
overflow checking is done.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_uint">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_uint</code><a class="headerlink" href="#ctypes.c_uint" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-expr docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.  On platforms
where <code class="docutils literal notranslate"><span class="pre">sizeof(int)</span> <span class="pre">==</span> <span class="pre">sizeof(long)</span></code> it is an alias for <a class="reference internal" href="#ctypes.c_ulong" title="ctypes.c_ulong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulong</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_uint8">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_uint8</code><a class="headerlink" href="#ctypes.c_uint8" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C 8-bit <code class="xref c c-expr docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_ubyte" title="ctypes.c_ubyte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ubyte</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_uint16">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_uint16</code><a class="headerlink" href="#ctypes.c_uint16" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C 16-bit <code class="xref c c-expr docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_ushort" title="ctypes.c_ushort"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ushort</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_uint32">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_uint32</code><a class="headerlink" href="#ctypes.c_uint32" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C 32-bit <code class="xref c c-expr docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_uint" title="ctypes.c_uint"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_uint</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_uint64">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_uint64</code><a class="headerlink" href="#ctypes.c_uint64" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C 64-bit <code class="xref c c-expr docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> datatype.  Usually an alias for
<a class="reference internal" href="#ctypes.c_ulonglong" title="ctypes.c_ulonglong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulonglong</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_ulong">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_ulong</code><a class="headerlink" href="#ctypes.c_ulong" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-expr docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code> datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_ulonglong">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_ulonglong</code><a class="headerlink" href="#ctypes.c_ulonglong" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-expr docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code> datatype.  The constructor
accepts an optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_ushort">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_ushort</code><a class="headerlink" href="#ctypes.c_ushort" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-expr docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span></code> datatype.  The constructor accepts
an optional integer initializer; no overflow checking is done.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_void_p">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_void_p</code><a class="headerlink" href="#ctypes.c_void_p" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-expr docutils literal notranslate"><span class="pre">void</span><span class="pre">*</span></code> type.  The value is represented as integer.
The constructor accepts an optional integer initializer.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_wchar">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_wchar</code><a class="headerlink" href="#ctypes.c_wchar" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-expr docutils literal notranslate"><span class="pre">wchar_t</span></code> datatype, and interprets the value as a
single character unicode string.  The constructor accepts an optional string
initializer, the length of the string must be exactly one character.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_wchar_p">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_wchar_p</code><a class="headerlink" href="#ctypes.c_wchar_p" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-expr docutils literal notranslate"><span class="pre">wchar_t</span><span class="pre">*</span></code> datatype, which must be a pointer to a
zero-terminated wide character string.  The constructor accepts an integer
address, or a string.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.c_bool">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">c_bool</code><a class="headerlink" href="#ctypes.c_bool" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represent the C <code class="xref c c-expr docutils literal notranslate"><span class="pre">bool</span></code> datatype (more accurately, <code class="xref c c-expr docutils literal notranslate"><span class="pre">_Bool</span></code> from
C99).  Its value can be <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>, and the constructor accepts any object
that has a truth value.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.HRESULT">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">HRESULT</code><a class="headerlink" href="#ctypes.HRESULT" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Sólo Windows: Representa un valor <code class="xref c c-type docutils literal notranslate"><span class="pre">HRESULT</span></code> , que contiene información de éxito o error para una llamada de función o método.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.py_object">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">py_object</code><a class="headerlink" href="#ctypes.py_object" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Represents the C <code class="xref c c-expr docutils literal notranslate"><a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><span class="pre">PyObject</span></a><span class="pre">*</span></code> datatype.  Calling this without an
argument creates a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> <code class="xref c c-expr docutils literal notranslate"><a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><span class="pre">PyObject</span></a><span class="pre">*</span></code> pointer.</p>
</dd></dl>

<p>El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes.wintypes</span></code> proporciona otros tipos de datos específicos de Windows, por ejemplo <code class="xref c c-type docutils literal notranslate"><span class="pre">HWND</span></code>, <code class="xref c c-type docutils literal notranslate"><span class="pre">WPARAM</span></code>, o <code class="xref c c-type docutils literal notranslate"><span class="pre">DWORD</span></code>. Algunas estructuras útiles como <code class="xref c c-type docutils literal notranslate"><span class="pre">MSG</span></code> o <code class="xref c c-type docutils literal notranslate"><span class="pre">RECT</span></code> también están definidas.</p>
</section>
<section id="structured-data-types">
<span id="ctypes-structured-data-types"></span><h3>Tipos de datos estructurados<a class="headerlink" href="#structured-data-types" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py class">
<dt id="ctypes.Union">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">Union</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kw</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Union" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Clase base abstracta para uniones en orden de bytes nativos.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.BigEndianStructure">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">BigEndianStructure</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kw</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.BigEndianStructure" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Clase base abstracta para estructuras en orden de bytes <em>big endian</em>.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes.LittleEndianStructure">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">LittleEndianStructure</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kw</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LittleEndianStructure" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Clase base abstracta para estructuras en orden de bytes <em>little endian</em>.</p>
</dd></dl>

<p>Las estructuras con un orden de bytes no nativo no pueden contener campos de tipo puntero, o cualquier otro tipo de datos que contenga campos de tipo puntero.</p>
<dl class="py class">
<dt id="ctypes.Structure">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">Structure</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kw</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Structure" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Clase base abstracta para estructuras en orden de bytes <em>native</em>.</p>
<p>La estructura concreta y los tipos de unión deben crearse subclasificando uno de estos tipos, y al menos definir una variable de clase <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a>. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> creará <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a>s que permitan leer y escribir los campos por accesos directos de atributos. Estos son los</p>
<dl class="py attribute">
<dt id="ctypes.Structure._fields_">
<code class="sig-name descname">_fields_</code><a class="headerlink" href="#ctypes.Structure._fields_" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una secuencia que define los campos de estructura. Los elementos deben ser de 2 o 3 tuplas. El primer ítem es el nombre del campo, el segundo ítem especifica el tipo de campo; puede ser cualquier tipo de datos ctypes.</p>
<p>Para los campos de tipo entero como <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>, se puede dar un tercer elemento opcional. Debe ser un pequeño entero positivo que defina el ancho de bit del campo.</p>
<p>Los nombres de los campos deben ser únicos dentro de una estructura o unión. Esto no se comprueba, sólo se puede acceder a un campo cuando los nombres se repiten.</p>
<p>Es posible definir la variable de clase <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> <em>después</em> de la sentencia de clase que define la subclase Estructura, esto permite crear tipos de datos que se refieren directa o indirectamente a sí mismos:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">List</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">List</span><span class="o">.</span><span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;pnext&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">List</span><span class="p">)),</span>
                 <span class="o">...</span>
                <span class="p">]</span>
</pre></div>
</div>
<p>Sin embargo, la variable de clase <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> debe ser definida antes de que el tipo sea usado por primera vez (se crea una instancia, se llama a <a class="reference internal" href="#ctypes.sizeof" title="ctypes.sizeof"><code class="xref py py-func docutils literal notranslate"><span class="pre">sizeof()</span></code></a>, y así sucesivamente). Las asignaciones posteriores a la variable de clase <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> lanzarán un AttributeError.</p>
<p>Es posible definir subclases de tipos de estructura, que heredan los campos de la clase base más el <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> definido en la subclase, si existe.</p>
</dd></dl>

<dl class="py attribute">
<dt id="ctypes.Structure._pack_">
<code class="sig-name descname">_pack_</code><a class="headerlink" href="#ctypes.Structure._pack_" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un pequeño entero opcional que permite anular la alineación de los campos de estructura en la instancia. <a class="reference internal" href="#ctypes.Structure._pack_" title="ctypes.Structure._pack_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code></a> ya debe estar definido cuando se asigna <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a>, de lo contrario no tendrá ningún efecto.</p>
</dd></dl>

<dl class="py attribute">
<dt id="ctypes.Structure._anonymous_">
<code class="sig-name descname">_anonymous_</code><a class="headerlink" href="#ctypes.Structure._anonymous_" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Una secuencia opcional que enumera los nombres de los campos sin nombre (anónimos). <a class="reference internal" href="#ctypes.Structure._anonymous_" title="ctypes.Structure._anonymous_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_anonymous_</span></code></a> debe estar ya definida cuando se asigna <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a>, de lo contrario no tendrá ningún efecto.</p>
<p>Los campos listados en esta variable deben ser campos de tipo estructura o unión. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> creará descriptores en el tipo de estructura que permitan acceder a los campos anidados directamente, sin necesidad de crear el campo de estructura o unión.</p>
<p>Aquí hay un tipo de ejemplo (Windows):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">_U</span><span class="p">(</span><span class="n">Union</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;lptdesc&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">TYPEDESC</span><span class="p">)),</span>
                <span class="p">(</span><span class="s2">&quot;lpadesc&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">ARRAYDESC</span><span class="p">)),</span>
                <span class="p">(</span><span class="s2">&quot;hreftype&quot;</span><span class="p">,</span> <span class="n">HREFTYPE</span><span class="p">)]</span>

<span class="k">class</span> <span class="nc">TYPEDESC</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_anonymous_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;u&quot;</span><span class="p">,)</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="n">_U</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;vt&quot;</span><span class="p">,</span> <span class="n">VARTYPE</span><span class="p">)]</span>
</pre></div>
</div>
<p>La estructura <code class="docutils literal notranslate"><span class="pre">TYPEDESC</span></code> describe un tipo de datos COM, el campo <code class="docutils literal notranslate"><span class="pre">vt</span></code> especifica cuál de los campos de unión es válido. Como el campo <code class="docutils literal notranslate"><span class="pre">u</span></code> está definido como campo anónimo, ahora es posible acceder a los miembros directamente desde la instancia TYPEDESC. <code class="docutils literal notranslate"><span class="pre">td.lptdesc</span></code> y <code class="docutils literal notranslate"><span class="pre">td.u.lptdesc</span></code> son equivalentes, pero el primero es más rápido ya que no necesita crear una instancia de unión temporal:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">td</span> <span class="o">=</span> <span class="n">TYPEDESC</span><span class="p">()</span>
<span class="n">td</span><span class="o">.</span><span class="n">vt</span> <span class="o">=</span> <span class="n">VT_PTR</span>
<span class="n">td</span><span class="o">.</span><span class="n">lptdesc</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">some_type</span><span class="p">)</span>
<span class="n">td</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">lptdesc</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">some_type</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<p>Es posible definir subclases de estructuras, que heredan los campos de la clase base. Si la definición de la subclase tiene una variable <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> separada, los campos especificados en ella se añaden a los campos de la clase base.</p>
<p>Los constructores de estructuras y uniones aceptan tanto argumentos posicionales como de palabras clave. Los argumentos posicionales se usan para inicializar los campos de los miembros en el mismo orden en que aparecen en <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a>. Los argumentos de palabras clave en el constructor se interpretan como asignaciones de atributos, por lo que inicializarán <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> con el mismo nombre, o crearán nuevos atributos para nombres no presentes en <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a>.</p>
</dd></dl>

</section>
<section id="arrays-and-pointers">
<span id="ctypes-arrays-pointers"></span><h3>Arreglos y punteros<a class="headerlink" href="#arrays-and-pointers" title="Enlazar permanentemente con este título">¶</a></h3>
<dl class="py class">
<dt id="ctypes.Array">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">Array</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Array" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Clase base abstracta para arreglos.</p>
<p>The recommended way to create concrete array types is by multiplying any
<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> data type with a non-negative integer.  Alternatively, you can subclass
this type and define <a class="reference internal" href="#ctypes.Array._length_" title="ctypes.Array._length_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_length_</span></code></a> and <a class="reference internal" href="#ctypes.Array._type_" title="ctypes.Array._type_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_type_</span></code></a> class variables.
Array elements can be read and written using standard
subscript and slice accesses; for slice reads, the resulting object is
<em>not</em> itself an <a class="reference internal" href="#ctypes.Array" title="ctypes.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a>.</p>
<dl class="py attribute">
<dt id="ctypes.Array._length_">
<code class="sig-name descname">_length_</code><a class="headerlink" href="#ctypes.Array._length_" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Un número entero positivo que especifica el número de elementos del conjunto. Los subíndices fuera de rango dan como resultado un <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>. Será retornado por <a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="ctypes.Array._type_">
<code class="sig-name descname">_type_</code><a class="headerlink" href="#ctypes.Array._type_" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Especifica el tipo de cada elemento del arreglo.</p>
</dd></dl>

<p>Los constructores de subclases de arreglos aceptan argumentos posicionales, usados para inicializar los elementos en orden.</p>
</dd></dl>

<dl class="py class">
<dt id="ctypes._Pointer">
<em class="property">class </em><code class="sig-prename descclassname">ctypes.</code><code class="sig-name descname">_Pointer</code><a class="headerlink" href="#ctypes._Pointer" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Clase base, privada y abstracta para punteros.</p>
<p>Los tipos de punteros concretos se crean llamando a <a class="reference internal" href="#ctypes.POINTER" title="ctypes.POINTER"><code class="xref py py-func docutils literal notranslate"><span class="pre">POINTER()</span></code></a> con el tipo que será apuntado; esto se hace automáticamente por <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a>.</p>
<p>Si un puntero apunta a un arreglo, sus elementos pueden ser leídos y escritos usando accesos de subíndices y cortes estándar. Los objetos punteros no tienen tamaño, así que <a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> lanzará un <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>. Los subíndices negativos se leerán de la memoria <em>antes</em> que el puntero (como en C), y los subíndices fuera de rango probablemente se bloqueen con una violación de acceso (si tienes suerte).</p>
<dl class="py attribute">
<dt id="ctypes._Pointer._type_">
<code class="sig-name descname">_type_</code><a class="headerlink" href="#ctypes._Pointer._type_" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Especifica el tipo apuntado.</p>
</dd></dl>

<dl class="py attribute">
<dt id="ctypes._Pointer.contents">
<code class="sig-name descname">contents</code><a class="headerlink" href="#ctypes._Pointer.contents" title="Enlazar permanentemente con esta definición">¶</a></dt>
<dd><p>Retorna el objeto al que el puntero apunta. Asignando a este atributo cambia el puntero para que apunte al objeto asignado.</p>
</dd></dl>

</dd></dl>

</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Tabla de contenido</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code> — Una biblioteca de funciones foráneas para Python</a><ul>
<li><a class="reference internal" href="#ctypes-tutorial">tutorial de ctypes</a><ul>
<li><a class="reference internal" href="#loading-dynamic-link-libraries">Carga de bibliotecas de enlaces dinámicos</a></li>
<li><a class="reference internal" href="#accessing-functions-from-loaded-dlls">Acceder a las funciones de los dll cargados</a></li>
<li><a class="reference internal" href="#calling-functions">Funciones de llamada</a></li>
<li><a class="reference internal" href="#fundamental-data-types">Tipos de datos fundamentales</a></li>
<li><a class="reference internal" href="#calling-functions-continued">Funciones de llamada, continuación</a></li>
<li><a class="reference internal" href="#calling-variadic-functions">Calling variadic functions</a></li>
<li><a class="reference internal" href="#calling-functions-with-your-own-custom-data-types">Funciones de llamada con sus propios tipos de datos personalizados</a></li>
<li><a class="reference internal" href="#specifying-the-required-argument-types-function-prototypes">Especificar los tipos de argumentos requeridos (prototipos de funciones)</a></li>
<li><a class="reference internal" href="#return-types">Tipos de retorno</a></li>
<li><a class="reference internal" href="#passing-pointers-or-passing-parameters-by-reference">Pasar los punteros (o: pasar los parámetros por referencia)</a></li>
<li><a class="reference internal" href="#structures-and-unions">Estructuras y uniones</a></li>
<li><a class="reference internal" href="#structure-union-alignment-and-byte-order">Alineación de estructura/unión y orden de bytes</a></li>
<li><a class="reference internal" href="#bit-fields-in-structures-and-unions">Campos de bits en estructuras y uniones</a></li>
<li><a class="reference internal" href="#arrays">Arreglos</a></li>
<li><a class="reference internal" href="#pointers">Punteros</a></li>
<li><a class="reference internal" href="#type-conversions">Conversiones de tipos</a></li>
<li><a class="reference internal" href="#incomplete-types">Tipos incompletos</a></li>
<li><a class="reference internal" href="#callback-functions">Funciones de retrollamadas (<em>callback</em>)</a></li>
<li><a class="reference internal" href="#accessing-values-exported-from-dlls">Acceder a los valores exportados de los dlls</a></li>
<li><a class="reference internal" href="#surprises">Sorpresas</a></li>
<li><a class="reference internal" href="#variable-sized-data-types">Tipos de datos de tamaño variable</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ctypes-reference">referencia ctypes</a><ul>
<li><a class="reference internal" href="#finding-shared-libraries">Encontrar bibliotecas compartidas</a></li>
<li><a class="reference internal" href="#loading-shared-libraries">Cargando bibliotecas compartidas</a></li>
<li><a class="reference internal" href="#foreign-functions">Funciones foráneas</a></li>
<li><a class="reference internal" href="#function-prototypes">Prototipos de funciones</a></li>
<li><a class="reference internal" href="#utility-functions">Funciones de utilidad</a></li>
<li><a class="reference internal" href="#data-types">Tipos de datos</a></li>
<li><a class="reference internal" href="#ctypes-fundamental-data-types-2">Tipos de datos fundamentales</a></li>
<li><a class="reference internal" href="#structured-data-types">Tipos de datos estructurados</a></li>
<li><a class="reference internal" href="#arrays-and-pointers">Arreglos y punteros</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Tema anterior</h4>
  <p class="topless"><a href="errno.html"
                        title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">errno</span></code> — Símbolos estándar del sistema errno</a></p>
  <h4>Próximo tema</h4>
  <p class="topless"><a href="concurrency.html"
                        title="próximo capítulo">Ejecución concurrente</a></p>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Reporta un Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.10/Doc/library/ctypes.rst"
            rel="nofollow">Ver Fuente
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="concurrency.html" title="Ejecución concurrente"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="errno.html" title="errno — Símbolos estándar del sistema errno"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.10.10 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La Biblioteca Estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" >Servicios genéricos del sistema operativo</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code> — Una biblioteca de funciones foráneas para Python</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="text" name="q" />
          <input type="submit" value="Ir" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
                     |
                </li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2023, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    See <a href="/license.html">History and License</a> for more information.<br />
    <br />

    La Python Software Foundation es una organización sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor, haga una donación.</a>
<br />
    <br />

    Última actualización el mar 27, 2023.
    <a href="/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
    </div>

  </body>
</html>